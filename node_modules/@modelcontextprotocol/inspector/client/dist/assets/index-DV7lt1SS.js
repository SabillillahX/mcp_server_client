function _mergeNamespaces(n, m2) {
  for (var i = 0; i < m2.length; i++) {
    const e = m2[i];
    if (typeof e !== "string" && !Array.isArray(e)) {
      for (const k2 in e) {
        if (k2 !== "default" && !(k2 in n)) {
          const d2 = Object.getOwnPropertyDescriptor(e, k2);
          if (d2) {
            Object.defineProperty(n, k2, d2.get ? d2 : {
              enumerable: true,
              get: () => e[k2]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) return;
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) processPreload(link);
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") continue;
      for (const node of mutation.addedNodes) if (node.tagName === "LINK" && node.rel === "modulepreload") processPreload(node);
    }
  }).observe(document, {
    childList: true,
    subtree: true
  });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials") fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep) return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
var react = { exports: {} };
var react_production_min = {};
var hasRequiredReact_production_min;
function requireReact_production_min() {
  if (hasRequiredReact_production_min) return react_production_min;
  hasRequiredReact_production_min = 1;
  var l = /* @__PURE__ */ Symbol.for("react.element"), n = /* @__PURE__ */ Symbol.for("react.portal"), p2 = /* @__PURE__ */ Symbol.for("react.fragment"), q2 = /* @__PURE__ */ Symbol.for("react.strict_mode"), r2 = /* @__PURE__ */ Symbol.for("react.profiler"), t = /* @__PURE__ */ Symbol.for("react.provider"), u2 = /* @__PURE__ */ Symbol.for("react.context"), v = /* @__PURE__ */ Symbol.for("react.forward_ref"), w2 = /* @__PURE__ */ Symbol.for("react.suspense"), x2 = /* @__PURE__ */ Symbol.for("react.memo"), y2 = /* @__PURE__ */ Symbol.for("react.lazy"), z2 = Symbol.iterator;
  function A2(a2) {
    if (null === a2 || "object" !== typeof a2) return null;
    a2 = z2 && a2[z2] || a2["@@iterator"];
    return "function" === typeof a2 ? a2 : null;
  }
  var B2 = { isMounted: function() {
    return false;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, C = Object.assign, D2 = {};
  function E2(a2, b, e) {
    this.props = a2;
    this.context = b;
    this.refs = D2;
    this.updater = e || B2;
  }
  E2.prototype.isReactComponent = {};
  E2.prototype.setState = function(a2, b) {
    if ("object" !== typeof a2 && "function" !== typeof a2 && null != a2) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, a2, b, "setState");
  };
  E2.prototype.forceUpdate = function(a2) {
    this.updater.enqueueForceUpdate(this, a2, "forceUpdate");
  };
  function F2() {
  }
  F2.prototype = E2.prototype;
  function G2(a2, b, e) {
    this.props = a2;
    this.context = b;
    this.refs = D2;
    this.updater = e || B2;
  }
  var H2 = G2.prototype = new F2();
  H2.constructor = G2;
  C(H2, E2.prototype);
  H2.isPureReactComponent = true;
  var I2 = Array.isArray, J2 = Object.prototype.hasOwnProperty, K2 = { current: null }, L2 = { key: true, ref: true, __self: true, __source: true };
  function M2(a2, b, e) {
    var d2, c = {}, k2 = null, h2 = null;
    if (null != b) for (d2 in void 0 !== b.ref && (h2 = b.ref), void 0 !== b.key && (k2 = "" + b.key), b) J2.call(b, d2) && !L2.hasOwnProperty(d2) && (c[d2] = b[d2]);
    var g2 = arguments.length - 2;
    if (1 === g2) c.children = e;
    else if (1 < g2) {
      for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++) f2[m2] = arguments[m2 + 2];
      c.children = f2;
    }
    if (a2 && a2.defaultProps) for (d2 in g2 = a2.defaultProps, g2) void 0 === c[d2] && (c[d2] = g2[d2]);
    return { $$typeof: l, type: a2, key: k2, ref: h2, props: c, _owner: K2.current };
  }
  function N2(a2, b) {
    return { $$typeof: l, type: a2.type, key: b, ref: a2.ref, props: a2.props, _owner: a2._owner };
  }
  function O(a2) {
    return "object" === typeof a2 && null !== a2 && a2.$$typeof === l;
  }
  function escape2(a2) {
    var b = { "=": "=0", ":": "=2" };
    return "$" + a2.replace(/[=:]/g, function(a3) {
      return b[a3];
    });
  }
  var P2 = /\/+/g;
  function Q2(a2, b) {
    return "object" === typeof a2 && null !== a2 && null != a2.key ? escape2("" + a2.key) : b.toString(36);
  }
  function R2(a2, b, e, d2, c) {
    var k2 = typeof a2;
    if ("undefined" === k2 || "boolean" === k2) a2 = null;
    var h2 = false;
    if (null === a2) h2 = true;
    else switch (k2) {
      case "string":
      case "number":
        h2 = true;
        break;
      case "object":
        switch (a2.$$typeof) {
          case l:
          case n:
            h2 = true;
        }
    }
    if (h2) return h2 = a2, c = c(h2), a2 = "" === d2 ? "." + Q2(h2, 0) : d2, I2(c) ? (e = "", null != a2 && (e = a2.replace(P2, "$&/") + "/"), R2(c, b, e, "", function(a3) {
      return a3;
    })) : null != c && (O(c) && (c = N2(c, e + (!c.key || h2 && h2.key === c.key ? "" : ("" + c.key).replace(P2, "$&/") + "/") + a2)), b.push(c)), 1;
    h2 = 0;
    d2 = "" === d2 ? "." : d2 + ":";
    if (I2(a2)) for (var g2 = 0; g2 < a2.length; g2++) {
      k2 = a2[g2];
      var f2 = d2 + Q2(k2, g2);
      h2 += R2(k2, b, e, f2, c);
    }
    else if (f2 = A2(a2), "function" === typeof f2) for (a2 = f2.call(a2), g2 = 0; !(k2 = a2.next()).done; ) k2 = k2.value, f2 = d2 + Q2(k2, g2++), h2 += R2(k2, b, e, f2, c);
    else if ("object" === k2) throw b = String(a2), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a2).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
    return h2;
  }
  function S2(a2, b, e) {
    if (null == a2) return a2;
    var d2 = [], c = 0;
    R2(a2, d2, "", "", function(a3) {
      return b.call(e, a3, c++);
    });
    return d2;
  }
  function T2(a2) {
    if (-1 === a2._status) {
      var b = a2._result;
      b = b();
      b.then(function(b2) {
        if (0 === a2._status || -1 === a2._status) a2._status = 1, a2._result = b2;
      }, function(b2) {
        if (0 === a2._status || -1 === a2._status) a2._status = 2, a2._result = b2;
      });
      -1 === a2._status && (a2._status = 0, a2._result = b);
    }
    if (1 === a2._status) return a2._result.default;
    throw a2._result;
  }
  var U2 = { current: null }, V2 = { transition: null }, W2 = { ReactCurrentDispatcher: U2, ReactCurrentBatchConfig: V2, ReactCurrentOwner: K2 };
  function X2() {
    throw Error("act(...) is not supported in production builds of React.");
  }
  react_production_min.Children = { map: S2, forEach: function(a2, b, e) {
    S2(a2, function() {
      b.apply(this, arguments);
    }, e);
  }, count: function(a2) {
    var b = 0;
    S2(a2, function() {
      b++;
    });
    return b;
  }, toArray: function(a2) {
    return S2(a2, function(a3) {
      return a3;
    }) || [];
  }, only: function(a2) {
    if (!O(a2)) throw Error("React.Children.only expected to receive a single React element child.");
    return a2;
  } };
  react_production_min.Component = E2;
  react_production_min.Fragment = p2;
  react_production_min.Profiler = r2;
  react_production_min.PureComponent = G2;
  react_production_min.StrictMode = q2;
  react_production_min.Suspense = w2;
  react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W2;
  react_production_min.act = X2;
  react_production_min.cloneElement = function(a2, b, e) {
    if (null === a2 || void 0 === a2) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a2 + ".");
    var d2 = C({}, a2.props), c = a2.key, k2 = a2.ref, h2 = a2._owner;
    if (null != b) {
      void 0 !== b.ref && (k2 = b.ref, h2 = K2.current);
      void 0 !== b.key && (c = "" + b.key);
      if (a2.type && a2.type.defaultProps) var g2 = a2.type.defaultProps;
      for (f2 in b) J2.call(b, f2) && !L2.hasOwnProperty(f2) && (d2[f2] = void 0 === b[f2] && void 0 !== g2 ? g2[f2] : b[f2]);
    }
    var f2 = arguments.length - 2;
    if (1 === f2) d2.children = e;
    else if (1 < f2) {
      g2 = Array(f2);
      for (var m2 = 0; m2 < f2; m2++) g2[m2] = arguments[m2 + 2];
      d2.children = g2;
    }
    return { $$typeof: l, type: a2.type, key: c, ref: k2, props: d2, _owner: h2 };
  };
  react_production_min.createContext = function(a2) {
    a2 = { $$typeof: u2, _currentValue: a2, _currentValue2: a2, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
    a2.Provider = { $$typeof: t, _context: a2 };
    return a2.Consumer = a2;
  };
  react_production_min.createElement = M2;
  react_production_min.createFactory = function(a2) {
    var b = M2.bind(null, a2);
    b.type = a2;
    return b;
  };
  react_production_min.createRef = function() {
    return { current: null };
  };
  react_production_min.forwardRef = function(a2) {
    return { $$typeof: v, render: a2 };
  };
  react_production_min.isValidElement = O;
  react_production_min.lazy = function(a2) {
    return { $$typeof: y2, _payload: { _status: -1, _result: a2 }, _init: T2 };
  };
  react_production_min.memo = function(a2, b) {
    return { $$typeof: x2, type: a2, compare: void 0 === b ? null : b };
  };
  react_production_min.startTransition = function(a2) {
    var b = V2.transition;
    V2.transition = {};
    try {
      a2();
    } finally {
      V2.transition = b;
    }
  };
  react_production_min.unstable_act = X2;
  react_production_min.useCallback = function(a2, b) {
    return U2.current.useCallback(a2, b);
  };
  react_production_min.useContext = function(a2) {
    return U2.current.useContext(a2);
  };
  react_production_min.useDebugValue = function() {
  };
  react_production_min.useDeferredValue = function(a2) {
    return U2.current.useDeferredValue(a2);
  };
  react_production_min.useEffect = function(a2, b) {
    return U2.current.useEffect(a2, b);
  };
  react_production_min.useId = function() {
    return U2.current.useId();
  };
  react_production_min.useImperativeHandle = function(a2, b, e) {
    return U2.current.useImperativeHandle(a2, b, e);
  };
  react_production_min.useInsertionEffect = function(a2, b) {
    return U2.current.useInsertionEffect(a2, b);
  };
  react_production_min.useLayoutEffect = function(a2, b) {
    return U2.current.useLayoutEffect(a2, b);
  };
  react_production_min.useMemo = function(a2, b) {
    return U2.current.useMemo(a2, b);
  };
  react_production_min.useReducer = function(a2, b, e) {
    return U2.current.useReducer(a2, b, e);
  };
  react_production_min.useRef = function(a2) {
    return U2.current.useRef(a2);
  };
  react_production_min.useState = function(a2) {
    return U2.current.useState(a2);
  };
  react_production_min.useSyncExternalStore = function(a2, b, e) {
    return U2.current.useSyncExternalStore(a2, b, e);
  };
  react_production_min.useTransition = function() {
    return U2.current.useTransition();
  };
  react_production_min.version = "18.3.1";
  return react_production_min;
}
var hasRequiredReact;
function requireReact() {
  if (hasRequiredReact) return react.exports;
  hasRequiredReact = 1;
  {
    react.exports = requireReact_production_min();
  }
  return react.exports;
}
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  var f2 = requireReact(), k2 = /* @__PURE__ */ Symbol.for("react.element"), l = /* @__PURE__ */ Symbol.for("react.fragment"), m2 = Object.prototype.hasOwnProperty, n = f2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p2 = { key: true, ref: true, __self: true, __source: true };
  function q2(c, a2, g2) {
    var b, d2 = {}, e = null, h2 = null;
    void 0 !== g2 && (e = "" + g2);
    void 0 !== a2.key && (e = "" + a2.key);
    void 0 !== a2.ref && (h2 = a2.ref);
    for (b in a2) m2.call(a2, b) && !p2.hasOwnProperty(b) && (d2[b] = a2[b]);
    if (c && c.defaultProps) for (b in a2 = c.defaultProps, a2) void 0 === d2[b] && (d2[b] = a2[b]);
    return { $$typeof: k2, type: c, key: e, ref: h2, props: d2, _owner: n.current };
  }
  reactJsxRuntime_production_min.Fragment = l;
  reactJsxRuntime_production_min.jsx = q2;
  reactJsxRuntime_production_min.jsxs = q2;
  return reactJsxRuntime_production_min;
}
var hasRequiredJsxRuntime;
function requireJsxRuntime() {
  if (hasRequiredJsxRuntime) return jsxRuntime.exports;
  hasRequiredJsxRuntime = 1;
  {
    jsxRuntime.exports = requireReactJsxRuntime_production_min();
  }
  return jsxRuntime.exports;
}
var jsxRuntimeExports = requireJsxRuntime();
var reactExports = requireReact();
const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
const React$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: React
}, [reactExports]);
var client = {};
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
var hasRequiredScheduler_production_min;
function requireScheduler_production_min() {
  if (hasRequiredScheduler_production_min) return scheduler_production_min;
  hasRequiredScheduler_production_min = 1;
  (function(exports$1) {
    function f2(a2, b) {
      var c = a2.length;
      a2.push(b);
      a: for (; 0 < c; ) {
        var d2 = c - 1 >>> 1, e = a2[d2];
        if (0 < g2(e, b)) a2[d2] = b, a2[c] = e, c = d2;
        else break a;
      }
    }
    function h2(a2) {
      return 0 === a2.length ? null : a2[0];
    }
    function k2(a2) {
      if (0 === a2.length) return null;
      var b = a2[0], c = a2.pop();
      if (c !== b) {
        a2[0] = c;
        a: for (var d2 = 0, e = a2.length, w2 = e >>> 1; d2 < w2; ) {
          var m2 = 2 * (d2 + 1) - 1, C = a2[m2], n = m2 + 1, x2 = a2[n];
          if (0 > g2(C, c)) n < e && 0 > g2(x2, C) ? (a2[d2] = x2, a2[n] = c, d2 = n) : (a2[d2] = C, a2[m2] = c, d2 = m2);
          else if (n < e && 0 > g2(x2, c)) a2[d2] = x2, a2[n] = c, d2 = n;
          else break a;
        }
      }
      return b;
    }
    function g2(a2, b) {
      var c = a2.sortIndex - b.sortIndex;
      return 0 !== c ? c : a2.id - b.id;
    }
    if ("object" === typeof performance && "function" === typeof performance.now) {
      var l = performance;
      exports$1.unstable_now = function() {
        return l.now();
      };
    } else {
      var p2 = Date, q2 = p2.now();
      exports$1.unstable_now = function() {
        return p2.now() - q2;
      };
    }
    var r2 = [], t = [], u2 = 1, v = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
    "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function G2(a2) {
      for (var b = h2(t); null !== b; ) {
        if (null === b.callback) k2(t);
        else if (b.startTime <= a2) k2(t), b.sortIndex = b.expirationTime, f2(r2, b);
        else break;
        b = h2(t);
      }
    }
    function H2(a2) {
      B2 = false;
      G2(a2);
      if (!A2) if (null !== h2(r2)) A2 = true, I2(J2);
      else {
        var b = h2(t);
        null !== b && K2(H2, b.startTime - a2);
      }
    }
    function J2(a2, b) {
      A2 = false;
      B2 && (B2 = false, E2(L2), L2 = -1);
      z2 = true;
      var c = y2;
      try {
        G2(b);
        for (v = h2(r2); null !== v && (!(v.expirationTime > b) || a2 && !M2()); ) {
          var d2 = v.callback;
          if ("function" === typeof d2) {
            v.callback = null;
            y2 = v.priorityLevel;
            var e = d2(v.expirationTime <= b);
            b = exports$1.unstable_now();
            "function" === typeof e ? v.callback = e : v === h2(r2) && k2(r2);
            G2(b);
          } else k2(r2);
          v = h2(r2);
        }
        if (null !== v) var w2 = true;
        else {
          var m2 = h2(t);
          null !== m2 && K2(H2, m2.startTime - b);
          w2 = false;
        }
        return w2;
      } finally {
        v = null, y2 = c, z2 = false;
      }
    }
    var N2 = false, O = null, L2 = -1, P2 = 5, Q2 = -1;
    function M2() {
      return exports$1.unstable_now() - Q2 < P2 ? false : true;
    }
    function R2() {
      if (null !== O) {
        var a2 = exports$1.unstable_now();
        Q2 = a2;
        var b = true;
        try {
          b = O(true, a2);
        } finally {
          b ? S2() : (N2 = false, O = null);
        }
      } else N2 = false;
    }
    var S2;
    if ("function" === typeof F2) S2 = function() {
      F2(R2);
    };
    else if ("undefined" !== typeof MessageChannel) {
      var T2 = new MessageChannel(), U2 = T2.port2;
      T2.port1.onmessage = R2;
      S2 = function() {
        U2.postMessage(null);
      };
    } else S2 = function() {
      D2(R2, 0);
    };
    function I2(a2) {
      O = a2;
      N2 || (N2 = true, S2());
    }
    function K2(a2, b) {
      L2 = D2(function() {
        a2(exports$1.unstable_now());
      }, b);
    }
    exports$1.unstable_IdlePriority = 5;
    exports$1.unstable_ImmediatePriority = 1;
    exports$1.unstable_LowPriority = 4;
    exports$1.unstable_NormalPriority = 3;
    exports$1.unstable_Profiling = null;
    exports$1.unstable_UserBlockingPriority = 2;
    exports$1.unstable_cancelCallback = function(a2) {
      a2.callback = null;
    };
    exports$1.unstable_continueExecution = function() {
      A2 || z2 || (A2 = true, I2(J2));
    };
    exports$1.unstable_forceFrameRate = function(a2) {
      0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a2 ? Math.floor(1e3 / a2) : 5;
    };
    exports$1.unstable_getCurrentPriorityLevel = function() {
      return y2;
    };
    exports$1.unstable_getFirstCallbackNode = function() {
      return h2(r2);
    };
    exports$1.unstable_next = function(a2) {
      switch (y2) {
        case 1:
        case 2:
        case 3:
          var b = 3;
          break;
        default:
          b = y2;
      }
      var c = y2;
      y2 = b;
      try {
        return a2();
      } finally {
        y2 = c;
      }
    };
    exports$1.unstable_pauseExecution = function() {
    };
    exports$1.unstable_requestPaint = function() {
    };
    exports$1.unstable_runWithPriority = function(a2, b) {
      switch (a2) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          a2 = 3;
      }
      var c = y2;
      y2 = a2;
      try {
        return b();
      } finally {
        y2 = c;
      }
    };
    exports$1.unstable_scheduleCallback = function(a2, b, c) {
      var d2 = exports$1.unstable_now();
      "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d2 + c : d2) : c = d2;
      switch (a2) {
        case 1:
          var e = -1;
          break;
        case 2:
          e = 250;
          break;
        case 5:
          e = 1073741823;
          break;
        case 4:
          e = 1e4;
          break;
        default:
          e = 5e3;
      }
      e = c + e;
      a2 = { id: u2++, callback: b, priorityLevel: a2, startTime: c, expirationTime: e, sortIndex: -1 };
      c > d2 ? (a2.sortIndex = c, f2(t, a2), null === h2(r2) && a2 === h2(t) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c - d2))) : (a2.sortIndex = e, f2(r2, a2), A2 || z2 || (A2 = true, I2(J2)));
      return a2;
    };
    exports$1.unstable_shouldYield = M2;
    exports$1.unstable_wrapCallback = function(a2) {
      var b = y2;
      return function() {
        var c = y2;
        y2 = b;
        try {
          return a2.apply(this, arguments);
        } finally {
          y2 = c;
        }
      };
    };
  })(scheduler_production_min);
  return scheduler_production_min;
}
var hasRequiredScheduler;
function requireScheduler() {
  if (hasRequiredScheduler) return scheduler.exports;
  hasRequiredScheduler = 1;
  {
    scheduler.exports = requireScheduler_production_min();
  }
  return scheduler.exports;
}
var hasRequiredReactDom_production_min;
function requireReactDom_production_min() {
  if (hasRequiredReactDom_production_min) return reactDom_production_min;
  hasRequiredReactDom_production_min = 1;
  var aa2 = requireReact(), ca2 = requireScheduler();
  function p2(a2) {
    for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c = 1; c < arguments.length; c++) b += "&args[]=" + encodeURIComponent(arguments[c]);
    return "Minified React error #" + a2 + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var da2 = /* @__PURE__ */ new Set(), ea2 = {};
  function fa2(a2, b) {
    ha2(a2, b);
    ha2(a2 + "Capture", b);
  }
  function ha2(a2, b) {
    ea2[a2] = b;
    for (a2 = 0; a2 < b.length; a2++) da2.add(b[a2]);
  }
  var ia2 = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja2 = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la2 = {}, ma2 = {};
  function oa2(a2) {
    if (ja2.call(ma2, a2)) return true;
    if (ja2.call(la2, a2)) return false;
    if (ka.test(a2)) return ma2[a2] = true;
    la2[a2] = true;
    return false;
  }
  function pa2(a2, b, c, d2) {
    if (null !== c && 0 === c.type) return false;
    switch (typeof b) {
      case "function":
      case "symbol":
        return true;
      case "boolean":
        if (d2) return false;
        if (null !== c) return !c.acceptsBooleans;
        a2 = a2.toLowerCase().slice(0, 5);
        return "data-" !== a2 && "aria-" !== a2;
      default:
        return false;
    }
  }
  function qa2(a2, b, c, d2) {
    if (null === b || "undefined" === typeof b || pa2(a2, b, c, d2)) return true;
    if (d2) return false;
    if (null !== c) switch (c.type) {
      case 3:
        return !b;
      case 4:
        return false === b;
      case 5:
        return isNaN(b);
      case 6:
        return isNaN(b) || 1 > b;
    }
    return false;
  }
  function v(a2, b, c, d2, e, f2, g2) {
    this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
    this.attributeName = d2;
    this.attributeNamespace = e;
    this.mustUseProperty = c;
    this.propertyName = a2;
    this.type = b;
    this.sanitizeURL = f2;
    this.removeEmptyString = g2;
  }
  var z2 = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
    z2[a2] = new v(a2, 0, false, a2, null, false, false);
  });
  [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
    var b = a2[0];
    z2[b] = new v(b, 1, false, a2[1], null, false, false);
  });
  ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
    z2[a2] = new v(a2, 2, false, a2.toLowerCase(), null, false, false);
  });
  ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
    z2[a2] = new v(a2, 2, false, a2, null, false, false);
  });
  "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
    z2[a2] = new v(a2, 3, false, a2.toLowerCase(), null, false, false);
  });
  ["checked", "multiple", "muted", "selected"].forEach(function(a2) {
    z2[a2] = new v(a2, 3, true, a2, null, false, false);
  });
  ["capture", "download"].forEach(function(a2) {
    z2[a2] = new v(a2, 4, false, a2, null, false, false);
  });
  ["cols", "rows", "size", "span"].forEach(function(a2) {
    z2[a2] = new v(a2, 6, false, a2, null, false, false);
  });
  ["rowSpan", "start"].forEach(function(a2) {
    z2[a2] = new v(a2, 5, false, a2.toLowerCase(), null, false, false);
  });
  var ra2 = /[\-:]([a-z])/g;
  function sa2(a2) {
    return a2[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
    var b = a2.replace(
      ra2,
      sa2
    );
    z2[b] = new v(b, 1, false, a2, null, false, false);
  });
  "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
    var b = a2.replace(ra2, sa2);
    z2[b] = new v(b, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
  });
  ["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
    var b = a2.replace(ra2, sa2);
    z2[b] = new v(b, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
  });
  ["tabIndex", "crossOrigin"].forEach(function(a2) {
    z2[a2] = new v(a2, 1, false, a2.toLowerCase(), null, false, false);
  });
  z2.xlinkHref = new v("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
  ["src", "href", "action", "formAction"].forEach(function(a2) {
    z2[a2] = new v(a2, 1, false, a2.toLowerCase(), null, true, true);
  });
  function ta2(a2, b, c, d2) {
    var e = z2.hasOwnProperty(b) ? z2[b] : null;
    if (null !== e ? 0 !== e.type : d2 || !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1]) qa2(b, c, e, d2) && (c = null), d2 || null === e ? oa2(b) && (null === c ? a2.removeAttribute(b) : a2.setAttribute(b, "" + c)) : e.mustUseProperty ? a2[e.propertyName] = null === c ? 3 === e.type ? false : "" : c : (b = e.attributeName, d2 = e.attributeNamespace, null === c ? a2.removeAttribute(b) : (e = e.type, c = 3 === e || 4 === e && true === c ? "" : "" + c, d2 ? a2.setAttributeNS(d2, b, c) : a2.setAttribute(b, c)));
  }
  var ua2 = aa2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va2 = /* @__PURE__ */ Symbol.for("react.element"), wa = /* @__PURE__ */ Symbol.for("react.portal"), ya = /* @__PURE__ */ Symbol.for("react.fragment"), za = /* @__PURE__ */ Symbol.for("react.strict_mode"), Aa2 = /* @__PURE__ */ Symbol.for("react.profiler"), Ba2 = /* @__PURE__ */ Symbol.for("react.provider"), Ca2 = /* @__PURE__ */ Symbol.for("react.context"), Da = /* @__PURE__ */ Symbol.for("react.forward_ref"), Ea = /* @__PURE__ */ Symbol.for("react.suspense"), Fa2 = /* @__PURE__ */ Symbol.for("react.suspense_list"), Ga2 = /* @__PURE__ */ Symbol.for("react.memo"), Ha2 = /* @__PURE__ */ Symbol.for("react.lazy");
  var Ia = /* @__PURE__ */ Symbol.for("react.offscreen");
  var Ja2 = Symbol.iterator;
  function Ka2(a2) {
    if (null === a2 || "object" !== typeof a2) return null;
    a2 = Ja2 && a2[Ja2] || a2["@@iterator"];
    return "function" === typeof a2 ? a2 : null;
  }
  var A2 = Object.assign, La2;
  function Ma2(a2) {
    if (void 0 === La2) try {
      throw Error();
    } catch (c) {
      var b = c.stack.trim().match(/\n( *(at )?)/);
      La2 = b && b[1] || "";
    }
    return "\n" + La2 + a2;
  }
  var Na = false;
  function Oa(a2, b) {
    if (!a2 || Na) return "";
    Na = true;
    var c = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (b) if (b = function() {
        throw Error();
      }, Object.defineProperty(b.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b, []);
        } catch (l) {
          var d2 = l;
        }
        Reflect.construct(a2, [], b);
      } else {
        try {
          b.call();
        } catch (l) {
          d2 = l;
        }
        a2.call(b.prototype);
      }
      else {
        try {
          throw Error();
        } catch (l) {
          d2 = l;
        }
        a2();
      }
    } catch (l) {
      if (l && d2 && "string" === typeof l.stack) {
        for (var e = l.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e[g2] !== f2[h2]; ) h2--;
        for (; 1 <= g2 && 0 <= h2; g2--, h2--) if (e[g2] !== f2[h2]) {
          if (1 !== g2 || 1 !== h2) {
            do
              if (g2--, h2--, 0 > h2 || e[g2] !== f2[h2]) {
                var k2 = "\n" + e[g2].replace(" at new ", " at ");
                a2.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a2.displayName));
                return k2;
              }
            while (1 <= g2 && 0 <= h2);
          }
          break;
        }
      }
    } finally {
      Na = false, Error.prepareStackTrace = c;
    }
    return (a2 = a2 ? a2.displayName || a2.name : "") ? Ma2(a2) : "";
  }
  function Pa(a2) {
    switch (a2.tag) {
      case 5:
        return Ma2(a2.type);
      case 16:
        return Ma2("Lazy");
      case 13:
        return Ma2("Suspense");
      case 19:
        return Ma2("SuspenseList");
      case 0:
      case 2:
      case 15:
        return a2 = Oa(a2.type, false), a2;
      case 11:
        return a2 = Oa(a2.type.render, false), a2;
      case 1:
        return a2 = Oa(a2.type, true), a2;
      default:
        return "";
    }
  }
  function Qa2(a2) {
    if (null == a2) return null;
    if ("function" === typeof a2) return a2.displayName || a2.name || null;
    if ("string" === typeof a2) return a2;
    switch (a2) {
      case ya:
        return "Fragment";
      case wa:
        return "Portal";
      case Aa2:
        return "Profiler";
      case za:
        return "StrictMode";
      case Ea:
        return "Suspense";
      case Fa2:
        return "SuspenseList";
    }
    if ("object" === typeof a2) switch (a2.$$typeof) {
      case Ca2:
        return (a2.displayName || "Context") + ".Consumer";
      case Ba2:
        return (a2._context.displayName || "Context") + ".Provider";
      case Da:
        var b = a2.render;
        a2 = a2.displayName;
        a2 || (a2 = b.displayName || b.name || "", a2 = "" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
        return a2;
      case Ga2:
        return b = a2.displayName || null, null !== b ? b : Qa2(a2.type) || "Memo";
      case Ha2:
        b = a2._payload;
        a2 = a2._init;
        try {
          return Qa2(a2(b));
        } catch (c) {
        }
    }
    return null;
  }
  function Ra(a2) {
    var b = a2.type;
    switch (a2.tag) {
      case 24:
        return "Cache";
      case 9:
        return (b.displayName || "Context") + ".Consumer";
      case 10:
        return (b._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return a2 = b.render, a2 = a2.displayName || a2.name || "", b.displayName || ("" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return b;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return Qa2(b);
      case 8:
        return b === za ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if ("function" === typeof b) return b.displayName || b.name || null;
        if ("string" === typeof b) return b;
    }
    return null;
  }
  function Sa(a2) {
    switch (typeof a2) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return a2;
      case "object":
        return a2;
      default:
        return "";
    }
  }
  function Ta(a2) {
    var b = a2.type;
    return (a2 = a2.nodeName) && "input" === a2.toLowerCase() && ("checkbox" === b || "radio" === b);
  }
  function Ua(a2) {
    var b = Ta(a2) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a2.constructor.prototype, b), d2 = "" + a2[b];
    if (!a2.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
      var e = c.get, f2 = c.set;
      Object.defineProperty(a2, b, { configurable: true, get: function() {
        return e.call(this);
      }, set: function(a3) {
        d2 = "" + a3;
        f2.call(this, a3);
      } });
      Object.defineProperty(a2, b, { enumerable: c.enumerable });
      return { getValue: function() {
        return d2;
      }, setValue: function(a3) {
        d2 = "" + a3;
      }, stopTracking: function() {
        a2._valueTracker = null;
        delete a2[b];
      } };
    }
  }
  function Va2(a2) {
    a2._valueTracker || (a2._valueTracker = Ua(a2));
  }
  function Wa2(a2) {
    if (!a2) return false;
    var b = a2._valueTracker;
    if (!b) return true;
    var c = b.getValue();
    var d2 = "";
    a2 && (d2 = Ta(a2) ? a2.checked ? "true" : "false" : a2.value);
    a2 = d2;
    return a2 !== c ? (b.setValue(a2), true) : false;
  }
  function Xa2(a2) {
    a2 = a2 || ("undefined" !== typeof document ? document : void 0);
    if ("undefined" === typeof a2) return null;
    try {
      return a2.activeElement || a2.body;
    } catch (b) {
      return a2.body;
    }
  }
  function Ya2(a2, b) {
    var c = b.checked;
    return A2({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c ? c : a2._wrapperState.initialChecked });
  }
  function Za2(a2, b) {
    var c = null == b.defaultValue ? "" : b.defaultValue, d2 = null != b.checked ? b.checked : b.defaultChecked;
    c = Sa(null != b.value ? b.value : c);
    a2._wrapperState = { initialChecked: d2, initialValue: c, controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value };
  }
  function ab(a2, b) {
    b = b.checked;
    null != b && ta2(a2, "checked", b, false);
  }
  function bb(a2, b) {
    ab(a2, b);
    var c = Sa(b.value), d2 = b.type;
    if (null != c) if ("number" === d2) {
      if (0 === c && "" === a2.value || a2.value != c) a2.value = "" + c;
    } else a2.value !== "" + c && (a2.value = "" + c);
    else if ("submit" === d2 || "reset" === d2) {
      a2.removeAttribute("value");
      return;
    }
    b.hasOwnProperty("value") ? cb(a2, b.type, c) : b.hasOwnProperty("defaultValue") && cb(a2, b.type, Sa(b.defaultValue));
    null == b.checked && null != b.defaultChecked && (a2.defaultChecked = !!b.defaultChecked);
  }
  function db(a2, b, c) {
    if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
      var d2 = b.type;
      if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b.value && null !== b.value)) return;
      b = "" + a2._wrapperState.initialValue;
      c || b === a2.value || (a2.value = b);
      a2.defaultValue = b;
    }
    c = a2.name;
    "" !== c && (a2.name = "");
    a2.defaultChecked = !!a2._wrapperState.initialChecked;
    "" !== c && (a2.name = c);
  }
  function cb(a2, b, c) {
    if ("number" !== b || Xa2(a2.ownerDocument) !== a2) null == c ? a2.defaultValue = "" + a2._wrapperState.initialValue : a2.defaultValue !== "" + c && (a2.defaultValue = "" + c);
  }
  var eb = Array.isArray;
  function fb(a2, b, c, d2) {
    a2 = a2.options;
    if (b) {
      b = {};
      for (var e = 0; e < c.length; e++) b["$" + c[e]] = true;
      for (c = 0; c < a2.length; c++) e = b.hasOwnProperty("$" + a2[c].value), a2[c].selected !== e && (a2[c].selected = e), e && d2 && (a2[c].defaultSelected = true);
    } else {
      c = "" + Sa(c);
      b = null;
      for (e = 0; e < a2.length; e++) {
        if (a2[e].value === c) {
          a2[e].selected = true;
          d2 && (a2[e].defaultSelected = true);
          return;
        }
        null !== b || a2[e].disabled || (b = a2[e]);
      }
      null !== b && (b.selected = true);
    }
  }
  function gb(a2, b) {
    if (null != b.dangerouslySetInnerHTML) throw Error(p2(91));
    return A2({}, b, { value: void 0, defaultValue: void 0, children: "" + a2._wrapperState.initialValue });
  }
  function hb(a2, b) {
    var c = b.value;
    if (null == c) {
      c = b.children;
      b = b.defaultValue;
      if (null != c) {
        if (null != b) throw Error(p2(92));
        if (eb(c)) {
          if (1 < c.length) throw Error(p2(93));
          c = c[0];
        }
        b = c;
      }
      null == b && (b = "");
      c = b;
    }
    a2._wrapperState = { initialValue: Sa(c) };
  }
  function ib(a2, b) {
    var c = Sa(b.value), d2 = Sa(b.defaultValue);
    null != c && (c = "" + c, c !== a2.value && (a2.value = c), null == b.defaultValue && a2.defaultValue !== c && (a2.defaultValue = c));
    null != d2 && (a2.defaultValue = "" + d2);
  }
  function jb(a2) {
    var b = a2.textContent;
    b === a2._wrapperState.initialValue && "" !== b && null !== b && (a2.value = b);
  }
  function kb(a2) {
    switch (a2) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function lb(a2, b) {
    return null == a2 || "http://www.w3.org/1999/xhtml" === a2 ? kb(b) : "http://www.w3.org/2000/svg" === a2 && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a2;
  }
  var mb, nb = (function(a2) {
    return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b, c, d2, e) {
      MSApp.execUnsafeLocalFunction(function() {
        return a2(b, c, d2, e);
      });
    } : a2;
  })(function(a2, b) {
    if ("http://www.w3.org/2000/svg" !== a2.namespaceURI || "innerHTML" in a2) a2.innerHTML = b;
    else {
      mb = mb || document.createElement("div");
      mb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
      for (b = mb.firstChild; a2.firstChild; ) a2.removeChild(a2.firstChild);
      for (; b.firstChild; ) a2.appendChild(b.firstChild);
    }
  });
  function ob(a2, b) {
    if (b) {
      var c = a2.firstChild;
      if (c && c === a2.lastChild && 3 === c.nodeType) {
        c.nodeValue = b;
        return;
      }
    }
    a2.textContent = b;
  }
  var pb = {
    animationIterationCount: true,
    aspectRatio: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    columns: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    gridArea: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowSpan: true,
    gridRowStart: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnSpan: true,
    gridColumnStart: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  }, qb = ["Webkit", "ms", "Moz", "O"];
  Object.keys(pb).forEach(function(a2) {
    qb.forEach(function(b) {
      b = b + a2.charAt(0).toUpperCase() + a2.substring(1);
      pb[b] = pb[a2];
    });
  });
  function rb(a2, b, c) {
    return null == b || "boolean" === typeof b || "" === b ? "" : c || "number" !== typeof b || 0 === b || pb.hasOwnProperty(a2) && pb[a2] ? ("" + b).trim() : b + "px";
  }
  function sb(a2, b) {
    a2 = a2.style;
    for (var c in b) if (b.hasOwnProperty(c)) {
      var d2 = 0 === c.indexOf("--"), e = rb(c, b[c], d2);
      "float" === c && (c = "cssFloat");
      d2 ? a2.setProperty(c, e) : a2[c] = e;
    }
  }
  var tb = A2({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
  function ub(a2, b) {
    if (b) {
      if (tb[a2] && (null != b.children || null != b.dangerouslySetInnerHTML)) throw Error(p2(137, a2));
      if (null != b.dangerouslySetInnerHTML) {
        if (null != b.children) throw Error(p2(60));
        if ("object" !== typeof b.dangerouslySetInnerHTML || !("__html" in b.dangerouslySetInnerHTML)) throw Error(p2(61));
      }
      if (null != b.style && "object" !== typeof b.style) throw Error(p2(62));
    }
  }
  function vb(a2, b) {
    if (-1 === a2.indexOf("-")) return "string" === typeof b.is;
    switch (a2) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return false;
      default:
        return true;
    }
  }
  var wb = null;
  function xb(a2) {
    a2 = a2.target || a2.srcElement || window;
    a2.correspondingUseElement && (a2 = a2.correspondingUseElement);
    return 3 === a2.nodeType ? a2.parentNode : a2;
  }
  var yb = null, zb = null, Ab = null;
  function Bb(a2) {
    if (a2 = Cb(a2)) {
      if ("function" !== typeof yb) throw Error(p2(280));
      var b = a2.stateNode;
      b && (b = Db(b), yb(a2.stateNode, a2.type, b));
    }
  }
  function Eb(a2) {
    zb ? Ab ? Ab.push(a2) : Ab = [a2] : zb = a2;
  }
  function Fb() {
    if (zb) {
      var a2 = zb, b = Ab;
      Ab = zb = null;
      Bb(a2);
      if (b) for (a2 = 0; a2 < b.length; a2++) Bb(b[a2]);
    }
  }
  function Gb(a2, b) {
    return a2(b);
  }
  function Hb() {
  }
  var Ib = false;
  function Jb(a2, b, c) {
    if (Ib) return a2(b, c);
    Ib = true;
    try {
      return Gb(a2, b, c);
    } finally {
      if (Ib = false, null !== zb || null !== Ab) Hb(), Fb();
    }
  }
  function Kb(a2, b) {
    var c = a2.stateNode;
    if (null === c) return null;
    var d2 = Db(c);
    if (null === d2) return null;
    c = d2[b];
    a: switch (b) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d2 = !d2.disabled) || (a2 = a2.type, d2 = !("button" === a2 || "input" === a2 || "select" === a2 || "textarea" === a2));
        a2 = !d2;
        break a;
      default:
        a2 = false;
    }
    if (a2) return null;
    if (c && "function" !== typeof c) throw Error(p2(231, b, typeof c));
    return c;
  }
  var Lb = false;
  if (ia2) try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", { get: function() {
      Lb = true;
    } });
    window.addEventListener("test", Mb, Mb);
    window.removeEventListener("test", Mb, Mb);
  } catch (a2) {
    Lb = false;
  }
  function Nb(a2, b, c, d2, e, f2, g2, h2, k2) {
    var l = Array.prototype.slice.call(arguments, 3);
    try {
      b.apply(c, l);
    } catch (m2) {
      this.onError(m2);
    }
  }
  var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a2) {
    Ob = true;
    Pb = a2;
  } };
  function Tb(a2, b, c, d2, e, f2, g2, h2, k2) {
    Ob = false;
    Pb = null;
    Nb.apply(Sb, arguments);
  }
  function Ub(a2, b, c, d2, e, f2, g2, h2, k2) {
    Tb.apply(this, arguments);
    if (Ob) {
      if (Ob) {
        var l = Pb;
        Ob = false;
        Pb = null;
      } else throw Error(p2(198));
      Qb || (Qb = true, Rb = l);
    }
  }
  function Vb(a2) {
    var b = a2, c = a2;
    if (a2.alternate) for (; b.return; ) b = b.return;
    else {
      a2 = b;
      do
        b = a2, 0 !== (b.flags & 4098) && (c = b.return), a2 = b.return;
      while (a2);
    }
    return 3 === b.tag ? c : null;
  }
  function Wb(a2) {
    if (13 === a2.tag) {
      var b = a2.memoizedState;
      null === b && (a2 = a2.alternate, null !== a2 && (b = a2.memoizedState));
      if (null !== b) return b.dehydrated;
    }
    return null;
  }
  function Xb(a2) {
    if (Vb(a2) !== a2) throw Error(p2(188));
  }
  function Yb(a2) {
    var b = a2.alternate;
    if (!b) {
      b = Vb(a2);
      if (null === b) throw Error(p2(188));
      return b !== a2 ? null : a2;
    }
    for (var c = a2, d2 = b; ; ) {
      var e = c.return;
      if (null === e) break;
      var f2 = e.alternate;
      if (null === f2) {
        d2 = e.return;
        if (null !== d2) {
          c = d2;
          continue;
        }
        break;
      }
      if (e.child === f2.child) {
        for (f2 = e.child; f2; ) {
          if (f2 === c) return Xb(e), a2;
          if (f2 === d2) return Xb(e), b;
          f2 = f2.sibling;
        }
        throw Error(p2(188));
      }
      if (c.return !== d2.return) c = e, d2 = f2;
      else {
        for (var g2 = false, h2 = e.child; h2; ) {
          if (h2 === c) {
            g2 = true;
            c = e;
            d2 = f2;
            break;
          }
          if (h2 === d2) {
            g2 = true;
            d2 = e;
            c = f2;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2) {
          for (h2 = f2.child; h2; ) {
            if (h2 === c) {
              g2 = true;
              c = f2;
              d2 = e;
              break;
            }
            if (h2 === d2) {
              g2 = true;
              d2 = f2;
              c = e;
              break;
            }
            h2 = h2.sibling;
          }
          if (!g2) throw Error(p2(189));
        }
      }
      if (c.alternate !== d2) throw Error(p2(190));
    }
    if (3 !== c.tag) throw Error(p2(188));
    return c.stateNode.current === c ? a2 : b;
  }
  function Zb(a2) {
    a2 = Yb(a2);
    return null !== a2 ? $b(a2) : null;
  }
  function $b(a2) {
    if (5 === a2.tag || 6 === a2.tag) return a2;
    for (a2 = a2.child; null !== a2; ) {
      var b = $b(a2);
      if (null !== b) return b;
      a2 = a2.sibling;
    }
    return null;
  }
  var ac2 = ca2.unstable_scheduleCallback, bc2 = ca2.unstable_cancelCallback, cc2 = ca2.unstable_shouldYield, dc2 = ca2.unstable_requestPaint, B2 = ca2.unstable_now, ec2 = ca2.unstable_getCurrentPriorityLevel, fc2 = ca2.unstable_ImmediatePriority, gc2 = ca2.unstable_UserBlockingPriority, hc2 = ca2.unstable_NormalPriority, ic2 = ca2.unstable_LowPriority, jc2 = ca2.unstable_IdlePriority, kc2 = null, lc2 = null;
  function mc2(a2) {
    if (lc2 && "function" === typeof lc2.onCommitFiberRoot) try {
      lc2.onCommitFiberRoot(kc2, a2, void 0, 128 === (a2.current.flags & 128));
    } catch (b) {
    }
  }
  var oc2 = Math.clz32 ? Math.clz32 : nc2, pc2 = Math.log, qc2 = Math.LN2;
  function nc2(a2) {
    a2 >>>= 0;
    return 0 === a2 ? 32 : 31 - (pc2(a2) / qc2 | 0) | 0;
  }
  var rc2 = 64, sc2 = 4194304;
  function tc2(a2) {
    switch (a2 & -a2) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return a2 & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return a2 & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return a2;
    }
  }
  function uc2(a2, b) {
    var c = a2.pendingLanes;
    if (0 === c) return 0;
    var d2 = 0, e = a2.suspendedLanes, f2 = a2.pingedLanes, g2 = c & 268435455;
    if (0 !== g2) {
      var h2 = g2 & ~e;
      0 !== h2 ? d2 = tc2(h2) : (f2 &= g2, 0 !== f2 && (d2 = tc2(f2)));
    } else g2 = c & ~e, 0 !== g2 ? d2 = tc2(g2) : 0 !== f2 && (d2 = tc2(f2));
    if (0 === d2) return 0;
    if (0 !== b && b !== d2 && 0 === (b & e) && (e = d2 & -d2, f2 = b & -b, e >= f2 || 16 === e && 0 !== (f2 & 4194240))) return b;
    0 !== (d2 & 4) && (d2 |= c & 16);
    b = a2.entangledLanes;
    if (0 !== b) for (a2 = a2.entanglements, b &= d2; 0 < b; ) c = 31 - oc2(b), e = 1 << c, d2 |= a2[c], b &= ~e;
    return d2;
  }
  function vc2(a2, b) {
    switch (a2) {
      case 1:
      case 2:
      case 4:
        return b + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return b + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function wc2(a2, b) {
    for (var c = a2.suspendedLanes, d2 = a2.pingedLanes, e = a2.expirationTimes, f2 = a2.pendingLanes; 0 < f2; ) {
      var g2 = 31 - oc2(f2), h2 = 1 << g2, k2 = e[g2];
      if (-1 === k2) {
        if (0 === (h2 & c) || 0 !== (h2 & d2)) e[g2] = vc2(h2, b);
      } else k2 <= b && (a2.expiredLanes |= h2);
      f2 &= ~h2;
    }
  }
  function xc2(a2) {
    a2 = a2.pendingLanes & -1073741825;
    return 0 !== a2 ? a2 : a2 & 1073741824 ? 1073741824 : 0;
  }
  function yc2() {
    var a2 = rc2;
    rc2 <<= 1;
    0 === (rc2 & 4194240) && (rc2 = 64);
    return a2;
  }
  function zc2(a2) {
    for (var b = [], c = 0; 31 > c; c++) b.push(a2);
    return b;
  }
  function Ac2(a2, b, c) {
    a2.pendingLanes |= b;
    536870912 !== b && (a2.suspendedLanes = 0, a2.pingedLanes = 0);
    a2 = a2.eventTimes;
    b = 31 - oc2(b);
    a2[b] = c;
  }
  function Bc2(a2, b) {
    var c = a2.pendingLanes & ~b;
    a2.pendingLanes = b;
    a2.suspendedLanes = 0;
    a2.pingedLanes = 0;
    a2.expiredLanes &= b;
    a2.mutableReadLanes &= b;
    a2.entangledLanes &= b;
    b = a2.entanglements;
    var d2 = a2.eventTimes;
    for (a2 = a2.expirationTimes; 0 < c; ) {
      var e = 31 - oc2(c), f2 = 1 << e;
      b[e] = 0;
      d2[e] = -1;
      a2[e] = -1;
      c &= ~f2;
    }
  }
  function Cc2(a2, b) {
    var c = a2.entangledLanes |= b;
    for (a2 = a2.entanglements; c; ) {
      var d2 = 31 - oc2(c), e = 1 << d2;
      e & b | a2[d2] & b && (a2[d2] |= b);
      c &= ~e;
    }
  }
  var C = 0;
  function Dc2(a2) {
    a2 &= -a2;
    return 1 < a2 ? 4 < a2 ? 0 !== (a2 & 268435455) ? 16 : 536870912 : 4 : 1;
  }
  var Ec2, Fc2, Gc2, Hc2, Ic2, Jc2 = false, Kc2 = [], Lc2 = null, Mc2 = null, Nc2 = null, Oc2 = /* @__PURE__ */ new Map(), Pc2 = /* @__PURE__ */ new Map(), Qc2 = [], Rc2 = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function Sc2(a2, b) {
    switch (a2) {
      case "focusin":
      case "focusout":
        Lc2 = null;
        break;
      case "dragenter":
      case "dragleave":
        Mc2 = null;
        break;
      case "mouseover":
      case "mouseout":
        Nc2 = null;
        break;
      case "pointerover":
      case "pointerout":
        Oc2.delete(b.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Pc2.delete(b.pointerId);
    }
  }
  function Tc2(a2, b, c, d2, e, f2) {
    if (null === a2 || a2.nativeEvent !== f2) return a2 = { blockedOn: b, domEventName: c, eventSystemFlags: d2, nativeEvent: f2, targetContainers: [e] }, null !== b && (b = Cb(b), null !== b && Fc2(b)), a2;
    a2.eventSystemFlags |= d2;
    b = a2.targetContainers;
    null !== e && -1 === b.indexOf(e) && b.push(e);
    return a2;
  }
  function Uc2(a2, b, c, d2, e) {
    switch (b) {
      case "focusin":
        return Lc2 = Tc2(Lc2, a2, b, c, d2, e), true;
      case "dragenter":
        return Mc2 = Tc2(Mc2, a2, b, c, d2, e), true;
      case "mouseover":
        return Nc2 = Tc2(Nc2, a2, b, c, d2, e), true;
      case "pointerover":
        var f2 = e.pointerId;
        Oc2.set(f2, Tc2(Oc2.get(f2) || null, a2, b, c, d2, e));
        return true;
      case "gotpointercapture":
        return f2 = e.pointerId, Pc2.set(f2, Tc2(Pc2.get(f2) || null, a2, b, c, d2, e)), true;
    }
    return false;
  }
  function Vc2(a2) {
    var b = Wc2(a2.target);
    if (null !== b) {
      var c = Vb(b);
      if (null !== c) {
        if (b = c.tag, 13 === b) {
          if (b = Wb(c), null !== b) {
            a2.blockedOn = b;
            Ic2(a2.priority, function() {
              Gc2(c);
            });
            return;
          }
        } else if (3 === b && c.stateNode.current.memoizedState.isDehydrated) {
          a2.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
          return;
        }
      }
    }
    a2.blockedOn = null;
  }
  function Xc2(a2) {
    if (null !== a2.blockedOn) return false;
    for (var b = a2.targetContainers; 0 < b.length; ) {
      var c = Yc2(a2.domEventName, a2.eventSystemFlags, b[0], a2.nativeEvent);
      if (null === c) {
        c = a2.nativeEvent;
        var d2 = new c.constructor(c.type, c);
        wb = d2;
        c.target.dispatchEvent(d2);
        wb = null;
      } else return b = Cb(c), null !== b && Fc2(b), a2.blockedOn = c, false;
      b.shift();
    }
    return true;
  }
  function Zc2(a2, b, c) {
    Xc2(a2) && c.delete(b);
  }
  function $c2() {
    Jc2 = false;
    null !== Lc2 && Xc2(Lc2) && (Lc2 = null);
    null !== Mc2 && Xc2(Mc2) && (Mc2 = null);
    null !== Nc2 && Xc2(Nc2) && (Nc2 = null);
    Oc2.forEach(Zc2);
    Pc2.forEach(Zc2);
  }
  function ad2(a2, b) {
    a2.blockedOn === b && (a2.blockedOn = null, Jc2 || (Jc2 = true, ca2.unstable_scheduleCallback(ca2.unstable_NormalPriority, $c2)));
  }
  function bd2(a2) {
    function b(b2) {
      return ad2(b2, a2);
    }
    if (0 < Kc2.length) {
      ad2(Kc2[0], a2);
      for (var c = 1; c < Kc2.length; c++) {
        var d2 = Kc2[c];
        d2.blockedOn === a2 && (d2.blockedOn = null);
      }
    }
    null !== Lc2 && ad2(Lc2, a2);
    null !== Mc2 && ad2(Mc2, a2);
    null !== Nc2 && ad2(Nc2, a2);
    Oc2.forEach(b);
    Pc2.forEach(b);
    for (c = 0; c < Qc2.length; c++) d2 = Qc2[c], d2.blockedOn === a2 && (d2.blockedOn = null);
    for (; 0 < Qc2.length && (c = Qc2[0], null === c.blockedOn); ) Vc2(c), null === c.blockedOn && Qc2.shift();
  }
  var cd2 = ua2.ReactCurrentBatchConfig, dd2 = true;
  function ed2(a2, b, c, d2) {
    var e = C, f2 = cd2.transition;
    cd2.transition = null;
    try {
      C = 1, fd2(a2, b, c, d2);
    } finally {
      C = e, cd2.transition = f2;
    }
  }
  function gd2(a2, b, c, d2) {
    var e = C, f2 = cd2.transition;
    cd2.transition = null;
    try {
      C = 4, fd2(a2, b, c, d2);
    } finally {
      C = e, cd2.transition = f2;
    }
  }
  function fd2(a2, b, c, d2) {
    if (dd2) {
      var e = Yc2(a2, b, c, d2);
      if (null === e) hd2(a2, b, d2, id2, c), Sc2(a2, d2);
      else if (Uc2(e, a2, b, c, d2)) d2.stopPropagation();
      else if (Sc2(a2, d2), b & 4 && -1 < Rc2.indexOf(a2)) {
        for (; null !== e; ) {
          var f2 = Cb(e);
          null !== f2 && Ec2(f2);
          f2 = Yc2(a2, b, c, d2);
          null === f2 && hd2(a2, b, d2, id2, c);
          if (f2 === e) break;
          e = f2;
        }
        null !== e && d2.stopPropagation();
      } else hd2(a2, b, d2, null, c);
    }
  }
  var id2 = null;
  function Yc2(a2, b, c, d2) {
    id2 = null;
    a2 = xb(d2);
    a2 = Wc2(a2);
    if (null !== a2) if (b = Vb(a2), null === b) a2 = null;
    else if (c = b.tag, 13 === c) {
      a2 = Wb(b);
      if (null !== a2) return a2;
      a2 = null;
    } else if (3 === c) {
      if (b.stateNode.current.memoizedState.isDehydrated) return 3 === b.tag ? b.stateNode.containerInfo : null;
      a2 = null;
    } else b !== a2 && (a2 = null);
    id2 = a2;
    return null;
  }
  function jd2(a2) {
    switch (a2) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (ec2()) {
          case fc2:
            return 1;
          case gc2:
            return 4;
          case hc2:
          case ic2:
            return 16;
          case jc2:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var kd2 = null, ld2 = null, md2 = null;
  function nd2() {
    if (md2) return md2;
    var a2, b = ld2, c = b.length, d2, e = "value" in kd2 ? kd2.value : kd2.textContent, f2 = e.length;
    for (a2 = 0; a2 < c && b[a2] === e[a2]; a2++) ;
    var g2 = c - a2;
    for (d2 = 1; d2 <= g2 && b[c - d2] === e[f2 - d2]; d2++) ;
    return md2 = e.slice(a2, 1 < d2 ? 1 - d2 : void 0);
  }
  function od2(a2) {
    var b = a2.keyCode;
    "charCode" in a2 ? (a2 = a2.charCode, 0 === a2 && 13 === b && (a2 = 13)) : a2 = b;
    10 === a2 && (a2 = 13);
    return 32 <= a2 || 13 === a2 ? a2 : 0;
  }
  function pd2() {
    return true;
  }
  function qd2() {
    return false;
  }
  function rd2(a2) {
    function b(b2, d2, e, f2, g2) {
      this._reactName = b2;
      this._targetInst = e;
      this.type = d2;
      this.nativeEvent = f2;
      this.target = g2;
      this.currentTarget = null;
      for (var c in a2) a2.hasOwnProperty(c) && (b2 = a2[c], this[c] = b2 ? b2(f2) : f2[c]);
      this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd2 : qd2;
      this.isPropagationStopped = qd2;
      return this;
    }
    A2(b.prototype, { preventDefault: function() {
      this.defaultPrevented = true;
      var a3 = this.nativeEvent;
      a3 && (a3.preventDefault ? a3.preventDefault() : "unknown" !== typeof a3.returnValue && (a3.returnValue = false), this.isDefaultPrevented = pd2);
    }, stopPropagation: function() {
      var a3 = this.nativeEvent;
      a3 && (a3.stopPropagation ? a3.stopPropagation() : "unknown" !== typeof a3.cancelBubble && (a3.cancelBubble = true), this.isPropagationStopped = pd2);
    }, persist: function() {
    }, isPersistent: pd2 });
    return b;
  }
  var sd2 = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a2) {
    return a2.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, td2 = rd2(sd2), ud2 = A2({}, sd2, { view: 0, detail: 0 }), vd2 = rd2(ud2), wd2, xd2, yd2, Ad2 = A2({}, ud2, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd2, button: 0, buttons: 0, relatedTarget: function(a2) {
    return void 0 === a2.relatedTarget ? a2.fromElement === a2.srcElement ? a2.toElement : a2.fromElement : a2.relatedTarget;
  }, movementX: function(a2) {
    if ("movementX" in a2) return a2.movementX;
    a2 !== yd2 && (yd2 && "mousemove" === a2.type ? (wd2 = a2.screenX - yd2.screenX, xd2 = a2.screenY - yd2.screenY) : xd2 = wd2 = 0, yd2 = a2);
    return wd2;
  }, movementY: function(a2) {
    return "movementY" in a2 ? a2.movementY : xd2;
  } }), Bd2 = rd2(Ad2), Cd2 = A2({}, Ad2, { dataTransfer: 0 }), Dd2 = rd2(Cd2), Ed2 = A2({}, ud2, { relatedTarget: 0 }), Fd2 = rd2(Ed2), Gd2 = A2({}, sd2, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd2 = rd2(Gd2), Id2 = A2({}, sd2, { clipboardData: function(a2) {
    return "clipboardData" in a2 ? a2.clipboardData : window.clipboardData;
  } }), Jd2 = rd2(Id2), Kd2 = A2({}, sd2, { data: 0 }), Ld2 = rd2(Kd2), Md2 = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, Nd2 = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, Od2 = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function Pd2(a2) {
    var b = this.nativeEvent;
    return b.getModifierState ? b.getModifierState(a2) : (a2 = Od2[a2]) ? !!b[a2] : false;
  }
  function zd2() {
    return Pd2;
  }
  var Qd2 = A2({}, ud2, { key: function(a2) {
    if (a2.key) {
      var b = Md2[a2.key] || a2.key;
      if ("Unidentified" !== b) return b;
    }
    return "keypress" === a2.type ? (a2 = od2(a2), 13 === a2 ? "Enter" : String.fromCharCode(a2)) : "keydown" === a2.type || "keyup" === a2.type ? Nd2[a2.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd2, charCode: function(a2) {
    return "keypress" === a2.type ? od2(a2) : 0;
  }, keyCode: function(a2) {
    return "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
  }, which: function(a2) {
    return "keypress" === a2.type ? od2(a2) : "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
  } }), Rd2 = rd2(Qd2), Sd2 = A2({}, Ad2, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td2 = rd2(Sd2), Ud2 = A2({}, ud2, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd2 }), Vd2 = rd2(Ud2), Wd2 = A2({}, sd2, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd2 = rd2(Wd2), Yd2 = A2({}, Ad2, {
    deltaX: function(a2) {
      return "deltaX" in a2 ? a2.deltaX : "wheelDeltaX" in a2 ? -a2.wheelDeltaX : 0;
    },
    deltaY: function(a2) {
      return "deltaY" in a2 ? a2.deltaY : "wheelDeltaY" in a2 ? -a2.wheelDeltaY : "wheelDelta" in a2 ? -a2.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), Zd2 = rd2(Yd2), $d2 = [9, 13, 27, 32], ae2 = ia2 && "CompositionEvent" in window, be2 = null;
  ia2 && "documentMode" in document && (be2 = document.documentMode);
  var ce2 = ia2 && "TextEvent" in window && !be2, de2 = ia2 && (!ae2 || be2 && 8 < be2 && 11 >= be2), ee2 = String.fromCharCode(32), fe2 = false;
  function ge2(a2, b) {
    switch (a2) {
      case "keyup":
        return -1 !== $d2.indexOf(b.keyCode);
      case "keydown":
        return 229 !== b.keyCode;
      case "keypress":
      case "mousedown":
      case "focusout":
        return true;
      default:
        return false;
    }
  }
  function he2(a2) {
    a2 = a2.detail;
    return "object" === typeof a2 && "data" in a2 ? a2.data : null;
  }
  var ie2 = false;
  function je2(a2, b) {
    switch (a2) {
      case "compositionend":
        return he2(b);
      case "keypress":
        if (32 !== b.which) return null;
        fe2 = true;
        return ee2;
      case "textInput":
        return a2 = b.data, a2 === ee2 && fe2 ? null : a2;
      default:
        return null;
    }
  }
  function ke2(a2, b) {
    if (ie2) return "compositionend" === a2 || !ae2 && ge2(a2, b) ? (a2 = nd2(), md2 = ld2 = kd2 = null, ie2 = false, a2) : null;
    switch (a2) {
      case "paste":
        return null;
      case "keypress":
        if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
          if (b.char && 1 < b.char.length) return b.char;
          if (b.which) return String.fromCharCode(b.which);
        }
        return null;
      case "compositionend":
        return de2 && "ko" !== b.locale ? null : b.data;
      default:
        return null;
    }
  }
  var le2 = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
  function me2(a2) {
    var b = a2 && a2.nodeName && a2.nodeName.toLowerCase();
    return "input" === b ? !!le2[a2.type] : "textarea" === b ? true : false;
  }
  function ne2(a2, b, c, d2) {
    Eb(d2);
    b = oe2(b, "onChange");
    0 < b.length && (c = new td2("onChange", "change", null, c, d2), a2.push({ event: c, listeners: b }));
  }
  var pe2 = null, qe2 = null;
  function re2(a2) {
    se2(a2, 0);
  }
  function te2(a2) {
    var b = ue2(a2);
    if (Wa2(b)) return a2;
  }
  function ve2(a2, b) {
    if ("change" === a2) return b;
  }
  var we2 = false;
  if (ia2) {
    var xe2;
    if (ia2) {
      var ye2 = "oninput" in document;
      if (!ye2) {
        var ze2 = document.createElement("div");
        ze2.setAttribute("oninput", "return;");
        ye2 = "function" === typeof ze2.oninput;
      }
      xe2 = ye2;
    } else xe2 = false;
    we2 = xe2 && (!document.documentMode || 9 < document.documentMode);
  }
  function Ae() {
    pe2 && (pe2.detachEvent("onpropertychange", Be2), qe2 = pe2 = null);
  }
  function Be2(a2) {
    if ("value" === a2.propertyName && te2(qe2)) {
      var b = [];
      ne2(b, qe2, a2, xb(a2));
      Jb(re2, b);
    }
  }
  function Ce2(a2, b, c) {
    "focusin" === a2 ? (Ae(), pe2 = b, qe2 = c, pe2.attachEvent("onpropertychange", Be2)) : "focusout" === a2 && Ae();
  }
  function De2(a2) {
    if ("selectionchange" === a2 || "keyup" === a2 || "keydown" === a2) return te2(qe2);
  }
  function Ee2(a2, b) {
    if ("click" === a2) return te2(b);
  }
  function Fe3(a2, b) {
    if ("input" === a2 || "change" === a2) return te2(b);
  }
  function Ge2(a2, b) {
    return a2 === b && (0 !== a2 || 1 / a2 === 1 / b) || a2 !== a2 && b !== b;
  }
  var He2 = "function" === typeof Object.is ? Object.is : Ge2;
  function Ie2(a2, b) {
    if (He2(a2, b)) return true;
    if ("object" !== typeof a2 || null === a2 || "object" !== typeof b || null === b) return false;
    var c = Object.keys(a2), d2 = Object.keys(b);
    if (c.length !== d2.length) return false;
    for (d2 = 0; d2 < c.length; d2++) {
      var e = c[d2];
      if (!ja2.call(b, e) || !He2(a2[e], b[e])) return false;
    }
    return true;
  }
  function Je2(a2) {
    for (; a2 && a2.firstChild; ) a2 = a2.firstChild;
    return a2;
  }
  function Ke2(a2, b) {
    var c = Je2(a2);
    a2 = 0;
    for (var d2; c; ) {
      if (3 === c.nodeType) {
        d2 = a2 + c.textContent.length;
        if (a2 <= b && d2 >= b) return { node: c, offset: b - a2 };
        a2 = d2;
      }
      a: {
        for (; c; ) {
          if (c.nextSibling) {
            c = c.nextSibling;
            break a;
          }
          c = c.parentNode;
        }
        c = void 0;
      }
      c = Je2(c);
    }
  }
  function Le2(a2, b) {
    return a2 && b ? a2 === b ? true : a2 && 3 === a2.nodeType ? false : b && 3 === b.nodeType ? Le2(a2, b.parentNode) : "contains" in a2 ? a2.contains(b) : a2.compareDocumentPosition ? !!(a2.compareDocumentPosition(b) & 16) : false : false;
  }
  function Me2() {
    for (var a2 = window, b = Xa2(); b instanceof a2.HTMLIFrameElement; ) {
      try {
        var c = "string" === typeof b.contentWindow.location.href;
      } catch (d2) {
        c = false;
      }
      if (c) a2 = b.contentWindow;
      else break;
      b = Xa2(a2.document);
    }
    return b;
  }
  function Ne(a2) {
    var b = a2 && a2.nodeName && a2.nodeName.toLowerCase();
    return b && ("input" === b && ("text" === a2.type || "search" === a2.type || "tel" === a2.type || "url" === a2.type || "password" === a2.type) || "textarea" === b || "true" === a2.contentEditable);
  }
  function Oe(a2) {
    var b = Me2(), c = a2.focusedElem, d2 = a2.selectionRange;
    if (b !== c && c && c.ownerDocument && Le2(c.ownerDocument.documentElement, c)) {
      if (null !== d2 && Ne(c)) {
        if (b = d2.start, a2 = d2.end, void 0 === a2 && (a2 = b), "selectionStart" in c) c.selectionStart = b, c.selectionEnd = Math.min(a2, c.value.length);
        else if (a2 = (b = c.ownerDocument || document) && b.defaultView || window, a2.getSelection) {
          a2 = a2.getSelection();
          var e = c.textContent.length, f2 = Math.min(d2.start, e);
          d2 = void 0 === d2.end ? f2 : Math.min(d2.end, e);
          !a2.extend && f2 > d2 && (e = d2, d2 = f2, f2 = e);
          e = Ke2(c, f2);
          var g2 = Ke2(
            c,
            d2
          );
          e && g2 && (1 !== a2.rangeCount || a2.anchorNode !== e.node || a2.anchorOffset !== e.offset || a2.focusNode !== g2.node || a2.focusOffset !== g2.offset) && (b = b.createRange(), b.setStart(e.node, e.offset), a2.removeAllRanges(), f2 > d2 ? (a2.addRange(b), a2.extend(g2.node, g2.offset)) : (b.setEnd(g2.node, g2.offset), a2.addRange(b)));
        }
      }
      b = [];
      for (a2 = c; a2 = a2.parentNode; ) 1 === a2.nodeType && b.push({ element: a2, left: a2.scrollLeft, top: a2.scrollTop });
      "function" === typeof c.focus && c.focus();
      for (c = 0; c < b.length; c++) a2 = b[c], a2.element.scrollLeft = a2.left, a2.element.scrollTop = a2.top;
    }
  }
  var Pe2 = ia2 && "documentMode" in document && 11 >= document.documentMode, Qe2 = null, Re2 = null, Se2 = null, Te2 = false;
  function Ue(a2, b, c) {
    var d2 = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
    Te2 || null == Qe2 || Qe2 !== Xa2(d2) || (d2 = Qe2, "selectionStart" in d2 && Ne(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se2 && Ie2(Se2, d2) || (Se2 = d2, d2 = oe2(Re2, "onSelect"), 0 < d2.length && (b = new td2("onSelect", "select", null, b, c), a2.push({ event: b, listeners: d2 }), b.target = Qe2)));
  }
  function Ve2(a2, b) {
    var c = {};
    c[a2.toLowerCase()] = b.toLowerCase();
    c["Webkit" + a2] = "webkit" + b;
    c["Moz" + a2] = "moz" + b;
    return c;
  }
  var We = { animationend: Ve2("Animation", "AnimationEnd"), animationiteration: Ve2("Animation", "AnimationIteration"), animationstart: Ve2("Animation", "AnimationStart"), transitionend: Ve2("Transition", "TransitionEnd") }, Xe = {}, Ye2 = {};
  ia2 && (Ye2 = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
  function Ze(a2) {
    if (Xe[a2]) return Xe[a2];
    if (!We[a2]) return a2;
    var b = We[a2], c;
    for (c in b) if (b.hasOwnProperty(c) && c in Ye2) return Xe[a2] = b[c];
    return a2;
  }
  var $e2 = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function ff(a2, b) {
    df.set(a2, b);
    fa2(b, [a2]);
  }
  for (var gf = 0; gf < ef.length; gf++) {
    var hf = ef[gf], jf2 = hf.toLowerCase(), kf2 = hf[0].toUpperCase() + hf.slice(1);
    ff(jf2, "on" + kf2);
  }
  ff($e2, "onAnimationEnd");
  ff(af, "onAnimationIteration");
  ff(bf, "onAnimationStart");
  ff("dblclick", "onDoubleClick");
  ff("focusin", "onFocus");
  ff("focusout", "onBlur");
  ff(cf, "onTransitionEnd");
  ha2("onMouseEnter", ["mouseout", "mouseover"]);
  ha2("onMouseLeave", ["mouseout", "mouseover"]);
  ha2("onPointerEnter", ["pointerout", "pointerover"]);
  ha2("onPointerLeave", ["pointerout", "pointerover"]);
  fa2("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
  fa2("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
  fa2("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
  fa2("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
  fa2("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
  fa2("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
  function nf(a2, b, c) {
    var d2 = a2.type || "unknown-event";
    a2.currentTarget = c;
    Ub(d2, b, void 0, a2);
    a2.currentTarget = null;
  }
  function se2(a2, b) {
    b = 0 !== (b & 4);
    for (var c = 0; c < a2.length; c++) {
      var d2 = a2[c], e = d2.event;
      d2 = d2.listeners;
      a: {
        var f2 = void 0;
        if (b) for (var g2 = d2.length - 1; 0 <= g2; g2--) {
          var h2 = d2[g2], k2 = h2.instance, l = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e.isPropagationStopped()) break a;
          nf(e, h2, l);
          f2 = k2;
        }
        else for (g2 = 0; g2 < d2.length; g2++) {
          h2 = d2[g2];
          k2 = h2.instance;
          l = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e.isPropagationStopped()) break a;
          nf(e, h2, l);
          f2 = k2;
        }
      }
    }
    if (Qb) throw a2 = Rb, Qb = false, Rb = null, a2;
  }
  function D2(a2, b) {
    var c = b[of];
    void 0 === c && (c = b[of] = /* @__PURE__ */ new Set());
    var d2 = a2 + "__bubble";
    c.has(d2) || (pf(b, a2, 2, false), c.add(d2));
  }
  function qf2(a2, b, c) {
    var d2 = 0;
    b && (d2 |= 4);
    pf(c, a2, d2, b);
  }
  var rf = "_reactListening" + Math.random().toString(36).slice(2);
  function sf(a2) {
    if (!a2[rf]) {
      a2[rf] = true;
      da2.forEach(function(b2) {
        "selectionchange" !== b2 && (mf.has(b2) || qf2(b2, false, a2), qf2(b2, true, a2));
      });
      var b = 9 === a2.nodeType ? a2 : a2.ownerDocument;
      null === b || b[rf] || (b[rf] = true, qf2("selectionchange", false, b));
    }
  }
  function pf(a2, b, c, d2) {
    switch (jd2(b)) {
      case 1:
        var e = ed2;
        break;
      case 4:
        e = gd2;
        break;
      default:
        e = fd2;
    }
    c = e.bind(null, b, c, a2);
    e = void 0;
    !Lb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e = true);
    d2 ? void 0 !== e ? a2.addEventListener(b, c, { capture: true, passive: e }) : a2.addEventListener(b, c, true) : void 0 !== e ? a2.addEventListener(b, c, { passive: e }) : a2.addEventListener(b, c, false);
  }
  function hd2(a2, b, c, d2, e) {
    var f2 = d2;
    if (0 === (b & 1) && 0 === (b & 2) && null !== d2) a: for (; ; ) {
      if (null === d2) return;
      var g2 = d2.tag;
      if (3 === g2 || 4 === g2) {
        var h2 = d2.stateNode.containerInfo;
        if (h2 === e || 8 === h2.nodeType && h2.parentNode === e) break;
        if (4 === g2) for (g2 = d2.return; null !== g2; ) {
          var k2 = g2.tag;
          if (3 === k2 || 4 === k2) {
            if (k2 = g2.stateNode.containerInfo, k2 === e || 8 === k2.nodeType && k2.parentNode === e) return;
          }
          g2 = g2.return;
        }
        for (; null !== h2; ) {
          g2 = Wc2(h2);
          if (null === g2) return;
          k2 = g2.tag;
          if (5 === k2 || 6 === k2) {
            d2 = f2 = g2;
            continue a;
          }
          h2 = h2.parentNode;
        }
      }
      d2 = d2.return;
    }
    Jb(function() {
      var d3 = f2, e2 = xb(c), g3 = [];
      a: {
        var h3 = df.get(a2);
        if (void 0 !== h3) {
          var k3 = td2, n = a2;
          switch (a2) {
            case "keypress":
              if (0 === od2(c)) break a;
            case "keydown":
            case "keyup":
              k3 = Rd2;
              break;
            case "focusin":
              n = "focus";
              k3 = Fd2;
              break;
            case "focusout":
              n = "blur";
              k3 = Fd2;
              break;
            case "beforeblur":
            case "afterblur":
              k3 = Fd2;
              break;
            case "click":
              if (2 === c.button) break a;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              k3 = Bd2;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              k3 = Dd2;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              k3 = Vd2;
              break;
            case $e2:
            case af:
            case bf:
              k3 = Hd2;
              break;
            case cf:
              k3 = Xd2;
              break;
            case "scroll":
              k3 = vd2;
              break;
            case "wheel":
              k3 = Zd2;
              break;
            case "copy":
            case "cut":
            case "paste":
              k3 = Jd2;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              k3 = Td2;
          }
          var t = 0 !== (b & 4), J2 = !t && "scroll" === a2, x2 = t ? null !== h3 ? h3 + "Capture" : null : h3;
          t = [];
          for (var w2 = d3, u2; null !== w2; ) {
            u2 = w2;
            var F2 = u2.stateNode;
            5 === u2.tag && null !== F2 && (u2 = F2, null !== x2 && (F2 = Kb(w2, x2), null != F2 && t.push(tf(w2, F2, u2))));
            if (J2) break;
            w2 = w2.return;
          }
          0 < t.length && (h3 = new k3(h3, n, null, c, e2), g3.push({ event: h3, listeners: t }));
        }
      }
      if (0 === (b & 7)) {
        a: {
          h3 = "mouseover" === a2 || "pointerover" === a2;
          k3 = "mouseout" === a2 || "pointerout" === a2;
          if (h3 && c !== wb && (n = c.relatedTarget || c.fromElement) && (Wc2(n) || n[uf])) break a;
          if (k3 || h3) {
            h3 = e2.window === e2 ? e2 : (h3 = e2.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
            if (k3) {
              if (n = c.relatedTarget || c.toElement, k3 = d3, n = n ? Wc2(n) : null, null !== n && (J2 = Vb(n), n !== J2 || 5 !== n.tag && 6 !== n.tag)) n = null;
            } else k3 = null, n = d3;
            if (k3 !== n) {
              t = Bd2;
              F2 = "onMouseLeave";
              x2 = "onMouseEnter";
              w2 = "mouse";
              if ("pointerout" === a2 || "pointerover" === a2) t = Td2, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
              J2 = null == k3 ? h3 : ue2(k3);
              u2 = null == n ? h3 : ue2(n);
              h3 = new t(F2, w2 + "leave", k3, c, e2);
              h3.target = J2;
              h3.relatedTarget = u2;
              F2 = null;
              Wc2(e2) === d3 && (t = new t(x2, w2 + "enter", n, c, e2), t.target = u2, t.relatedTarget = J2, F2 = t);
              J2 = F2;
              if (k3 && n) b: {
                t = k3;
                x2 = n;
                w2 = 0;
                for (u2 = t; u2; u2 = vf(u2)) w2++;
                u2 = 0;
                for (F2 = x2; F2; F2 = vf(F2)) u2++;
                for (; 0 < w2 - u2; ) t = vf(t), w2--;
                for (; 0 < u2 - w2; ) x2 = vf(x2), u2--;
                for (; w2--; ) {
                  if (t === x2 || null !== x2 && t === x2.alternate) break b;
                  t = vf(t);
                  x2 = vf(x2);
                }
                t = null;
              }
              else t = null;
              null !== k3 && wf2(g3, h3, k3, t, false);
              null !== n && null !== J2 && wf2(g3, J2, n, t, true);
            }
          }
        }
        a: {
          h3 = d3 ? ue2(d3) : window;
          k3 = h3.nodeName && h3.nodeName.toLowerCase();
          if ("select" === k3 || "input" === k3 && "file" === h3.type) var na2 = ve2;
          else if (me2(h3)) if (we2) na2 = Fe3;
          else {
            na2 = De2;
            var xa = Ce2;
          }
          else (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na2 = Ee2);
          if (na2 && (na2 = na2(a2, d3))) {
            ne2(g3, na2, c, e2);
            break a;
          }
          xa && xa(a2, h3, d3);
          "focusout" === a2 && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
        }
        xa = d3 ? ue2(d3) : window;
        switch (a2) {
          case "focusin":
            if (me2(xa) || "true" === xa.contentEditable) Qe2 = xa, Re2 = d3, Se2 = null;
            break;
          case "focusout":
            Se2 = Re2 = Qe2 = null;
            break;
          case "mousedown":
            Te2 = true;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Te2 = false;
            Ue(g3, c, e2);
            break;
          case "selectionchange":
            if (Pe2) break;
          case "keydown":
          case "keyup":
            Ue(g3, c, e2);
        }
        var $a;
        if (ae2) b: {
          switch (a2) {
            case "compositionstart":
              var ba = "onCompositionStart";
              break b;
            case "compositionend":
              ba = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba = "onCompositionUpdate";
              break b;
          }
          ba = void 0;
        }
        else ie2 ? ge2(a2, c) && (ba = "onCompositionEnd") : "keydown" === a2 && 229 === c.keyCode && (ba = "onCompositionStart");
        ba && (de2 && "ko" !== c.locale && (ie2 || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie2 && ($a = nd2()) : (kd2 = e2, ld2 = "value" in kd2 ? kd2.value : kd2.textContent, ie2 = true)), xa = oe2(d3, ba), 0 < xa.length && (ba = new Ld2(ba, a2, null, c, e2), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he2(c), null !== $a && (ba.data = $a))));
        if ($a = ce2 ? je2(a2, c) : ke2(a2, c)) d3 = oe2(d3, "onBeforeInput"), 0 < d3.length && (e2 = new Ld2("onBeforeInput", "beforeinput", null, c, e2), g3.push({ event: e2, listeners: d3 }), e2.data = $a);
      }
      se2(g3, b);
    });
  }
  function tf(a2, b, c) {
    return { instance: a2, listener: b, currentTarget: c };
  }
  function oe2(a2, b) {
    for (var c = b + "Capture", d2 = []; null !== a2; ) {
      var e = a2, f2 = e.stateNode;
      5 === e.tag && null !== f2 && (e = f2, f2 = Kb(a2, c), null != f2 && d2.unshift(tf(a2, f2, e)), f2 = Kb(a2, b), null != f2 && d2.push(tf(a2, f2, e)));
      a2 = a2.return;
    }
    return d2;
  }
  function vf(a2) {
    if (null === a2) return null;
    do
      a2 = a2.return;
    while (a2 && 5 !== a2.tag);
    return a2 ? a2 : null;
  }
  function wf2(a2, b, c, d2, e) {
    for (var f2 = b._reactName, g2 = []; null !== c && c !== d2; ) {
      var h2 = c, k2 = h2.alternate, l = h2.stateNode;
      if (null !== k2 && k2 === d2) break;
      5 === h2.tag && null !== l && (h2 = l, e ? (k2 = Kb(c, f2), null != k2 && g2.unshift(tf(c, k2, h2))) : e || (k2 = Kb(c, f2), null != k2 && g2.push(tf(c, k2, h2))));
      c = c.return;
    }
    0 !== g2.length && a2.push({ event: b, listeners: g2 });
  }
  var xf2 = /\r\n?/g, yf = /\u0000|\uFFFD/g;
  function zf2(a2) {
    return ("string" === typeof a2 ? a2 : "" + a2).replace(xf2, "\n").replace(yf, "");
  }
  function Af2(a2, b, c) {
    b = zf2(b);
    if (zf2(a2) !== b && c) throw Error(p2(425));
  }
  function Bf2() {
  }
  var Cf2 = null, Df2 = null;
  function Ef2(a2, b) {
    return "textarea" === a2 || "noscript" === a2 || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
  }
  var Ff2 = "function" === typeof setTimeout ? setTimeout : void 0, Gf2 = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf2 = "function" === typeof Promise ? Promise : void 0, Jf2 = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf2 ? function(a2) {
    return Hf2.resolve(null).then(a2).catch(If2);
  } : Ff2;
  function If2(a2) {
    setTimeout(function() {
      throw a2;
    });
  }
  function Kf2(a2, b) {
    var c = b, d2 = 0;
    do {
      var e = c.nextSibling;
      a2.removeChild(c);
      if (e && 8 === e.nodeType) if (c = e.data, "/$" === c) {
        if (0 === d2) {
          a2.removeChild(e);
          bd2(b);
          return;
        }
        d2--;
      } else "$" !== c && "$?" !== c && "$!" !== c || d2++;
      c = e;
    } while (c);
    bd2(b);
  }
  function Lf2(a2) {
    for (; null != a2; a2 = a2.nextSibling) {
      var b = a2.nodeType;
      if (1 === b || 3 === b) break;
      if (8 === b) {
        b = a2.data;
        if ("$" === b || "$!" === b || "$?" === b) break;
        if ("/$" === b) return null;
      }
    }
    return a2;
  }
  function Mf2(a2) {
    a2 = a2.previousSibling;
    for (var b = 0; a2; ) {
      if (8 === a2.nodeType) {
        var c = a2.data;
        if ("$" === c || "$!" === c || "$?" === c) {
          if (0 === b) return a2;
          b--;
        } else "/$" === c && b++;
      }
      a2 = a2.previousSibling;
    }
    return null;
  }
  var Nf2 = Math.random().toString(36).slice(2), Of2 = "__reactFiber$" + Nf2, Pf2 = "__reactProps$" + Nf2, uf = "__reactContainer$" + Nf2, of = "__reactEvents$" + Nf2, Qf2 = "__reactListeners$" + Nf2, Rf2 = "__reactHandles$" + Nf2;
  function Wc2(a2) {
    var b = a2[Of2];
    if (b) return b;
    for (var c = a2.parentNode; c; ) {
      if (b = c[uf] || c[Of2]) {
        c = b.alternate;
        if (null !== b.child || null !== c && null !== c.child) for (a2 = Mf2(a2); null !== a2; ) {
          if (c = a2[Of2]) return c;
          a2 = Mf2(a2);
        }
        return b;
      }
      a2 = c;
      c = a2.parentNode;
    }
    return null;
  }
  function Cb(a2) {
    a2 = a2[Of2] || a2[uf];
    return !a2 || 5 !== a2.tag && 6 !== a2.tag && 13 !== a2.tag && 3 !== a2.tag ? null : a2;
  }
  function ue2(a2) {
    if (5 === a2.tag || 6 === a2.tag) return a2.stateNode;
    throw Error(p2(33));
  }
  function Db(a2) {
    return a2[Pf2] || null;
  }
  var Sf2 = [], Tf2 = -1;
  function Uf2(a2) {
    return { current: a2 };
  }
  function E2(a2) {
    0 > Tf2 || (a2.current = Sf2[Tf2], Sf2[Tf2] = null, Tf2--);
  }
  function G2(a2, b) {
    Tf2++;
    Sf2[Tf2] = a2.current;
    a2.current = b;
  }
  var Vf2 = {}, H2 = Uf2(Vf2), Wf2 = Uf2(false), Xf2 = Vf2;
  function Yf2(a2, b) {
    var c = a2.type.contextTypes;
    if (!c) return Vf2;
    var d2 = a2.stateNode;
    if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b) return d2.__reactInternalMemoizedMaskedChildContext;
    var e = {}, f2;
    for (f2 in c) e[f2] = b[f2];
    d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b, a2.__reactInternalMemoizedMaskedChildContext = e);
    return e;
  }
  function Zf2(a2) {
    a2 = a2.childContextTypes;
    return null !== a2 && void 0 !== a2;
  }
  function $f() {
    E2(Wf2);
    E2(H2);
  }
  function ag2(a2, b, c) {
    if (H2.current !== Vf2) throw Error(p2(168));
    G2(H2, b);
    G2(Wf2, c);
  }
  function bg2(a2, b, c) {
    var d2 = a2.stateNode;
    b = b.childContextTypes;
    if ("function" !== typeof d2.getChildContext) return c;
    d2 = d2.getChildContext();
    for (var e in d2) if (!(e in b)) throw Error(p2(108, Ra(a2) || "Unknown", e));
    return A2({}, c, d2);
  }
  function cg2(a2) {
    a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Vf2;
    Xf2 = H2.current;
    G2(H2, a2);
    G2(Wf2, Wf2.current);
    return true;
  }
  function dg2(a2, b, c) {
    var d2 = a2.stateNode;
    if (!d2) throw Error(p2(169));
    c ? (a2 = bg2(a2, b, Xf2), d2.__reactInternalMemoizedMergedChildContext = a2, E2(Wf2), E2(H2), G2(H2, a2)) : E2(Wf2);
    G2(Wf2, c);
  }
  var eg2 = null, fg2 = false, gg2 = false;
  function hg2(a2) {
    null === eg2 ? eg2 = [a2] : eg2.push(a2);
  }
  function ig2(a2) {
    fg2 = true;
    hg2(a2);
  }
  function jg2() {
    if (!gg2 && null !== eg2) {
      gg2 = true;
      var a2 = 0, b = C;
      try {
        var c = eg2;
        for (C = 1; a2 < c.length; a2++) {
          var d2 = c[a2];
          do
            d2 = d2(true);
          while (null !== d2);
        }
        eg2 = null;
        fg2 = false;
      } catch (e) {
        throw null !== eg2 && (eg2 = eg2.slice(a2 + 1)), ac2(fc2, jg2), e;
      } finally {
        C = b, gg2 = false;
      }
    }
    return null;
  }
  var kg2 = [], lg2 = 0, mg2 = null, ng2 = 0, og2 = [], pg2 = 0, qg2 = null, rg2 = 1, sg2 = "";
  function tg2(a2, b) {
    kg2[lg2++] = ng2;
    kg2[lg2++] = mg2;
    mg2 = a2;
    ng2 = b;
  }
  function ug2(a2, b, c) {
    og2[pg2++] = rg2;
    og2[pg2++] = sg2;
    og2[pg2++] = qg2;
    qg2 = a2;
    var d2 = rg2;
    a2 = sg2;
    var e = 32 - oc2(d2) - 1;
    d2 &= ~(1 << e);
    c += 1;
    var f2 = 32 - oc2(b) + e;
    if (30 < f2) {
      var g2 = e - e % 5;
      f2 = (d2 & (1 << g2) - 1).toString(32);
      d2 >>= g2;
      e -= g2;
      rg2 = 1 << 32 - oc2(b) + e | c << e | d2;
      sg2 = f2 + a2;
    } else rg2 = 1 << f2 | c << e | d2, sg2 = a2;
  }
  function vg3(a2) {
    null !== a2.return && (tg2(a2, 1), ug2(a2, 1, 0));
  }
  function wg2(a2) {
    for (; a2 === mg2; ) mg2 = kg2[--lg2], kg2[lg2] = null, ng2 = kg2[--lg2], kg2[lg2] = null;
    for (; a2 === qg2; ) qg2 = og2[--pg2], og2[pg2] = null, sg2 = og2[--pg2], og2[pg2] = null, rg2 = og2[--pg2], og2[pg2] = null;
  }
  var xg2 = null, yg2 = null, I2 = false, zg2 = null;
  function Ag2(a2, b) {
    var c = Bg2(5, null, null, 0);
    c.elementType = "DELETED";
    c.stateNode = b;
    c.return = a2;
    b = a2.deletions;
    null === b ? (a2.deletions = [c], a2.flags |= 16) : b.push(c);
  }
  function Cg2(a2, b) {
    switch (a2.tag) {
      case 5:
        var c = a2.type;
        b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
        return null !== b ? (a2.stateNode = b, xg2 = a2, yg2 = Lf2(b.firstChild), true) : false;
      case 6:
        return b = "" === a2.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a2.stateNode = b, xg2 = a2, yg2 = null, true) : false;
      case 13:
        return b = 8 !== b.nodeType ? null : b, null !== b ? (c = null !== qg2 ? { id: rg2, overflow: sg2 } : null, a2.memoizedState = { dehydrated: b, treeContext: c, retryLane: 1073741824 }, c = Bg2(18, null, null, 0), c.stateNode = b, c.return = a2, a2.child = c, xg2 = a2, yg2 = null, true) : false;
      default:
        return false;
    }
  }
  function Dg2(a2) {
    return 0 !== (a2.mode & 1) && 0 === (a2.flags & 128);
  }
  function Eg2(a2) {
    if (I2) {
      var b = yg2;
      if (b) {
        var c = b;
        if (!Cg2(a2, b)) {
          if (Dg2(a2)) throw Error(p2(418));
          b = Lf2(c.nextSibling);
          var d2 = xg2;
          b && Cg2(a2, b) ? Ag2(d2, c) : (a2.flags = a2.flags & -4097 | 2, I2 = false, xg2 = a2);
        }
      } else {
        if (Dg2(a2)) throw Error(p2(418));
        a2.flags = a2.flags & -4097 | 2;
        I2 = false;
        xg2 = a2;
      }
    }
  }
  function Fg2(a2) {
    for (a2 = a2.return; null !== a2 && 5 !== a2.tag && 3 !== a2.tag && 13 !== a2.tag; ) a2 = a2.return;
    xg2 = a2;
  }
  function Gg2(a2) {
    if (a2 !== xg2) return false;
    if (!I2) return Fg2(a2), I2 = true, false;
    var b;
    (b = 3 !== a2.tag) && !(b = 5 !== a2.tag) && (b = a2.type, b = "head" !== b && "body" !== b && !Ef2(a2.type, a2.memoizedProps));
    if (b && (b = yg2)) {
      if (Dg2(a2)) throw Hg2(), Error(p2(418));
      for (; b; ) Ag2(a2, b), b = Lf2(b.nextSibling);
    }
    Fg2(a2);
    if (13 === a2.tag) {
      a2 = a2.memoizedState;
      a2 = null !== a2 ? a2.dehydrated : null;
      if (!a2) throw Error(p2(317));
      a: {
        a2 = a2.nextSibling;
        for (b = 0; a2; ) {
          if (8 === a2.nodeType) {
            var c = a2.data;
            if ("/$" === c) {
              if (0 === b) {
                yg2 = Lf2(a2.nextSibling);
                break a;
              }
              b--;
            } else "$" !== c && "$!" !== c && "$?" !== c || b++;
          }
          a2 = a2.nextSibling;
        }
        yg2 = null;
      }
    } else yg2 = xg2 ? Lf2(a2.stateNode.nextSibling) : null;
    return true;
  }
  function Hg2() {
    for (var a2 = yg2; a2; ) a2 = Lf2(a2.nextSibling);
  }
  function Ig2() {
    yg2 = xg2 = null;
    I2 = false;
  }
  function Jg2(a2) {
    null === zg2 ? zg2 = [a2] : zg2.push(a2);
  }
  var Kg2 = ua2.ReactCurrentBatchConfig;
  function Lg2(a2, b, c) {
    a2 = c.ref;
    if (null !== a2 && "function" !== typeof a2 && "object" !== typeof a2) {
      if (c._owner) {
        c = c._owner;
        if (c) {
          if (1 !== c.tag) throw Error(p2(309));
          var d2 = c.stateNode;
        }
        if (!d2) throw Error(p2(147, a2));
        var e = d2, f2 = "" + a2;
        if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === f2) return b.ref;
        b = function(a3) {
          var b2 = e.refs;
          null === a3 ? delete b2[f2] : b2[f2] = a3;
        };
        b._stringRef = f2;
        return b;
      }
      if ("string" !== typeof a2) throw Error(p2(284));
      if (!c._owner) throw Error(p2(290, a2));
    }
    return a2;
  }
  function Mg2(a2, b) {
    a2 = Object.prototype.toString.call(b);
    throw Error(p2(31, "[object Object]" === a2 ? "object with keys {" + Object.keys(b).join(", ") + "}" : a2));
  }
  function Ng2(a2) {
    var b = a2._init;
    return b(a2._payload);
  }
  function Og2(a2) {
    function b(b2, c2) {
      if (a2) {
        var d3 = b2.deletions;
        null === d3 ? (b2.deletions = [c2], b2.flags |= 16) : d3.push(c2);
      }
    }
    function c(c2, d3) {
      if (!a2) return null;
      for (; null !== d3; ) b(c2, d3), d3 = d3.sibling;
      return null;
    }
    function d2(a3, b2) {
      for (a3 = /* @__PURE__ */ new Map(); null !== b2; ) null !== b2.key ? a3.set(b2.key, b2) : a3.set(b2.index, b2), b2 = b2.sibling;
      return a3;
    }
    function e(a3, b2) {
      a3 = Pg2(a3, b2);
      a3.index = 0;
      a3.sibling = null;
      return a3;
    }
    function f2(b2, c2, d3) {
      b2.index = d3;
      if (!a2) return b2.flags |= 1048576, c2;
      d3 = b2.alternate;
      if (null !== d3) return d3 = d3.index, d3 < c2 ? (b2.flags |= 2, c2) : d3;
      b2.flags |= 2;
      return c2;
    }
    function g2(b2) {
      a2 && null === b2.alternate && (b2.flags |= 2);
      return b2;
    }
    function h2(a3, b2, c2, d3) {
      if (null === b2 || 6 !== b2.tag) return b2 = Qg2(c2, a3.mode, d3), b2.return = a3, b2;
      b2 = e(b2, c2);
      b2.return = a3;
      return b2;
    }
    function k2(a3, b2, c2, d3) {
      var f3 = c2.type;
      if (f3 === ya) return m2(a3, b2, c2.props.children, d3, c2.key);
      if (null !== b2 && (b2.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha2 && Ng2(f3) === b2.type)) return d3 = e(b2, c2.props), d3.ref = Lg2(a3, b2, c2), d3.return = a3, d3;
      d3 = Rg2(c2.type, c2.key, c2.props, null, a3.mode, d3);
      d3.ref = Lg2(a3, b2, c2);
      d3.return = a3;
      return d3;
    }
    function l(a3, b2, c2, d3) {
      if (null === b2 || 4 !== b2.tag || b2.stateNode.containerInfo !== c2.containerInfo || b2.stateNode.implementation !== c2.implementation) return b2 = Sg2(c2, a3.mode, d3), b2.return = a3, b2;
      b2 = e(b2, c2.children || []);
      b2.return = a3;
      return b2;
    }
    function m2(a3, b2, c2, d3, f3) {
      if (null === b2 || 7 !== b2.tag) return b2 = Tg2(c2, a3.mode, d3, f3), b2.return = a3, b2;
      b2 = e(b2, c2);
      b2.return = a3;
      return b2;
    }
    function q2(a3, b2, c2) {
      if ("string" === typeof b2 && "" !== b2 || "number" === typeof b2) return b2 = Qg2("" + b2, a3.mode, c2), b2.return = a3, b2;
      if ("object" === typeof b2 && null !== b2) {
        switch (b2.$$typeof) {
          case va2:
            return c2 = Rg2(b2.type, b2.key, b2.props, null, a3.mode, c2), c2.ref = Lg2(a3, null, b2), c2.return = a3, c2;
          case wa:
            return b2 = Sg2(b2, a3.mode, c2), b2.return = a3, b2;
          case Ha2:
            var d3 = b2._init;
            return q2(a3, d3(b2._payload), c2);
        }
        if (eb(b2) || Ka2(b2)) return b2 = Tg2(b2, a3.mode, c2, null), b2.return = a3, b2;
        Mg2(a3, b2);
      }
      return null;
    }
    function r2(a3, b2, c2, d3) {
      var e2 = null !== b2 ? b2.key : null;
      if ("string" === typeof c2 && "" !== c2 || "number" === typeof c2) return null !== e2 ? null : h2(a3, b2, "" + c2, d3);
      if ("object" === typeof c2 && null !== c2) {
        switch (c2.$$typeof) {
          case va2:
            return c2.key === e2 ? k2(a3, b2, c2, d3) : null;
          case wa:
            return c2.key === e2 ? l(a3, b2, c2, d3) : null;
          case Ha2:
            return e2 = c2._init, r2(
              a3,
              b2,
              e2(c2._payload),
              d3
            );
        }
        if (eb(c2) || Ka2(c2)) return null !== e2 ? null : m2(a3, b2, c2, d3, null);
        Mg2(a3, c2);
      }
      return null;
    }
    function y2(a3, b2, c2, d3, e2) {
      if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3) return a3 = a3.get(c2) || null, h2(b2, a3, "" + d3, e2);
      if ("object" === typeof d3 && null !== d3) {
        switch (d3.$$typeof) {
          case va2:
            return a3 = a3.get(null === d3.key ? c2 : d3.key) || null, k2(b2, a3, d3, e2);
          case wa:
            return a3 = a3.get(null === d3.key ? c2 : d3.key) || null, l(b2, a3, d3, e2);
          case Ha2:
            var f3 = d3._init;
            return y2(a3, b2, c2, f3(d3._payload), e2);
        }
        if (eb(d3) || Ka2(d3)) return a3 = a3.get(c2) || null, m2(b2, a3, d3, e2, null);
        Mg2(b2, d3);
      }
      return null;
    }
    function n(e2, g3, h3, k3) {
      for (var l2 = null, m3 = null, u2 = g3, w2 = g3 = 0, x2 = null; null !== u2 && w2 < h3.length; w2++) {
        u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
        var n2 = r2(e2, u2, h3[w2], k3);
        if (null === n2) {
          null === u2 && (u2 = x2);
          break;
        }
        a2 && u2 && null === n2.alternate && b(e2, u2);
        g3 = f2(n2, g3, w2);
        null === m3 ? l2 = n2 : m3.sibling = n2;
        m3 = n2;
        u2 = x2;
      }
      if (w2 === h3.length) return c(e2, u2), I2 && tg2(e2, w2), l2;
      if (null === u2) {
        for (; w2 < h3.length; w2++) u2 = q2(e2, h3[w2], k3), null !== u2 && (g3 = f2(u2, g3, w2), null === m3 ? l2 = u2 : m3.sibling = u2, m3 = u2);
        I2 && tg2(e2, w2);
        return l2;
      }
      for (u2 = d2(e2, u2); w2 < h3.length; w2++) x2 = y2(u2, e2, w2, h3[w2], k3), null !== x2 && (a2 && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g3 = f2(x2, g3, w2), null === m3 ? l2 = x2 : m3.sibling = x2, m3 = x2);
      a2 && u2.forEach(function(a3) {
        return b(e2, a3);
      });
      I2 && tg2(e2, w2);
      return l2;
    }
    function t(e2, g3, h3, k3) {
      var l2 = Ka2(h3);
      if ("function" !== typeof l2) throw Error(p2(150));
      h3 = l2.call(h3);
      if (null == h3) throw Error(p2(151));
      for (var u2 = l2 = null, m3 = g3, w2 = g3 = 0, x2 = null, n2 = h3.next(); null !== m3 && !n2.done; w2++, n2 = h3.next()) {
        m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
        var t2 = r2(e2, m3, n2.value, k3);
        if (null === t2) {
          null === m3 && (m3 = x2);
          break;
        }
        a2 && m3 && null === t2.alternate && b(e2, m3);
        g3 = f2(t2, g3, w2);
        null === u2 ? l2 = t2 : u2.sibling = t2;
        u2 = t2;
        m3 = x2;
      }
      if (n2.done) return c(
        e2,
        m3
      ), I2 && tg2(e2, w2), l2;
      if (null === m3) {
        for (; !n2.done; w2++, n2 = h3.next()) n2 = q2(e2, n2.value, k3), null !== n2 && (g3 = f2(n2, g3, w2), null === u2 ? l2 = n2 : u2.sibling = n2, u2 = n2);
        I2 && tg2(e2, w2);
        return l2;
      }
      for (m3 = d2(e2, m3); !n2.done; w2++, n2 = h3.next()) n2 = y2(m3, e2, w2, n2.value, k3), null !== n2 && (a2 && null !== n2.alternate && m3.delete(null === n2.key ? w2 : n2.key), g3 = f2(n2, g3, w2), null === u2 ? l2 = n2 : u2.sibling = n2, u2 = n2);
      a2 && m3.forEach(function(a3) {
        return b(e2, a3);
      });
      I2 && tg2(e2, w2);
      return l2;
    }
    function J2(a3, d3, f3, h3) {
      "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
      if ("object" === typeof f3 && null !== f3) {
        switch (f3.$$typeof) {
          case va2:
            a: {
              for (var k3 = f3.key, l2 = d3; null !== l2; ) {
                if (l2.key === k3) {
                  k3 = f3.type;
                  if (k3 === ya) {
                    if (7 === l2.tag) {
                      c(a3, l2.sibling);
                      d3 = e(l2, f3.props.children);
                      d3.return = a3;
                      a3 = d3;
                      break a;
                    }
                  } else if (l2.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha2 && Ng2(k3) === l2.type) {
                    c(a3, l2.sibling);
                    d3 = e(l2, f3.props);
                    d3.ref = Lg2(a3, l2, f3);
                    d3.return = a3;
                    a3 = d3;
                    break a;
                  }
                  c(a3, l2);
                  break;
                } else b(a3, l2);
                l2 = l2.sibling;
              }
              f3.type === ya ? (d3 = Tg2(f3.props.children, a3.mode, h3, f3.key), d3.return = a3, a3 = d3) : (h3 = Rg2(f3.type, f3.key, f3.props, null, a3.mode, h3), h3.ref = Lg2(a3, d3, f3), h3.return = a3, a3 = h3);
            }
            return g2(a3);
          case wa:
            a: {
              for (l2 = f3.key; null !== d3; ) {
                if (d3.key === l2) if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                  c(a3, d3.sibling);
                  d3 = e(d3, f3.children || []);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                } else {
                  c(a3, d3);
                  break;
                }
                else b(a3, d3);
                d3 = d3.sibling;
              }
              d3 = Sg2(f3, a3.mode, h3);
              d3.return = a3;
              a3 = d3;
            }
            return g2(a3);
          case Ha2:
            return l2 = f3._init, J2(a3, d3, l2(f3._payload), h3);
        }
        if (eb(f3)) return n(a3, d3, f3, h3);
        if (Ka2(f3)) return t(a3, d3, f3, h3);
        Mg2(a3, f3);
      }
      return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c(a3, d3.sibling), d3 = e(d3, f3), d3.return = a3, a3 = d3) : (c(a3, d3), d3 = Qg2(f3, a3.mode, h3), d3.return = a3, a3 = d3), g2(a3)) : c(a3, d3);
    }
    return J2;
  }
  var Ug2 = Og2(true), Vg2 = Og2(false), Wg2 = Uf2(null), Xg2 = null, Yg2 = null, Zg2 = null;
  function $g2() {
    Zg2 = Yg2 = Xg2 = null;
  }
  function ah2(a2) {
    var b = Wg2.current;
    E2(Wg2);
    a2._currentValue = b;
  }
  function bh2(a2, b, c) {
    for (; null !== a2; ) {
      var d2 = a2.alternate;
      (a2.childLanes & b) !== b ? (a2.childLanes |= b, null !== d2 && (d2.childLanes |= b)) : null !== d2 && (d2.childLanes & b) !== b && (d2.childLanes |= b);
      if (a2 === c) break;
      a2 = a2.return;
    }
  }
  function ch2(a2, b) {
    Xg2 = a2;
    Zg2 = Yg2 = null;
    a2 = a2.dependencies;
    null !== a2 && null !== a2.firstContext && (0 !== (a2.lanes & b) && (dh2 = true), a2.firstContext = null);
  }
  function eh2(a2) {
    var b = a2._currentValue;
    if (Zg2 !== a2) if (a2 = { context: a2, memoizedValue: b, next: null }, null === Yg2) {
      if (null === Xg2) throw Error(p2(308));
      Yg2 = a2;
      Xg2.dependencies = { lanes: 0, firstContext: a2 };
    } else Yg2 = Yg2.next = a2;
    return b;
  }
  var fh2 = null;
  function gh2(a2) {
    null === fh2 ? fh2 = [a2] : fh2.push(a2);
  }
  function hh2(a2, b, c, d2) {
    var e = b.interleaved;
    null === e ? (c.next = c, gh2(b)) : (c.next = e.next, e.next = c);
    b.interleaved = c;
    return ih2(a2, d2);
  }
  function ih2(a2, b) {
    a2.lanes |= b;
    var c = a2.alternate;
    null !== c && (c.lanes |= b);
    c = a2;
    for (a2 = a2.return; null !== a2; ) a2.childLanes |= b, c = a2.alternate, null !== c && (c.childLanes |= b), c = a2, a2 = a2.return;
    return 3 === c.tag ? c.stateNode : null;
  }
  var jh = false;
  function kh(a2) {
    a2.updateQueue = { baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function lh2(a2, b) {
    a2 = a2.updateQueue;
    b.updateQueue === a2 && (b.updateQueue = { baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects });
  }
  function mh2(a2, b) {
    return { eventTime: a2, lane: b, tag: 0, payload: null, callback: null, next: null };
  }
  function nh2(a2, b, c) {
    var d2 = a2.updateQueue;
    if (null === d2) return null;
    d2 = d2.shared;
    if (0 !== (K2 & 2)) {
      var e = d2.pending;
      null === e ? b.next = b : (b.next = e.next, e.next = b);
      d2.pending = b;
      return ih2(a2, c);
    }
    e = d2.interleaved;
    null === e ? (b.next = b, gh2(d2)) : (b.next = e.next, e.next = b);
    d2.interleaved = b;
    return ih2(a2, c);
  }
  function oh2(a2, b, c) {
    b = b.updateQueue;
    if (null !== b && (b = b.shared, 0 !== (c & 4194240))) {
      var d2 = b.lanes;
      d2 &= a2.pendingLanes;
      c |= d2;
      b.lanes = c;
      Cc2(a2, c);
    }
  }
  function ph2(a2, b) {
    var c = a2.updateQueue, d2 = a2.alternate;
    if (null !== d2 && (d2 = d2.updateQueue, c === d2)) {
      var e = null, f2 = null;
      c = c.firstBaseUpdate;
      if (null !== c) {
        do {
          var g2 = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };
          null === f2 ? e = f2 = g2 : f2 = f2.next = g2;
          c = c.next;
        } while (null !== c);
        null === f2 ? e = f2 = b : f2 = f2.next = b;
      } else e = f2 = b;
      c = { baseState: d2.baseState, firstBaseUpdate: e, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
      a2.updateQueue = c;
      return;
    }
    a2 = c.lastBaseUpdate;
    null === a2 ? c.firstBaseUpdate = b : a2.next = b;
    c.lastBaseUpdate = b;
  }
  function qh(a2, b, c, d2) {
    var e = a2.updateQueue;
    jh = false;
    var f2 = e.firstBaseUpdate, g2 = e.lastBaseUpdate, h2 = e.shared.pending;
    if (null !== h2) {
      e.shared.pending = null;
      var k2 = h2, l = k2.next;
      k2.next = null;
      null === g2 ? f2 = l : g2.next = l;
      g2 = k2;
      var m2 = a2.alternate;
      null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (null === h2 ? m2.firstBaseUpdate = l : h2.next = l, m2.lastBaseUpdate = k2));
    }
    if (null !== f2) {
      var q2 = e.baseState;
      g2 = 0;
      m2 = l = k2 = null;
      h2 = f2;
      do {
        var r2 = h2.lane, y2 = h2.eventTime;
        if ((d2 & r2) === r2) {
          null !== m2 && (m2 = m2.next = {
            eventTime: y2,
            lane: 0,
            tag: h2.tag,
            payload: h2.payload,
            callback: h2.callback,
            next: null
          });
          a: {
            var n = a2, t = h2;
            r2 = b;
            y2 = c;
            switch (t.tag) {
              case 1:
                n = t.payload;
                if ("function" === typeof n) {
                  q2 = n.call(y2, q2, r2);
                  break a;
                }
                q2 = n;
                break a;
              case 3:
                n.flags = n.flags & -65537 | 128;
              case 0:
                n = t.payload;
                r2 = "function" === typeof n ? n.call(y2, q2, r2) : n;
                if (null === r2 || void 0 === r2) break a;
                q2 = A2({}, q2, r2);
                break a;
              case 2:
                jh = true;
            }
          }
          null !== h2.callback && 0 !== h2.lane && (a2.flags |= 64, r2 = e.effects, null === r2 ? e.effects = [h2] : r2.push(h2));
        } else y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l = m2 = y2, k2 = q2) : m2 = m2.next = y2, g2 |= r2;
        h2 = h2.next;
        if (null === h2) if (h2 = e.shared.pending, null === h2) break;
        else r2 = h2, h2 = r2.next, r2.next = null, e.lastBaseUpdate = r2, e.shared.pending = null;
      } while (1);
      null === m2 && (k2 = q2);
      e.baseState = k2;
      e.firstBaseUpdate = l;
      e.lastBaseUpdate = m2;
      b = e.shared.interleaved;
      if (null !== b) {
        e = b;
        do
          g2 |= e.lane, e = e.next;
        while (e !== b);
      } else null === f2 && (e.shared.lanes = 0);
      rh2 |= g2;
      a2.lanes = g2;
      a2.memoizedState = q2;
    }
  }
  function sh2(a2, b, c) {
    a2 = b.effects;
    b.effects = null;
    if (null !== a2) for (b = 0; b < a2.length; b++) {
      var d2 = a2[b], e = d2.callback;
      if (null !== e) {
        d2.callback = null;
        d2 = c;
        if ("function" !== typeof e) throw Error(p2(191, e));
        e.call(d2);
      }
    }
  }
  var th2 = {}, uh2 = Uf2(th2), vh2 = Uf2(th2), wh = Uf2(th2);
  function xh2(a2) {
    if (a2 === th2) throw Error(p2(174));
    return a2;
  }
  function yh2(a2, b) {
    G2(wh, b);
    G2(vh2, a2);
    G2(uh2, th2);
    a2 = b.nodeType;
    switch (a2) {
      case 9:
      case 11:
        b = (b = b.documentElement) ? b.namespaceURI : lb(null, "");
        break;
      default:
        a2 = 8 === a2 ? b.parentNode : b, b = a2.namespaceURI || null, a2 = a2.tagName, b = lb(b, a2);
    }
    E2(uh2);
    G2(uh2, b);
  }
  function zh2() {
    E2(uh2);
    E2(vh2);
    E2(wh);
  }
  function Ah(a2) {
    xh2(wh.current);
    var b = xh2(uh2.current);
    var c = lb(b, a2.type);
    b !== c && (G2(vh2, a2), G2(uh2, c));
  }
  function Bh(a2) {
    vh2.current === a2 && (E2(uh2), E2(vh2));
  }
  var L2 = Uf2(0);
  function Ch(a2) {
    for (var b = a2; null !== b; ) {
      if (13 === b.tag) {
        var c = b.memoizedState;
        if (null !== c && (c = c.dehydrated, null === c || "$?" === c.data || "$!" === c.data)) return b;
      } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
        if (0 !== (b.flags & 128)) return b;
      } else if (null !== b.child) {
        b.child.return = b;
        b = b.child;
        continue;
      }
      if (b === a2) break;
      for (; null === b.sibling; ) {
        if (null === b.return || b.return === a2) return null;
        b = b.return;
      }
      b.sibling.return = b.return;
      b = b.sibling;
    }
    return null;
  }
  var Dh = [];
  function Eh2() {
    for (var a2 = 0; a2 < Dh.length; a2++) Dh[a2]._workInProgressVersionPrimary = null;
    Dh.length = 0;
  }
  var Fh = ua2.ReactCurrentDispatcher, Gh = ua2.ReactCurrentBatchConfig, Hh = 0, M2 = null, N2 = null, O = null, Ih2 = false, Jh = false, Kh = 0, Lh = 0;
  function P2() {
    throw Error(p2(321));
  }
  function Mh(a2, b) {
    if (null === b) return false;
    for (var c = 0; c < b.length && c < a2.length; c++) if (!He2(a2[c], b[c])) return false;
    return true;
  }
  function Nh(a2, b, c, d2, e, f2) {
    Hh = f2;
    M2 = b;
    b.memoizedState = null;
    b.updateQueue = null;
    b.lanes = 0;
    Fh.current = null === a2 || null === a2.memoizedState ? Oh2 : Ph;
    a2 = c(d2, e);
    if (Jh) {
      f2 = 0;
      do {
        Jh = false;
        Kh = 0;
        if (25 <= f2) throw Error(p2(301));
        f2 += 1;
        O = N2 = null;
        b.updateQueue = null;
        Fh.current = Qh;
        a2 = c(d2, e);
      } while (Jh);
    }
    Fh.current = Rh;
    b = null !== N2 && null !== N2.next;
    Hh = 0;
    O = N2 = M2 = null;
    Ih2 = false;
    if (b) throw Error(p2(300));
    return a2;
  }
  function Sh2() {
    var a2 = 0 !== Kh;
    Kh = 0;
    return a2;
  }
  function Th2() {
    var a2 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    null === O ? M2.memoizedState = O = a2 : O = O.next = a2;
    return O;
  }
  function Uh2() {
    if (null === N2) {
      var a2 = M2.alternate;
      a2 = null !== a2 ? a2.memoizedState : null;
    } else a2 = N2.next;
    var b = null === O ? M2.memoizedState : O.next;
    if (null !== b) O = b, N2 = a2;
    else {
      if (null === a2) throw Error(p2(310));
      N2 = a2;
      a2 = { memoizedState: N2.memoizedState, baseState: N2.baseState, baseQueue: N2.baseQueue, queue: N2.queue, next: null };
      null === O ? M2.memoizedState = O = a2 : O = O.next = a2;
    }
    return O;
  }
  function Vh(a2, b) {
    return "function" === typeof b ? b(a2) : b;
  }
  function Wh(a2) {
    var b = Uh2(), c = b.queue;
    if (null === c) throw Error(p2(311));
    c.lastRenderedReducer = a2;
    var d2 = N2, e = d2.baseQueue, f2 = c.pending;
    if (null !== f2) {
      if (null !== e) {
        var g2 = e.next;
        e.next = f2.next;
        f2.next = g2;
      }
      d2.baseQueue = e = f2;
      c.pending = null;
    }
    if (null !== e) {
      f2 = e.next;
      d2 = d2.baseState;
      var h2 = g2 = null, k2 = null, l = f2;
      do {
        var m2 = l.lane;
        if ((Hh & m2) === m2) null !== k2 && (k2 = k2.next = { lane: 0, action: l.action, hasEagerState: l.hasEagerState, eagerState: l.eagerState, next: null }), d2 = l.hasEagerState ? l.eagerState : a2(d2, l.action);
        else {
          var q2 = {
            lane: m2,
            action: l.action,
            hasEagerState: l.hasEagerState,
            eagerState: l.eagerState,
            next: null
          };
          null === k2 ? (h2 = k2 = q2, g2 = d2) : k2 = k2.next = q2;
          M2.lanes |= m2;
          rh2 |= m2;
        }
        l = l.next;
      } while (null !== l && l !== f2);
      null === k2 ? g2 = d2 : k2.next = h2;
      He2(d2, b.memoizedState) || (dh2 = true);
      b.memoizedState = d2;
      b.baseState = g2;
      b.baseQueue = k2;
      c.lastRenderedState = d2;
    }
    a2 = c.interleaved;
    if (null !== a2) {
      e = a2;
      do
        f2 = e.lane, M2.lanes |= f2, rh2 |= f2, e = e.next;
      while (e !== a2);
    } else null === e && (c.lanes = 0);
    return [b.memoizedState, c.dispatch];
  }
  function Xh(a2) {
    var b = Uh2(), c = b.queue;
    if (null === c) throw Error(p2(311));
    c.lastRenderedReducer = a2;
    var d2 = c.dispatch, e = c.pending, f2 = b.memoizedState;
    if (null !== e) {
      c.pending = null;
      var g2 = e = e.next;
      do
        f2 = a2(f2, g2.action), g2 = g2.next;
      while (g2 !== e);
      He2(f2, b.memoizedState) || (dh2 = true);
      b.memoizedState = f2;
      null === b.baseQueue && (b.baseState = f2);
      c.lastRenderedState = f2;
    }
    return [f2, d2];
  }
  function Yh() {
  }
  function Zh(a2, b) {
    var c = M2, d2 = Uh2(), e = b(), f2 = !He2(d2.memoizedState, e);
    f2 && (d2.memoizedState = e, dh2 = true);
    d2 = d2.queue;
    $h2(ai2.bind(null, c, d2, a2), [a2]);
    if (d2.getSnapshot !== b || f2 || null !== O && O.memoizedState.tag & 1) {
      c.flags |= 2048;
      bi2(9, ci2.bind(null, c, d2, e, b), void 0, null);
      if (null === Q2) throw Error(p2(349));
      0 !== (Hh & 30) || di2(c, b, e);
    }
    return e;
  }
  function di2(a2, b, c) {
    a2.flags |= 16384;
    a2 = { getSnapshot: b, value: c };
    b = M2.updateQueue;
    null === b ? (b = { lastEffect: null, stores: null }, M2.updateQueue = b, b.stores = [a2]) : (c = b.stores, null === c ? b.stores = [a2] : c.push(a2));
  }
  function ci2(a2, b, c, d2) {
    b.value = c;
    b.getSnapshot = d2;
    ei2(b) && fi2(a2);
  }
  function ai2(a2, b, c) {
    return c(function() {
      ei2(b) && fi2(a2);
    });
  }
  function ei2(a2) {
    var b = a2.getSnapshot;
    a2 = a2.value;
    try {
      var c = b();
      return !He2(a2, c);
    } catch (d2) {
      return true;
    }
  }
  function fi2(a2) {
    var b = ih2(a2, 1);
    null !== b && gi2(b, a2, 1, -1);
  }
  function hi2(a2) {
    var b = Th2();
    "function" === typeof a2 && (a2 = a2());
    b.memoizedState = b.baseState = a2;
    a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a2 };
    b.queue = a2;
    a2 = a2.dispatch = ii2.bind(null, M2, a2);
    return [b.memoizedState, a2];
  }
  function bi2(a2, b, c, d2) {
    a2 = { tag: a2, create: b, destroy: c, deps: d2, next: null };
    b = M2.updateQueue;
    null === b ? (b = { lastEffect: null, stores: null }, M2.updateQueue = b, b.lastEffect = a2.next = a2) : (c = b.lastEffect, null === c ? b.lastEffect = a2.next = a2 : (d2 = c.next, c.next = a2, a2.next = d2, b.lastEffect = a2));
    return a2;
  }
  function ji2() {
    return Uh2().memoizedState;
  }
  function ki2(a2, b, c, d2) {
    var e = Th2();
    M2.flags |= a2;
    e.memoizedState = bi2(1 | b, c, void 0, void 0 === d2 ? null : d2);
  }
  function li2(a2, b, c, d2) {
    var e = Uh2();
    d2 = void 0 === d2 ? null : d2;
    var f2 = void 0;
    if (null !== N2) {
      var g2 = N2.memoizedState;
      f2 = g2.destroy;
      if (null !== d2 && Mh(d2, g2.deps)) {
        e.memoizedState = bi2(b, c, f2, d2);
        return;
      }
    }
    M2.flags |= a2;
    e.memoizedState = bi2(1 | b, c, f2, d2);
  }
  function mi2(a2, b) {
    return ki2(8390656, 8, a2, b);
  }
  function $h2(a2, b) {
    return li2(2048, 8, a2, b);
  }
  function ni2(a2, b) {
    return li2(4, 2, a2, b);
  }
  function oi2(a2, b) {
    return li2(4, 4, a2, b);
  }
  function pi2(a2, b) {
    if ("function" === typeof b) return a2 = a2(), b(a2), function() {
      b(null);
    };
    if (null !== b && void 0 !== b) return a2 = a2(), b.current = a2, function() {
      b.current = null;
    };
  }
  function qi2(a2, b, c) {
    c = null !== c && void 0 !== c ? c.concat([a2]) : null;
    return li2(4, 4, pi2.bind(null, b, a2), c);
  }
  function ri2() {
  }
  function si2(a2, b) {
    var c = Uh2();
    b = void 0 === b ? null : b;
    var d2 = c.memoizedState;
    if (null !== d2 && null !== b && Mh(b, d2[1])) return d2[0];
    c.memoizedState = [a2, b];
    return a2;
  }
  function ti2(a2, b) {
    var c = Uh2();
    b = void 0 === b ? null : b;
    var d2 = c.memoizedState;
    if (null !== d2 && null !== b && Mh(b, d2[1])) return d2[0];
    a2 = a2();
    c.memoizedState = [a2, b];
    return a2;
  }
  function ui2(a2, b, c) {
    if (0 === (Hh & 21)) return a2.baseState && (a2.baseState = false, dh2 = true), a2.memoizedState = c;
    He2(c, b) || (c = yc2(), M2.lanes |= c, rh2 |= c, a2.baseState = true);
    return b;
  }
  function vi2(a2, b) {
    var c = C;
    C = 0 !== c && 4 > c ? c : 4;
    a2(true);
    var d2 = Gh.transition;
    Gh.transition = {};
    try {
      a2(false), b();
    } finally {
      C = c, Gh.transition = d2;
    }
  }
  function wi2() {
    return Uh2().memoizedState;
  }
  function xi2(a2, b, c) {
    var d2 = yi2(a2);
    c = { lane: d2, action: c, hasEagerState: false, eagerState: null, next: null };
    if (zi2(a2)) Ai2(b, c);
    else if (c = hh2(a2, b, c, d2), null !== c) {
      var e = R2();
      gi2(c, a2, d2, e);
      Bi2(c, b, d2);
    }
  }
  function ii2(a2, b, c) {
    var d2 = yi2(a2), e = { lane: d2, action: c, hasEagerState: false, eagerState: null, next: null };
    if (zi2(a2)) Ai2(b, e);
    else {
      var f2 = a2.alternate;
      if (0 === a2.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b.lastRenderedReducer, null !== f2)) try {
        var g2 = b.lastRenderedState, h2 = f2(g2, c);
        e.hasEagerState = true;
        e.eagerState = h2;
        if (He2(h2, g2)) {
          var k2 = b.interleaved;
          null === k2 ? (e.next = e, gh2(b)) : (e.next = k2.next, k2.next = e);
          b.interleaved = e;
          return;
        }
      } catch (l) {
      } finally {
      }
      c = hh2(a2, b, e, d2);
      null !== c && (e = R2(), gi2(c, a2, d2, e), Bi2(c, b, d2));
    }
  }
  function zi2(a2) {
    var b = a2.alternate;
    return a2 === M2 || null !== b && b === M2;
  }
  function Ai2(a2, b) {
    Jh = Ih2 = true;
    var c = a2.pending;
    null === c ? b.next = b : (b.next = c.next, c.next = b);
    a2.pending = b;
  }
  function Bi2(a2, b, c) {
    if (0 !== (c & 4194240)) {
      var d2 = b.lanes;
      d2 &= a2.pendingLanes;
      c |= d2;
      b.lanes = c;
      Cc2(a2, c);
    }
  }
  var Rh = { readContext: eh2, useCallback: P2, useContext: P2, useEffect: P2, useImperativeHandle: P2, useInsertionEffect: P2, useLayoutEffect: P2, useMemo: P2, useReducer: P2, useRef: P2, useState: P2, useDebugValue: P2, useDeferredValue: P2, useTransition: P2, useMutableSource: P2, useSyncExternalStore: P2, useId: P2, unstable_isNewReconciler: false }, Oh2 = { readContext: eh2, useCallback: function(a2, b) {
    Th2().memoizedState = [a2, void 0 === b ? null : b];
    return a2;
  }, useContext: eh2, useEffect: mi2, useImperativeHandle: function(a2, b, c) {
    c = null !== c && void 0 !== c ? c.concat([a2]) : null;
    return ki2(
      4194308,
      4,
      pi2.bind(null, b, a2),
      c
    );
  }, useLayoutEffect: function(a2, b) {
    return ki2(4194308, 4, a2, b);
  }, useInsertionEffect: function(a2, b) {
    return ki2(4, 2, a2, b);
  }, useMemo: function(a2, b) {
    var c = Th2();
    b = void 0 === b ? null : b;
    a2 = a2();
    c.memoizedState = [a2, b];
    return a2;
  }, useReducer: function(a2, b, c) {
    var d2 = Th2();
    b = void 0 !== c ? c(b) : b;
    d2.memoizedState = d2.baseState = b;
    a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b };
    d2.queue = a2;
    a2 = a2.dispatch = xi2.bind(null, M2, a2);
    return [d2.memoizedState, a2];
  }, useRef: function(a2) {
    var b = Th2();
    a2 = { current: a2 };
    return b.memoizedState = a2;
  }, useState: hi2, useDebugValue: ri2, useDeferredValue: function(a2) {
    return Th2().memoizedState = a2;
  }, useTransition: function() {
    var a2 = hi2(false), b = a2[0];
    a2 = vi2.bind(null, a2[1]);
    Th2().memoizedState = a2;
    return [b, a2];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(a2, b, c) {
    var d2 = M2, e = Th2();
    if (I2) {
      if (void 0 === c) throw Error(p2(407));
      c = c();
    } else {
      c = b();
      if (null === Q2) throw Error(p2(349));
      0 !== (Hh & 30) || di2(d2, b, c);
    }
    e.memoizedState = c;
    var f2 = { value: c, getSnapshot: b };
    e.queue = f2;
    mi2(ai2.bind(
      null,
      d2,
      f2,
      a2
    ), [a2]);
    d2.flags |= 2048;
    bi2(9, ci2.bind(null, d2, f2, c, b), void 0, null);
    return c;
  }, useId: function() {
    var a2 = Th2(), b = Q2.identifierPrefix;
    if (I2) {
      var c = sg2;
      var d2 = rg2;
      c = (d2 & ~(1 << 32 - oc2(d2) - 1)).toString(32) + c;
      b = ":" + b + "R" + c;
      c = Kh++;
      0 < c && (b += "H" + c.toString(32));
      b += ":";
    } else c = Lh++, b = ":" + b + "r" + c.toString(32) + ":";
    return a2.memoizedState = b;
  }, unstable_isNewReconciler: false }, Ph = {
    readContext: eh2,
    useCallback: si2,
    useContext: eh2,
    useEffect: $h2,
    useImperativeHandle: qi2,
    useInsertionEffect: ni2,
    useLayoutEffect: oi2,
    useMemo: ti2,
    useReducer: Wh,
    useRef: ji2,
    useState: function() {
      return Wh(Vh);
    },
    useDebugValue: ri2,
    useDeferredValue: function(a2) {
      var b = Uh2();
      return ui2(b, N2.memoizedState, a2);
    },
    useTransition: function() {
      var a2 = Wh(Vh)[0], b = Uh2().memoizedState;
      return [a2, b];
    },
    useMutableSource: Yh,
    useSyncExternalStore: Zh,
    useId: wi2,
    unstable_isNewReconciler: false
  }, Qh = { readContext: eh2, useCallback: si2, useContext: eh2, useEffect: $h2, useImperativeHandle: qi2, useInsertionEffect: ni2, useLayoutEffect: oi2, useMemo: ti2, useReducer: Xh, useRef: ji2, useState: function() {
    return Xh(Vh);
  }, useDebugValue: ri2, useDeferredValue: function(a2) {
    var b = Uh2();
    return null === N2 ? b.memoizedState = a2 : ui2(b, N2.memoizedState, a2);
  }, useTransition: function() {
    var a2 = Xh(Vh)[0], b = Uh2().memoizedState;
    return [a2, b];
  }, useMutableSource: Yh, useSyncExternalStore: Zh, useId: wi2, unstable_isNewReconciler: false };
  function Ci2(a2, b) {
    if (a2 && a2.defaultProps) {
      b = A2({}, b);
      a2 = a2.defaultProps;
      for (var c in a2) void 0 === b[c] && (b[c] = a2[c]);
      return b;
    }
    return b;
  }
  function Di2(a2, b, c, d2) {
    b = a2.memoizedState;
    c = c(d2, b);
    c = null === c || void 0 === c ? b : A2({}, b, c);
    a2.memoizedState = c;
    0 === a2.lanes && (a2.updateQueue.baseState = c);
  }
  var Ei2 = { isMounted: function(a2) {
    return (a2 = a2._reactInternals) ? Vb(a2) === a2 : false;
  }, enqueueSetState: function(a2, b, c) {
    a2 = a2._reactInternals;
    var d2 = R2(), e = yi2(a2), f2 = mh2(d2, e);
    f2.payload = b;
    void 0 !== c && null !== c && (f2.callback = c);
    b = nh2(a2, f2, e);
    null !== b && (gi2(b, a2, e, d2), oh2(b, a2, e));
  }, enqueueReplaceState: function(a2, b, c) {
    a2 = a2._reactInternals;
    var d2 = R2(), e = yi2(a2), f2 = mh2(d2, e);
    f2.tag = 1;
    f2.payload = b;
    void 0 !== c && null !== c && (f2.callback = c);
    b = nh2(a2, f2, e);
    null !== b && (gi2(b, a2, e, d2), oh2(b, a2, e));
  }, enqueueForceUpdate: function(a2, b) {
    a2 = a2._reactInternals;
    var c = R2(), d2 = yi2(a2), e = mh2(c, d2);
    e.tag = 2;
    void 0 !== b && null !== b && (e.callback = b);
    b = nh2(a2, e, d2);
    null !== b && (gi2(b, a2, d2, c), oh2(b, a2, d2));
  } };
  function Fi2(a2, b, c, d2, e, f2, g2) {
    a2 = a2.stateNode;
    return "function" === typeof a2.shouldComponentUpdate ? a2.shouldComponentUpdate(d2, f2, g2) : b.prototype && b.prototype.isPureReactComponent ? !Ie2(c, d2) || !Ie2(e, f2) : true;
  }
  function Gi2(a2, b, c) {
    var d2 = false, e = Vf2;
    var f2 = b.contextType;
    "object" === typeof f2 && null !== f2 ? f2 = eh2(f2) : (e = Zf2(b) ? Xf2 : H2.current, d2 = b.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Yf2(a2, e) : Vf2);
    b = new b(c, f2);
    a2.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
    b.updater = Ei2;
    a2.stateNode = b;
    b._reactInternals = a2;
    d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e, a2.__reactInternalMemoizedMaskedChildContext = f2);
    return b;
  }
  function Hi2(a2, b, c, d2) {
    a2 = b.state;
    "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d2);
    "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d2);
    b.state !== a2 && Ei2.enqueueReplaceState(b, b.state, null);
  }
  function Ii2(a2, b, c, d2) {
    var e = a2.stateNode;
    e.props = c;
    e.state = a2.memoizedState;
    e.refs = {};
    kh(a2);
    var f2 = b.contextType;
    "object" === typeof f2 && null !== f2 ? e.context = eh2(f2) : (f2 = Zf2(b) ? Xf2 : H2.current, e.context = Yf2(a2, f2));
    e.state = a2.memoizedState;
    f2 = b.getDerivedStateFromProps;
    "function" === typeof f2 && (Di2(a2, b, f2, c), e.state = a2.memoizedState);
    "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && Ei2.enqueueReplaceState(e, e.state, null), qh(a2, c, e, d2), e.state = a2.memoizedState);
    "function" === typeof e.componentDidMount && (a2.flags |= 4194308);
  }
  function Ji2(a2, b) {
    try {
      var c = "", d2 = b;
      do
        c += Pa(d2), d2 = d2.return;
      while (d2);
      var e = c;
    } catch (f2) {
      e = "\nError generating stack: " + f2.message + "\n" + f2.stack;
    }
    return { value: a2, source: b, stack: e, digest: null };
  }
  function Ki2(a2, b, c) {
    return { value: a2, source: null, stack: null != c ? c : null, digest: null != b ? b : null };
  }
  function Li2(a2, b) {
    try {
      console.error(b.value);
    } catch (c) {
      setTimeout(function() {
        throw c;
      });
    }
  }
  var Mi2 = "function" === typeof WeakMap ? WeakMap : Map;
  function Ni2(a2, b, c) {
    c = mh2(-1, c);
    c.tag = 3;
    c.payload = { element: null };
    var d2 = b.value;
    c.callback = function() {
      Oi2 || (Oi2 = true, Pi2 = d2);
      Li2(a2, b);
    };
    return c;
  }
  function Qi2(a2, b, c) {
    c = mh2(-1, c);
    c.tag = 3;
    var d2 = a2.type.getDerivedStateFromError;
    if ("function" === typeof d2) {
      var e = b.value;
      c.payload = function() {
        return d2(e);
      };
      c.callback = function() {
        Li2(a2, b);
      };
    }
    var f2 = a2.stateNode;
    null !== f2 && "function" === typeof f2.componentDidCatch && (c.callback = function() {
      Li2(a2, b);
      "function" !== typeof d2 && (null === Ri2 ? Ri2 = /* @__PURE__ */ new Set([this]) : Ri2.add(this));
      var c2 = b.stack;
      this.componentDidCatch(b.value, { componentStack: null !== c2 ? c2 : "" });
    });
    return c;
  }
  function Si2(a2, b, c) {
    var d2 = a2.pingCache;
    if (null === d2) {
      d2 = a2.pingCache = new Mi2();
      var e = /* @__PURE__ */ new Set();
      d2.set(b, e);
    } else e = d2.get(b), void 0 === e && (e = /* @__PURE__ */ new Set(), d2.set(b, e));
    e.has(c) || (e.add(c), a2 = Ti2.bind(null, a2, b, c), b.then(a2, a2));
  }
  function Ui2(a2) {
    do {
      var b;
      if (b = 13 === a2.tag) b = a2.memoizedState, b = null !== b ? null !== b.dehydrated ? true : false : true;
      if (b) return a2;
      a2 = a2.return;
    } while (null !== a2);
    return null;
  }
  function Vi2(a2, b, c, d2, e) {
    if (0 === (a2.mode & 1)) return a2 === b ? a2.flags |= 65536 : (a2.flags |= 128, c.flags |= 131072, c.flags &= -52805, 1 === c.tag && (null === c.alternate ? c.tag = 17 : (b = mh2(-1, 1), b.tag = 2, nh2(c, b, 1))), c.lanes |= 1), a2;
    a2.flags |= 65536;
    a2.lanes = e;
    return a2;
  }
  var Wi2 = ua2.ReactCurrentOwner, dh2 = false;
  function Xi2(a2, b, c, d2) {
    b.child = null === a2 ? Vg2(b, null, c, d2) : Ug2(b, a2.child, c, d2);
  }
  function Yi2(a2, b, c, d2, e) {
    c = c.render;
    var f2 = b.ref;
    ch2(b, e);
    d2 = Nh(a2, b, c, d2, f2, e);
    c = Sh2();
    if (null !== a2 && !dh2) return b.updateQueue = a2.updateQueue, b.flags &= -2053, a2.lanes &= ~e, Zi2(a2, b, e);
    I2 && c && vg3(b);
    b.flags |= 1;
    Xi2(a2, b, d2, e);
    return b.child;
  }
  function $i2(a2, b, c, d2, e) {
    if (null === a2) {
      var f2 = c.type;
      if ("function" === typeof f2 && !aj(f2) && void 0 === f2.defaultProps && null === c.compare && void 0 === c.defaultProps) return b.tag = 15, b.type = f2, bj(a2, b, f2, d2, e);
      a2 = Rg2(c.type, null, d2, b, b.mode, e);
      a2.ref = b.ref;
      a2.return = b;
      return b.child = a2;
    }
    f2 = a2.child;
    if (0 === (a2.lanes & e)) {
      var g2 = f2.memoizedProps;
      c = c.compare;
      c = null !== c ? c : Ie2;
      if (c(g2, d2) && a2.ref === b.ref) return Zi2(a2, b, e);
    }
    b.flags |= 1;
    a2 = Pg2(f2, d2);
    a2.ref = b.ref;
    a2.return = b;
    return b.child = a2;
  }
  function bj(a2, b, c, d2, e) {
    if (null !== a2) {
      var f2 = a2.memoizedProps;
      if (Ie2(f2, d2) && a2.ref === b.ref) if (dh2 = false, b.pendingProps = d2 = f2, 0 !== (a2.lanes & e)) 0 !== (a2.flags & 131072) && (dh2 = true);
      else return b.lanes = a2.lanes, Zi2(a2, b, e);
    }
    return cj(a2, b, c, d2, e);
  }
  function dj(a2, b, c) {
    var d2 = b.pendingProps, e = d2.children, f2 = null !== a2 ? a2.memoizedState : null;
    if ("hidden" === d2.mode) if (0 === (b.mode & 1)) b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G2(ej, fj), fj |= c;
    else {
      if (0 === (c & 1073741824)) return a2 = null !== f2 ? f2.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = { baseLanes: a2, cachePool: null, transitions: null }, b.updateQueue = null, G2(ej, fj), fj |= a2, null;
      b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
      d2 = null !== f2 ? f2.baseLanes : c;
      G2(ej, fj);
      fj |= d2;
    }
    else null !== f2 ? (d2 = f2.baseLanes | c, b.memoizedState = null) : d2 = c, G2(ej, fj), fj |= d2;
    Xi2(a2, b, e, c);
    return b.child;
  }
  function gj(a2, b) {
    var c = b.ref;
    if (null === a2 && null !== c || null !== a2 && a2.ref !== c) b.flags |= 512, b.flags |= 2097152;
  }
  function cj(a2, b, c, d2, e) {
    var f2 = Zf2(c) ? Xf2 : H2.current;
    f2 = Yf2(b, f2);
    ch2(b, e);
    c = Nh(a2, b, c, d2, f2, e);
    d2 = Sh2();
    if (null !== a2 && !dh2) return b.updateQueue = a2.updateQueue, b.flags &= -2053, a2.lanes &= ~e, Zi2(a2, b, e);
    I2 && d2 && vg3(b);
    b.flags |= 1;
    Xi2(a2, b, c, e);
    return b.child;
  }
  function hj(a2, b, c, d2, e) {
    if (Zf2(c)) {
      var f2 = true;
      cg2(b);
    } else f2 = false;
    ch2(b, e);
    if (null === b.stateNode) ij(a2, b), Gi2(b, c, d2), Ii2(b, c, d2, e), d2 = true;
    else if (null === a2) {
      var g2 = b.stateNode, h2 = b.memoizedProps;
      g2.props = h2;
      var k2 = g2.context, l = c.contextType;
      "object" === typeof l && null !== l ? l = eh2(l) : (l = Zf2(c) ? Xf2 : H2.current, l = Yf2(b, l));
      var m2 = c.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
      q2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || k2 !== l) && Hi2(b, g2, d2, l);
      jh = false;
      var r2 = b.memoizedState;
      g2.state = r2;
      qh(b, d2, g2, e);
      k2 = b.memoizedState;
      h2 !== d2 || r2 !== k2 || Wf2.current || jh ? ("function" === typeof m2 && (Di2(b, c, m2, d2), k2 = b.memoizedState), (h2 = jh || Fi2(b, c, h2, d2, r2, k2, l)) ? (q2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b.flags |= 4194308), b.memoizedProps = d2, b.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l, d2 = h2) : ("function" === typeof g2.componentDidMount && (b.flags |= 4194308), d2 = false);
    } else {
      g2 = b.stateNode;
      lh2(a2, b);
      h2 = b.memoizedProps;
      l = b.type === b.elementType ? h2 : Ci2(b.type, h2);
      g2.props = l;
      q2 = b.pendingProps;
      r2 = g2.context;
      k2 = c.contextType;
      "object" === typeof k2 && null !== k2 ? k2 = eh2(k2) : (k2 = Zf2(c) ? Xf2 : H2.current, k2 = Yf2(b, k2));
      var y2 = c.getDerivedStateFromProps;
      (m2 = "function" === typeof y2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== q2 || r2 !== k2) && Hi2(b, g2, d2, k2);
      jh = false;
      r2 = b.memoizedState;
      g2.state = r2;
      qh(b, d2, g2, e);
      var n = b.memoizedState;
      h2 !== q2 || r2 !== n || Wf2.current || jh ? ("function" === typeof y2 && (Di2(b, c, y2, d2), n = b.memoizedState), (l = jh || Fi2(b, c, l, d2, r2, n, k2) || false) ? (m2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d2, n, k2), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, n, k2)), "function" === typeof g2.componentDidUpdate && (b.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b.flags |= 1024), b.memoizedProps = d2, b.memoizedState = n), g2.props = d2, g2.state = n, g2.context = k2, d2 = l) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b.flags |= 1024), d2 = false);
    }
    return jj(a2, b, c, d2, f2, e);
  }
  function jj(a2, b, c, d2, e, f2) {
    gj(a2, b);
    var g2 = 0 !== (b.flags & 128);
    if (!d2 && !g2) return e && dg2(b, c, false), Zi2(a2, b, f2);
    d2 = b.stateNode;
    Wi2.current = b;
    var h2 = g2 && "function" !== typeof c.getDerivedStateFromError ? null : d2.render();
    b.flags |= 1;
    null !== a2 && g2 ? (b.child = Ug2(b, a2.child, null, f2), b.child = Ug2(b, null, h2, f2)) : Xi2(a2, b, h2, f2);
    b.memoizedState = d2.state;
    e && dg2(b, c, true);
    return b.child;
  }
  function kj(a2) {
    var b = a2.stateNode;
    b.pendingContext ? ag2(a2, b.pendingContext, b.pendingContext !== b.context) : b.context && ag2(a2, b.context, false);
    yh2(a2, b.containerInfo);
  }
  function lj(a2, b, c, d2, e) {
    Ig2();
    Jg2(e);
    b.flags |= 256;
    Xi2(a2, b, c, d2);
    return b.child;
  }
  var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
  function nj(a2) {
    return { baseLanes: a2, cachePool: null, transitions: null };
  }
  function oj(a2, b, c) {
    var d2 = b.pendingProps, e = L2.current, f2 = false, g2 = 0 !== (b.flags & 128), h2;
    (h2 = g2) || (h2 = null !== a2 && null === a2.memoizedState ? false : 0 !== (e & 2));
    if (h2) f2 = true, b.flags &= -129;
    else if (null === a2 || null !== a2.memoizedState) e |= 1;
    G2(L2, e & 1);
    if (null === a2) {
      Eg2(b);
      a2 = b.memoizedState;
      if (null !== a2 && (a2 = a2.dehydrated, null !== a2)) return 0 === (b.mode & 1) ? b.lanes = 1 : "$!" === a2.data ? b.lanes = 8 : b.lanes = 1073741824, null;
      g2 = d2.children;
      a2 = d2.fallback;
      return f2 ? (d2 = b.mode, f2 = b.child, g2 = { mode: "hidden", children: g2 }, 0 === (d2 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = pj(g2, d2, 0, null), a2 = Tg2(a2, d2, c, null), f2.return = b, a2.return = b, f2.sibling = a2, b.child = f2, b.child.memoizedState = nj(c), b.memoizedState = mj, a2) : qj(b, g2);
    }
    e = a2.memoizedState;
    if (null !== e && (h2 = e.dehydrated, null !== h2)) return rj(a2, b, g2, d2, h2, e, c);
    if (f2) {
      f2 = d2.fallback;
      g2 = b.mode;
      e = a2.child;
      h2 = e.sibling;
      var k2 = { mode: "hidden", children: d2.children };
      0 === (g2 & 1) && b.child !== e ? (d2 = b.child, d2.childLanes = 0, d2.pendingProps = k2, b.deletions = null) : (d2 = Pg2(e, k2), d2.subtreeFlags = e.subtreeFlags & 14680064);
      null !== h2 ? f2 = Pg2(h2, f2) : (f2 = Tg2(f2, g2, c, null), f2.flags |= 2);
      f2.return = b;
      d2.return = b;
      d2.sibling = f2;
      b.child = d2;
      d2 = f2;
      f2 = b.child;
      g2 = a2.child.memoizedState;
      g2 = null === g2 ? nj(c) : { baseLanes: g2.baseLanes | c, cachePool: null, transitions: g2.transitions };
      f2.memoizedState = g2;
      f2.childLanes = a2.childLanes & ~c;
      b.memoizedState = mj;
      return d2;
    }
    f2 = a2.child;
    a2 = f2.sibling;
    d2 = Pg2(f2, { mode: "visible", children: d2.children });
    0 === (b.mode & 1) && (d2.lanes = c);
    d2.return = b;
    d2.sibling = null;
    null !== a2 && (c = b.deletions, null === c ? (b.deletions = [a2], b.flags |= 16) : c.push(a2));
    b.child = d2;
    b.memoizedState = null;
    return d2;
  }
  function qj(a2, b) {
    b = pj({ mode: "visible", children: b }, a2.mode, 0, null);
    b.return = a2;
    return a2.child = b;
  }
  function sj(a2, b, c, d2) {
    null !== d2 && Jg2(d2);
    Ug2(b, a2.child, null, c);
    a2 = qj(b, b.pendingProps.children);
    a2.flags |= 2;
    b.memoizedState = null;
    return a2;
  }
  function rj(a2, b, c, d2, e, f2, g2) {
    if (c) {
      if (b.flags & 256) return b.flags &= -257, d2 = Ki2(Error(p2(422))), sj(a2, b, g2, d2);
      if (null !== b.memoizedState) return b.child = a2.child, b.flags |= 128, null;
      f2 = d2.fallback;
      e = b.mode;
      d2 = pj({ mode: "visible", children: d2.children }, e, 0, null);
      f2 = Tg2(f2, e, g2, null);
      f2.flags |= 2;
      d2.return = b;
      f2.return = b;
      d2.sibling = f2;
      b.child = d2;
      0 !== (b.mode & 1) && Ug2(b, a2.child, null, g2);
      b.child.memoizedState = nj(g2);
      b.memoizedState = mj;
      return f2;
    }
    if (0 === (b.mode & 1)) return sj(a2, b, g2, null);
    if ("$!" === e.data) {
      d2 = e.nextSibling && e.nextSibling.dataset;
      if (d2) var h2 = d2.dgst;
      d2 = h2;
      f2 = Error(p2(419));
      d2 = Ki2(f2, d2, void 0);
      return sj(a2, b, g2, d2);
    }
    h2 = 0 !== (g2 & a2.childLanes);
    if (dh2 || h2) {
      d2 = Q2;
      if (null !== d2) {
        switch (g2 & -g2) {
          case 4:
            e = 2;
            break;
          case 16:
            e = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            e = 32;
            break;
          case 536870912:
            e = 268435456;
            break;
          default:
            e = 0;
        }
        e = 0 !== (e & (d2.suspendedLanes | g2)) ? 0 : e;
        0 !== e && e !== f2.retryLane && (f2.retryLane = e, ih2(a2, e), gi2(d2, a2, e, -1));
      }
      tj();
      d2 = Ki2(Error(p2(421)));
      return sj(a2, b, g2, d2);
    }
    if ("$?" === e.data) return b.flags |= 128, b.child = a2.child, b = uj.bind(null, a2), e._reactRetry = b, null;
    a2 = f2.treeContext;
    yg2 = Lf2(e.nextSibling);
    xg2 = b;
    I2 = true;
    zg2 = null;
    null !== a2 && (og2[pg2++] = rg2, og2[pg2++] = sg2, og2[pg2++] = qg2, rg2 = a2.id, sg2 = a2.overflow, qg2 = b);
    b = qj(b, d2.children);
    b.flags |= 4096;
    return b;
  }
  function vj(a2, b, c) {
    a2.lanes |= b;
    var d2 = a2.alternate;
    null !== d2 && (d2.lanes |= b);
    bh2(a2.return, b, c);
  }
  function wj(a2, b, c, d2, e) {
    var f2 = a2.memoizedState;
    null === f2 ? a2.memoizedState = { isBackwards: b, rendering: null, renderingStartTime: 0, last: d2, tail: c, tailMode: e } : (f2.isBackwards = b, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d2, f2.tail = c, f2.tailMode = e);
  }
  function xj(a2, b, c) {
    var d2 = b.pendingProps, e = d2.revealOrder, f2 = d2.tail;
    Xi2(a2, b, d2.children, c);
    d2 = L2.current;
    if (0 !== (d2 & 2)) d2 = d2 & 1 | 2, b.flags |= 128;
    else {
      if (null !== a2 && 0 !== (a2.flags & 128)) a: for (a2 = b.child; null !== a2; ) {
        if (13 === a2.tag) null !== a2.memoizedState && vj(a2, c, b);
        else if (19 === a2.tag) vj(a2, c, b);
        else if (null !== a2.child) {
          a2.child.return = a2;
          a2 = a2.child;
          continue;
        }
        if (a2 === b) break a;
        for (; null === a2.sibling; ) {
          if (null === a2.return || a2.return === b) break a;
          a2 = a2.return;
        }
        a2.sibling.return = a2.return;
        a2 = a2.sibling;
      }
      d2 &= 1;
    }
    G2(L2, d2);
    if (0 === (b.mode & 1)) b.memoizedState = null;
    else switch (e) {
      case "forwards":
        c = b.child;
        for (e = null; null !== c; ) a2 = c.alternate, null !== a2 && null === Ch(a2) && (e = c), c = c.sibling;
        c = e;
        null === c ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
        wj(b, false, e, c, f2);
        break;
      case "backwards":
        c = null;
        e = b.child;
        for (b.child = null; null !== e; ) {
          a2 = e.alternate;
          if (null !== a2 && null === Ch(a2)) {
            b.child = e;
            break;
          }
          a2 = e.sibling;
          e.sibling = c;
          c = e;
          e = a2;
        }
        wj(b, true, c, null, f2);
        break;
      case "together":
        wj(b, false, null, null, void 0);
        break;
      default:
        b.memoizedState = null;
    }
    return b.child;
  }
  function ij(a2, b) {
    0 === (b.mode & 1) && null !== a2 && (a2.alternate = null, b.alternate = null, b.flags |= 2);
  }
  function Zi2(a2, b, c) {
    null !== a2 && (b.dependencies = a2.dependencies);
    rh2 |= b.lanes;
    if (0 === (c & b.childLanes)) return null;
    if (null !== a2 && b.child !== a2.child) throw Error(p2(153));
    if (null !== b.child) {
      a2 = b.child;
      c = Pg2(a2, a2.pendingProps);
      b.child = c;
      for (c.return = b; null !== a2.sibling; ) a2 = a2.sibling, c = c.sibling = Pg2(a2, a2.pendingProps), c.return = b;
      c.sibling = null;
    }
    return b.child;
  }
  function yj(a2, b, c) {
    switch (b.tag) {
      case 3:
        kj(b);
        Ig2();
        break;
      case 5:
        Ah(b);
        break;
      case 1:
        Zf2(b.type) && cg2(b);
        break;
      case 4:
        yh2(b, b.stateNode.containerInfo);
        break;
      case 10:
        var d2 = b.type._context, e = b.memoizedProps.value;
        G2(Wg2, d2._currentValue);
        d2._currentValue = e;
        break;
      case 13:
        d2 = b.memoizedState;
        if (null !== d2) {
          if (null !== d2.dehydrated) return G2(L2, L2.current & 1), b.flags |= 128, null;
          if (0 !== (c & b.child.childLanes)) return oj(a2, b, c);
          G2(L2, L2.current & 1);
          a2 = Zi2(a2, b, c);
          return null !== a2 ? a2.sibling : null;
        }
        G2(L2, L2.current & 1);
        break;
      case 19:
        d2 = 0 !== (c & b.childLanes);
        if (0 !== (a2.flags & 128)) {
          if (d2) return xj(a2, b, c);
          b.flags |= 128;
        }
        e = b.memoizedState;
        null !== e && (e.rendering = null, e.tail = null, e.lastEffect = null);
        G2(L2, L2.current);
        if (d2) break;
        else return null;
      case 22:
      case 23:
        return b.lanes = 0, dj(a2, b, c);
    }
    return Zi2(a2, b, c);
  }
  var zj, Aj, Bj, Cj;
  zj = function(a2, b) {
    for (var c = b.child; null !== c; ) {
      if (5 === c.tag || 6 === c.tag) a2.appendChild(c.stateNode);
      else if (4 !== c.tag && null !== c.child) {
        c.child.return = c;
        c = c.child;
        continue;
      }
      if (c === b) break;
      for (; null === c.sibling; ) {
        if (null === c.return || c.return === b) return;
        c = c.return;
      }
      c.sibling.return = c.return;
      c = c.sibling;
    }
  };
  Aj = function() {
  };
  Bj = function(a2, b, c, d2) {
    var e = a2.memoizedProps;
    if (e !== d2) {
      a2 = b.stateNode;
      xh2(uh2.current);
      var f2 = null;
      switch (c) {
        case "input":
          e = Ya2(a2, e);
          d2 = Ya2(a2, d2);
          f2 = [];
          break;
        case "select":
          e = A2({}, e, { value: void 0 });
          d2 = A2({}, d2, { value: void 0 });
          f2 = [];
          break;
        case "textarea":
          e = gb(a2, e);
          d2 = gb(a2, d2);
          f2 = [];
          break;
        default:
          "function" !== typeof e.onClick && "function" === typeof d2.onClick && (a2.onclick = Bf2);
      }
      ub(c, d2);
      var g2;
      c = null;
      for (l in e) if (!d2.hasOwnProperty(l) && e.hasOwnProperty(l) && null != e[l]) if ("style" === l) {
        var h2 = e[l];
        for (g2 in h2) h2.hasOwnProperty(g2) && (c || (c = {}), c[g2] = "");
      } else "dangerouslySetInnerHTML" !== l && "children" !== l && "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && "autoFocus" !== l && (ea2.hasOwnProperty(l) ? f2 || (f2 = []) : (f2 = f2 || []).push(l, null));
      for (l in d2) {
        var k2 = d2[l];
        h2 = null != e ? e[l] : void 0;
        if (d2.hasOwnProperty(l) && k2 !== h2 && (null != k2 || null != h2)) if ("style" === l) if (h2) {
          for (g2 in h2) !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c || (c = {}), c[g2] = "");
          for (g2 in k2) k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c || (c = {}), c[g2] = k2[g2]);
        } else c || (f2 || (f2 = []), f2.push(
          l,
          c
        )), c = k2;
        else "dangerouslySetInnerHTML" === l ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l, k2)) : "children" === l ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l, "" + k2) : "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && (ea2.hasOwnProperty(l) ? (null != k2 && "onScroll" === l && D2("scroll", a2), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l, k2));
      }
      c && (f2 = f2 || []).push("style", c);
      var l = f2;
      if (b.updateQueue = l) b.flags |= 4;
    }
  };
  Cj = function(a2, b, c, d2) {
    c !== d2 && (b.flags |= 4);
  };
  function Dj(a2, b) {
    if (!I2) switch (a2.tailMode) {
      case "hidden":
        b = a2.tail;
        for (var c = null; null !== b; ) null !== b.alternate && (c = b), b = b.sibling;
        null === c ? a2.tail = null : c.sibling = null;
        break;
      case "collapsed":
        c = a2.tail;
        for (var d2 = null; null !== c; ) null !== c.alternate && (d2 = c), c = c.sibling;
        null === d2 ? b || null === a2.tail ? a2.tail = null : a2.tail.sibling = null : d2.sibling = null;
    }
  }
  function S2(a2) {
    var b = null !== a2.alternate && a2.alternate.child === a2.child, c = 0, d2 = 0;
    if (b) for (var e = a2.child; null !== e; ) c |= e.lanes | e.childLanes, d2 |= e.subtreeFlags & 14680064, d2 |= e.flags & 14680064, e.return = a2, e = e.sibling;
    else for (e = a2.child; null !== e; ) c |= e.lanes | e.childLanes, d2 |= e.subtreeFlags, d2 |= e.flags, e.return = a2, e = e.sibling;
    a2.subtreeFlags |= d2;
    a2.childLanes = c;
    return b;
  }
  function Ej(a2, b, c) {
    var d2 = b.pendingProps;
    wg2(b);
    switch (b.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return S2(b), null;
      case 1:
        return Zf2(b.type) && $f(), S2(b), null;
      case 3:
        d2 = b.stateNode;
        zh2();
        E2(Wf2);
        E2(H2);
        Eh2();
        d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
        if (null === a2 || null === a2.child) Gg2(b) ? b.flags |= 4 : null === a2 || a2.memoizedState.isDehydrated && 0 === (b.flags & 256) || (b.flags |= 1024, null !== zg2 && (Fj(zg2), zg2 = null));
        Aj(a2, b);
        S2(b);
        return null;
      case 5:
        Bh(b);
        var e = xh2(wh.current);
        c = b.type;
        if (null !== a2 && null != b.stateNode) Bj(a2, b, c, d2, e), a2.ref !== b.ref && (b.flags |= 512, b.flags |= 2097152);
        else {
          if (!d2) {
            if (null === b.stateNode) throw Error(p2(166));
            S2(b);
            return null;
          }
          a2 = xh2(uh2.current);
          if (Gg2(b)) {
            d2 = b.stateNode;
            c = b.type;
            var f2 = b.memoizedProps;
            d2[Of2] = b;
            d2[Pf2] = f2;
            a2 = 0 !== (b.mode & 1);
            switch (c) {
              case "dialog":
                D2("cancel", d2);
                D2("close", d2);
                break;
              case "iframe":
              case "object":
              case "embed":
                D2("load", d2);
                break;
              case "video":
              case "audio":
                for (e = 0; e < lf.length; e++) D2(lf[e], d2);
                break;
              case "source":
                D2("error", d2);
                break;
              case "img":
              case "image":
              case "link":
                D2(
                  "error",
                  d2
                );
                D2("load", d2);
                break;
              case "details":
                D2("toggle", d2);
                break;
              case "input":
                Za2(d2, f2);
                D2("invalid", d2);
                break;
              case "select":
                d2._wrapperState = { wasMultiple: !!f2.multiple };
                D2("invalid", d2);
                break;
              case "textarea":
                hb(d2, f2), D2("invalid", d2);
            }
            ub(c, f2);
            e = null;
            for (var g2 in f2) if (f2.hasOwnProperty(g2)) {
              var h2 = f2[g2];
              "children" === g2 ? "string" === typeof h2 ? d2.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af2(d2.textContent, h2, a2), e = ["children", h2]) : "number" === typeof h2 && d2.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af2(
                d2.textContent,
                h2,
                a2
              ), e = ["children", "" + h2]) : ea2.hasOwnProperty(g2) && null != h2 && "onScroll" === g2 && D2("scroll", d2);
            }
            switch (c) {
              case "input":
                Va2(d2);
                db(d2, f2, true);
                break;
              case "textarea":
                Va2(d2);
                jb(d2);
                break;
              case "select":
              case "option":
                break;
              default:
                "function" === typeof f2.onClick && (d2.onclick = Bf2);
            }
            d2 = e;
            b.updateQueue = d2;
            null !== d2 && (b.flags |= 4);
          } else {
            g2 = 9 === e.nodeType ? e : e.ownerDocument;
            "http://www.w3.org/1999/xhtml" === a2 && (a2 = kb(c));
            "http://www.w3.org/1999/xhtml" === a2 ? "script" === c ? (a2 = g2.createElement("div"), a2.innerHTML = "<script><\/script>", a2 = a2.removeChild(a2.firstChild)) : "string" === typeof d2.is ? a2 = g2.createElement(c, { is: d2.is }) : (a2 = g2.createElement(c), "select" === c && (g2 = a2, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a2 = g2.createElementNS(a2, c);
            a2[Of2] = b;
            a2[Pf2] = d2;
            zj(a2, b, false, false);
            b.stateNode = a2;
            a: {
              g2 = vb(c, d2);
              switch (c) {
                case "dialog":
                  D2("cancel", a2);
                  D2("close", a2);
                  e = d2;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  D2("load", a2);
                  e = d2;
                  break;
                case "video":
                case "audio":
                  for (e = 0; e < lf.length; e++) D2(lf[e], a2);
                  e = d2;
                  break;
                case "source":
                  D2("error", a2);
                  e = d2;
                  break;
                case "img":
                case "image":
                case "link":
                  D2(
                    "error",
                    a2
                  );
                  D2("load", a2);
                  e = d2;
                  break;
                case "details":
                  D2("toggle", a2);
                  e = d2;
                  break;
                case "input":
                  Za2(a2, d2);
                  e = Ya2(a2, d2);
                  D2("invalid", a2);
                  break;
                case "option":
                  e = d2;
                  break;
                case "select":
                  a2._wrapperState = { wasMultiple: !!d2.multiple };
                  e = A2({}, d2, { value: void 0 });
                  D2("invalid", a2);
                  break;
                case "textarea":
                  hb(a2, d2);
                  e = gb(a2, d2);
                  D2("invalid", a2);
                  break;
                default:
                  e = d2;
              }
              ub(c, e);
              h2 = e;
              for (f2 in h2) if (h2.hasOwnProperty(f2)) {
                var k2 = h2[f2];
                "style" === f2 ? sb(a2, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a2, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c || "" !== k2) && ob(a2, k2) : "number" === typeof k2 && ob(a2, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea2.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D2("scroll", a2) : null != k2 && ta2(a2, f2, k2, g2));
              }
              switch (c) {
                case "input":
                  Va2(a2);
                  db(a2, d2, false);
                  break;
                case "textarea":
                  Va2(a2);
                  jb(a2);
                  break;
                case "option":
                  null != d2.value && a2.setAttribute("value", "" + Sa(d2.value));
                  break;
                case "select":
                  a2.multiple = !!d2.multiple;
                  f2 = d2.value;
                  null != f2 ? fb(a2, !!d2.multiple, f2, false) : null != d2.defaultValue && fb(
                    a2,
                    !!d2.multiple,
                    d2.defaultValue,
                    true
                  );
                  break;
                default:
                  "function" === typeof e.onClick && (a2.onclick = Bf2);
              }
              switch (c) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  d2 = !!d2.autoFocus;
                  break a;
                case "img":
                  d2 = true;
                  break a;
                default:
                  d2 = false;
              }
            }
            d2 && (b.flags |= 4);
          }
          null !== b.ref && (b.flags |= 512, b.flags |= 2097152);
        }
        S2(b);
        return null;
      case 6:
        if (a2 && null != b.stateNode) Cj(a2, b, a2.memoizedProps, d2);
        else {
          if ("string" !== typeof d2 && null === b.stateNode) throw Error(p2(166));
          c = xh2(wh.current);
          xh2(uh2.current);
          if (Gg2(b)) {
            d2 = b.stateNode;
            c = b.memoizedProps;
            d2[Of2] = b;
            if (f2 = d2.nodeValue !== c) {
              if (a2 = xg2, null !== a2) switch (a2.tag) {
                case 3:
                  Af2(d2.nodeValue, c, 0 !== (a2.mode & 1));
                  break;
                case 5:
                  true !== a2.memoizedProps.suppressHydrationWarning && Af2(d2.nodeValue, c, 0 !== (a2.mode & 1));
              }
            }
            f2 && (b.flags |= 4);
          } else d2 = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d2), d2[Of2] = b, b.stateNode = d2;
        }
        S2(b);
        return null;
      case 13:
        E2(L2);
        d2 = b.memoizedState;
        if (null === a2 || null !== a2.memoizedState && null !== a2.memoizedState.dehydrated) {
          if (I2 && null !== yg2 && 0 !== (b.mode & 1) && 0 === (b.flags & 128)) Hg2(), Ig2(), b.flags |= 98560, f2 = false;
          else if (f2 = Gg2(b), null !== d2 && null !== d2.dehydrated) {
            if (null === a2) {
              if (!f2) throw Error(p2(318));
              f2 = b.memoizedState;
              f2 = null !== f2 ? f2.dehydrated : null;
              if (!f2) throw Error(p2(317));
              f2[Of2] = b;
            } else Ig2(), 0 === (b.flags & 128) && (b.memoizedState = null), b.flags |= 4;
            S2(b);
            f2 = false;
          } else null !== zg2 && (Fj(zg2), zg2 = null), f2 = true;
          if (!f2) return b.flags & 65536 ? b : null;
        }
        if (0 !== (b.flags & 128)) return b.lanes = c, b;
        d2 = null !== d2;
        d2 !== (null !== a2 && null !== a2.memoizedState) && d2 && (b.child.flags |= 8192, 0 !== (b.mode & 1) && (null === a2 || 0 !== (L2.current & 1) ? 0 === T2 && (T2 = 3) : tj()));
        null !== b.updateQueue && (b.flags |= 4);
        S2(b);
        return null;
      case 4:
        return zh2(), Aj(a2, b), null === a2 && sf(b.stateNode.containerInfo), S2(b), null;
      case 10:
        return ah2(b.type._context), S2(b), null;
      case 17:
        return Zf2(b.type) && $f(), S2(b), null;
      case 19:
        E2(L2);
        f2 = b.memoizedState;
        if (null === f2) return S2(b), null;
        d2 = 0 !== (b.flags & 128);
        g2 = f2.rendering;
        if (null === g2) if (d2) Dj(f2, false);
        else {
          if (0 !== T2 || null !== a2 && 0 !== (a2.flags & 128)) for (a2 = b.child; null !== a2; ) {
            g2 = Ch(a2);
            if (null !== g2) {
              b.flags |= 128;
              Dj(f2, false);
              d2 = g2.updateQueue;
              null !== d2 && (b.updateQueue = d2, b.flags |= 4);
              b.subtreeFlags = 0;
              d2 = c;
              for (c = b.child; null !== c; ) f2 = c, a2 = d2, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a2, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a2 = g2.dependencies, f2.dependencies = null === a2 ? null : { lanes: a2.lanes, firstContext: a2.firstContext }), c = c.sibling;
              G2(L2, L2.current & 1 | 2);
              return b.child;
            }
            a2 = a2.sibling;
          }
          null !== f2.tail && B2() > Gj && (b.flags |= 128, d2 = true, Dj(f2, false), b.lanes = 4194304);
        }
        else {
          if (!d2) if (a2 = Ch(g2), null !== a2) {
            if (b.flags |= 128, d2 = true, c = a2.updateQueue, null !== c && (b.updateQueue = c, b.flags |= 4), Dj(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I2) return S2(b), null;
          } else 2 * B2() - f2.renderingStartTime > Gj && 1073741824 !== c && (b.flags |= 128, d2 = true, Dj(f2, false), b.lanes = 4194304);
          f2.isBackwards ? (g2.sibling = b.child, b.child = g2) : (c = f2.last, null !== c ? c.sibling = g2 : b.child = g2, f2.last = g2);
        }
        if (null !== f2.tail) return b = f2.tail, f2.rendering = b, f2.tail = b.sibling, f2.renderingStartTime = B2(), b.sibling = null, c = L2.current, G2(L2, d2 ? c & 1 | 2 : c & 1), b;
        S2(b);
        return null;
      case 22:
      case 23:
        return Hj(), d2 = null !== b.memoizedState, null !== a2 && null !== a2.memoizedState !== d2 && (b.flags |= 8192), d2 && 0 !== (b.mode & 1) ? 0 !== (fj & 1073741824) && (S2(b), b.subtreeFlags & 6 && (b.flags |= 8192)) : S2(b), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(p2(156, b.tag));
  }
  function Ij(a2, b) {
    wg2(b);
    switch (b.tag) {
      case 1:
        return Zf2(b.type) && $f(), a2 = b.flags, a2 & 65536 ? (b.flags = a2 & -65537 | 128, b) : null;
      case 3:
        return zh2(), E2(Wf2), E2(H2), Eh2(), a2 = b.flags, 0 !== (a2 & 65536) && 0 === (a2 & 128) ? (b.flags = a2 & -65537 | 128, b) : null;
      case 5:
        return Bh(b), null;
      case 13:
        E2(L2);
        a2 = b.memoizedState;
        if (null !== a2 && null !== a2.dehydrated) {
          if (null === b.alternate) throw Error(p2(340));
          Ig2();
        }
        a2 = b.flags;
        return a2 & 65536 ? (b.flags = a2 & -65537 | 128, b) : null;
      case 19:
        return E2(L2), null;
      case 4:
        return zh2(), null;
      case 10:
        return ah2(b.type._context), null;
      case 22:
      case 23:
        return Hj(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Jj = false, U2 = false, Kj = "function" === typeof WeakSet ? WeakSet : Set, V2 = null;
  function Lj(a2, b) {
    var c = a2.ref;
    if (null !== c) if ("function" === typeof c) try {
      c(null);
    } catch (d2) {
      W2(a2, b, d2);
    }
    else c.current = null;
  }
  function Mj(a2, b, c) {
    try {
      c();
    } catch (d2) {
      W2(a2, b, d2);
    }
  }
  var Nj = false;
  function Oj(a2, b) {
    Cf2 = dd2;
    a2 = Me2();
    if (Ne(a2)) {
      if ("selectionStart" in a2) var c = { start: a2.selectionStart, end: a2.selectionEnd };
      else a: {
        c = (c = a2.ownerDocument) && c.defaultView || window;
        var d2 = c.getSelection && c.getSelection();
        if (d2 && 0 !== d2.rangeCount) {
          c = d2.anchorNode;
          var e = d2.anchorOffset, f2 = d2.focusNode;
          d2 = d2.focusOffset;
          try {
            c.nodeType, f2.nodeType;
          } catch (F2) {
            c = null;
            break a;
          }
          var g2 = 0, h2 = -1, k2 = -1, l = 0, m2 = 0, q2 = a2, r2 = null;
          b: for (; ; ) {
            for (var y2; ; ) {
              q2 !== c || 0 !== e && 3 !== q2.nodeType || (h2 = g2 + e);
              q2 !== f2 || 0 !== d2 && 3 !== q2.nodeType || (k2 = g2 + d2);
              3 === q2.nodeType && (g2 += q2.nodeValue.length);
              if (null === (y2 = q2.firstChild)) break;
              r2 = q2;
              q2 = y2;
            }
            for (; ; ) {
              if (q2 === a2) break b;
              r2 === c && ++l === e && (h2 = g2);
              r2 === f2 && ++m2 === d2 && (k2 = g2);
              if (null !== (y2 = q2.nextSibling)) break;
              q2 = r2;
              r2 = q2.parentNode;
            }
            q2 = y2;
          }
          c = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
        } else c = null;
      }
      c = c || { start: 0, end: 0 };
    } else c = null;
    Df2 = { focusedElem: a2, selectionRange: c };
    dd2 = false;
    for (V2 = b; null !== V2; ) if (b = V2, a2 = b.child, 0 !== (b.subtreeFlags & 1028) && null !== a2) a2.return = b, V2 = a2;
    else for (; null !== V2; ) {
      b = V2;
      try {
        var n = b.alternate;
        if (0 !== (b.flags & 1024)) switch (b.tag) {
          case 0:
          case 11:
          case 15:
            break;
          case 1:
            if (null !== n) {
              var t = n.memoizedProps, J2 = n.memoizedState, x2 = b.stateNode, w2 = x2.getSnapshotBeforeUpdate(b.elementType === b.type ? t : Ci2(b.type, t), J2);
              x2.__reactInternalSnapshotBeforeUpdate = w2;
            }
            break;
          case 3:
            var u2 = b.stateNode.containerInfo;
            1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
            break;
          case 5:
          case 6:
          case 4:
          case 17:
            break;
          default:
            throw Error(p2(163));
        }
      } catch (F2) {
        W2(b, b.return, F2);
      }
      a2 = b.sibling;
      if (null !== a2) {
        a2.return = b.return;
        V2 = a2;
        break;
      }
      V2 = b.return;
    }
    n = Nj;
    Nj = false;
    return n;
  }
  function Pj(a2, b, c) {
    var d2 = b.updateQueue;
    d2 = null !== d2 ? d2.lastEffect : null;
    if (null !== d2) {
      var e = d2 = d2.next;
      do {
        if ((e.tag & a2) === a2) {
          var f2 = e.destroy;
          e.destroy = void 0;
          void 0 !== f2 && Mj(b, c, f2);
        }
        e = e.next;
      } while (e !== d2);
    }
  }
  function Qj(a2, b) {
    b = b.updateQueue;
    b = null !== b ? b.lastEffect : null;
    if (null !== b) {
      var c = b = b.next;
      do {
        if ((c.tag & a2) === a2) {
          var d2 = c.create;
          c.destroy = d2();
        }
        c = c.next;
      } while (c !== b);
    }
  }
  function Rj(a2) {
    var b = a2.ref;
    if (null !== b) {
      var c = a2.stateNode;
      switch (a2.tag) {
        case 5:
          a2 = c;
          break;
        default:
          a2 = c;
      }
      "function" === typeof b ? b(a2) : b.current = a2;
    }
  }
  function Sj(a2) {
    var b = a2.alternate;
    null !== b && (a2.alternate = null, Sj(b));
    a2.child = null;
    a2.deletions = null;
    a2.sibling = null;
    5 === a2.tag && (b = a2.stateNode, null !== b && (delete b[Of2], delete b[Pf2], delete b[of], delete b[Qf2], delete b[Rf2]));
    a2.stateNode = null;
    a2.return = null;
    a2.dependencies = null;
    a2.memoizedProps = null;
    a2.memoizedState = null;
    a2.pendingProps = null;
    a2.stateNode = null;
    a2.updateQueue = null;
  }
  function Tj(a2) {
    return 5 === a2.tag || 3 === a2.tag || 4 === a2.tag;
  }
  function Uj(a2) {
    a: for (; ; ) {
      for (; null === a2.sibling; ) {
        if (null === a2.return || Tj(a2.return)) return null;
        a2 = a2.return;
      }
      a2.sibling.return = a2.return;
      for (a2 = a2.sibling; 5 !== a2.tag && 6 !== a2.tag && 18 !== a2.tag; ) {
        if (a2.flags & 2) continue a;
        if (null === a2.child || 4 === a2.tag) continue a;
        else a2.child.return = a2, a2 = a2.child;
      }
      if (!(a2.flags & 2)) return a2.stateNode;
    }
  }
  function Vj(a2, b, c) {
    var d2 = a2.tag;
    if (5 === d2 || 6 === d2) a2 = a2.stateNode, b ? 8 === c.nodeType ? c.parentNode.insertBefore(a2, b) : c.insertBefore(a2, b) : (8 === c.nodeType ? (b = c.parentNode, b.insertBefore(a2, c)) : (b = c, b.appendChild(a2)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b.onclick || (b.onclick = Bf2));
    else if (4 !== d2 && (a2 = a2.child, null !== a2)) for (Vj(a2, b, c), a2 = a2.sibling; null !== a2; ) Vj(a2, b, c), a2 = a2.sibling;
  }
  function Wj(a2, b, c) {
    var d2 = a2.tag;
    if (5 === d2 || 6 === d2) a2 = a2.stateNode, b ? c.insertBefore(a2, b) : c.appendChild(a2);
    else if (4 !== d2 && (a2 = a2.child, null !== a2)) for (Wj(a2, b, c), a2 = a2.sibling; null !== a2; ) Wj(a2, b, c), a2 = a2.sibling;
  }
  var X2 = null, Xj = false;
  function Yj(a2, b, c) {
    for (c = c.child; null !== c; ) Zj(a2, b, c), c = c.sibling;
  }
  function Zj(a2, b, c) {
    if (lc2 && "function" === typeof lc2.onCommitFiberUnmount) try {
      lc2.onCommitFiberUnmount(kc2, c);
    } catch (h2) {
    }
    switch (c.tag) {
      case 5:
        U2 || Lj(c, b);
      case 6:
        var d2 = X2, e = Xj;
        X2 = null;
        Yj(a2, b, c);
        X2 = d2;
        Xj = e;
        null !== X2 && (Xj ? (a2 = X2, c = c.stateNode, 8 === a2.nodeType ? a2.parentNode.removeChild(c) : a2.removeChild(c)) : X2.removeChild(c.stateNode));
        break;
      case 18:
        null !== X2 && (Xj ? (a2 = X2, c = c.stateNode, 8 === a2.nodeType ? Kf2(a2.parentNode, c) : 1 === a2.nodeType && Kf2(a2, c), bd2(a2)) : Kf2(X2, c.stateNode));
        break;
      case 4:
        d2 = X2;
        e = Xj;
        X2 = c.stateNode.containerInfo;
        Xj = true;
        Yj(a2, b, c);
        X2 = d2;
        Xj = e;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!U2 && (d2 = c.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
          e = d2 = d2.next;
          do {
            var f2 = e, g2 = f2.destroy;
            f2 = f2.tag;
            void 0 !== g2 && (0 !== (f2 & 2) ? Mj(c, b, g2) : 0 !== (f2 & 4) && Mj(c, b, g2));
            e = e.next;
          } while (e !== d2);
        }
        Yj(a2, b, c);
        break;
      case 1:
        if (!U2 && (Lj(c, b), d2 = c.stateNode, "function" === typeof d2.componentWillUnmount)) try {
          d2.props = c.memoizedProps, d2.state = c.memoizedState, d2.componentWillUnmount();
        } catch (h2) {
          W2(c, b, h2);
        }
        Yj(a2, b, c);
        break;
      case 21:
        Yj(a2, b, c);
        break;
      case 22:
        c.mode & 1 ? (U2 = (d2 = U2) || null !== c.memoizedState, Yj(a2, b, c), U2 = d2) : Yj(a2, b, c);
        break;
      default:
        Yj(a2, b, c);
    }
  }
  function ak(a2) {
    var b = a2.updateQueue;
    if (null !== b) {
      a2.updateQueue = null;
      var c = a2.stateNode;
      null === c && (c = a2.stateNode = new Kj());
      b.forEach(function(b2) {
        var d2 = bk.bind(null, a2, b2);
        c.has(b2) || (c.add(b2), b2.then(d2, d2));
      });
    }
  }
  function ck(a2, b) {
    var c = b.deletions;
    if (null !== c) for (var d2 = 0; d2 < c.length; d2++) {
      var e = c[d2];
      try {
        var f2 = a2, g2 = b, h2 = g2;
        a: for (; null !== h2; ) {
          switch (h2.tag) {
            case 5:
              X2 = h2.stateNode;
              Xj = false;
              break a;
            case 3:
              X2 = h2.stateNode.containerInfo;
              Xj = true;
              break a;
            case 4:
              X2 = h2.stateNode.containerInfo;
              Xj = true;
              break a;
          }
          h2 = h2.return;
        }
        if (null === X2) throw Error(p2(160));
        Zj(f2, g2, e);
        X2 = null;
        Xj = false;
        var k2 = e.alternate;
        null !== k2 && (k2.return = null);
        e.return = null;
      } catch (l) {
        W2(e, b, l);
      }
    }
    if (b.subtreeFlags & 12854) for (b = b.child; null !== b; ) dk(b, a2), b = b.sibling;
  }
  function dk(a2, b) {
    var c = a2.alternate, d2 = a2.flags;
    switch (a2.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        ck(b, a2);
        ek(a2);
        if (d2 & 4) {
          try {
            Pj(3, a2, a2.return), Qj(3, a2);
          } catch (t) {
            W2(a2, a2.return, t);
          }
          try {
            Pj(5, a2, a2.return);
          } catch (t) {
            W2(a2, a2.return, t);
          }
        }
        break;
      case 1:
        ck(b, a2);
        ek(a2);
        d2 & 512 && null !== c && Lj(c, c.return);
        break;
      case 5:
        ck(b, a2);
        ek(a2);
        d2 & 512 && null !== c && Lj(c, c.return);
        if (a2.flags & 32) {
          var e = a2.stateNode;
          try {
            ob(e, "");
          } catch (t) {
            W2(a2, a2.return, t);
          }
        }
        if (d2 & 4 && (e = a2.stateNode, null != e)) {
          var f2 = a2.memoizedProps, g2 = null !== c ? c.memoizedProps : f2, h2 = a2.type, k2 = a2.updateQueue;
          a2.updateQueue = null;
          if (null !== k2) try {
            "input" === h2 && "radio" === f2.type && null != f2.name && ab(e, f2);
            vb(h2, g2);
            var l = vb(h2, f2);
            for (g2 = 0; g2 < k2.length; g2 += 2) {
              var m2 = k2[g2], q2 = k2[g2 + 1];
              "style" === m2 ? sb(e, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e, q2) : "children" === m2 ? ob(e, q2) : ta2(e, m2, q2, l);
            }
            switch (h2) {
              case "input":
                bb(e, f2);
                break;
              case "textarea":
                ib(e, f2);
                break;
              case "select":
                var r2 = e._wrapperState.wasMultiple;
                e._wrapperState.wasMultiple = !!f2.multiple;
                var y2 = f2.value;
                null != y2 ? fb(e, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                  e,
                  !!f2.multiple,
                  f2.defaultValue,
                  true
                ) : fb(e, !!f2.multiple, f2.multiple ? [] : "", false));
            }
            e[Pf2] = f2;
          } catch (t) {
            W2(a2, a2.return, t);
          }
        }
        break;
      case 6:
        ck(b, a2);
        ek(a2);
        if (d2 & 4) {
          if (null === a2.stateNode) throw Error(p2(162));
          e = a2.stateNode;
          f2 = a2.memoizedProps;
          try {
            e.nodeValue = f2;
          } catch (t) {
            W2(a2, a2.return, t);
          }
        }
        break;
      case 3:
        ck(b, a2);
        ek(a2);
        if (d2 & 4 && null !== c && c.memoizedState.isDehydrated) try {
          bd2(b.containerInfo);
        } catch (t) {
          W2(a2, a2.return, t);
        }
        break;
      case 4:
        ck(b, a2);
        ek(a2);
        break;
      case 13:
        ck(b, a2);
        ek(a2);
        e = a2.child;
        e.flags & 8192 && (f2 = null !== e.memoizedState, e.stateNode.isHidden = f2, !f2 || null !== e.alternate && null !== e.alternate.memoizedState || (fk = B2()));
        d2 & 4 && ak(a2);
        break;
      case 22:
        m2 = null !== c && null !== c.memoizedState;
        a2.mode & 1 ? (U2 = (l = U2) || m2, ck(b, a2), U2 = l) : ck(b, a2);
        ek(a2);
        if (d2 & 8192) {
          l = null !== a2.memoizedState;
          if ((a2.stateNode.isHidden = l) && !m2 && 0 !== (a2.mode & 1)) for (V2 = a2, m2 = a2.child; null !== m2; ) {
            for (q2 = V2 = m2; null !== V2; ) {
              r2 = V2;
              y2 = r2.child;
              switch (r2.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Pj(4, r2, r2.return);
                  break;
                case 1:
                  Lj(r2, r2.return);
                  var n = r2.stateNode;
                  if ("function" === typeof n.componentWillUnmount) {
                    d2 = r2;
                    c = r2.return;
                    try {
                      b = d2, n.props = b.memoizedProps, n.state = b.memoizedState, n.componentWillUnmount();
                    } catch (t) {
                      W2(d2, c, t);
                    }
                  }
                  break;
                case 5:
                  Lj(r2, r2.return);
                  break;
                case 22:
                  if (null !== r2.memoizedState) {
                    gk(q2);
                    continue;
                  }
              }
              null !== y2 ? (y2.return = r2, V2 = y2) : gk(q2);
            }
            m2 = m2.sibling;
          }
          a: for (m2 = null, q2 = a2; ; ) {
            if (5 === q2.tag) {
              if (null === m2) {
                m2 = q2;
                try {
                  e = q2.stateNode, l ? (f2 = e.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g2 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g2));
                } catch (t) {
                  W2(a2, a2.return, t);
                }
              }
            } else if (6 === q2.tag) {
              if (null === m2) try {
                q2.stateNode.nodeValue = l ? "" : q2.memoizedProps;
              } catch (t) {
                W2(a2, a2.return, t);
              }
            } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a2) && null !== q2.child) {
              q2.child.return = q2;
              q2 = q2.child;
              continue;
            }
            if (q2 === a2) break a;
            for (; null === q2.sibling; ) {
              if (null === q2.return || q2.return === a2) break a;
              m2 === q2 && (m2 = null);
              q2 = q2.return;
            }
            m2 === q2 && (m2 = null);
            q2.sibling.return = q2.return;
            q2 = q2.sibling;
          }
        }
        break;
      case 19:
        ck(b, a2);
        ek(a2);
        d2 & 4 && ak(a2);
        break;
      case 21:
        break;
      default:
        ck(
          b,
          a2
        ), ek(a2);
    }
  }
  function ek(a2) {
    var b = a2.flags;
    if (b & 2) {
      try {
        a: {
          for (var c = a2.return; null !== c; ) {
            if (Tj(c)) {
              var d2 = c;
              break a;
            }
            c = c.return;
          }
          throw Error(p2(160));
        }
        switch (d2.tag) {
          case 5:
            var e = d2.stateNode;
            d2.flags & 32 && (ob(e, ""), d2.flags &= -33);
            var f2 = Uj(a2);
            Wj(a2, f2, e);
            break;
          case 3:
          case 4:
            var g2 = d2.stateNode.containerInfo, h2 = Uj(a2);
            Vj(a2, h2, g2);
            break;
          default:
            throw Error(p2(161));
        }
      } catch (k2) {
        W2(a2, a2.return, k2);
      }
      a2.flags &= -3;
    }
    b & 4096 && (a2.flags &= -4097);
  }
  function hk(a2, b, c) {
    V2 = a2;
    ik(a2);
  }
  function ik(a2, b, c) {
    for (var d2 = 0 !== (a2.mode & 1); null !== V2; ) {
      var e = V2, f2 = e.child;
      if (22 === e.tag && d2) {
        var g2 = null !== e.memoizedState || Jj;
        if (!g2) {
          var h2 = e.alternate, k2 = null !== h2 && null !== h2.memoizedState || U2;
          h2 = Jj;
          var l = U2;
          Jj = g2;
          if ((U2 = k2) && !l) for (V2 = e; null !== V2; ) g2 = V2, k2 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? jk(e) : null !== k2 ? (k2.return = g2, V2 = k2) : jk(e);
          for (; null !== f2; ) V2 = f2, ik(f2), f2 = f2.sibling;
          V2 = e;
          Jj = h2;
          U2 = l;
        }
        kk(a2);
      } else 0 !== (e.subtreeFlags & 8772) && null !== f2 ? (f2.return = e, V2 = f2) : kk(a2);
    }
  }
  function kk(a2) {
    for (; null !== V2; ) {
      var b = V2;
      if (0 !== (b.flags & 8772)) {
        var c = b.alternate;
        try {
          if (0 !== (b.flags & 8772)) switch (b.tag) {
            case 0:
            case 11:
            case 15:
              U2 || Qj(5, b);
              break;
            case 1:
              var d2 = b.stateNode;
              if (b.flags & 4 && !U2) if (null === c) d2.componentDidMount();
              else {
                var e = b.elementType === b.type ? c.memoizedProps : Ci2(b.type, c.memoizedProps);
                d2.componentDidUpdate(e, c.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
              }
              var f2 = b.updateQueue;
              null !== f2 && sh2(b, f2, d2);
              break;
            case 3:
              var g2 = b.updateQueue;
              if (null !== g2) {
                c = null;
                if (null !== b.child) switch (b.child.tag) {
                  case 5:
                    c = b.child.stateNode;
                    break;
                  case 1:
                    c = b.child.stateNode;
                }
                sh2(b, g2, c);
              }
              break;
            case 5:
              var h2 = b.stateNode;
              if (null === c && b.flags & 4) {
                c = h2;
                var k2 = b.memoizedProps;
                switch (b.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k2.autoFocus && c.focus();
                    break;
                  case "img":
                    k2.src && (c.src = k2.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (null === b.memoizedState) {
                var l = b.alternate;
                if (null !== l) {
                  var m2 = l.memoizedState;
                  if (null !== m2) {
                    var q2 = m2.dehydrated;
                    null !== q2 && bd2(q2);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p2(163));
          }
          U2 || b.flags & 512 && Rj(b);
        } catch (r2) {
          W2(b, b.return, r2);
        }
      }
      if (b === a2) {
        V2 = null;
        break;
      }
      c = b.sibling;
      if (null !== c) {
        c.return = b.return;
        V2 = c;
        break;
      }
      V2 = b.return;
    }
  }
  function gk(a2) {
    for (; null !== V2; ) {
      var b = V2;
      if (b === a2) {
        V2 = null;
        break;
      }
      var c = b.sibling;
      if (null !== c) {
        c.return = b.return;
        V2 = c;
        break;
      }
      V2 = b.return;
    }
  }
  function jk(a2) {
    for (; null !== V2; ) {
      var b = V2;
      try {
        switch (b.tag) {
          case 0:
          case 11:
          case 15:
            var c = b.return;
            try {
              Qj(4, b);
            } catch (k2) {
              W2(b, c, k2);
            }
            break;
          case 1:
            var d2 = b.stateNode;
            if ("function" === typeof d2.componentDidMount) {
              var e = b.return;
              try {
                d2.componentDidMount();
              } catch (k2) {
                W2(b, e, k2);
              }
            }
            var f2 = b.return;
            try {
              Rj(b);
            } catch (k2) {
              W2(b, f2, k2);
            }
            break;
          case 5:
            var g2 = b.return;
            try {
              Rj(b);
            } catch (k2) {
              W2(b, g2, k2);
            }
        }
      } catch (k2) {
        W2(b, b.return, k2);
      }
      if (b === a2) {
        V2 = null;
        break;
      }
      var h2 = b.sibling;
      if (null !== h2) {
        h2.return = b.return;
        V2 = h2;
        break;
      }
      V2 = b.return;
    }
  }
  var lk = Math.ceil, mk = ua2.ReactCurrentDispatcher, nk = ua2.ReactCurrentOwner, ok = ua2.ReactCurrentBatchConfig, K2 = 0, Q2 = null, Y2 = null, Z2 = 0, fj = 0, ej = Uf2(0), T2 = 0, pk2 = null, rh2 = 0, qk = 0, rk = 0, sk = null, tk = null, fk = 0, Gj = Infinity, uk = null, Oi2 = false, Pi2 = null, Ri2 = null, vk = false, wk = null, xk = 0, yk = 0, zk = null, Ak = -1, Bk = 0;
  function R2() {
    return 0 !== (K2 & 6) ? B2() : -1 !== Ak ? Ak : Ak = B2();
  }
  function yi2(a2) {
    if (0 === (a2.mode & 1)) return 1;
    if (0 !== (K2 & 2) && 0 !== Z2) return Z2 & -Z2;
    if (null !== Kg2.transition) return 0 === Bk && (Bk = yc2()), Bk;
    a2 = C;
    if (0 !== a2) return a2;
    a2 = window.event;
    a2 = void 0 === a2 ? 16 : jd2(a2.type);
    return a2;
  }
  function gi2(a2, b, c, d2) {
    if (50 < yk) throw yk = 0, zk = null, Error(p2(185));
    Ac2(a2, c, d2);
    if (0 === (K2 & 2) || a2 !== Q2) a2 === Q2 && (0 === (K2 & 2) && (qk |= c), 4 === T2 && Ck(a2, Z2)), Dk(a2, d2), 1 === c && 0 === K2 && 0 === (b.mode & 1) && (Gj = B2() + 500, fg2 && jg2());
  }
  function Dk(a2, b) {
    var c = a2.callbackNode;
    wc2(a2, b);
    var d2 = uc2(a2, a2 === Q2 ? Z2 : 0);
    if (0 === d2) null !== c && bc2(c), a2.callbackNode = null, a2.callbackPriority = 0;
    else if (b = d2 & -d2, a2.callbackPriority !== b) {
      null != c && bc2(c);
      if (1 === b) 0 === a2.tag ? ig2(Ek.bind(null, a2)) : hg2(Ek.bind(null, a2)), Jf2(function() {
        0 === (K2 & 6) && jg2();
      }), c = null;
      else {
        switch (Dc2(d2)) {
          case 1:
            c = fc2;
            break;
          case 4:
            c = gc2;
            break;
          case 16:
            c = hc2;
            break;
          case 536870912:
            c = jc2;
            break;
          default:
            c = hc2;
        }
        c = Fk(c, Gk.bind(null, a2));
      }
      a2.callbackPriority = b;
      a2.callbackNode = c;
    }
  }
  function Gk(a2, b) {
    Ak = -1;
    Bk = 0;
    if (0 !== (K2 & 6)) throw Error(p2(327));
    var c = a2.callbackNode;
    if (Hk() && a2.callbackNode !== c) return null;
    var d2 = uc2(a2, a2 === Q2 ? Z2 : 0);
    if (0 === d2) return null;
    if (0 !== (d2 & 30) || 0 !== (d2 & a2.expiredLanes) || b) b = Ik(a2, d2);
    else {
      b = d2;
      var e = K2;
      K2 |= 2;
      var f2 = Jk();
      if (Q2 !== a2 || Z2 !== b) uk = null, Gj = B2() + 500, Kk(a2, b);
      do
        try {
          Lk();
          break;
        } catch (h2) {
          Mk(a2, h2);
        }
      while (1);
      $g2();
      mk.current = f2;
      K2 = e;
      null !== Y2 ? b = 0 : (Q2 = null, Z2 = 0, b = T2);
    }
    if (0 !== b) {
      2 === b && (e = xc2(a2), 0 !== e && (d2 = e, b = Nk(a2, e)));
      if (1 === b) throw c = pk2, Kk(a2, 0), Ck(a2, d2), Dk(a2, B2()), c;
      if (6 === b) Ck(a2, d2);
      else {
        e = a2.current.alternate;
        if (0 === (d2 & 30) && !Ok(e) && (b = Ik(a2, d2), 2 === b && (f2 = xc2(a2), 0 !== f2 && (d2 = f2, b = Nk(a2, f2))), 1 === b)) throw c = pk2, Kk(a2, 0), Ck(a2, d2), Dk(a2, B2()), c;
        a2.finishedWork = e;
        a2.finishedLanes = d2;
        switch (b) {
          case 0:
          case 1:
            throw Error(p2(345));
          case 2:
            Pk(a2, tk, uk);
            break;
          case 3:
            Ck(a2, d2);
            if ((d2 & 130023424) === d2 && (b = fk + 500 - B2(), 10 < b)) {
              if (0 !== uc2(a2, 0)) break;
              e = a2.suspendedLanes;
              if ((e & d2) !== d2) {
                R2();
                a2.pingedLanes |= a2.suspendedLanes & e;
                break;
              }
              a2.timeoutHandle = Ff2(Pk.bind(null, a2, tk, uk), b);
              break;
            }
            Pk(a2, tk, uk);
            break;
          case 4:
            Ck(a2, d2);
            if ((d2 & 4194240) === d2) break;
            b = a2.eventTimes;
            for (e = -1; 0 < d2; ) {
              var g2 = 31 - oc2(d2);
              f2 = 1 << g2;
              g2 = b[g2];
              g2 > e && (e = g2);
              d2 &= ~f2;
            }
            d2 = e;
            d2 = B2() - d2;
            d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * lk(d2 / 1960)) - d2;
            if (10 < d2) {
              a2.timeoutHandle = Ff2(Pk.bind(null, a2, tk, uk), d2);
              break;
            }
            Pk(a2, tk, uk);
            break;
          case 5:
            Pk(a2, tk, uk);
            break;
          default:
            throw Error(p2(329));
        }
      }
    }
    Dk(a2, B2());
    return a2.callbackNode === c ? Gk.bind(null, a2) : null;
  }
  function Nk(a2, b) {
    var c = sk;
    a2.current.memoizedState.isDehydrated && (Kk(a2, b).flags |= 256);
    a2 = Ik(a2, b);
    2 !== a2 && (b = tk, tk = c, null !== b && Fj(b));
    return a2;
  }
  function Fj(a2) {
    null === tk ? tk = a2 : tk.push.apply(tk, a2);
  }
  function Ok(a2) {
    for (var b = a2; ; ) {
      if (b.flags & 16384) {
        var c = b.updateQueue;
        if (null !== c && (c = c.stores, null !== c)) for (var d2 = 0; d2 < c.length; d2++) {
          var e = c[d2], f2 = e.getSnapshot;
          e = e.value;
          try {
            if (!He2(f2(), e)) return false;
          } catch (g2) {
            return false;
          }
        }
      }
      c = b.child;
      if (b.subtreeFlags & 16384 && null !== c) c.return = b, b = c;
      else {
        if (b === a2) break;
        for (; null === b.sibling; ) {
          if (null === b.return || b.return === a2) return true;
          b = b.return;
        }
        b.sibling.return = b.return;
        b = b.sibling;
      }
    }
    return true;
  }
  function Ck(a2, b) {
    b &= ~rk;
    b &= ~qk;
    a2.suspendedLanes |= b;
    a2.pingedLanes &= ~b;
    for (a2 = a2.expirationTimes; 0 < b; ) {
      var c = 31 - oc2(b), d2 = 1 << c;
      a2[c] = -1;
      b &= ~d2;
    }
  }
  function Ek(a2) {
    if (0 !== (K2 & 6)) throw Error(p2(327));
    Hk();
    var b = uc2(a2, 0);
    if (0 === (b & 1)) return Dk(a2, B2()), null;
    var c = Ik(a2, b);
    if (0 !== a2.tag && 2 === c) {
      var d2 = xc2(a2);
      0 !== d2 && (b = d2, c = Nk(a2, d2));
    }
    if (1 === c) throw c = pk2, Kk(a2, 0), Ck(a2, b), Dk(a2, B2()), c;
    if (6 === c) throw Error(p2(345));
    a2.finishedWork = a2.current.alternate;
    a2.finishedLanes = b;
    Pk(a2, tk, uk);
    Dk(a2, B2());
    return null;
  }
  function Qk(a2, b) {
    var c = K2;
    K2 |= 1;
    try {
      return a2(b);
    } finally {
      K2 = c, 0 === K2 && (Gj = B2() + 500, fg2 && jg2());
    }
  }
  function Rk(a2) {
    null !== wk && 0 === wk.tag && 0 === (K2 & 6) && Hk();
    var b = K2;
    K2 |= 1;
    var c = ok.transition, d2 = C;
    try {
      if (ok.transition = null, C = 1, a2) return a2();
    } finally {
      C = d2, ok.transition = c, K2 = b, 0 === (K2 & 6) && jg2();
    }
  }
  function Hj() {
    fj = ej.current;
    E2(ej);
  }
  function Kk(a2, b) {
    a2.finishedWork = null;
    a2.finishedLanes = 0;
    var c = a2.timeoutHandle;
    -1 !== c && (a2.timeoutHandle = -1, Gf2(c));
    if (null !== Y2) for (c = Y2.return; null !== c; ) {
      var d2 = c;
      wg2(d2);
      switch (d2.tag) {
        case 1:
          d2 = d2.type.childContextTypes;
          null !== d2 && void 0 !== d2 && $f();
          break;
        case 3:
          zh2();
          E2(Wf2);
          E2(H2);
          Eh2();
          break;
        case 5:
          Bh(d2);
          break;
        case 4:
          zh2();
          break;
        case 13:
          E2(L2);
          break;
        case 19:
          E2(L2);
          break;
        case 10:
          ah2(d2.type._context);
          break;
        case 22:
        case 23:
          Hj();
      }
      c = c.return;
    }
    Q2 = a2;
    Y2 = a2 = Pg2(a2.current, null);
    Z2 = fj = b;
    T2 = 0;
    pk2 = null;
    rk = qk = rh2 = 0;
    tk = sk = null;
    if (null !== fh2) {
      for (b = 0; b < fh2.length; b++) if (c = fh2[b], d2 = c.interleaved, null !== d2) {
        c.interleaved = null;
        var e = d2.next, f2 = c.pending;
        if (null !== f2) {
          var g2 = f2.next;
          f2.next = e;
          d2.next = g2;
        }
        c.pending = d2;
      }
      fh2 = null;
    }
    return a2;
  }
  function Mk(a2, b) {
    do {
      var c = Y2;
      try {
        $g2();
        Fh.current = Rh;
        if (Ih2) {
          for (var d2 = M2.memoizedState; null !== d2; ) {
            var e = d2.queue;
            null !== e && (e.pending = null);
            d2 = d2.next;
          }
          Ih2 = false;
        }
        Hh = 0;
        O = N2 = M2 = null;
        Jh = false;
        Kh = 0;
        nk.current = null;
        if (null === c || null === c.return) {
          T2 = 1;
          pk2 = b;
          Y2 = null;
          break;
        }
        a: {
          var f2 = a2, g2 = c.return, h2 = c, k2 = b;
          b = Z2;
          h2.flags |= 32768;
          if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
            var l = k2, m2 = h2, q2 = m2.tag;
            if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
              var r2 = m2.alternate;
              r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
            }
            var y2 = Ui2(g2);
            if (null !== y2) {
              y2.flags &= -257;
              Vi2(y2, g2, h2, f2, b);
              y2.mode & 1 && Si2(f2, l, b);
              b = y2;
              k2 = l;
              var n = b.updateQueue;
              if (null === n) {
                var t = /* @__PURE__ */ new Set();
                t.add(k2);
                b.updateQueue = t;
              } else n.add(k2);
              break a;
            } else {
              if (0 === (b & 1)) {
                Si2(f2, l, b);
                tj();
                break a;
              }
              k2 = Error(p2(426));
            }
          } else if (I2 && h2.mode & 1) {
            var J2 = Ui2(g2);
            if (null !== J2) {
              0 === (J2.flags & 65536) && (J2.flags |= 256);
              Vi2(J2, g2, h2, f2, b);
              Jg2(Ji2(k2, h2));
              break a;
            }
          }
          f2 = k2 = Ji2(k2, h2);
          4 !== T2 && (T2 = 2);
          null === sk ? sk = [f2] : sk.push(f2);
          f2 = g2;
          do {
            switch (f2.tag) {
              case 3:
                f2.flags |= 65536;
                b &= -b;
                f2.lanes |= b;
                var x2 = Ni2(f2, k2, b);
                ph2(f2, x2);
                break a;
              case 1:
                h2 = k2;
                var w2 = f2.type, u2 = f2.stateNode;
                if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Ri2 || !Ri2.has(u2)))) {
                  f2.flags |= 65536;
                  b &= -b;
                  f2.lanes |= b;
                  var F2 = Qi2(f2, h2, b);
                  ph2(f2, F2);
                  break a;
                }
            }
            f2 = f2.return;
          } while (null !== f2);
        }
        Sk(c);
      } catch (na2) {
        b = na2;
        Y2 === c && null !== c && (Y2 = c = c.return);
        continue;
      }
      break;
    } while (1);
  }
  function Jk() {
    var a2 = mk.current;
    mk.current = Rh;
    return null === a2 ? Rh : a2;
  }
  function tj() {
    if (0 === T2 || 3 === T2 || 2 === T2) T2 = 4;
    null === Q2 || 0 === (rh2 & 268435455) && 0 === (qk & 268435455) || Ck(Q2, Z2);
  }
  function Ik(a2, b) {
    var c = K2;
    K2 |= 2;
    var d2 = Jk();
    if (Q2 !== a2 || Z2 !== b) uk = null, Kk(a2, b);
    do
      try {
        Tk();
        break;
      } catch (e) {
        Mk(a2, e);
      }
    while (1);
    $g2();
    K2 = c;
    mk.current = d2;
    if (null !== Y2) throw Error(p2(261));
    Q2 = null;
    Z2 = 0;
    return T2;
  }
  function Tk() {
    for (; null !== Y2; ) Uk(Y2);
  }
  function Lk() {
    for (; null !== Y2 && !cc2(); ) Uk(Y2);
  }
  function Uk(a2) {
    var b = Vk(a2.alternate, a2, fj);
    a2.memoizedProps = a2.pendingProps;
    null === b ? Sk(a2) : Y2 = b;
    nk.current = null;
  }
  function Sk(a2) {
    var b = a2;
    do {
      var c = b.alternate;
      a2 = b.return;
      if (0 === (b.flags & 32768)) {
        if (c = Ej(c, b, fj), null !== c) {
          Y2 = c;
          return;
        }
      } else {
        c = Ij(c, b);
        if (null !== c) {
          c.flags &= 32767;
          Y2 = c;
          return;
        }
        if (null !== a2) a2.flags |= 32768, a2.subtreeFlags = 0, a2.deletions = null;
        else {
          T2 = 6;
          Y2 = null;
          return;
        }
      }
      b = b.sibling;
      if (null !== b) {
        Y2 = b;
        return;
      }
      Y2 = b = a2;
    } while (null !== b);
    0 === T2 && (T2 = 5);
  }
  function Pk(a2, b, c) {
    var d2 = C, e = ok.transition;
    try {
      ok.transition = null, C = 1, Wk(a2, b, c, d2);
    } finally {
      ok.transition = e, C = d2;
    }
    return null;
  }
  function Wk(a2, b, c, d2) {
    do
      Hk();
    while (null !== wk);
    if (0 !== (K2 & 6)) throw Error(p2(327));
    c = a2.finishedWork;
    var e = a2.finishedLanes;
    if (null === c) return null;
    a2.finishedWork = null;
    a2.finishedLanes = 0;
    if (c === a2.current) throw Error(p2(177));
    a2.callbackNode = null;
    a2.callbackPriority = 0;
    var f2 = c.lanes | c.childLanes;
    Bc2(a2, f2);
    a2 === Q2 && (Y2 = Q2 = null, Z2 = 0);
    0 === (c.subtreeFlags & 2064) && 0 === (c.flags & 2064) || vk || (vk = true, Fk(hc2, function() {
      Hk();
      return null;
    }));
    f2 = 0 !== (c.flags & 15990);
    if (0 !== (c.subtreeFlags & 15990) || f2) {
      f2 = ok.transition;
      ok.transition = null;
      var g2 = C;
      C = 1;
      var h2 = K2;
      K2 |= 4;
      nk.current = null;
      Oj(a2, c);
      dk(c, a2);
      Oe(Df2);
      dd2 = !!Cf2;
      Df2 = Cf2 = null;
      a2.current = c;
      hk(c);
      dc2();
      K2 = h2;
      C = g2;
      ok.transition = f2;
    } else a2.current = c;
    vk && (vk = false, wk = a2, xk = e);
    f2 = a2.pendingLanes;
    0 === f2 && (Ri2 = null);
    mc2(c.stateNode);
    Dk(a2, B2());
    if (null !== b) for (d2 = a2.onRecoverableError, c = 0; c < b.length; c++) e = b[c], d2(e.value, { componentStack: e.stack, digest: e.digest });
    if (Oi2) throw Oi2 = false, a2 = Pi2, Pi2 = null, a2;
    0 !== (xk & 1) && 0 !== a2.tag && Hk();
    f2 = a2.pendingLanes;
    0 !== (f2 & 1) ? a2 === zk ? yk++ : (yk = 0, zk = a2) : yk = 0;
    jg2();
    return null;
  }
  function Hk() {
    if (null !== wk) {
      var a2 = Dc2(xk), b = ok.transition, c = C;
      try {
        ok.transition = null;
        C = 16 > a2 ? 16 : a2;
        if (null === wk) var d2 = false;
        else {
          a2 = wk;
          wk = null;
          xk = 0;
          if (0 !== (K2 & 6)) throw Error(p2(331));
          var e = K2;
          K2 |= 4;
          for (V2 = a2.current; null !== V2; ) {
            var f2 = V2, g2 = f2.child;
            if (0 !== (V2.flags & 16)) {
              var h2 = f2.deletions;
              if (null !== h2) {
                for (var k2 = 0; k2 < h2.length; k2++) {
                  var l = h2[k2];
                  for (V2 = l; null !== V2; ) {
                    var m2 = V2;
                    switch (m2.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Pj(8, m2, f2);
                    }
                    var q2 = m2.child;
                    if (null !== q2) q2.return = m2, V2 = q2;
                    else for (; null !== V2; ) {
                      m2 = V2;
                      var r2 = m2.sibling, y2 = m2.return;
                      Sj(m2);
                      if (m2 === l) {
                        V2 = null;
                        break;
                      }
                      if (null !== r2) {
                        r2.return = y2;
                        V2 = r2;
                        break;
                      }
                      V2 = y2;
                    }
                  }
                }
                var n = f2.alternate;
                if (null !== n) {
                  var t = n.child;
                  if (null !== t) {
                    n.child = null;
                    do {
                      var J2 = t.sibling;
                      t.sibling = null;
                      t = J2;
                    } while (null !== t);
                  }
                }
                V2 = f2;
              }
            }
            if (0 !== (f2.subtreeFlags & 2064) && null !== g2) g2.return = f2, V2 = g2;
            else b: for (; null !== V2; ) {
              f2 = V2;
              if (0 !== (f2.flags & 2048)) switch (f2.tag) {
                case 0:
                case 11:
                case 15:
                  Pj(9, f2, f2.return);
              }
              var x2 = f2.sibling;
              if (null !== x2) {
                x2.return = f2.return;
                V2 = x2;
                break b;
              }
              V2 = f2.return;
            }
          }
          var w2 = a2.current;
          for (V2 = w2; null !== V2; ) {
            g2 = V2;
            var u2 = g2.child;
            if (0 !== (g2.subtreeFlags & 2064) && null !== u2) u2.return = g2, V2 = u2;
            else b: for (g2 = w2; null !== V2; ) {
              h2 = V2;
              if (0 !== (h2.flags & 2048)) try {
                switch (h2.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Qj(9, h2);
                }
              } catch (na2) {
                W2(h2, h2.return, na2);
              }
              if (h2 === g2) {
                V2 = null;
                break b;
              }
              var F2 = h2.sibling;
              if (null !== F2) {
                F2.return = h2.return;
                V2 = F2;
                break b;
              }
              V2 = h2.return;
            }
          }
          K2 = e;
          jg2();
          if (lc2 && "function" === typeof lc2.onPostCommitFiberRoot) try {
            lc2.onPostCommitFiberRoot(kc2, a2);
          } catch (na2) {
          }
          d2 = true;
        }
        return d2;
      } finally {
        C = c, ok.transition = b;
      }
    }
    return false;
  }
  function Xk(a2, b, c) {
    b = Ji2(c, b);
    b = Ni2(a2, b, 1);
    a2 = nh2(a2, b, 1);
    b = R2();
    null !== a2 && (Ac2(a2, 1, b), Dk(a2, b));
  }
  function W2(a2, b, c) {
    if (3 === a2.tag) Xk(a2, a2, c);
    else for (; null !== b; ) {
      if (3 === b.tag) {
        Xk(b, a2, c);
        break;
      } else if (1 === b.tag) {
        var d2 = b.stateNode;
        if ("function" === typeof b.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Ri2 || !Ri2.has(d2))) {
          a2 = Ji2(c, a2);
          a2 = Qi2(b, a2, 1);
          b = nh2(b, a2, 1);
          a2 = R2();
          null !== b && (Ac2(b, 1, a2), Dk(b, a2));
          break;
        }
      }
      b = b.return;
    }
  }
  function Ti2(a2, b, c) {
    var d2 = a2.pingCache;
    null !== d2 && d2.delete(b);
    b = R2();
    a2.pingedLanes |= a2.suspendedLanes & c;
    Q2 === a2 && (Z2 & c) === c && (4 === T2 || 3 === T2 && (Z2 & 130023424) === Z2 && 500 > B2() - fk ? Kk(a2, 0) : rk |= c);
    Dk(a2, b);
  }
  function Yk(a2, b) {
    0 === b && (0 === (a2.mode & 1) ? b = 1 : (b = sc2, sc2 <<= 1, 0 === (sc2 & 130023424) && (sc2 = 4194304)));
    var c = R2();
    a2 = ih2(a2, b);
    null !== a2 && (Ac2(a2, b, c), Dk(a2, c));
  }
  function uj(a2) {
    var b = a2.memoizedState, c = 0;
    null !== b && (c = b.retryLane);
    Yk(a2, c);
  }
  function bk(a2, b) {
    var c = 0;
    switch (a2.tag) {
      case 13:
        var d2 = a2.stateNode;
        var e = a2.memoizedState;
        null !== e && (c = e.retryLane);
        break;
      case 19:
        d2 = a2.stateNode;
        break;
      default:
        throw Error(p2(314));
    }
    null !== d2 && d2.delete(b);
    Yk(a2, c);
  }
  var Vk;
  Vk = function(a2, b, c) {
    if (null !== a2) if (a2.memoizedProps !== b.pendingProps || Wf2.current) dh2 = true;
    else {
      if (0 === (a2.lanes & c) && 0 === (b.flags & 128)) return dh2 = false, yj(a2, b, c);
      dh2 = 0 !== (a2.flags & 131072) ? true : false;
    }
    else dh2 = false, I2 && 0 !== (b.flags & 1048576) && ug2(b, ng2, b.index);
    b.lanes = 0;
    switch (b.tag) {
      case 2:
        var d2 = b.type;
        ij(a2, b);
        a2 = b.pendingProps;
        var e = Yf2(b, H2.current);
        ch2(b, c);
        e = Nh(null, b, d2, a2, e, c);
        var f2 = Sh2();
        b.flags |= 1;
        "object" === typeof e && null !== e && "function" === typeof e.render && void 0 === e.$$typeof ? (b.tag = 1, b.memoizedState = null, b.updateQueue = null, Zf2(d2) ? (f2 = true, cg2(b)) : f2 = false, b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null, kh(b), e.updater = Ei2, b.stateNode = e, e._reactInternals = b, Ii2(b, d2, a2, c), b = jj(null, b, d2, true, f2, c)) : (b.tag = 0, I2 && f2 && vg3(b), Xi2(null, b, e, c), b = b.child);
        return b;
      case 16:
        d2 = b.elementType;
        a: {
          ij(a2, b);
          a2 = b.pendingProps;
          e = d2._init;
          d2 = e(d2._payload);
          b.type = d2;
          e = b.tag = Zk(d2);
          a2 = Ci2(d2, a2);
          switch (e) {
            case 0:
              b = cj(null, b, d2, a2, c);
              break a;
            case 1:
              b = hj(null, b, d2, a2, c);
              break a;
            case 11:
              b = Yi2(null, b, d2, a2, c);
              break a;
            case 14:
              b = $i2(null, b, d2, Ci2(d2.type, a2), c);
              break a;
          }
          throw Error(p2(
            306,
            d2,
            ""
          ));
        }
        return b;
      case 0:
        return d2 = b.type, e = b.pendingProps, e = b.elementType === d2 ? e : Ci2(d2, e), cj(a2, b, d2, e, c);
      case 1:
        return d2 = b.type, e = b.pendingProps, e = b.elementType === d2 ? e : Ci2(d2, e), hj(a2, b, d2, e, c);
      case 3:
        a: {
          kj(b);
          if (null === a2) throw Error(p2(387));
          d2 = b.pendingProps;
          f2 = b.memoizedState;
          e = f2.element;
          lh2(a2, b);
          qh(b, d2, null, c);
          var g2 = b.memoizedState;
          d2 = g2.element;
          if (f2.isDehydrated) if (f2 = { element: d2, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b.updateQueue.baseState = f2, b.memoizedState = f2, b.flags & 256) {
            e = Ji2(Error(p2(423)), b);
            b = lj(a2, b, d2, c, e);
            break a;
          } else if (d2 !== e) {
            e = Ji2(Error(p2(424)), b);
            b = lj(a2, b, d2, c, e);
            break a;
          } else for (yg2 = Lf2(b.stateNode.containerInfo.firstChild), xg2 = b, I2 = true, zg2 = null, c = Vg2(b, null, d2, c), b.child = c; c; ) c.flags = c.flags & -3 | 4096, c = c.sibling;
          else {
            Ig2();
            if (d2 === e) {
              b = Zi2(a2, b, c);
              break a;
            }
            Xi2(a2, b, d2, c);
          }
          b = b.child;
        }
        return b;
      case 5:
        return Ah(b), null === a2 && Eg2(b), d2 = b.type, e = b.pendingProps, f2 = null !== a2 ? a2.memoizedProps : null, g2 = e.children, Ef2(d2, e) ? g2 = null : null !== f2 && Ef2(d2, f2) && (b.flags |= 32), gj(a2, b), Xi2(a2, b, g2, c), b.child;
      case 6:
        return null === a2 && Eg2(b), null;
      case 13:
        return oj(a2, b, c);
      case 4:
        return yh2(b, b.stateNode.containerInfo), d2 = b.pendingProps, null === a2 ? b.child = Ug2(b, null, d2, c) : Xi2(a2, b, d2, c), b.child;
      case 11:
        return d2 = b.type, e = b.pendingProps, e = b.elementType === d2 ? e : Ci2(d2, e), Yi2(a2, b, d2, e, c);
      case 7:
        return Xi2(a2, b, b.pendingProps, c), b.child;
      case 8:
        return Xi2(a2, b, b.pendingProps.children, c), b.child;
      case 12:
        return Xi2(a2, b, b.pendingProps.children, c), b.child;
      case 10:
        a: {
          d2 = b.type._context;
          e = b.pendingProps;
          f2 = b.memoizedProps;
          g2 = e.value;
          G2(Wg2, d2._currentValue);
          d2._currentValue = g2;
          if (null !== f2) if (He2(f2.value, g2)) {
            if (f2.children === e.children && !Wf2.current) {
              b = Zi2(a2, b, c);
              break a;
            }
          } else for (f2 = b.child, null !== f2 && (f2.return = b); null !== f2; ) {
            var h2 = f2.dependencies;
            if (null !== h2) {
              g2 = f2.child;
              for (var k2 = h2.firstContext; null !== k2; ) {
                if (k2.context === d2) {
                  if (1 === f2.tag) {
                    k2 = mh2(-1, c & -c);
                    k2.tag = 2;
                    var l = f2.updateQueue;
                    if (null !== l) {
                      l = l.shared;
                      var m2 = l.pending;
                      null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                      l.pending = k2;
                    }
                  }
                  f2.lanes |= c;
                  k2 = f2.alternate;
                  null !== k2 && (k2.lanes |= c);
                  bh2(
                    f2.return,
                    c,
                    b
                  );
                  h2.lanes |= c;
                  break;
                }
                k2 = k2.next;
              }
            } else if (10 === f2.tag) g2 = f2.type === b.type ? null : f2.child;
            else if (18 === f2.tag) {
              g2 = f2.return;
              if (null === g2) throw Error(p2(341));
              g2.lanes |= c;
              h2 = g2.alternate;
              null !== h2 && (h2.lanes |= c);
              bh2(g2, c, b);
              g2 = f2.sibling;
            } else g2 = f2.child;
            if (null !== g2) g2.return = f2;
            else for (g2 = f2; null !== g2; ) {
              if (g2 === b) {
                g2 = null;
                break;
              }
              f2 = g2.sibling;
              if (null !== f2) {
                f2.return = g2.return;
                g2 = f2;
                break;
              }
              g2 = g2.return;
            }
            f2 = g2;
          }
          Xi2(a2, b, e.children, c);
          b = b.child;
        }
        return b;
      case 9:
        return e = b.type, d2 = b.pendingProps.children, ch2(b, c), e = eh2(e), d2 = d2(e), b.flags |= 1, Xi2(a2, b, d2, c), b.child;
      case 14:
        return d2 = b.type, e = Ci2(d2, b.pendingProps), e = Ci2(d2.type, e), $i2(a2, b, d2, e, c);
      case 15:
        return bj(a2, b, b.type, b.pendingProps, c);
      case 17:
        return d2 = b.type, e = b.pendingProps, e = b.elementType === d2 ? e : Ci2(d2, e), ij(a2, b), b.tag = 1, Zf2(d2) ? (a2 = true, cg2(b)) : a2 = false, ch2(b, c), Gi2(b, d2, e), Ii2(b, d2, e, c), jj(null, b, d2, true, a2, c);
      case 19:
        return xj(a2, b, c);
      case 22:
        return dj(a2, b, c);
    }
    throw Error(p2(156, b.tag));
  };
  function Fk(a2, b) {
    return ac2(a2, b);
  }
  function $k(a2, b, c, d2) {
    this.tag = a2;
    this.key = c;
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
    this.index = 0;
    this.ref = null;
    this.pendingProps = b;
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
    this.mode = d2;
    this.subtreeFlags = this.flags = 0;
    this.deletions = null;
    this.childLanes = this.lanes = 0;
    this.alternate = null;
  }
  function Bg2(a2, b, c, d2) {
    return new $k(a2, b, c, d2);
  }
  function aj(a2) {
    a2 = a2.prototype;
    return !(!a2 || !a2.isReactComponent);
  }
  function Zk(a2) {
    if ("function" === typeof a2) return aj(a2) ? 1 : 0;
    if (void 0 !== a2 && null !== a2) {
      a2 = a2.$$typeof;
      if (a2 === Da) return 11;
      if (a2 === Ga2) return 14;
    }
    return 2;
  }
  function Pg2(a2, b) {
    var c = a2.alternate;
    null === c ? (c = Bg2(a2.tag, b, a2.key, a2.mode), c.elementType = a2.elementType, c.type = a2.type, c.stateNode = a2.stateNode, c.alternate = a2, a2.alternate = c) : (c.pendingProps = b, c.type = a2.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null);
    c.flags = a2.flags & 14680064;
    c.childLanes = a2.childLanes;
    c.lanes = a2.lanes;
    c.child = a2.child;
    c.memoizedProps = a2.memoizedProps;
    c.memoizedState = a2.memoizedState;
    c.updateQueue = a2.updateQueue;
    b = a2.dependencies;
    c.dependencies = null === b ? null : { lanes: b.lanes, firstContext: b.firstContext };
    c.sibling = a2.sibling;
    c.index = a2.index;
    c.ref = a2.ref;
    return c;
  }
  function Rg2(a2, b, c, d2, e, f2) {
    var g2 = 2;
    d2 = a2;
    if ("function" === typeof a2) aj(a2) && (g2 = 1);
    else if ("string" === typeof a2) g2 = 5;
    else a: switch (a2) {
      case ya:
        return Tg2(c.children, e, f2, b);
      case za:
        g2 = 8;
        e |= 8;
        break;
      case Aa2:
        return a2 = Bg2(12, c, b, e | 2), a2.elementType = Aa2, a2.lanes = f2, a2;
      case Ea:
        return a2 = Bg2(13, c, b, e), a2.elementType = Ea, a2.lanes = f2, a2;
      case Fa2:
        return a2 = Bg2(19, c, b, e), a2.elementType = Fa2, a2.lanes = f2, a2;
      case Ia:
        return pj(c, e, f2, b);
      default:
        if ("object" === typeof a2 && null !== a2) switch (a2.$$typeof) {
          case Ba2:
            g2 = 10;
            break a;
          case Ca2:
            g2 = 9;
            break a;
          case Da:
            g2 = 11;
            break a;
          case Ga2:
            g2 = 14;
            break a;
          case Ha2:
            g2 = 16;
            d2 = null;
            break a;
        }
        throw Error(p2(130, null == a2 ? a2 : typeof a2, ""));
    }
    b = Bg2(g2, c, b, e);
    b.elementType = a2;
    b.type = d2;
    b.lanes = f2;
    return b;
  }
  function Tg2(a2, b, c, d2) {
    a2 = Bg2(7, a2, d2, b);
    a2.lanes = c;
    return a2;
  }
  function pj(a2, b, c, d2) {
    a2 = Bg2(22, a2, d2, b);
    a2.elementType = Ia;
    a2.lanes = c;
    a2.stateNode = { isHidden: false };
    return a2;
  }
  function Qg2(a2, b, c) {
    a2 = Bg2(6, a2, null, b);
    a2.lanes = c;
    return a2;
  }
  function Sg2(a2, b, c) {
    b = Bg2(4, null !== a2.children ? a2.children : [], a2.key, b);
    b.lanes = c;
    b.stateNode = { containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation };
    return b;
  }
  function al2(a2, b, c, d2, e) {
    this.tag = b;
    this.containerInfo = a2;
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
    this.timeoutHandle = -1;
    this.callbackNode = this.pendingContext = this.context = null;
    this.callbackPriority = 0;
    this.eventTimes = zc2(0);
    this.expirationTimes = zc2(-1);
    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
    this.entanglements = zc2(0);
    this.identifierPrefix = d2;
    this.onRecoverableError = e;
    this.mutableSourceEagerHydrationData = null;
  }
  function bl2(a2, b, c, d2, e, f2, g2, h2, k2) {
    a2 = new al2(a2, b, c, h2, k2);
    1 === b ? (b = 1, true === f2 && (b |= 8)) : b = 0;
    f2 = Bg2(3, null, null, b);
    a2.current = f2;
    f2.stateNode = a2;
    f2.memoizedState = { element: d2, isDehydrated: c, cache: null, transitions: null, pendingSuspenseBoundaries: null };
    kh(f2);
    return a2;
  }
  function cl2(a2, b, c) {
    var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
    return { $$typeof: wa, key: null == d2 ? null : "" + d2, children: a2, containerInfo: b, implementation: c };
  }
  function dl2(a2) {
    if (!a2) return Vf2;
    a2 = a2._reactInternals;
    a: {
      if (Vb(a2) !== a2 || 1 !== a2.tag) throw Error(p2(170));
      var b = a2;
      do {
        switch (b.tag) {
          case 3:
            b = b.stateNode.context;
            break a;
          case 1:
            if (Zf2(b.type)) {
              b = b.stateNode.__reactInternalMemoizedMergedChildContext;
              break a;
            }
        }
        b = b.return;
      } while (null !== b);
      throw Error(p2(171));
    }
    if (1 === a2.tag) {
      var c = a2.type;
      if (Zf2(c)) return bg2(a2, c, b);
    }
    return b;
  }
  function el2(a2, b, c, d2, e, f2, g2, h2, k2) {
    a2 = bl2(c, d2, true, a2, e, f2, g2, h2, k2);
    a2.context = dl2(null);
    c = a2.current;
    d2 = R2();
    e = yi2(c);
    f2 = mh2(d2, e);
    f2.callback = void 0 !== b && null !== b ? b : null;
    nh2(c, f2, e);
    a2.current.lanes = e;
    Ac2(a2, e, d2);
    Dk(a2, d2);
    return a2;
  }
  function fl2(a2, b, c, d2) {
    var e = b.current, f2 = R2(), g2 = yi2(e);
    c = dl2(c);
    null === b.context ? b.context = c : b.pendingContext = c;
    b = mh2(f2, g2);
    b.payload = { element: a2 };
    d2 = void 0 === d2 ? null : d2;
    null !== d2 && (b.callback = d2);
    a2 = nh2(e, b, g2);
    null !== a2 && (gi2(a2, e, g2, f2), oh2(a2, e, g2));
    return g2;
  }
  function gl2(a2) {
    a2 = a2.current;
    if (!a2.child) return null;
    switch (a2.child.tag) {
      case 5:
        return a2.child.stateNode;
      default:
        return a2.child.stateNode;
    }
  }
  function hl2(a2, b) {
    a2 = a2.memoizedState;
    if (null !== a2 && null !== a2.dehydrated) {
      var c = a2.retryLane;
      a2.retryLane = 0 !== c && c < b ? c : b;
    }
  }
  function il2(a2, b) {
    hl2(a2, b);
    (a2 = a2.alternate) && hl2(a2, b);
  }
  function jl2() {
    return null;
  }
  var kl2 = "function" === typeof reportError ? reportError : function(a2) {
    console.error(a2);
  };
  function ll2(a2) {
    this._internalRoot = a2;
  }
  ml2.prototype.render = ll2.prototype.render = function(a2) {
    var b = this._internalRoot;
    if (null === b) throw Error(p2(409));
    fl2(a2, b, null, null);
  };
  ml2.prototype.unmount = ll2.prototype.unmount = function() {
    var a2 = this._internalRoot;
    if (null !== a2) {
      this._internalRoot = null;
      var b = a2.containerInfo;
      Rk(function() {
        fl2(null, a2, null, null);
      });
      b[uf] = null;
    }
  };
  function ml2(a2) {
    this._internalRoot = a2;
  }
  ml2.prototype.unstable_scheduleHydration = function(a2) {
    if (a2) {
      var b = Hc2();
      a2 = { blockedOn: null, target: a2, priority: b };
      for (var c = 0; c < Qc2.length && 0 !== b && b < Qc2[c].priority; c++) ;
      Qc2.splice(c, 0, a2);
      0 === c && Vc2(a2);
    }
  };
  function nl2(a2) {
    return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType);
  }
  function ol2(a2) {
    return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType && (8 !== a2.nodeType || " react-mount-point-unstable " !== a2.nodeValue));
  }
  function pl2() {
  }
  function ql2(a2, b, c, d2, e) {
    if (e) {
      if ("function" === typeof d2) {
        var f2 = d2;
        d2 = function() {
          var a3 = gl2(g2);
          f2.call(a3);
        };
      }
      var g2 = el2(b, d2, a2, 0, null, false, false, "", pl2);
      a2._reactRootContainer = g2;
      a2[uf] = g2.current;
      sf(8 === a2.nodeType ? a2.parentNode : a2);
      Rk();
      return g2;
    }
    for (; e = a2.lastChild; ) a2.removeChild(e);
    if ("function" === typeof d2) {
      var h2 = d2;
      d2 = function() {
        var a3 = gl2(k2);
        h2.call(a3);
      };
    }
    var k2 = bl2(a2, 0, false, null, null, false, false, "", pl2);
    a2._reactRootContainer = k2;
    a2[uf] = k2.current;
    sf(8 === a2.nodeType ? a2.parentNode : a2);
    Rk(function() {
      fl2(b, k2, c, d2);
    });
    return k2;
  }
  function rl2(a2, b, c, d2, e) {
    var f2 = c._reactRootContainer;
    if (f2) {
      var g2 = f2;
      if ("function" === typeof e) {
        var h2 = e;
        e = function() {
          var a3 = gl2(g2);
          h2.call(a3);
        };
      }
      fl2(b, g2, a2, e);
    } else g2 = ql2(c, b, a2, e, d2);
    return gl2(g2);
  }
  Ec2 = function(a2) {
    switch (a2.tag) {
      case 3:
        var b = a2.stateNode;
        if (b.current.memoizedState.isDehydrated) {
          var c = tc2(b.pendingLanes);
          0 !== c && (Cc2(b, c | 1), Dk(b, B2()), 0 === (K2 & 6) && (Gj = B2() + 500, jg2()));
        }
        break;
      case 13:
        Rk(function() {
          var b2 = ih2(a2, 1);
          if (null !== b2) {
            var c2 = R2();
            gi2(b2, a2, 1, c2);
          }
        }), il2(a2, 1);
    }
  };
  Fc2 = function(a2) {
    if (13 === a2.tag) {
      var b = ih2(a2, 134217728);
      if (null !== b) {
        var c = R2();
        gi2(b, a2, 134217728, c);
      }
      il2(a2, 134217728);
    }
  };
  Gc2 = function(a2) {
    if (13 === a2.tag) {
      var b = yi2(a2), c = ih2(a2, b);
      if (null !== c) {
        var d2 = R2();
        gi2(c, a2, b, d2);
      }
      il2(a2, b);
    }
  };
  Hc2 = function() {
    return C;
  };
  Ic2 = function(a2, b) {
    var c = C;
    try {
      return C = a2, b();
    } finally {
      C = c;
    }
  };
  yb = function(a2, b, c) {
    switch (b) {
      case "input":
        bb(a2, c);
        b = c.name;
        if ("radio" === c.type && null != b) {
          for (c = a2; c.parentNode; ) c = c.parentNode;
          c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
          for (b = 0; b < c.length; b++) {
            var d2 = c[b];
            if (d2 !== a2 && d2.form === a2.form) {
              var e = Db(d2);
              if (!e) throw Error(p2(90));
              Wa2(d2);
              bb(d2, e);
            }
          }
        }
        break;
      case "textarea":
        ib(a2, c);
        break;
      case "select":
        b = c.value, null != b && fb(a2, !!c.multiple, b, false);
    }
  };
  Gb = Qk;
  Hb = Rk;
  var sl2 = { usingClientEntryPoint: false, Events: [Cb, ue2, Db, Eb, Fb, Qk] }, tl2 = { findFiberByHostInstance: Wc2, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" };
  var ul2 = { bundleType: tl2.bundleType, version: tl2.version, rendererPackageName: tl2.rendererPackageName, rendererConfig: tl2.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua2.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
    a2 = Zb(a2);
    return null === a2 ? null : a2.stateNode;
  }, findFiberByHostInstance: tl2.findFiberByHostInstance || jl2, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
  if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
    var vl2 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!vl2.isDisabled && vl2.supportsFiber) try {
      kc2 = vl2.inject(ul2), lc2 = vl2;
    } catch (a2) {
    }
  }
  reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl2;
  reactDom_production_min.createPortal = function(a2, b) {
    var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
    if (!nl2(b)) throw Error(p2(200));
    return cl2(a2, b, null, c);
  };
  reactDom_production_min.createRoot = function(a2, b) {
    if (!nl2(a2)) throw Error(p2(299));
    var c = false, d2 = "", e = kl2;
    null !== b && void 0 !== b && (true === b.unstable_strictMode && (c = true), void 0 !== b.identifierPrefix && (d2 = b.identifierPrefix), void 0 !== b.onRecoverableError && (e = b.onRecoverableError));
    b = bl2(a2, 1, false, null, null, c, false, d2, e);
    a2[uf] = b.current;
    sf(8 === a2.nodeType ? a2.parentNode : a2);
    return new ll2(b);
  };
  reactDom_production_min.findDOMNode = function(a2) {
    if (null == a2) return null;
    if (1 === a2.nodeType) return a2;
    var b = a2._reactInternals;
    if (void 0 === b) {
      if ("function" === typeof a2.render) throw Error(p2(188));
      a2 = Object.keys(a2).join(",");
      throw Error(p2(268, a2));
    }
    a2 = Zb(b);
    a2 = null === a2 ? null : a2.stateNode;
    return a2;
  };
  reactDom_production_min.flushSync = function(a2) {
    return Rk(a2);
  };
  reactDom_production_min.hydrate = function(a2, b, c) {
    if (!ol2(b)) throw Error(p2(200));
    return rl2(null, a2, b, true, c);
  };
  reactDom_production_min.hydrateRoot = function(a2, b, c) {
    if (!nl2(a2)) throw Error(p2(405));
    var d2 = null != c && c.hydratedSources || null, e = false, f2 = "", g2 = kl2;
    null !== c && void 0 !== c && (true === c.unstable_strictMode && (e = true), void 0 !== c.identifierPrefix && (f2 = c.identifierPrefix), void 0 !== c.onRecoverableError && (g2 = c.onRecoverableError));
    b = el2(b, null, a2, 1, null != c ? c : null, e, false, f2, g2);
    a2[uf] = b.current;
    sf(a2);
    if (d2) for (a2 = 0; a2 < d2.length; a2++) c = d2[a2], e = c._getVersion, e = e(c._source), null == b.mutableSourceEagerHydrationData ? b.mutableSourceEagerHydrationData = [c, e] : b.mutableSourceEagerHydrationData.push(
      c,
      e
    );
    return new ml2(b);
  };
  reactDom_production_min.render = function(a2, b, c) {
    if (!ol2(b)) throw Error(p2(200));
    return rl2(null, a2, b, false, c);
  };
  reactDom_production_min.unmountComponentAtNode = function(a2) {
    if (!ol2(a2)) throw Error(p2(40));
    return a2._reactRootContainer ? (Rk(function() {
      rl2(null, null, a2, false, function() {
        a2._reactRootContainer = null;
        a2[uf] = null;
      });
    }), true) : false;
  };
  reactDom_production_min.unstable_batchedUpdates = Qk;
  reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a2, b, c, d2) {
    if (!ol2(c)) throw Error(p2(200));
    if (null == a2 || void 0 === a2._reactInternals) throw Error(p2(38));
    return rl2(a2, b, c, false, d2);
  };
  reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
  return reactDom_production_min;
}
var hasRequiredReactDom;
function requireReactDom() {
  if (hasRequiredReactDom) return reactDom.exports;
  hasRequiredReactDom = 1;
  function checkDCE() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
      return;
    }
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      console.error(err);
    }
  }
  {
    checkDCE();
    reactDom.exports = requireReactDom_production_min();
  }
  return reactDom.exports;
}
var hasRequiredClient;
function requireClient() {
  if (hasRequiredClient) return client;
  hasRequiredClient = 1;
  var m2 = requireReactDom();
  {
    client.createRoot = m2.createRoot;
    client.hydrateRoot = m2.hydrateRoot;
  }
  return client;
}
var clientExports = requireClient();
const TOAST_LIMIT = 1;
const TOAST_REMOVE_DELAY = 1e6;
let count$2 = 0;
function genId() {
  count$2 = (count$2 + 1) % Number.MAX_SAFE_INTEGER;
  return count$2.toString();
}
const toastTimeouts = /* @__PURE__ */ new Map();
const addToRemoveQueue = (toastId) => {
  if (toastTimeouts.has(toastId)) {
    return;
  }
  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId);
    dispatch({
      type: "REMOVE_TOAST",
      toastId
    });
  }, TOAST_REMOVE_DELAY);
  toastTimeouts.set(toastId, timeout);
};
const reducer = (state, action) => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT)
      };
    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map(
          (t) => t.id === action.toast.id ? { ...t, ...action.toast } : t
        )
      };
    case "DISMISS_TOAST": {
      const { toastId } = action;
      if (toastId) {
        addToRemoveQueue(toastId);
      } else {
        state.toasts.forEach((toast2) => {
          addToRemoveQueue(toast2.id);
        });
      }
      return {
        ...state,
        toasts: state.toasts.map(
          (t) => t.id === toastId || toastId === void 0 ? {
            ...t,
            open: false
          } : t
        )
      };
    }
    case "REMOVE_TOAST":
      if (action.toastId === void 0) {
        return {
          ...state,
          toasts: []
        };
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId)
      };
  }
};
const listeners = [];
let memoryState = { toasts: [] };
function dispatch(action) {
  memoryState = reducer(memoryState, action);
  listeners.forEach((listener) => {
    listener(memoryState);
  });
}
function toast({ ...props }) {
  const id2 = genId();
  const update = (props2) => dispatch({
    type: "UPDATE_TOAST",
    toast: { ...props2, id: id2 }
  });
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id2 });
  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id: id2,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss();
      }
    }
  });
  return {
    id: id2,
    dismiss,
    update
  };
}
function useToast() {
  const [state, setState] = reactExports.useState(memoryState);
  reactExports.useEffect(() => {
    listeners.push(setState);
    return () => {
      const index2 = listeners.indexOf(setState);
      if (index2 > -1) {
        listeners.splice(index2, 1);
      }
    };
  }, [state]);
  return {
    ...state,
    toast,
    dismiss: (toastId) => dispatch({ type: "DISMISS_TOAST", toastId })
  };
}
var reactDomExports = requireReactDom();
const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler?.(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) {
      return ourEventHandler?.(event);
    }
  };
}
function setRef(ref2, value) {
  if (typeof ref2 === "function") {
    return ref2(value);
  } else if (ref2 !== null && ref2 !== void 0) {
    ref2.current = value;
  }
}
function composeRefs(...refs) {
  return (node) => {
    let hasCleanup = false;
    const cleanups = refs.map((ref2) => {
      const cleanup = setRef(ref2, node);
      if (!hasCleanup && typeof cleanup == "function") {
        hasCleanup = true;
      }
      return cleanup;
    });
    if (hasCleanup) {
      return () => {
        for (let i = 0; i < cleanups.length; i++) {
          const cleanup = cleanups[i];
          if (typeof cleanup == "function") {
            cleanup();
          } else {
            setRef(refs[i], null);
          }
        }
      };
    }
  };
}
function useComposedRefs(...refs) {
  return reactExports.useCallback(composeRefs(...refs), refs);
}
function createContext2(rootComponentName, defaultContext) {
  const Context = reactExports.createContext(defaultContext);
  const Provider2 = (props) => {
    const { children, ...context } = props;
    const value = reactExports.useMemo(() => context, Object.values(context));
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Context.Provider, { value, children });
  };
  Provider2.displayName = rootComponentName + "Provider";
  function useContext2(consumerName) {
    const context = reactExports.useContext(Context);
    if (context) return context;
    if (defaultContext !== void 0) return defaultContext;
    throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
  }
  return [Provider2, useContext2];
}
function createContextScope(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function createContext3(rootComponentName, defaultContext) {
    const BaseContext = reactExports.createContext(defaultContext);
    const index2 = defaultContexts.length;
    defaultContexts = [...defaultContexts, defaultContext];
    const Provider2 = (props) => {
      const { scope: scope2, children, ...context } = props;
      const Context = scope2?.[scopeName]?.[index2] || BaseContext;
      const value = reactExports.useMemo(() => context, Object.values(context));
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Context.Provider, { value, children });
    };
    Provider2.displayName = rootComponentName + "Provider";
    function useContext2(consumerName, scope2) {
      const Context = scope2?.[scopeName]?.[index2] || BaseContext;
      const context = reactExports.useContext(Context);
      if (context) return context;
      if (defaultContext !== void 0) return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    return [Provider2, useContext2];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return reactExports.createContext(defaultContext);
    });
    return function useScope(scope2) {
      const contexts = scope2?.[scopeName] || scopeContexts;
      return reactExports.useMemo(
        () => ({ [`__scope${scopeName}`]: { ...scope2, [scopeName]: contexts } }),
        [scope2, contexts]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [createContext3, composeContextScopes(createScope, ...createContextScopeDeps)];
}
function composeContextScopes(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1) return baseScope;
  const createScope = () => {
    const scopeHooks = scopes.map((createScope2) => ({
      useScope: createScope2(),
      scopeName: createScope2.scopeName
    }));
    return function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return { ...nextScopes2, ...currentScope };
      }, {});
      return reactExports.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    };
  };
  createScope.scopeName = baseScope.scopeName;
  return createScope;
}
// @__NO_SIDE_EFFECTS__
function createSlot$5(ownerName) {
  const SlotClone = /* @__PURE__ */ createSlotClone$5(ownerName);
  const Slot2 = reactExports.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    const childrenArray = reactExports.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable$5);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (reactExports.Children.count(newElement) > 1) return reactExports.Children.only(null);
          return reactExports.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children: reactExports.isValidElement(newElement) ? reactExports.cloneElement(newElement, void 0, newChildren) : null });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children });
  });
  Slot2.displayName = `${ownerName}.Slot`;
  return Slot2;
}
// @__NO_SIDE_EFFECTS__
function createSlotClone$5(ownerName) {
  const SlotClone = reactExports.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    if (reactExports.isValidElement(children)) {
      const childrenRef = getElementRef$6(children);
      const props2 = mergeProps$5(slotProps, children.props);
      if (children.type !== reactExports.Fragment) {
        props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
      }
      return reactExports.cloneElement(children, props2);
    }
    return reactExports.Children.count(children) > 1 ? reactExports.Children.only(null) : null;
  });
  SlotClone.displayName = `${ownerName}.SlotClone`;
  return SlotClone;
}
var SLOTTABLE_IDENTIFIER$6 = /* @__PURE__ */ Symbol("radix.slottable");
function isSlottable$5(child) {
  return reactExports.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER$6;
}
function mergeProps$5(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          const result = childPropValue(...args);
          slotPropValue(...args);
          return result;
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef$6(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
function createCollection(name2) {
  const PROVIDER_NAME2 = name2 + "CollectionProvider";
  const [createCollectionContext, createCollectionScope2] = createContextScope(PROVIDER_NAME2);
  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(
    PROVIDER_NAME2,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  );
  const CollectionProvider = (props) => {
    const { scope: scope2, children } = props;
    const ref2 = React.useRef(null);
    const itemMap = React.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(CollectionProviderImpl, { scope: scope2, itemMap, collectionRef: ref2, children });
  };
  CollectionProvider.displayName = PROVIDER_NAME2;
  const COLLECTION_SLOT_NAME = name2 + "CollectionSlot";
  const CollectionSlotImpl = /* @__PURE__ */ createSlot$5(COLLECTION_SLOT_NAME);
  const CollectionSlot = React.forwardRef(
    (props, forwardedRef) => {
      const { scope: scope2, children } = props;
      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope2);
      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(CollectionSlotImpl, { ref: composedRefs, children });
    }
  );
  CollectionSlot.displayName = COLLECTION_SLOT_NAME;
  const ITEM_SLOT_NAME = name2 + "CollectionItemSlot";
  const ITEM_DATA_ATTR = "data-radix-collection-item";
  const CollectionItemSlotImpl = /* @__PURE__ */ createSlot$5(ITEM_SLOT_NAME);
  const CollectionItemSlot = React.forwardRef(
    (props, forwardedRef) => {
      const { scope: scope2, children, ...itemData } = props;
      const ref2 = React.useRef(null);
      const composedRefs = useComposedRefs(forwardedRef, ref2);
      const context = useCollectionContext(ITEM_SLOT_NAME, scope2);
      React.useEffect(() => {
        context.itemMap.set(ref2, { ref: ref2, ...itemData });
        return () => void context.itemMap.delete(ref2);
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx(CollectionItemSlotImpl, { ...{ [ITEM_DATA_ATTR]: "" }, ref: composedRefs, children });
    }
  );
  CollectionItemSlot.displayName = ITEM_SLOT_NAME;
  function useCollection2(scope2) {
    const context = useCollectionContext(name2 + "CollectionConsumer", scope2);
    const getItems = React.useCallback(() => {
      const collectionNode = context.collectionRef.current;
      if (!collectionNode) return [];
      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
      const items2 = Array.from(context.itemMap.values());
      const orderedItems = items2.sort(
        (a2, b) => orderedNodes.indexOf(a2.ref.current) - orderedNodes.indexOf(b.ref.current)
      );
      return orderedItems;
    }, [context.collectionRef, context.itemMap]);
    return getItems;
  }
  return [
    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },
    useCollection2,
    createCollectionScope2
  ];
}
// @__NO_SIDE_EFFECTS__
function createSlot$4(ownerName) {
  const SlotClone = /* @__PURE__ */ createSlotClone$4(ownerName);
  const Slot2 = reactExports.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    const childrenArray = reactExports.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable$4);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (reactExports.Children.count(newElement) > 1) return reactExports.Children.only(null);
          return reactExports.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children: reactExports.isValidElement(newElement) ? reactExports.cloneElement(newElement, void 0, newChildren) : null });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children });
  });
  Slot2.displayName = `${ownerName}.Slot`;
  return Slot2;
}
// @__NO_SIDE_EFFECTS__
function createSlotClone$4(ownerName) {
  const SlotClone = reactExports.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    if (reactExports.isValidElement(children)) {
      const childrenRef = getElementRef$5(children);
      const props2 = mergeProps$4(slotProps, children.props);
      if (children.type !== reactExports.Fragment) {
        props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
      }
      return reactExports.cloneElement(children, props2);
    }
    return reactExports.Children.count(children) > 1 ? reactExports.Children.only(null) : null;
  });
  SlotClone.displayName = `${ownerName}.SlotClone`;
  return SlotClone;
}
var SLOTTABLE_IDENTIFIER$5 = /* @__PURE__ */ Symbol("radix.slottable");
function isSlottable$4(child) {
  return reactExports.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER$5;
}
function mergeProps$4(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          const result = childPropValue(...args);
          slotPropValue(...args);
          return result;
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef$5(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
var NODES$1 = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
];
var Primitive$1 = NODES$1.reduce((primitive, node) => {
  const Slot2 = /* @__PURE__ */ createSlot$4(`Primitive.${node}`);
  const Node2 = reactExports.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot2 : node;
    if (typeof window !== "undefined") {
      window[/* @__PURE__ */ Symbol.for("radix-ui")] = true;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node2.displayName = `Primitive.${node}`;
  return { ...primitive, [node]: Node2 };
}, {});
function dispatchDiscreteCustomEvent(target, event) {
  if (target) reactDomExports.flushSync(() => target.dispatchEvent(event));
}
function useCallbackRef$1(callback) {
  const callbackRef = reactExports.useRef(callback);
  reactExports.useEffect(() => {
    callbackRef.current = callback;
  });
  return reactExports.useMemo(() => (...args) => callbackRef.current?.(...args), []);
}
function useEscapeKeydown(onEscapeKeyDownProp, ownerDocument = globalThis?.document) {
  const onEscapeKeyDown = useCallbackRef$1(onEscapeKeyDownProp);
  reactExports.useEffect(() => {
    const handleKeyDown = (event) => {
      if (event.key === "Escape") {
        onEscapeKeyDown(event);
      }
    };
    ownerDocument.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => ownerDocument.removeEventListener("keydown", handleKeyDown, { capture: true });
  }, [onEscapeKeyDown, ownerDocument]);
}
var DISMISSABLE_LAYER_NAME = "DismissableLayer";
var CONTEXT_UPDATE = "dismissableLayer.update";
var POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
var FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
var originalBodyPointerEvents;
var DismissableLayerContext = reactExports.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var DismissableLayer = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      disableOutsidePointerEvents = false,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      ...layerProps
    } = props;
    const context = reactExports.useContext(DismissableLayerContext);
    const [node, setNode] = reactExports.useState(null);
    const ownerDocument = node?.ownerDocument ?? globalThis?.document;
    const [, force] = reactExports.useState({});
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode(node2));
    const layers = Array.from(context.layers);
    const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
    const index2 = node ? layers.indexOf(node) : -1;
    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
    const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
    const pointerDownOutside = usePointerDownOutside((event) => {
      const target = event.target;
      const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));
      if (!isPointerEventsEnabled || isPointerDownOnBranch) return;
      onPointerDownOutside?.(event);
      onInteractOutside?.(event);
      if (!event.defaultPrevented) onDismiss?.();
    }, ownerDocument);
    const focusOutside = useFocusOutside((event) => {
      const target = event.target;
      const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));
      if (isFocusInBranch) return;
      onFocusOutside?.(event);
      onInteractOutside?.(event);
      if (!event.defaultPrevented) onDismiss?.();
    }, ownerDocument);
    useEscapeKeydown((event) => {
      const isHighestLayer = index2 === context.layers.size - 1;
      if (!isHighestLayer) return;
      onEscapeKeyDown?.(event);
      if (!event.defaultPrevented && onDismiss) {
        event.preventDefault();
        onDismiss();
      }
    }, ownerDocument);
    reactExports.useEffect(() => {
      if (!node) return;
      if (disableOutsidePointerEvents) {
        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
          originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
          ownerDocument.body.style.pointerEvents = "none";
        }
        context.layersWithOutsidePointerEventsDisabled.add(node);
      }
      context.layers.add(node);
      dispatchUpdate();
      return () => {
        if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {
          ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;
        }
      };
    }, [node, ownerDocument, disableOutsidePointerEvents, context]);
    reactExports.useEffect(() => {
      return () => {
        if (!node) return;
        context.layers.delete(node);
        context.layersWithOutsidePointerEventsDisabled.delete(node);
        dispatchUpdate();
      };
    }, [node, context]);
    reactExports.useEffect(() => {
      const handleUpdate = () => force({});
      document.addEventListener(CONTEXT_UPDATE, handleUpdate);
      return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive$1.div,
      {
        ...layerProps,
        ref: composedRefs,
        style: {
          pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
          ...props.style
        },
        onFocusCapture: composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture),
        onBlurCapture: composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture),
        onPointerDownCapture: composeEventHandlers(
          props.onPointerDownCapture,
          pointerDownOutside.onPointerDownCapture
        )
      }
    );
  }
);
DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
var BRANCH_NAME = "DismissableLayerBranch";
var DismissableLayerBranch = reactExports.forwardRef((props, forwardedRef) => {
  const context = reactExports.useContext(DismissableLayerContext);
  const ref2 = reactExports.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref2);
  reactExports.useEffect(() => {
    const node = ref2.current;
    if (node) {
      context.branches.add(node);
      return () => {
        context.branches.delete(node);
      };
    }
  }, [context.branches]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive$1.div, { ...props, ref: composedRefs });
});
DismissableLayerBranch.displayName = BRANCH_NAME;
function usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis?.document) {
  const handlePointerDownOutside = useCallbackRef$1(onPointerDownOutside);
  const isPointerInsideReactTreeRef = reactExports.useRef(false);
  const handleClickRef = reactExports.useRef(() => {
  });
  reactExports.useEffect(() => {
    const handlePointerDown = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent2 = function() {
          handleAndDispatchCustomEvent$1(
            POINTER_DOWN_OUTSIDE,
            handlePointerDownOutside,
            eventDetail,
            { discrete: true }
          );
        };
        const eventDetail = { originalEvent: event };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
          ownerDocument.addEventListener("click", handleClickRef.current, { once: true });
        } else {
          handleAndDispatchPointerDownOutsideEvent2();
        }
      } else {
        ownerDocument.removeEventListener("click", handleClickRef.current);
      }
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown);
      ownerDocument.removeEventListener("click", handleClickRef.current);
    };
  }, [ownerDocument, handlePointerDownOutside]);
  return {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function useFocusOutside(onFocusOutside, ownerDocument = globalThis?.document) {
  const handleFocusOutside = useCallbackRef$1(onFocusOutside);
  const isFocusInsideReactTreeRef = reactExports.useRef(false);
  reactExports.useEffect(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = { originalEvent: event };
        handleAndDispatchCustomEvent$1(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    return () => ownerDocument.removeEventListener("focusin", handleFocus);
  }, [ownerDocument, handleFocusOutside]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function dispatchUpdate() {
  const event = new CustomEvent(CONTEXT_UPDATE);
  document.dispatchEvent(event);
}
function handleAndDispatchCustomEvent$1(name2, handler, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name2, { bubbles: false, cancelable: true, detail });
  if (handler) target.addEventListener(name2, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(target, event);
  } else {
    target.dispatchEvent(event);
  }
}
var Root$6 = DismissableLayer;
var Branch = DismissableLayerBranch;
var useLayoutEffect2 = globalThis?.document ? reactExports.useLayoutEffect : () => {
};
var PORTAL_NAME$4 = "Portal";
var Portal$3 = reactExports.forwardRef((props, forwardedRef) => {
  const { container: containerProp, ...portalProps } = props;
  const [mounted, setMounted] = reactExports.useState(false);
  useLayoutEffect2(() => setMounted(true), []);
  const container = containerProp || mounted && globalThis?.document?.body;
  return container ? ReactDOM.createPortal(/* @__PURE__ */ jsxRuntimeExports.jsx(Primitive$1.div, { ...portalProps, ref: forwardedRef }), container) : null;
});
Portal$3.displayName = PORTAL_NAME$4;
function useStateMachine(initialState, machine) {
  return reactExports.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState ?? state;
  }, initialState);
}
var Presence = (props) => {
  const { present, children } = props;
  const presence = usePresence(present);
  const child = typeof children === "function" ? children({ present: presence.isPresent }) : reactExports.Children.only(children);
  const ref2 = useComposedRefs(presence.ref, getElementRef$4(child));
  const forceMount = typeof children === "function";
  return forceMount || presence.isPresent ? reactExports.cloneElement(child, { ref: ref2 }) : null;
};
Presence.displayName = "Presence";
function usePresence(present) {
  const [node, setNode] = reactExports.useState();
  const stylesRef = reactExports.useRef(null);
  const prevPresentRef = reactExports.useRef(present);
  const prevAnimationNameRef = reactExports.useRef("none");
  const initialState = present ? "mounted" : "unmounted";
  const [state, send] = useStateMachine(initialState, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  reactExports.useEffect(() => {
    const currentAnimationName = getAnimationName(stylesRef.current);
    prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
  }, [state]);
  useLayoutEffect2(() => {
    const styles = stylesRef.current;
    const wasPresent = prevPresentRef.current;
    const hasPresentChanged = wasPresent !== present;
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.current;
      const currentAnimationName = getAnimationName(styles);
      if (present) {
        send("MOUNT");
      } else if (currentAnimationName === "none" || styles?.display === "none") {
        send("UNMOUNT");
      } else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (wasPresent && isAnimating) {
          send("ANIMATION_OUT");
        } else {
          send("UNMOUNT");
        }
      }
      prevPresentRef.current = present;
    }
  }, [present, send]);
  useLayoutEffect2(() => {
    if (node) {
      let timeoutId;
      const ownerWindow = node.ownerDocument.defaultView ?? window;
      const handleAnimationEnd = (event) => {
        const currentAnimationName = getAnimationName(stylesRef.current);
        const isCurrentAnimation = currentAnimationName.includes(CSS.escape(event.animationName));
        if (event.target === node && isCurrentAnimation) {
          send("ANIMATION_END");
          if (!prevPresentRef.current) {
            const currentFillMode = node.style.animationFillMode;
            node.style.animationFillMode = "forwards";
            timeoutId = ownerWindow.setTimeout(() => {
              if (node.style.animationFillMode === "forwards") {
                node.style.animationFillMode = currentFillMode;
              }
            });
          }
        }
      };
      const handleAnimationStart = (event) => {
        if (event.target === node) {
          prevAnimationNameRef.current = getAnimationName(stylesRef.current);
        }
      };
      node.addEventListener("animationstart", handleAnimationStart);
      node.addEventListener("animationcancel", handleAnimationEnd);
      node.addEventListener("animationend", handleAnimationEnd);
      return () => {
        ownerWindow.clearTimeout(timeoutId);
        node.removeEventListener("animationstart", handleAnimationStart);
        node.removeEventListener("animationcancel", handleAnimationEnd);
        node.removeEventListener("animationend", handleAnimationEnd);
      };
    } else {
      send("ANIMATION_END");
    }
  }, [node, send]);
  return {
    isPresent: ["mounted", "unmountSuspended"].includes(state),
    ref: reactExports.useCallback((node2) => {
      stylesRef.current = node2 ? getComputedStyle(node2) : null;
      setNode(node2);
    }, [])
  };
}
function getAnimationName(styles) {
  return styles?.animationName || "none";
}
function getElementRef$4(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
var useInsertionEffect = React$1[" useInsertionEffect ".trim().toString()] || useLayoutEffect2;
function useControllableState({
  prop,
  defaultProp,
  onChange = () => {
  },
  caller
}) {
  const [uncontrolledProp, setUncontrolledProp, onChangeRef] = useUncontrolledState({
    defaultProp,
    onChange
  });
  const isControlled = prop !== void 0;
  const value = isControlled ? prop : uncontrolledProp;
  {
    const isControlledRef = reactExports.useRef(prop !== void 0);
    reactExports.useEffect(() => {
      const wasControlled = isControlledRef.current;
      if (wasControlled !== isControlled) {
        const from = wasControlled ? "controlled" : "uncontrolled";
        const to2 = isControlled ? "controlled" : "uncontrolled";
        console.warn(
          `${caller} is changing from ${from} to ${to2}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
        );
      }
      isControlledRef.current = isControlled;
    }, [isControlled, caller]);
  }
  const setValue = reactExports.useCallback(
    (nextValue) => {
      if (isControlled) {
        const value2 = isFunction$1(nextValue) ? nextValue(prop) : nextValue;
        if (value2 !== prop) {
          onChangeRef.current?.(value2);
        }
      } else {
        setUncontrolledProp(nextValue);
      }
    },
    [isControlled, prop, setUncontrolledProp, onChangeRef]
  );
  return [value, setValue];
}
function useUncontrolledState({
  defaultProp,
  onChange
}) {
  const [value, setValue] = reactExports.useState(defaultProp);
  const prevValueRef = reactExports.useRef(value);
  const onChangeRef = reactExports.useRef(onChange);
  useInsertionEffect(() => {
    onChangeRef.current = onChange;
  }, [onChange]);
  reactExports.useEffect(() => {
    if (prevValueRef.current !== value) {
      onChangeRef.current?.(value);
      prevValueRef.current = value;
    }
  }, [value, prevValueRef]);
  return [value, setValue, onChangeRef];
}
function isFunction$1(value) {
  return typeof value === "function";
}
var VISUALLY_HIDDEN_STYLES = Object.freeze({
  // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
  position: "absolute",
  border: 0,
  width: 1,
  height: 1,
  padding: 0,
  margin: -1,
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  wordWrap: "normal"
});
var NAME$2 = "VisuallyHidden";
var VisuallyHidden = reactExports.forwardRef(
  (props, forwardedRef) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive$1.span,
      {
        ...props,
        ref: forwardedRef,
        style: { ...VISUALLY_HIDDEN_STYLES, ...props.style }
      }
    );
  }
);
VisuallyHidden.displayName = NAME$2;
var Root$5 = VisuallyHidden;
var PROVIDER_NAME$1 = "ToastProvider";
var [Collection$2, useCollection$2, createCollectionScope$2] = createCollection("Toast");
var [createToastContext] = createContextScope("Toast", [createCollectionScope$2]);
var [ToastProviderProvider, useToastProviderContext] = createToastContext(PROVIDER_NAME$1);
var ToastProvider$1 = (props) => {
  const {
    __scopeToast,
    label = "Notification",
    duration: duration2 = 5e3,
    swipeDirection = "right",
    swipeThreshold = 50,
    children
  } = props;
  const [viewport, setViewport] = reactExports.useState(null);
  const [toastCount, setToastCount] = reactExports.useState(0);
  const isFocusedToastEscapeKeyDownRef = reactExports.useRef(false);
  const isClosePausedRef = reactExports.useRef(false);
  if (!label.trim()) {
    console.error(
      `Invalid prop \`label\` supplied to \`${PROVIDER_NAME$1}\`. Expected non-empty \`string\`.`
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$2.Provider, { scope: __scopeToast, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    ToastProviderProvider,
    {
      scope: __scopeToast,
      label,
      duration: duration2,
      swipeDirection,
      swipeThreshold,
      toastCount,
      viewport,
      onViewportChange: setViewport,
      onToastAdd: reactExports.useCallback(() => setToastCount((prevCount) => prevCount + 1), []),
      onToastRemove: reactExports.useCallback(() => setToastCount((prevCount) => prevCount - 1), []),
      isFocusedToastEscapeKeyDownRef,
      isClosePausedRef,
      children
    }
  ) });
};
ToastProvider$1.displayName = PROVIDER_NAME$1;
var VIEWPORT_NAME$1 = "ToastViewport";
var VIEWPORT_DEFAULT_HOTKEY = ["F8"];
var VIEWPORT_PAUSE = "toast.viewportPause";
var VIEWPORT_RESUME = "toast.viewportResume";
var ToastViewport$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeToast,
      hotkey = VIEWPORT_DEFAULT_HOTKEY,
      label = "Notifications ({hotkey})",
      ...viewportProps
    } = props;
    const context = useToastProviderContext(VIEWPORT_NAME$1, __scopeToast);
    const getItems = useCollection$2(__scopeToast);
    const wrapperRef = reactExports.useRef(null);
    const headFocusProxyRef = reactExports.useRef(null);
    const tailFocusProxyRef = reactExports.useRef(null);
    const ref2 = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref2, context.onViewportChange);
    const hotkeyLabel = hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
    const hasToasts = context.toastCount > 0;
    reactExports.useEffect(() => {
      const handleKeyDown = (event) => {
        const isHotkeyPressed = hotkey.length !== 0 && hotkey.every((key) => event[key] || event.code === key);
        if (isHotkeyPressed) ref2.current?.focus();
      };
      document.addEventListener("keydown", handleKeyDown);
      return () => document.removeEventListener("keydown", handleKeyDown);
    }, [hotkey]);
    reactExports.useEffect(() => {
      const wrapper = wrapperRef.current;
      const viewport = ref2.current;
      if (hasToasts && wrapper && viewport) {
        const handlePause = () => {
          if (!context.isClosePausedRef.current) {
            const pauseEvent = new CustomEvent(VIEWPORT_PAUSE);
            viewport.dispatchEvent(pauseEvent);
            context.isClosePausedRef.current = true;
          }
        };
        const handleResume = () => {
          if (context.isClosePausedRef.current) {
            const resumeEvent = new CustomEvent(VIEWPORT_RESUME);
            viewport.dispatchEvent(resumeEvent);
            context.isClosePausedRef.current = false;
          }
        };
        const handleFocusOutResume = (event) => {
          const isFocusMovingOutside = !wrapper.contains(event.relatedTarget);
          if (isFocusMovingOutside) handleResume();
        };
        const handlePointerLeaveResume = () => {
          const isFocusInside = wrapper.contains(document.activeElement);
          if (!isFocusInside) handleResume();
        };
        wrapper.addEventListener("focusin", handlePause);
        wrapper.addEventListener("focusout", handleFocusOutResume);
        wrapper.addEventListener("pointermove", handlePause);
        wrapper.addEventListener("pointerleave", handlePointerLeaveResume);
        window.addEventListener("blur", handlePause);
        window.addEventListener("focus", handleResume);
        return () => {
          wrapper.removeEventListener("focusin", handlePause);
          wrapper.removeEventListener("focusout", handleFocusOutResume);
          wrapper.removeEventListener("pointermove", handlePause);
          wrapper.removeEventListener("pointerleave", handlePointerLeaveResume);
          window.removeEventListener("blur", handlePause);
          window.removeEventListener("focus", handleResume);
        };
      }
    }, [hasToasts, context.isClosePausedRef]);
    const getSortedTabbableCandidates = reactExports.useCallback(
      ({ tabbingDirection }) => {
        const toastItems = getItems();
        const tabbableCandidates = toastItems.map((toastItem) => {
          const toastNode = toastItem.ref.current;
          const toastTabbableCandidates = [toastNode, ...getTabbableCandidates$1(toastNode)];
          return tabbingDirection === "forwards" ? toastTabbableCandidates : toastTabbableCandidates.reverse();
        });
        return (tabbingDirection === "forwards" ? tabbableCandidates.reverse() : tabbableCandidates).flat();
      },
      [getItems]
    );
    reactExports.useEffect(() => {
      const viewport = ref2.current;
      if (viewport) {
        const handleKeyDown = (event) => {
          const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;
          const isTabKey = event.key === "Tab" && !isMetaKey;
          if (isTabKey) {
            const focusedElement = document.activeElement;
            const isTabbingBackwards = event.shiftKey;
            const targetIsViewport = event.target === viewport;
            if (targetIsViewport && isTabbingBackwards) {
              headFocusProxyRef.current?.focus();
              return;
            }
            const tabbingDirection = isTabbingBackwards ? "backwards" : "forwards";
            const sortedCandidates = getSortedTabbableCandidates({ tabbingDirection });
            const index2 = sortedCandidates.findIndex((candidate) => candidate === focusedElement);
            if (focusFirst$2(sortedCandidates.slice(index2 + 1))) {
              event.preventDefault();
            } else {
              isTabbingBackwards ? headFocusProxyRef.current?.focus() : tailFocusProxyRef.current?.focus();
            }
          }
        };
        viewport.addEventListener("keydown", handleKeyDown);
        return () => viewport.removeEventListener("keydown", handleKeyDown);
      }
    }, [getItems, getSortedTabbableCandidates]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Branch,
      {
        ref: wrapperRef,
        role: "region",
        "aria-label": label.replace("{hotkey}", hotkeyLabel),
        tabIndex: -1,
        style: { pointerEvents: hasToasts ? void 0 : "none" },
        children: [
          hasToasts && /* @__PURE__ */ jsxRuntimeExports.jsx(
            FocusProxy,
            {
              ref: headFocusProxyRef,
              onFocusFromOutsideViewport: () => {
                const tabbableCandidates = getSortedTabbableCandidates({
                  tabbingDirection: "forwards"
                });
                focusFirst$2(tabbableCandidates);
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$2.Slot, { scope: __scopeToast, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive$1.ol, { tabIndex: -1, ...viewportProps, ref: composedRefs }) }),
          hasToasts && /* @__PURE__ */ jsxRuntimeExports.jsx(
            FocusProxy,
            {
              ref: tailFocusProxyRef,
              onFocusFromOutsideViewport: () => {
                const tabbableCandidates = getSortedTabbableCandidates({
                  tabbingDirection: "backwards"
                });
                focusFirst$2(tabbableCandidates);
              }
            }
          )
        ]
      }
    );
  }
);
ToastViewport$1.displayName = VIEWPORT_NAME$1;
var FOCUS_PROXY_NAME = "ToastFocusProxy";
var FocusProxy = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, onFocusFromOutsideViewport, ...proxyProps } = props;
    const context = useToastProviderContext(FOCUS_PROXY_NAME, __scopeToast);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      VisuallyHidden,
      {
        tabIndex: 0,
        ...proxyProps,
        ref: forwardedRef,
        style: { position: "fixed" },
        onFocus: (event) => {
          const prevFocusedElement = event.relatedTarget;
          const isFocusFromOutsideViewport = !context.viewport?.contains(prevFocusedElement);
          if (isFocusFromOutsideViewport) onFocusFromOutsideViewport();
        }
      }
    );
  }
);
FocusProxy.displayName = FOCUS_PROXY_NAME;
var TOAST_NAME = "Toast";
var TOAST_SWIPE_START = "toast.swipeStart";
var TOAST_SWIPE_MOVE = "toast.swipeMove";
var TOAST_SWIPE_CANCEL = "toast.swipeCancel";
var TOAST_SWIPE_END = "toast.swipeEnd";
var Toast$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { forceMount, open: openProp, defaultOpen, onOpenChange, ...toastProps } = props;
    const [open, setOpen] = useControllableState({
      prop: openProp,
      defaultProp: defaultOpen ?? true,
      onChange: onOpenChange,
      caller: TOAST_NAME
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      ToastImpl,
      {
        open,
        ...toastProps,
        ref: forwardedRef,
        onClose: () => setOpen(false),
        onPause: useCallbackRef$1(props.onPause),
        onResume: useCallbackRef$1(props.onResume),
        onSwipeStart: composeEventHandlers(props.onSwipeStart, (event) => {
          event.currentTarget.setAttribute("data-swipe", "start");
        }),
        onSwipeMove: composeEventHandlers(props.onSwipeMove, (event) => {
          const { x: x2, y: y2 } = event.detail.delta;
          event.currentTarget.setAttribute("data-swipe", "move");
          event.currentTarget.style.setProperty("--radix-toast-swipe-move-x", `${x2}px`);
          event.currentTarget.style.setProperty("--radix-toast-swipe-move-y", `${y2}px`);
        }),
        onSwipeCancel: composeEventHandlers(props.onSwipeCancel, (event) => {
          event.currentTarget.setAttribute("data-swipe", "cancel");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-x");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-y");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-end-x");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-end-y");
        }),
        onSwipeEnd: composeEventHandlers(props.onSwipeEnd, (event) => {
          const { x: x2, y: y2 } = event.detail.delta;
          event.currentTarget.setAttribute("data-swipe", "end");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-x");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-y");
          event.currentTarget.style.setProperty("--radix-toast-swipe-end-x", `${x2}px`);
          event.currentTarget.style.setProperty("--radix-toast-swipe-end-y", `${y2}px`);
          setOpen(false);
        })
      }
    ) });
  }
);
Toast$1.displayName = TOAST_NAME;
var [ToastInteractiveProvider, useToastInteractiveContext] = createToastContext(TOAST_NAME, {
  onClose() {
  }
});
var ToastImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeToast,
      type: type2 = "foreground",
      duration: durationProp,
      open,
      onClose,
      onEscapeKeyDown,
      onPause,
      onResume,
      onSwipeStart,
      onSwipeMove,
      onSwipeCancel,
      onSwipeEnd,
      ...toastProps
    } = props;
    const context = useToastProviderContext(TOAST_NAME, __scopeToast);
    const [node, setNode] = reactExports.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode(node2));
    const pointerStartRef = reactExports.useRef(null);
    const swipeDeltaRef = reactExports.useRef(null);
    const duration2 = durationProp || context.duration;
    const closeTimerStartTimeRef = reactExports.useRef(0);
    const closeTimerRemainingTimeRef = reactExports.useRef(duration2);
    const closeTimerRef = reactExports.useRef(0);
    const { onToastAdd, onToastRemove } = context;
    const handleClose = useCallbackRef$1(() => {
      const isFocusInToast = node?.contains(document.activeElement);
      if (isFocusInToast) context.viewport?.focus();
      onClose();
    });
    const startTimer = reactExports.useCallback(
      (duration22) => {
        if (!duration22 || duration22 === Infinity) return;
        window.clearTimeout(closeTimerRef.current);
        closeTimerStartTimeRef.current = (/* @__PURE__ */ new Date()).getTime();
        closeTimerRef.current = window.setTimeout(handleClose, duration22);
      },
      [handleClose]
    );
    reactExports.useEffect(() => {
      const viewport = context.viewport;
      if (viewport) {
        const handleResume = () => {
          startTimer(closeTimerRemainingTimeRef.current);
          onResume?.();
        };
        const handlePause = () => {
          const elapsedTime = (/* @__PURE__ */ new Date()).getTime() - closeTimerStartTimeRef.current;
          closeTimerRemainingTimeRef.current = closeTimerRemainingTimeRef.current - elapsedTime;
          window.clearTimeout(closeTimerRef.current);
          onPause?.();
        };
        viewport.addEventListener(VIEWPORT_PAUSE, handlePause);
        viewport.addEventListener(VIEWPORT_RESUME, handleResume);
        return () => {
          viewport.removeEventListener(VIEWPORT_PAUSE, handlePause);
          viewport.removeEventListener(VIEWPORT_RESUME, handleResume);
        };
      }
    }, [context.viewport, duration2, onPause, onResume, startTimer]);
    reactExports.useEffect(() => {
      if (open && !context.isClosePausedRef.current) startTimer(duration2);
    }, [open, duration2, context.isClosePausedRef, startTimer]);
    reactExports.useEffect(() => {
      onToastAdd();
      return () => onToastRemove();
    }, [onToastAdd, onToastRemove]);
    const announceTextContent = reactExports.useMemo(() => {
      return node ? getAnnounceTextContent(node) : null;
    }, [node]);
    if (!context.viewport) return null;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      announceTextContent && /* @__PURE__ */ jsxRuntimeExports.jsx(
        ToastAnnounce,
        {
          __scopeToast,
          role: "status",
          "aria-live": type2 === "foreground" ? "assertive" : "polite",
          children: announceTextContent
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ToastInteractiveProvider, { scope: __scopeToast, onClose: handleClose, children: reactDomExports.createPortal(
        /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$2.ItemSlot, { scope: __scopeToast, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Root$6,
          {
            asChild: true,
            onEscapeKeyDown: composeEventHandlers(onEscapeKeyDown, () => {
              if (!context.isFocusedToastEscapeKeyDownRef.current) handleClose();
              context.isFocusedToastEscapeKeyDownRef.current = false;
            }),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Primitive$1.li,
              {
                tabIndex: 0,
                "data-state": open ? "open" : "closed",
                "data-swipe-direction": context.swipeDirection,
                ...toastProps,
                ref: composedRefs,
                style: { userSelect: "none", touchAction: "none", ...props.style },
                onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
                  if (event.key !== "Escape") return;
                  onEscapeKeyDown?.(event.nativeEvent);
                  if (!event.nativeEvent.defaultPrevented) {
                    context.isFocusedToastEscapeKeyDownRef.current = true;
                    handleClose();
                  }
                }),
                onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
                  if (event.button !== 0) return;
                  pointerStartRef.current = { x: event.clientX, y: event.clientY };
                }),
                onPointerMove: composeEventHandlers(props.onPointerMove, (event) => {
                  if (!pointerStartRef.current) return;
                  const x2 = event.clientX - pointerStartRef.current.x;
                  const y2 = event.clientY - pointerStartRef.current.y;
                  const hasSwipeMoveStarted = Boolean(swipeDeltaRef.current);
                  const isHorizontalSwipe = ["left", "right"].includes(context.swipeDirection);
                  const clamp2 = ["left", "up"].includes(context.swipeDirection) ? Math.min : Math.max;
                  const clampedX = isHorizontalSwipe ? clamp2(0, x2) : 0;
                  const clampedY = !isHorizontalSwipe ? clamp2(0, y2) : 0;
                  const moveStartBuffer = event.pointerType === "touch" ? 10 : 2;
                  const delta = { x: clampedX, y: clampedY };
                  const eventDetail = { originalEvent: event, delta };
                  if (hasSwipeMoveStarted) {
                    swipeDeltaRef.current = delta;
                    handleAndDispatchCustomEvent(TOAST_SWIPE_MOVE, onSwipeMove, eventDetail, {
                      discrete: false
                    });
                  } else if (isDeltaInDirection(delta, context.swipeDirection, moveStartBuffer)) {
                    swipeDeltaRef.current = delta;
                    handleAndDispatchCustomEvent(TOAST_SWIPE_START, onSwipeStart, eventDetail, {
                      discrete: false
                    });
                    event.target.setPointerCapture(event.pointerId);
                  } else if (Math.abs(x2) > moveStartBuffer || Math.abs(y2) > moveStartBuffer) {
                    pointerStartRef.current = null;
                  }
                }),
                onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
                  const delta = swipeDeltaRef.current;
                  const target = event.target;
                  if (target.hasPointerCapture(event.pointerId)) {
                    target.releasePointerCapture(event.pointerId);
                  }
                  swipeDeltaRef.current = null;
                  pointerStartRef.current = null;
                  if (delta) {
                    const toast2 = event.currentTarget;
                    const eventDetail = { originalEvent: event, delta };
                    if (isDeltaInDirection(delta, context.swipeDirection, context.swipeThreshold)) {
                      handleAndDispatchCustomEvent(TOAST_SWIPE_END, onSwipeEnd, eventDetail, {
                        discrete: true
                      });
                    } else {
                      handleAndDispatchCustomEvent(
                        TOAST_SWIPE_CANCEL,
                        onSwipeCancel,
                        eventDetail,
                        {
                          discrete: true
                        }
                      );
                    }
                    toast2.addEventListener("click", (event2) => event2.preventDefault(), {
                      once: true
                    });
                  }
                })
              }
            )
          }
        ) }),
        context.viewport
      ) })
    ] });
  }
);
var ToastAnnounce = (props) => {
  const { __scopeToast, children, ...announceProps } = props;
  const context = useToastProviderContext(TOAST_NAME, __scopeToast);
  const [renderAnnounceText, setRenderAnnounceText] = reactExports.useState(false);
  const [isAnnounced, setIsAnnounced] = reactExports.useState(false);
  useNextFrame(() => setRenderAnnounceText(true));
  reactExports.useEffect(() => {
    const timer = window.setTimeout(() => setIsAnnounced(true), 1e3);
    return () => window.clearTimeout(timer);
  }, []);
  return isAnnounced ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$3, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(VisuallyHidden, { ...announceProps, children: renderAnnounceText && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    context.label,
    " ",
    children
  ] }) }) });
};
var TITLE_NAME$1 = "ToastTitle";
var ToastTitle$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, ...titleProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive$1.div, { ...titleProps, ref: forwardedRef });
  }
);
ToastTitle$1.displayName = TITLE_NAME$1;
var DESCRIPTION_NAME$1 = "ToastDescription";
var ToastDescription$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, ...descriptionProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive$1.div, { ...descriptionProps, ref: forwardedRef });
  }
);
ToastDescription$1.displayName = DESCRIPTION_NAME$1;
var ACTION_NAME = "ToastAction";
var ToastAction$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { altText, ...actionProps } = props;
    if (!altText.trim()) {
      console.error(
        `Invalid prop \`altText\` supplied to \`${ACTION_NAME}\`. Expected non-empty \`string\`.`
      );
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ToastAnnounceExclude, { altText, asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ToastClose$1, { ...actionProps, ref: forwardedRef }) });
  }
);
ToastAction$1.displayName = ACTION_NAME;
var CLOSE_NAME$2 = "ToastClose";
var ToastClose$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, ...closeProps } = props;
    const interactiveContext = useToastInteractiveContext(CLOSE_NAME$2, __scopeToast);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ToastAnnounceExclude, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive$1.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, interactiveContext.onClose)
      }
    ) });
  }
);
ToastClose$1.displayName = CLOSE_NAME$2;
var ToastAnnounceExclude = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeToast, altText, ...announceExcludeProps } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive$1.div,
    {
      "data-radix-toast-announce-exclude": "",
      "data-radix-toast-announce-alt": altText || void 0,
      ...announceExcludeProps,
      ref: forwardedRef
    }
  );
});
function getAnnounceTextContent(container) {
  const textContent = [];
  const childNodes = Array.from(container.childNodes);
  childNodes.forEach((node) => {
    if (node.nodeType === node.TEXT_NODE && node.textContent) textContent.push(node.textContent);
    if (isHTMLElement$1(node)) {
      const isHidden2 = node.ariaHidden || node.hidden || node.style.display === "none";
      const isExcluded = node.dataset.radixToastAnnounceExclude === "";
      if (!isHidden2) {
        if (isExcluded) {
          const altText = node.dataset.radixToastAnnounceAlt;
          if (altText) textContent.push(altText);
        } else {
          textContent.push(...getAnnounceTextContent(node));
        }
      }
    }
  });
  return textContent;
}
function handleAndDispatchCustomEvent(name2, handler, detail, { discrete }) {
  const currentTarget = detail.originalEvent.currentTarget;
  const event = new CustomEvent(name2, { bubbles: true, cancelable: true, detail });
  if (handler) currentTarget.addEventListener(name2, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(currentTarget, event);
  } else {
    currentTarget.dispatchEvent(event);
  }
}
var isDeltaInDirection = (delta, direction, threshold = 0) => {
  const deltaX = Math.abs(delta.x);
  const deltaY = Math.abs(delta.y);
  const isDeltaX = deltaX > deltaY;
  if (direction === "left" || direction === "right") {
    return isDeltaX && deltaX > threshold;
  } else {
    return !isDeltaX && deltaY > threshold;
  }
};
function useNextFrame(callback = () => {
}) {
  const fn2 = useCallbackRef$1(callback);
  useLayoutEffect2(() => {
    let raf1 = 0;
    let raf2 = 0;
    raf1 = window.requestAnimationFrame(() => raf2 = window.requestAnimationFrame(fn2));
    return () => {
      window.cancelAnimationFrame(raf1);
      window.cancelAnimationFrame(raf2);
    };
  }, [fn2]);
}
function isHTMLElement$1(node) {
  return node.nodeType === node.ELEMENT_NODE;
}
function getTabbableCandidates$1(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function focusFirst$2(candidates) {
  const previouslyFocusedElement = document.activeElement;
  return candidates.some((candidate) => {
    if (candidate === previouslyFocusedElement) return true;
    candidate.focus();
    return document.activeElement !== previouslyFocusedElement;
  });
}
var Provider$1 = ToastProvider$1;
var Viewport$1 = ToastViewport$1;
var Root2$4 = Toast$1;
var Title$1 = ToastTitle$1;
var Description$1 = ToastDescription$1;
var Action = ToastAction$1;
var Close$1 = ToastClose$1;
function r(e) {
  var t, f2, n = "";
  if ("string" == typeof e || "number" == typeof e) n += e;
  else if ("object" == typeof e) if (Array.isArray(e)) {
    var o = e.length;
    for (t = 0; t < o; t++) e[t] && (f2 = r(e[t])) && (n && (n += " "), n += f2);
  } else for (f2 in e) e[f2] && (n && (n += " "), n += f2);
  return n;
}
function clsx() {
  for (var e, t, f2 = 0, n = "", o = arguments.length; f2 < o; f2++) (e = arguments[f2]) && (t = r(e)) && (n && (n += " "), n += t);
  return n;
}
const falsyToString = (value) => typeof value === "boolean" ? `${value}` : value === 0 ? "0" : value;
const cx = clsx;
const cva = (base, config2) => (props) => {
  var _config_compoundVariants;
  if ((config2 === null || config2 === void 0 ? void 0 : config2.variants) == null) return cx(base, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);
  const { variants, defaultVariants } = config2;
  const getVariantClassNames = Object.keys(variants).map((variant) => {
    const variantProp = props === null || props === void 0 ? void 0 : props[variant];
    const defaultVariantProp = defaultVariants === null || defaultVariants === void 0 ? void 0 : defaultVariants[variant];
    if (variantProp === null) return null;
    const variantKey = falsyToString(variantProp) || falsyToString(defaultVariantProp);
    return variants[variant][variantKey];
  });
  const propsWithoutUndefined = props && Object.entries(props).reduce((acc, param) => {
    let [key, value] = param;
    if (value === void 0) {
      return acc;
    }
    acc[key] = value;
    return acc;
  }, {});
  const getCompoundVariantClassNames = config2 === null || config2 === void 0 ? void 0 : (_config_compoundVariants = config2.compoundVariants) === null || _config_compoundVariants === void 0 ? void 0 : _config_compoundVariants.reduce((acc, param) => {
    let { class: cvClass, className: cvClassName, ...compoundVariantOptions } = param;
    return Object.entries(compoundVariantOptions).every((param2) => {
      let [key, value] = param2;
      return Array.isArray(value) ? value.includes({
        ...defaultVariants,
        ...propsWithoutUndefined
      }[key]) : {
        ...defaultVariants,
        ...propsWithoutUndefined
      }[key] === value;
    }) ? [
      ...acc,
      cvClass,
      cvClassName
    ] : acc;
  }, []);
  return cx(base, getVariantClassNames, getCompoundVariantClassNames, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);
};
const CLASS_PART_SEPARATOR = "-";
const createClassGroupUtils = (config2) => {
  const classMap = createClassMap(config2);
  const {
    conflictingClassGroups,
    conflictingClassGroupModifiers
  } = config2;
  const getClassGroupId = (className) => {
    const classParts = className.split(CLASS_PART_SEPARATOR);
    if (classParts[0] === "" && classParts.length !== 1) {
      classParts.shift();
    }
    return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);
  };
  const getConflictingClassGroupIds = (classGroupId, hasPostfixModifier) => {
    const conflicts = conflictingClassGroups[classGroupId] || [];
    if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {
      return [...conflicts, ...conflictingClassGroupModifiers[classGroupId]];
    }
    return conflicts;
  };
  return {
    getClassGroupId,
    getConflictingClassGroupIds
  };
};
const getGroupRecursive = (classParts, classPartObject) => {
  if (classParts.length === 0) {
    return classPartObject.classGroupId;
  }
  const currentClassPart = classParts[0];
  const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
  const classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : void 0;
  if (classGroupFromNextClassPart) {
    return classGroupFromNextClassPart;
  }
  if (classPartObject.validators.length === 0) {
    return void 0;
  }
  const classRest = classParts.join(CLASS_PART_SEPARATOR);
  return classPartObject.validators.find(({
    validator
  }) => validator(classRest))?.classGroupId;
};
const arbitraryPropertyRegex = /^\[(.+)\]$/;
const getGroupIdForArbitraryProperty = (className) => {
  if (arbitraryPropertyRegex.test(className)) {
    const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];
    const property = arbitraryPropertyClassName?.substring(0, arbitraryPropertyClassName.indexOf(":"));
    if (property) {
      return "arbitrary.." + property;
    }
  }
};
const createClassMap = (config2) => {
  const {
    theme,
    prefix
  } = config2;
  const classMap = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  const prefixedClassGroupEntries = getPrefixedClassGroupEntries(Object.entries(config2.classGroups), prefix);
  prefixedClassGroupEntries.forEach(([classGroupId, classGroup]) => {
    processClassesRecursively(classGroup, classMap, classGroupId, theme);
  });
  return classMap;
};
const processClassesRecursively = (classGroup, classPartObject, classGroupId, theme) => {
  classGroup.forEach((classDefinition) => {
    if (typeof classDefinition === "string") {
      const classPartObjectToEdit = classDefinition === "" ? classPartObject : getPart(classPartObject, classDefinition);
      classPartObjectToEdit.classGroupId = classGroupId;
      return;
    }
    if (typeof classDefinition === "function") {
      if (isThemeGetter(classDefinition)) {
        processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);
        return;
      }
      classPartObject.validators.push({
        validator: classDefinition,
        classGroupId
      });
      return;
    }
    Object.entries(classDefinition).forEach(([key, classGroup2]) => {
      processClassesRecursively(classGroup2, getPart(classPartObject, key), classGroupId, theme);
    });
  });
};
const getPart = (classPartObject, path) => {
  let currentClassPartObject = classPartObject;
  path.split(CLASS_PART_SEPARATOR).forEach((pathPart) => {
    if (!currentClassPartObject.nextPart.has(pathPart)) {
      currentClassPartObject.nextPart.set(pathPart, {
        nextPart: /* @__PURE__ */ new Map(),
        validators: []
      });
    }
    currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
  });
  return currentClassPartObject;
};
const isThemeGetter = (func) => func.isThemeGetter;
const getPrefixedClassGroupEntries = (classGroupEntries, prefix) => {
  if (!prefix) {
    return classGroupEntries;
  }
  return classGroupEntries.map(([classGroupId, classGroup]) => {
    const prefixedClassGroup = classGroup.map((classDefinition) => {
      if (typeof classDefinition === "string") {
        return prefix + classDefinition;
      }
      if (typeof classDefinition === "object") {
        return Object.fromEntries(Object.entries(classDefinition).map(([key, value]) => [prefix + key, value]));
      }
      return classDefinition;
    });
    return [classGroupId, prefixedClassGroup];
  });
};
const createLruCache = (maxCacheSize) => {
  if (maxCacheSize < 1) {
    return {
      get: () => void 0,
      set: () => {
      }
    };
  }
  let cacheSize = 0;
  let cache2 = /* @__PURE__ */ new Map();
  let previousCache = /* @__PURE__ */ new Map();
  const update = (key, value) => {
    cache2.set(key, value);
    cacheSize++;
    if (cacheSize > maxCacheSize) {
      cacheSize = 0;
      previousCache = cache2;
      cache2 = /* @__PURE__ */ new Map();
    }
  };
  return {
    get(key) {
      let value = cache2.get(key);
      if (value !== void 0) {
        return value;
      }
      if ((value = previousCache.get(key)) !== void 0) {
        update(key, value);
        return value;
      }
    },
    set(key, value) {
      if (cache2.has(key)) {
        cache2.set(key, value);
      } else {
        update(key, value);
      }
    }
  };
};
const IMPORTANT_MODIFIER = "!";
const createParseClassName = (config2) => {
  const {
    separator,
    experimentalParseClassName
  } = config2;
  const isSeparatorSingleCharacter = separator.length === 1;
  const firstSeparatorCharacter = separator[0];
  const separatorLength = separator.length;
  const parseClassName = (className) => {
    const modifiers = [];
    let bracketDepth = 0;
    let modifierStart = 0;
    let postfixModifierPosition;
    for (let index2 = 0; index2 < className.length; index2++) {
      let currentCharacter = className[index2];
      if (bracketDepth === 0) {
        if (currentCharacter === firstSeparatorCharacter && (isSeparatorSingleCharacter || className.slice(index2, index2 + separatorLength) === separator)) {
          modifiers.push(className.slice(modifierStart, index2));
          modifierStart = index2 + separatorLength;
          continue;
        }
        if (currentCharacter === "/") {
          postfixModifierPosition = index2;
          continue;
        }
      }
      if (currentCharacter === "[") {
        bracketDepth++;
      } else if (currentCharacter === "]") {
        bracketDepth--;
      }
    }
    const baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);
    const hasImportantModifier = baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER);
    const baseClassName = hasImportantModifier ? baseClassNameWithImportantModifier.substring(1) : baseClassNameWithImportantModifier;
    const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : void 0;
    return {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    };
  };
  if (experimentalParseClassName) {
    return (className) => experimentalParseClassName({
      className,
      parseClassName
    });
  }
  return parseClassName;
};
const sortModifiers = (modifiers) => {
  if (modifiers.length <= 1) {
    return modifiers;
  }
  const sortedModifiers = [];
  let unsortedModifiers = [];
  modifiers.forEach((modifier) => {
    const isArbitraryVariant = modifier[0] === "[";
    if (isArbitraryVariant) {
      sortedModifiers.push(...unsortedModifiers.sort(), modifier);
      unsortedModifiers = [];
    } else {
      unsortedModifiers.push(modifier);
    }
  });
  sortedModifiers.push(...unsortedModifiers.sort());
  return sortedModifiers;
};
const createConfigUtils = (config2) => ({
  cache: createLruCache(config2.cacheSize),
  parseClassName: createParseClassName(config2),
  ...createClassGroupUtils(config2)
});
const SPLIT_CLASSES_REGEX = /\s+/;
const mergeClassList = (classList, configUtils) => {
  const {
    parseClassName,
    getClassGroupId,
    getConflictingClassGroupIds
  } = configUtils;
  const classGroupsInConflict = [];
  const classNames = classList.trim().split(SPLIT_CLASSES_REGEX);
  let result = "";
  for (let index2 = classNames.length - 1; index2 >= 0; index2 -= 1) {
    const originalClassName = classNames[index2];
    const {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    } = parseClassName(originalClassName);
    let hasPostfixModifier = Boolean(maybePostfixModifierPosition);
    let classGroupId = getClassGroupId(hasPostfixModifier ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
    if (!classGroupId) {
      if (!hasPostfixModifier) {
        result = originalClassName + (result.length > 0 ? " " + result : result);
        continue;
      }
      classGroupId = getClassGroupId(baseClassName);
      if (!classGroupId) {
        result = originalClassName + (result.length > 0 ? " " + result : result);
        continue;
      }
      hasPostfixModifier = false;
    }
    const variantModifier = sortModifiers(modifiers).join(":");
    const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
    const classId = modifierId + classGroupId;
    if (classGroupsInConflict.includes(classId)) {
      continue;
    }
    classGroupsInConflict.push(classId);
    const conflictGroups = getConflictingClassGroupIds(classGroupId, hasPostfixModifier);
    for (let i = 0; i < conflictGroups.length; ++i) {
      const group = conflictGroups[i];
      classGroupsInConflict.push(modifierId + group);
    }
    result = originalClassName + (result.length > 0 ? " " + result : result);
  }
  return result;
};
function twJoin() {
  let index2 = 0;
  let argument;
  let resolvedValue;
  let string2 = "";
  while (index2 < arguments.length) {
    if (argument = arguments[index2++]) {
      if (resolvedValue = toValue(argument)) {
        string2 && (string2 += " ");
        string2 += resolvedValue;
      }
    }
  }
  return string2;
}
const toValue = (mix) => {
  if (typeof mix === "string") {
    return mix;
  }
  let resolvedValue;
  let string2 = "";
  for (let k2 = 0; k2 < mix.length; k2++) {
    if (mix[k2]) {
      if (resolvedValue = toValue(mix[k2])) {
        string2 && (string2 += " ");
        string2 += resolvedValue;
      }
    }
  }
  return string2;
};
function createTailwindMerge(createConfigFirst, ...createConfigRest) {
  let configUtils;
  let cacheGet;
  let cacheSet;
  let functionToCall = initTailwindMerge;
  function initTailwindMerge(classList) {
    const config2 = createConfigRest.reduce((previousConfig, createConfigCurrent) => createConfigCurrent(previousConfig), createConfigFirst());
    configUtils = createConfigUtils(config2);
    cacheGet = configUtils.cache.get;
    cacheSet = configUtils.cache.set;
    functionToCall = tailwindMerge;
    return tailwindMerge(classList);
  }
  function tailwindMerge(classList) {
    const cachedResult = cacheGet(classList);
    if (cachedResult) {
      return cachedResult;
    }
    const result = mergeClassList(classList, configUtils);
    cacheSet(classList, result);
    return result;
  }
  return function callTailwindMerge() {
    return functionToCall(twJoin.apply(null, arguments));
  };
}
const fromTheme = (key) => {
  const themeGetter = (theme) => theme[key] || [];
  themeGetter.isThemeGetter = true;
  return themeGetter;
};
const arbitraryValueRegex = /^\[(?:([a-z-]+):)?(.+)\]$/i;
const fractionRegex = /^\d+\/\d+$/;
const stringLengths = /* @__PURE__ */ new Set(["px", "full", "screen"]);
const tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
const lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
const colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch)|color-mix)\(.+\)$/;
const shadowRegex = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
const imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
const isLength = (value) => isNumber(value) || stringLengths.has(value) || fractionRegex.test(value);
const isArbitraryLength = (value) => getIsArbitraryValue(value, "length", isLengthOnly);
const isNumber = (value) => Boolean(value) && !Number.isNaN(Number(value));
const isArbitraryNumber = (value) => getIsArbitraryValue(value, "number", isNumber);
const isInteger = (value) => Boolean(value) && Number.isInteger(Number(value));
const isPercent = (value) => value.endsWith("%") && isNumber(value.slice(0, -1));
const isArbitraryValue = (value) => arbitraryValueRegex.test(value);
const isTshirtSize = (value) => tshirtUnitRegex.test(value);
const sizeLabels = /* @__PURE__ */ new Set(["length", "size", "percentage"]);
const isArbitrarySize = (value) => getIsArbitraryValue(value, sizeLabels, isNever);
const isArbitraryPosition = (value) => getIsArbitraryValue(value, "position", isNever);
const imageLabels = /* @__PURE__ */ new Set(["image", "url"]);
const isArbitraryImage = (value) => getIsArbitraryValue(value, imageLabels, isImage);
const isArbitraryShadow = (value) => getIsArbitraryValue(value, "", isShadow);
const isAny = () => true;
const getIsArbitraryValue = (value, label, testValue) => {
  const result = arbitraryValueRegex.exec(value);
  if (result) {
    if (result[1]) {
      return typeof label === "string" ? result[1] === label : label.has(result[1]);
    }
    return testValue(result[2]);
  }
  return false;
};
const isLengthOnly = (value) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  lengthUnitRegex.test(value) && !colorFunctionRegex.test(value)
);
const isNever = () => false;
const isShadow = (value) => shadowRegex.test(value);
const isImage = (value) => imageRegex.test(value);
const getDefaultConfig = () => {
  const colors = fromTheme("colors");
  const spacing = fromTheme("spacing");
  const blur = fromTheme("blur");
  const brightness = fromTheme("brightness");
  const borderColor = fromTheme("borderColor");
  const borderRadius = fromTheme("borderRadius");
  const borderSpacing = fromTheme("borderSpacing");
  const borderWidth = fromTheme("borderWidth");
  const contrast = fromTheme("contrast");
  const grayscale = fromTheme("grayscale");
  const hueRotate = fromTheme("hueRotate");
  const invert = fromTheme("invert");
  const gap = fromTheme("gap");
  const gradientColorStops = fromTheme("gradientColorStops");
  const gradientColorStopPositions = fromTheme("gradientColorStopPositions");
  const inset = fromTheme("inset");
  const margin = fromTheme("margin");
  const opacity = fromTheme("opacity");
  const padding = fromTheme("padding");
  const saturate = fromTheme("saturate");
  const scale = fromTheme("scale");
  const sepia = fromTheme("sepia");
  const skew = fromTheme("skew");
  const space = fromTheme("space");
  const translate = fromTheme("translate");
  const getOverscroll = () => ["auto", "contain", "none"];
  const getOverflow = () => ["auto", "hidden", "clip", "visible", "scroll"];
  const getSpacingWithAutoAndArbitrary = () => ["auto", isArbitraryValue, spacing];
  const getSpacingWithArbitrary = () => [isArbitraryValue, spacing];
  const getLengthWithEmptyAndArbitrary = () => ["", isLength, isArbitraryLength];
  const getNumberWithAutoAndArbitrary = () => ["auto", isNumber, isArbitraryValue];
  const getPositions = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"];
  const getLineStyles = () => ["solid", "dashed", "dotted", "double", "none"];
  const getBlendModes = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"];
  const getAlign = () => ["start", "end", "center", "between", "around", "evenly", "stretch"];
  const getZeroAndEmpty = () => ["", "0", isArbitraryValue];
  const getBreaks = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"];
  const getNumberAndArbitrary = () => [isNumber, isArbitraryValue];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [isAny],
      spacing: [isLength, isArbitraryLength],
      blur: ["none", "", isTshirtSize, isArbitraryValue],
      brightness: getNumberAndArbitrary(),
      borderColor: [colors],
      borderRadius: ["none", "", "full", isTshirtSize, isArbitraryValue],
      borderSpacing: getSpacingWithArbitrary(),
      borderWidth: getLengthWithEmptyAndArbitrary(),
      contrast: getNumberAndArbitrary(),
      grayscale: getZeroAndEmpty(),
      hueRotate: getNumberAndArbitrary(),
      invert: getZeroAndEmpty(),
      gap: getSpacingWithArbitrary(),
      gradientColorStops: [colors],
      gradientColorStopPositions: [isPercent, isArbitraryLength],
      inset: getSpacingWithAutoAndArbitrary(),
      margin: getSpacingWithAutoAndArbitrary(),
      opacity: getNumberAndArbitrary(),
      padding: getSpacingWithArbitrary(),
      saturate: getNumberAndArbitrary(),
      scale: getNumberAndArbitrary(),
      sepia: getZeroAndEmpty(),
      skew: getNumberAndArbitrary(),
      space: getSpacingWithArbitrary(),
      translate: getSpacingWithArbitrary()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", isArbitraryValue]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [isTshirtSize]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": getBreaks()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": getBreaks()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...getPositions(), isArbitraryValue]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: getOverflow()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": getOverflow()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": getOverflow()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: getOverscroll()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": getOverscroll()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": getOverscroll()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [inset]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [inset]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [inset]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [inset]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [inset]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [inset]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [inset]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [inset]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [inset]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", isInteger, isArbitraryValue]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: getSpacingWithAutoAndArbitrary()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", isArbitraryValue]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: getZeroAndEmpty()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: getZeroAndEmpty()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", isInteger, isArbitraryValue]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [isAny]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", isInteger, isArbitraryValue]
        }, isArbitraryValue]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [isAny]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [isInteger, isArbitraryValue]
        }, isArbitraryValue]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", isArbitraryValue]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", isArbitraryValue]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [gap]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [gap]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [gap]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...getAlign()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...getAlign(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...getAlign(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [padding]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [padding]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [padding]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [padding]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [padding]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [padding]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [padding]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [padding]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [padding]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [margin]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [margin]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [margin]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [margin]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [margin]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [margin]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [margin]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [margin]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [margin]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [space]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [space]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", isArbitraryValue, spacing]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [isArbitraryValue, spacing, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [isArbitraryValue, spacing, "none", "full", "min", "max", "fit", "prose", {
          screen: [isTshirtSize]
        }, isTshirtSize]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [isArbitraryValue, spacing, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [isArbitraryValue, spacing, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [isArbitraryValue, spacing, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [isArbitraryValue, spacing, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", isTshirtSize, isArbitraryLength]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", isArbitraryNumber]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [isAny]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", isArbitraryValue]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", isNumber, isArbitraryNumber]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", isLength, isArbitraryValue]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", isArbitraryValue]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", isArbitraryValue]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [colors]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [opacity]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [colors]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [opacity]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...getLineStyles(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", isLength, isArbitraryLength]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", isLength, isArbitraryValue]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [colors]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: getSpacingWithArbitrary()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", isArbitraryValue]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", isArbitraryValue]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [opacity]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...getPositions(), isArbitraryPosition]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", isArbitrarySize]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, isArbitraryImage]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [colors]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [gradientColorStops]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [gradientColorStops]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [gradientColorStops]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [borderRadius]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [borderRadius]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [borderRadius]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [borderRadius]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [borderRadius]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [borderRadius]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [borderRadius]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [borderRadius]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [borderRadius]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [borderRadius]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [borderRadius]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [borderRadius]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [borderRadius]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [borderRadius]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [borderRadius]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [borderWidth]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [borderWidth]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [borderWidth]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [borderWidth]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [borderWidth]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [borderWidth]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [borderWidth]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [borderWidth]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [borderWidth]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [opacity]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...getLineStyles(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [borderWidth]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [borderWidth]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [opacity]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: getLineStyles()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [borderColor]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [borderColor]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [borderColor]
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": [borderColor]
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": [borderColor]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [borderColor]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [borderColor]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [borderColor]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [borderColor]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [borderColor]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...getLineStyles()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [isLength, isArbitraryValue]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [isLength, isArbitraryLength]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [colors]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: getLengthWithEmptyAndArbitrary()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [colors]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [opacity]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [isLength, isArbitraryLength]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [colors]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", isTshirtSize, isArbitraryShadow]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [isAny]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [opacity]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...getBlendModes(), "plus-lighter", "plus-darker"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": getBlendModes()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [blur]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [brightness]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [contrast]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", isTshirtSize, isArbitraryValue]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [grayscale]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [hueRotate]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [invert]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [saturate]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [sepia]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [blur]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [brightness]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [contrast]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [grayscale]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [hueRotate]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [invert]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [opacity]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [saturate]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [sepia]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [borderSpacing]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [borderSpacing]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [borderSpacing]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", isArbitraryValue]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: getNumberAndArbitrary()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", isArbitraryValue]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: getNumberAndArbitrary()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", isArbitraryValue]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [scale]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [scale]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [scale]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [isInteger, isArbitraryValue]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [translate]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [translate]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [skew]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [skew]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", isArbitraryValue]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", colors]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", isArbitraryValue]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [colors]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", isArbitraryValue]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [colors, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [isLength, isArbitraryLength, isArbitraryNumber]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [colors, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
};
const twMerge = /* @__PURE__ */ createTailwindMerge(getDefaultConfig);
function cn$2(...inputs) {
  return twMerge(clsx(inputs));
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var _excluded$Q = ["color"];
var CaretSortIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$Q);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M4.93179 5.43179C4.75605 5.60753 4.75605 5.89245 4.93179 6.06819C5.10753 6.24392 5.39245 6.24392 5.56819 6.06819L7.49999 4.13638L9.43179 6.06819C9.60753 6.24392 9.89245 6.24392 10.0682 6.06819C10.2439 5.89245 10.2439 5.60753 10.0682 5.43179L7.81819 3.18179C7.73379 3.0974 7.61933 3.04999 7.49999 3.04999C7.38064 3.04999 7.26618 3.0974 7.18179 3.18179L4.93179 5.43179ZM10.0682 9.56819C10.2439 9.39245 10.2439 9.10753 10.0682 8.93179C9.89245 8.75606 9.60753 8.75606 9.43179 8.93179L7.49999 10.8636L5.56819 8.93179C5.39245 8.75606 5.10753 8.75606 4.93179 8.93179C4.75605 9.10753 4.75605 9.39245 4.93179 9.56819L7.18179 11.8182C7.35753 11.9939 7.64245 11.9939 7.81819 11.8182L10.0682 9.56819Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$T = ["color"];
var CheckIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$T);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M11.4669 3.72684C11.7558 3.91574 11.8369 4.30308 11.648 4.59198L7.39799 11.092C7.29783 11.2452 7.13556 11.3467 6.95402 11.3699C6.77247 11.3931 6.58989 11.3355 6.45446 11.2124L3.70446 8.71241C3.44905 8.48022 3.43023 8.08494 3.66242 7.82953C3.89461 7.57412 4.28989 7.55529 4.5453 7.78749L6.75292 9.79441L10.6018 3.90792C10.7907 3.61902 11.178 3.53795 11.4669 3.72684Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$W = ["color"];
var ChevronDownIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$W);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M3.13523 6.15803C3.3241 5.95657 3.64052 5.94637 3.84197 6.13523L7.5 9.56464L11.158 6.13523C11.3595 5.94637 11.6759 5.95657 11.8648 6.15803C12.0536 6.35949 12.0434 6.67591 11.842 6.86477L7.84197 10.6148C7.64964 10.7951 7.35036 10.7951 7.15803 10.6148L3.15803 6.86477C2.95657 6.67591 2.94637 6.35949 3.13523 6.15803Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$Z = ["color"];
var ChevronUpIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$Z);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M3.13523 8.84197C3.3241 9.04343 3.64052 9.05363 3.84197 8.86477L7.5 5.43536L11.158 8.86477C11.3595 9.05363 11.6759 9.04343 11.8648 8.84197C12.0536 8.64051 12.0434 8.32409 11.842 8.13523L7.84197 4.38523C7.64964 4.20492 7.35036 4.20492 7.15803 4.38523L3.15803 8.13523C2.95657 8.32409 2.94637 8.64051 3.13523 8.84197Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$1r = ["color"];
var Cross2Icon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$1r);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M11.7816 4.03157C12.0062 3.80702 12.0062 3.44295 11.7816 3.2184C11.5571 2.99385 11.193 2.99385 10.9685 3.2184L7.50005 6.68682L4.03164 3.2184C3.80708 2.99385 3.44301 2.99385 3.21846 3.2184C2.99391 3.44295 2.99391 3.80702 3.21846 4.03157L6.68688 7.49999L3.21846 10.9684C2.99391 11.193 2.99391 11.557 3.21846 11.7816C3.44301 12.0061 3.80708 12.0061 4.03164 11.7816L7.50005 8.31316L10.9685 11.7816C11.193 12.0061 11.5571 12.0061 11.7816 11.7816C12.0062 11.557 12.0062 11.193 11.7816 10.9684L8.31322 7.49999L11.7816 4.03157Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$33 = ["color"];
var MagnifyingGlassIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$33);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M10 6.5C10 8.433 8.433 10 6.5 10C4.567 10 3 8.433 3 6.5C3 4.567 4.567 3 6.5 3C8.433 3 10 4.567 10 6.5ZM9.30884 10.0159C8.53901 10.6318 7.56251 11 6.5 11C4.01472 11 2 8.98528 2 6.5C2 4.01472 4.01472 2 6.5 2C8.98528 2 11 4.01472 11 6.5C11 7.56251 10.6318 8.53901 10.0159 9.30884L12.8536 12.1464C13.0488 12.3417 13.0488 12.6583 12.8536 12.8536C12.6583 13.0488 12.3417 13.0488 12.1464 12.8536L9.30884 10.0159Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
const ToastProvider = Provider$1;
const ToastViewport = reactExports.forwardRef(({ className, ...props }, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Viewport$1,
  {
    ref: ref2,
    className: cn$2(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    ),
    ...props
  }
));
ToastViewport.displayName = Viewport$1.displayName;
const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-2 overflow-hidden rounded-md border p-4 pr-6 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive: "destructive group border-destructive bg-destructive text-destructive-foreground"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
);
const Toast = reactExports.forwardRef(({ className, variant, ...props }, ref2) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Root2$4,
    {
      ref: ref2,
      className: cn$2(toastVariants({ variant }), className),
      ...props
    }
  );
});
Toast.displayName = Root2$4.displayName;
const ToastAction = reactExports.forwardRef(({ className, ...props }, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Action,
  {
    ref: ref2,
    className: cn$2(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium transition-colors hover:bg-secondary focus:outline-none focus:ring-1 focus:ring-ring disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    ),
    ...props
  }
));
ToastAction.displayName = Action.displayName;
const ToastClose = reactExports.forwardRef(({ className, ...props }, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Close$1,
  {
    ref: ref2,
    className: cn$2(
      "absolute right-1 top-1 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-1 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    ),
    "toast-close": "",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Cross2Icon, { className: "h-4 w-4" })
  }
));
ToastClose.displayName = Close$1.displayName;
const ToastTitle = reactExports.forwardRef(({ className, ...props }, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Title$1,
  {
    ref: ref2,
    className: cn$2("text-sm font-semibold [&+div]:text-xs", className),
    ...props
  }
));
ToastTitle.displayName = Title$1.displayName;
const ToastDescription = reactExports.forwardRef(({ className, ...props }, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Description$1,
  {
    ref: ref2,
    className: cn$2("text-sm opacity-90", className),
    ...props
  }
));
ToastDescription.displayName = Description$1.displayName;
function Toaster() {
  const { toasts } = useToast();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ToastProvider, { children: [
    toasts.map(function({ id: id2, title: title2, description: description2, action, ...props }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Toast, { ...props, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid gap-1", children: [
          title2 && /* @__PURE__ */ jsxRuntimeExports.jsx(ToastTitle, { children: title2 }),
          description2 && /* @__PURE__ */ jsxRuntimeExports.jsx(ToastDescription, { children: description2 })
        ] }),
        action,
        /* @__PURE__ */ jsxRuntimeExports.jsx(ToastClose, {})
      ] }, id2);
    }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ToastViewport, {})
  ] });
}
const scriptRel = "modulepreload";
const assetsURL = function(dep) {
  return "/" + dep;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  let promise = Promise.resolve();
  if (deps && deps.length > 0) {
    let allSettled = function(promises$2) {
      return Promise.all(promises$2.map((p2) => Promise.resolve(p2).then((value$1) => ({
        status: "fulfilled",
        value: value$1
      }), (reason) => ({
        status: "rejected",
        reason
      }))));
    };
    document.getElementsByTagName("link");
    const cspNonceMeta = document.querySelector("meta[property=csp-nonce]");
    const cspNonce = cspNonceMeta?.nonce || cspNonceMeta?.getAttribute("nonce");
    promise = allSettled(deps.map((dep) => {
      dep = assetsURL(dep);
      if (dep in seen) return;
      seen[dep] = true;
      const isCss = dep.endsWith(".css");
      const cssSelector = isCss ? '[rel="stylesheet"]' : "";
      if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) return;
      const link = document.createElement("link");
      link.rel = isCss ? "stylesheet" : scriptRel;
      if (!isCss) link.as = "script";
      link.crossOrigin = "";
      link.href = dep;
      if (cspNonce) link.setAttribute("nonce", cspNonce);
      document.head.appendChild(link);
      if (isCss) return new Promise((res, rej) => {
        link.addEventListener("load", res);
        link.addEventListener("error", () => rej(/* @__PURE__ */ new Error(`Unable to preload CSS for ${dep}`)));
      });
    }));
  }
  function handlePreloadError(err$2) {
    const e$1 = new Event("vite:preloadError", { cancelable: true });
    e$1.payload = err$2;
    window.dispatchEvent(e$1);
    if (!e$1.defaultPrevented) throw err$2;
  }
  return promise.then((res) => {
    for (const item of res || []) {
      if (item.status !== "rejected") continue;
      handlePreloadError(item.reason);
    }
    return baseModule().catch(handlePreloadError);
  });
};
const NEVER = Object.freeze({
  status: "aborted"
});
function $constructor(name2, initializer2, params) {
  function init(inst, def) {
    var _a2;
    Object.defineProperty(inst, "_zod", {
      value: inst._zod ?? {},
      enumerable: false
    });
    (_a2 = inst._zod).traits ?? (_a2.traits = /* @__PURE__ */ new Set());
    inst._zod.traits.add(name2);
    initializer2(inst, def);
    for (const k2 in _2.prototype) {
      if (!(k2 in inst))
        Object.defineProperty(inst, k2, { value: _2.prototype[k2].bind(inst) });
    }
    inst._zod.constr = _2;
    inst._zod.def = def;
  }
  const Parent = params?.Parent ?? Object;
  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name2 });
  function _2(def) {
    var _a2;
    const inst = params?.Parent ? new Definition() : this;
    init(inst, def);
    (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
    for (const fn2 of inst._zod.deferred) {
      fn2();
    }
    return inst;
  }
  Object.defineProperty(_2, "init", { value: init });
  Object.defineProperty(_2, Symbol.hasInstance, {
    value: (inst) => {
      if (params?.Parent && inst instanceof params.Parent)
        return true;
      return inst?._zod?.traits?.has(name2);
    }
  });
  Object.defineProperty(_2, "name", { value: name2 });
  return _2;
}
class $ZodAsyncError extends Error {
  constructor() {
    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
  }
}
const globalConfig = {};
function config(newConfig) {
  return globalConfig;
}
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter((v) => typeof v === "number");
  const values = Object.entries(entries).filter(([k2, _2]) => numericValues.indexOf(+k2) === -1).map(([_2, v]) => v);
  return values;
}
function jsonStringifyReplacer(_2, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached(getter) {
  return {
    get value() {
      {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
    }
  };
}
function nullish(input) {
  return input === null || input === void 0;
}
function cleanRegex(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder$1(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
function defineLazy(object2, key, getter) {
  Object.defineProperty(object2, key, {
    get() {
      {
        const value = getter();
        object2[key] = value;
        return value;
      }
    },
    set(v) {
      Object.defineProperty(object2, key, {
        value: v
        // configurable: true,
      });
    },
    configurable: true
  });
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function esc(str) {
  return JSON.stringify(str);
}
const captureStackTrace = Error.captureStackTrace ? Error.captureStackTrace : (..._args) => {
};
function isObject(data2) {
  return typeof data2 === "object" && data2 !== null && !Array.isArray(data2);
}
const allowsEval = cached(() => {
  if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
    return false;
  }
  try {
    const F2 = Function;
    new F2("");
    return true;
  } catch (_2) {
    return false;
  }
});
function isPlainObject$1(o) {
  if (isObject(o) === false)
    return false;
  const ctor = o.constructor;
  if (ctor === void 0)
    return true;
  const prot = ctor.prototype;
  if (isObject(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
const propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
  const cl2 = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent)
    cl2._zod.parent = inst;
  return cl2;
}
function normalizeParams(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if (params?.message !== void 0) {
    if (params?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter((k2) => {
    return shape[k2]._zod.optin === "optional" && shape[k2]._zod.optout === "optional";
  });
}
const NUMBER_FORMAT_RANGES = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
function pick(schema, mask) {
  const newShape = {};
  const currDef = schema._zod.def;
  for (const key in mask) {
    if (!(key in currDef.shape)) {
      throw new Error(`Unrecognized key: "${key}"`);
    }
    if (!mask[key])
      continue;
    newShape[key] = currDef.shape[key];
  }
  return clone(schema, {
    ...schema._zod.def,
    shape: newShape,
    checks: []
  });
}
function omit(schema, mask) {
  const newShape = { ...schema._zod.def.shape };
  const currDef = schema._zod.def;
  for (const key in mask) {
    if (!(key in currDef.shape)) {
      throw new Error(`Unrecognized key: "${key}"`);
    }
    if (!mask[key])
      continue;
    delete newShape[key];
  }
  return clone(schema, {
    ...schema._zod.def,
    shape: newShape,
    checks: []
  });
}
function extend(schema, shape) {
  if (!isPlainObject$1(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const def = {
    ...schema._zod.def,
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    checks: []
    // delete existing checks
  };
  return clone(schema, def);
}
function merge(a2, b) {
  return clone(a2, {
    ...a2._zod.def,
    get shape() {
      const _shape = { ...a2._zod.def.shape, ...b._zod.def.shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    catchall: b._zod.def.catchall,
    checks: []
    // delete existing checks
  });
}
function partial(Class, schema, mask) {
  const oldShape = schema._zod.def.shape;
  const shape = { ...oldShape };
  if (mask) {
    for (const key in mask) {
      if (!(key in oldShape)) {
        throw new Error(`Unrecognized key: "${key}"`);
      }
      if (!mask[key])
        continue;
      shape[key] = Class ? new Class({
        type: "optional",
        innerType: oldShape[key]
      }) : oldShape[key];
    }
  } else {
    for (const key in oldShape) {
      shape[key] = Class ? new Class({
        type: "optional",
        innerType: oldShape[key]
      }) : oldShape[key];
    }
  }
  return clone(schema, {
    ...schema._zod.def,
    shape,
    checks: []
  });
}
function required$6(Class, schema, mask) {
  const oldShape = schema._zod.def.shape;
  const shape = { ...oldShape };
  if (mask) {
    for (const key in mask) {
      if (!(key in shape)) {
        throw new Error(`Unrecognized key: "${key}"`);
      }
      if (!mask[key])
        continue;
      shape[key] = new Class({
        type: "nonoptional",
        innerType: oldShape[key]
      });
    }
  } else {
    for (const key in oldShape) {
      shape[key] = new Class({
        type: "nonoptional",
        innerType: oldShape[key]
      });
    }
  }
  return clone(schema, {
    ...schema._zod.def,
    shape,
    // optional: [],
    checks: []
  });
}
function aborted(x2, startIndex = 0) {
  for (let i = startIndex; i < x2.issues.length; i++) {
    if (x2.issues[i]?.continue !== true)
      return true;
  }
  return false;
}
function prefixIssues(path, issues) {
  return issues.map((iss) => {
    var _a2;
    (_a2 = iss).path ?? (_a2.path = []);
    iss.path.unshift(path);
    return iss;
  });
}
function unwrapMessage(message) {
  return typeof message === "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config2) {
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
function getLengthableOrigin(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function issue(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
const initializer$1 = (inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  Object.defineProperty(inst, "message", {
    get() {
      return JSON.stringify(def, jsonStringifyReplacer, 2);
    },
    enumerable: true
    // configurable: false,
  });
  Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: false
  });
};
const $ZodError = $constructor("$ZodError", initializer$1);
const $ZodRealError = $constructor("$ZodError", initializer$1, { Parent: Error });
function flattenError$1(error, mapper = (issue2) => issue2.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError(error, _mapper) {
  const mapper = _mapper || function(issue2) {
    return issue2.message;
  };
  const fieldErrors = { _errors: [] };
  const processError = (error2) => {
    for (const issue2 of error2.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues });
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues });
      } else if (issue2.path.length === 0) {
        fieldErrors._errors.push(mapper(issue2));
      } else {
        let curr = fieldErrors;
        let i = 0;
        while (i < issue2.path.length) {
          const el2 = issue2.path[i];
          const terminal = i === issue2.path.length - 1;
          if (!terminal) {
            curr[el2] = curr[el2] || { _errors: [] };
          } else {
            curr[el2] = curr[el2] || { _errors: [] };
            curr[el2]._errors.push(mapper(issue2));
          }
          curr = curr[el2];
          i++;
        }
      }
    }
  };
  processError(error);
  return fieldErrors;
}
const _parse = (_Err) => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  if (result.issues.length) {
    const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, _params?.callee);
    throw e;
  }
  return result.value;
};
const _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, params?.callee);
    throw e;
  }
  return result.value;
};
const _safeParse = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
const safeParse$2 = /* @__PURE__ */ _safeParse($ZodRealError);
const _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
const safeParseAsync$1 = /* @__PURE__ */ _safeParseAsync($ZodRealError);
const cuid = /^[cC][^\s-]{8,}$/;
const cuid2 = /^[0-9a-z]+$/;
const ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
const xid = /^[0-9a-vA-V]{20}$/;
const ksuid = /^[A-Za-z0-9]{27}$/;
const nanoid = /^[a-zA-Z0-9_-]{21}$/;
const duration$1 = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
const guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
const uuid = (version2) => {
  if (!version2)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version2}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
const email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
const _emoji$1 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji() {
  return new RegExp(_emoji$1, "u");
}
const ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/;
const cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
const cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
const base64url = /^[A-Za-z0-9_-]*$/;
const hostname = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/;
const e164 = /^\+(?:[0-9]){6,14}[0-9]$/;
const dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
const date$1 = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
function timeSource(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time$1(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime$1(args) {
  const time2 = timeSource({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-]\\d{2}:\\d{2})`);
  const timeRegex2 = `${time2}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex2})$`);
}
const string$1 = (params) => {
  const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
};
const integer = /^\d+$/;
const number$2 = /^-?\d+(?:\.\d+)?/i;
const boolean$1 = /true|false/i;
const _null$2 = /null/i;
const lowercase = /^[^A-Z]*$/;
const uppercase = /^[^a-z]*$/;
const $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
  var _a2;
  inst._zod ?? (inst._zod = {});
  inst._zod.def = def;
  (_a2 = inst._zod).onattach ?? (_a2.onattach = []);
});
const numericOriginMap = {
  number: "number",
  bigint: "bigint",
  object: "date"
};
const $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (def.value < curr) {
      if (def.inclusive)
        bag.maximum = def.value;
      else
        bag.exclusiveMaximum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (def.value > curr) {
      if (def.inclusive)
        bag.minimum = def.value;
      else
        bag.exclusiveMinimum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    var _a2;
    (_a2 = inst2._zod.bag).multipleOf ?? (_a2.multipleOf = def.value);
  });
  inst._zod.check = (payload) => {
    if (typeof payload.value !== typeof def.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder$1(payload.value, def.value) === 0;
    if (isMultiple)
      return;
    payload.issues.push({
      origin: typeof payload.value,
      code: "not_multiple_of",
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  def.format = def.format || "float64";
  const isInt = def.format?.includes("int");
  const origin = isInt ? "int" : "number";
  const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
    if (isInt)
      bag.pattern = integer;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (isInt) {
      if (!Number.isInteger(input)) {
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: "invalid_type",
          input,
          inst
        });
        return;
      }
      if (!Number.isSafeInteger(input)) {
        if (input > 0) {
          payload.issues.push({
            input,
            code: "too_big",
            maximum: Number.MAX_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        } else {
          payload.issues.push({
            input,
            code: "too_small",
            minimum: Number.MIN_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        }
        return;
      }
    }
    if (input < minimum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
const $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length <= def.maximum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length >= def.minimum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.length;
    bag.maximum = def.length;
    bag.length = def.length;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length === def.length)
      return;
    const origin = getLengthableOrigin(input);
    const tooBig = length > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
  var _a2, _b;
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    if (def.pattern) {
      bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
      bag.patterns.add(def.pattern);
    }
  });
  if (def.pattern)
    (_a2 = inst._zod).check ?? (_a2.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        ...def.pattern ? { pattern: def.pattern.toString() } : {},
        inst,
        continue: !def.abort
      });
    });
  else
    (_b = inst._zod).check ?? (_b.check = () => {
    });
});
const $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0;
    if (def.pattern.test(payload.value))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase);
  $ZodCheckStringFormat.init(inst, def);
});
const $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase);
  $ZodCheckStringFormat.init(inst, def);
});
const $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck.init(inst, def);
  const escapedRegex = escapeRegex(def.includes);
  const pattern2 = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern2;
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern2);
  });
  inst._zod.check = (payload) => {
    if (payload.value.includes(def.includes, def.position))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern2 = new RegExp(`^${escapeRegex(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern2);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern2);
  });
  inst._zod.check = (payload) => {
    if (payload.value.startsWith(def.prefix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern2 = new RegExp(`.*${escapeRegex(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern2);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern2);
  });
  inst._zod.check = (payload) => {
    if (payload.value.endsWith(def.suffix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});
class Doc {
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this)
      this.args = args;
  }
  indented(fn2) {
    this.indent += 1;
    fn2(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split("\n").filter((x2) => x2);
    const minIndent = Math.min(...lines.map((x2) => x2.length - x2.trimStart().length));
    const dedented = lines.map((x2) => x2.slice(minIndent)).map((x2) => " ".repeat(this.indent * 2) + x2);
    for (const line of dedented) {
      this.content.push(line);
    }
  }
  compile() {
    const F2 = Function;
    const args = this?.args;
    const content = this?.content ?? [``];
    const lines = [...content.map((x2) => `  ${x2}`)];
    return new F2(...args, lines.join("\n"));
  }
}
const version$2 = {
  major: 4,
  minor: 0,
  patch: 0
};
const $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
  var _a2;
  inst ?? (inst = {});
  inst._zod.def = def;
  inst._zod.bag = inst._zod.bag || {};
  inst._zod.version = version$2;
  const checks = [...inst._zod.def.checks ?? []];
  if (inst._zod.traits.has("$ZodCheck")) {
    checks.unshift(inst);
  }
  for (const ch2 of checks) {
    for (const fn2 of ch2._zod.onattach) {
      fn2(inst);
    }
  }
  if (checks.length === 0) {
    (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
    inst._zod.deferred?.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  } else {
    const runChecks = (payload, checks2, ctx) => {
      let isAborted2 = aborted(payload);
      let asyncResult;
      for (const ch2 of checks2) {
        if (ch2._zod.def.when) {
          const shouldRun = ch2._zod.def.when(payload);
          if (!shouldRun)
            continue;
        } else if (isAborted2) {
          continue;
        }
        const currLen = payload.issues.length;
        const _2 = ch2._zod.check(payload);
        if (_2 instanceof Promise && ctx?.async === false) {
          throw new $ZodAsyncError();
        }
        if (asyncResult || _2 instanceof Promise) {
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _2;
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              return;
            if (!isAborted2)
              isAborted2 = aborted(payload, currLen);
          });
        } else {
          const nextLen = payload.issues.length;
          if (nextLen === currLen)
            continue;
          if (!isAborted2)
            isAborted2 = aborted(payload, currLen);
        }
      }
      if (asyncResult) {
        return asyncResult.then(() => {
          return payload;
        });
      }
      return payload;
    };
    inst._zod.run = (payload, ctx) => {
      const result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError();
        return result.then((result2) => runChecks(result2, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  inst["~standard"] = {
    validate: (value) => {
      try {
        const r2 = safeParse$2(inst, value);
        return r2.success ? { value: r2.data } : { issues: r2.error?.issues };
      } catch (_2) {
        return safeParseAsync$1(inst, value).then((r2) => r2.success ? { value: r2.data } : { issues: r2.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  };
});
const $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string$1(inst._zod.bag);
  inst._zod.parse = (payload, _2) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch (_3) {
      }
    if (typeof payload.value === "string")
      return payload;
    payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
const $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  $ZodString.init(inst, def);
});
const $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid);
  $ZodStringFormat.init(inst, def);
});
const $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
  if (def.version) {
    const versionMap = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    };
    const v = versionMap[def.version];
    if (v === void 0)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid(v));
  } else
    def.pattern ?? (def.pattern = uuid());
  $ZodStringFormat.init(inst, def);
});
const $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email);
  $ZodStringFormat.init(inst, def);
});
const $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    try {
      const orig = payload.value;
      const url2 = new URL(orig);
      const href = url2.href;
      if (def.hostname) {
        def.hostname.lastIndex = 0;
        if (!def.hostname.test(url2.hostname)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid hostname",
            pattern: hostname.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.protocol) {
        def.protocol.lastIndex = 0;
        if (!def.protocol.test(url2.protocol.endsWith(":") ? url2.protocol.slice(0, -1) : url2.protocol)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid protocol",
            pattern: def.protocol.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (!orig.endsWith("/") && href.endsWith("/")) {
        payload.value = href.slice(0, -1);
      } else {
        payload.value = href;
      }
      return;
    } catch (_2) {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
const $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji());
  $ZodStringFormat.init(inst, def);
});
const $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid);
  $ZodStringFormat.init(inst, def);
});
const $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid);
  $ZodStringFormat.init(inst, def);
});
const $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid2);
  $ZodStringFormat.init(inst, def);
});
const $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid);
  $ZodStringFormat.init(inst, def);
});
const $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid);
  $ZodStringFormat.init(inst, def);
});
const $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid);
  $ZodStringFormat.init(inst, def);
});
const $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime$1(def));
  $ZodStringFormat.init(inst, def);
});
const $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date$1);
  $ZodStringFormat.init(inst, def);
});
const $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time$1(def));
  $ZodStringFormat.init(inst, def);
});
const $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration$1);
  $ZodStringFormat.init(inst, def);
});
const $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv4);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv4`;
  });
});
const $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv6`;
  });
  inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
const $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv4);
  $ZodStringFormat.init(inst, def);
});
const $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    const [address, prefix] = payload.value.split("/");
    try {
      if (!prefix)
        throw new Error();
      const prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix)
        throw new Error();
      if (prefixNum < 0 || prefixNum > 128)
        throw new Error();
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase64(data2) {
  if (data2 === "")
    return true;
  if (data2.length % 4 !== 0)
    return false;
  try {
    atob(data2);
    return true;
  } catch {
    return false;
  }
}
const $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base64);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL(data2) {
  if (!base64url.test(data2))
    return false;
  const base642 = data2.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
  const padded = base642.padEnd(Math.ceil(base642.length / 4) * 4, "=");
  return isValidBase64(padded);
}
const $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64url";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64URL(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e164);
  $ZodStringFormat.init(inst, def);
});
function isValidJWT$1(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
const $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (isValidJWT$1(payload.value, def.alg))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = inst._zod.bag.pattern ?? number$2;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Number(payload.value);
      } catch (_2) {
      }
    const input = payload.value;
    if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
      return payload;
    }
    const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
    payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...received ? { received } : {}
    });
    return payload;
  };
});
const $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodCheckNumberFormat.init(inst, def);
  $ZodNumber.init(inst, def);
});
const $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = boolean$1;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Boolean(payload.value);
      } catch (_2) {
      }
    const input = payload.value;
    if (typeof input === "boolean")
      return payload;
    payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
const $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _null$2;
  inst._zod.values = /* @__PURE__ */ new Set([null]);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input === null)
      return payload;
    payload.issues.push({
      expected: "null",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
const $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
const $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
const $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.issues.push({
      expected: "never",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
function handleArrayResult(result, final, index2) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index2, result.issues));
  }
  final.value[index2] = result.value;
}
const $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = Array(input.length);
    const proms = [];
    for (let i = 0; i < input.length; i++) {
      const item = input[i];
      const result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));
      } else {
        handleArrayResult(result, payload, i);
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
function handleObjectResult(result, final, key) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(key, result.issues));
  }
  final.value[key] = result.value;
}
function handleOptionalObjectResult(result, final, key, input) {
  if (result.issues.length) {
    if (input[key] === void 0) {
      if (key in input) {
        final.value[key] = void 0;
      } else {
        final.value[key] = result.value;
      }
    } else {
      final.issues.push(...prefixIssues(key, result.issues));
    }
  } else if (result.value === void 0) {
    if (key in input)
      final.value[key] = void 0;
  } else {
    final.value[key] = result.value;
  }
}
const $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
  $ZodType.init(inst, def);
  const _normalized = cached(() => {
    const keys = Object.keys(def.shape);
    for (const k2 of keys) {
      if (!(def.shape[k2] instanceof $ZodType)) {
        throw new Error(`Invalid element at key "${k2}": expected a Zod schema`);
      }
    }
    const okeys = optionalKeys(def.shape);
    return {
      shape: def.shape,
      keys,
      keySet: new Set(keys),
      numKeys: keys.length,
      optionalKeys: new Set(okeys)
    };
  });
  defineLazy(inst._zod, "propValues", () => {
    const shape = def.shape;
    const propValues = {};
    for (const key in shape) {
      const field = shape[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
        for (const v of field.values)
          propValues[key].add(v);
      }
    }
    return propValues;
  });
  const generateFastpass = (shape) => {
    const doc = new Doc(["shape", "payload", "ctx"]);
    const normalized = _normalized.value;
    const parseStr = (key) => {
      const k2 = esc(key);
      return `shape[${k2}]._zod.run({ value: input[${k2}], issues: [] }, ctx)`;
    };
    doc.write(`const input = payload.value;`);
    const ids = /* @__PURE__ */ Object.create(null);
    let counter = 0;
    for (const key of normalized.keys) {
      ids[key] = `key_${counter++}`;
    }
    doc.write(`const newResult = {}`);
    for (const key of normalized.keys) {
      if (normalized.optionalKeys.has(key)) {
        const id2 = ids[key];
        doc.write(`const ${id2} = ${parseStr(key)};`);
        const k2 = esc(key);
        doc.write(`
        if (${id2}.issues.length) {
          if (input[${k2}] === undefined) {
            if (${k2} in input) {
              newResult[${k2}] = undefined;
            }
          } else {
            payload.issues = payload.issues.concat(
              ${id2}.issues.map((iss) => ({
                ...iss,
                path: iss.path ? [${k2}, ...iss.path] : [${k2}],
              }))
            );
          }
        } else if (${id2}.value === undefined) {
          if (${k2} in input) newResult[${k2}] = undefined;
        } else {
          newResult[${k2}] = ${id2}.value;
        }
        `);
      } else {
        const id2 = ids[key];
        doc.write(`const ${id2} = ${parseStr(key)};`);
        doc.write(`
          if (${id2}.issues.length) payload.issues = payload.issues.concat(${id2}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${esc(key)}, ...iss.path] : [${esc(key)}]
          })));`);
        doc.write(`newResult[${esc(key)}] = ${id2}.value`);
      }
    }
    doc.write(`payload.value = newResult;`);
    doc.write(`return payload;`);
    const fn2 = doc.compile();
    return (payload, ctx) => fn2(shape, payload, ctx);
  };
  let fastpass;
  const isObject$1 = isObject;
  const jit = !globalConfig.jitless;
  const allowsEval$1 = allowsEval;
  const fastEnabled = jit && allowsEval$1.value;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject$1(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
      if (!fastpass)
        fastpass = generateFastpass(def.shape);
      payload = fastpass(payload, ctx);
    } else {
      payload.value = {};
      const shape = value.shape;
      for (const key of value.keys) {
        const el2 = shape[key];
        const r2 = el2._zod.run({ value: input[key], issues: [] }, ctx);
        const isOptional = el2._zod.optin === "optional" && el2._zod.optout === "optional";
        if (r2 instanceof Promise) {
          proms.push(r2.then((r3) => isOptional ? handleOptionalObjectResult(r3, payload, key, input) : handleObjectResult(r3, payload, key)));
        } else if (isOptional) {
          handleOptionalObjectResult(r2, payload, key, input);
        } else {
          handleObjectResult(r2, payload, key);
        }
      }
    }
    if (!catchall) {
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    }
    const unrecognized = [];
    const keySet = value.keySet;
    const _catchall = catchall._zod;
    const t = _catchall.def.type;
    for (const key of Object.keys(input)) {
      if (keySet.has(key))
        continue;
      if (t === "never") {
        unrecognized.push(key);
        continue;
      }
      const r2 = _catchall.run({ value: input[key], issues: [] }, ctx);
      if (r2 instanceof Promise) {
        proms.push(r2.then((r3) => handleObjectResult(r3, payload, key)));
      } else {
        handleObjectResult(r2, payload, key);
      }
    }
    if (unrecognized.length) {
      payload.issues.push({
        code: "unrecognized_keys",
        keys: unrecognized,
        input,
        inst
      });
    }
    if (!proms.length)
      return payload;
    return Promise.all(proms).then(() => {
      return payload;
    });
  };
});
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  });
  return final;
}
const $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "values", () => {
    if (def.options.every((o) => o._zod.values)) {
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
    }
    return void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    if (def.options.every((o) => o._zod.pattern)) {
      const patterns = def.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${patterns.map((p2) => cleanRegex(p2.source)).join("|")})$`);
    }
    return void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    let async2 = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async2 = true;
      } else {
        if (result.issues.length === 0)
          return result;
        results.push(result);
      }
    }
    if (!async2)
      return handleUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleUnionResults(results2, payload, inst, ctx);
    });
  };
});
const $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  const _super = inst._zod.parse;
  defineLazy(inst._zod, "propValues", () => {
    const propValues = {};
    for (const option of def.options) {
      const pv2 = option._zod.propValues;
      if (!pv2 || Object.keys(pv2).length === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
      for (const [k2, v] of Object.entries(pv2)) {
        if (!propValues[k2])
          propValues[k2] = /* @__PURE__ */ new Set();
        for (const val of v) {
          propValues[k2].add(val);
        }
      }
    }
    return propValues;
  });
  const disc = cached(() => {
    const opts = def.options;
    const map = /* @__PURE__ */ new Map();
    for (const o of opts) {
      const values = o._zod.propValues[def.discriminator];
      if (!values || values.size === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
      for (const v of values) {
        if (map.has(v)) {
          throw new Error(`Duplicate discriminator value "${String(v)}"`);
        }
        map.set(v, o);
      }
    }
    return map;
  });
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isObject(input)) {
      payload.issues.push({
        code: "invalid_type",
        expected: "object",
        input,
        inst
      });
      return payload;
    }
    const opt = disc.value.get(input?.[def.discriminator]);
    if (opt) {
      return opt._zod.run(payload, ctx);
    }
    if (def.unionFallback) {
      return _super(payload, ctx);
    }
    payload.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      input,
      path: [def.discriminator],
      inst
    });
    return payload;
  };
});
const $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    const left = def.left._zod.run({ value: input, issues: [] }, ctx);
    const right = def.right._zod.run({ value: input, issues: [] }, ctx);
    const async2 = left instanceof Promise || right instanceof Promise;
    if (async2) {
      return Promise.all([left, right]).then(([left2, right2]) => {
        return handleIntersectionResults(payload, left2, right2);
      });
    }
    return handleIntersectionResults(payload, left, right);
  };
});
function mergeValues$1(a2, b) {
  if (a2 === b) {
    return { valid: true, data: a2 };
  }
  if (a2 instanceof Date && b instanceof Date && +a2 === +b) {
    return { valid: true, data: a2 };
  }
  if (isPlainObject$1(a2) && isPlainObject$1(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a2).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a2, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues$1(a2[key], b[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a2) && Array.isArray(b)) {
    if (a2.length !== b.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index2 = 0; index2 < a2.length; index2++) {
      const itemA = a2[index2];
      const itemB = b[index2];
      const sharedValue = mergeValues$1(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index2, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  if (left.issues.length) {
    result.issues.push(...left.issues);
  }
  if (right.issues.length) {
    result.issues.push(...right.issues);
  }
  if (aborted(result))
    return result;
  const merged = mergeValues$1(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
const $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isPlainObject$1(input)) {
      payload.issues.push({
        expected: "record",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    if (def.keyType._zod.values) {
      const values = def.keyType._zod.values;
      payload.value = {};
      for (const key of values) {
        if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
          const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => {
              if (result2.issues.length) {
                payload.issues.push(...prefixIssues(key, result2.issues));
              }
              payload.value[key] = result2.value;
            }));
          } else {
            if (result.issues.length) {
              payload.issues.push(...prefixIssues(key, result.issues));
            }
            payload.value[key] = result.value;
          }
        }
      }
      let unrecognized;
      for (const key in input) {
        if (!values.has(key)) {
          unrecognized = unrecognized ?? [];
          unrecognized.push(key);
        }
      }
      if (unrecognized && unrecognized.length > 0) {
        payload.issues.push({
          code: "unrecognized_keys",
          input,
          inst,
          keys: unrecognized
        });
      }
    } else {
      payload.value = {};
      for (const key of Reflect.ownKeys(input)) {
        if (key === "__proto__")
          continue;
        const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        if (keyResult instanceof Promise) {
          throw new Error("Async schemas not supported in object keys currently");
        }
        if (keyResult.issues.length) {
          payload.issues.push({
            origin: "record",
            code: "invalid_key",
            issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
            input: key,
            path: [key],
            inst
          });
          payload.value[keyResult.value] = keyResult.value;
          continue;
        }
        const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => {
            if (result2.issues.length) {
              payload.issues.push(...prefixIssues(key, result2.issues));
            }
            payload.value[keyResult.value] = result2.value;
          }));
        } else {
          if (result.issues.length) {
            payload.issues.push(...prefixIssues(key, result.issues));
          }
          payload.value[keyResult.value] = result.value;
        }
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
const $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
  $ZodType.init(inst, def);
  const values = getEnumValues(def.entries);
  inst._zod.values = new Set(values);
  inst._zod.pattern = new RegExp(`^(${values.filter((k2) => propertyKeyTypes.has(typeof k2)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (inst._zod.values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values,
      input,
      inst
    });
    return payload;
  };
});
const $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.values = new Set(def.values);
  inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? o.toString() : String(o)).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (inst._zod.values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values: def.values,
      input,
      inst
    });
    return payload;
  };
});
const $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const _out = def.transform(payload.value, payload);
    if (_ctx.async) {
      const output = _out instanceof Promise ? _out : Promise.resolve(_out);
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    if (_out instanceof Promise) {
      throw new $ZodAsyncError();
    }
    payload.value = _out;
    return payload;
  };
});
const $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    const pattern2 = def.innerType._zod.pattern;
    return pattern2 ? new RegExp(`^(${cleanRegex(pattern2.source)})?$`) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      return payload;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
const $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "pattern", () => {
    const pattern2 = def.innerType._zod.pattern;
    return pattern2 ? new RegExp(`^(${cleanRegex(pattern2.source)}|null)$`) : void 0;
  });
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === null)
      return payload;
    return def.innerType._zod.run(payload, ctx);
  };
});
const $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
      return payload;
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleDefaultResult(result2, def));
    }
    return handleDefaultResult(result, def);
  };
});
function handleDefaultResult(payload, def) {
  if (payload.value === void 0) {
    payload.value = def.defaultValue;
  }
  return payload;
}
const $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
const $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => {
    const v = def.innerType._zod.values;
    return v ? new Set([...v].filter((x2) => x2 !== void 0)) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleNonOptionalResult(result2, inst));
    }
    return handleNonOptionalResult(result, inst);
  };
});
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === void 0) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
const $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.value;
        if (result2.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      });
    }
    payload.value = result.value;
    if (result.issues.length) {
      payload.value = def.catchValue({
        ...payload,
        error: {
          issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
        },
        input: payload.value
      });
      payload.issues = [];
    }
    return payload;
  };
});
const $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    const left = def.in._zod.run(payload, ctx);
    if (left instanceof Promise) {
      return left.then((left2) => handlePipeResult(left2, def, ctx));
    }
    return handlePipeResult(left, def, ctx);
  };
});
function handlePipeResult(left, def, ctx) {
  if (aborted(left)) {
    return left;
  }
  return def.out._zod.run({ value: left.value, issues: left.issues }, ctx);
}
const $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(handleReadonlyResult);
    }
    return handleReadonlyResult(result);
  };
});
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
const $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
  $ZodCheck.init(inst, def);
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _2) => {
    return payload;
  };
  inst._zod.check = (payload) => {
    const input = payload.value;
    const r2 = def.fn(input);
    if (r2 instanceof Promise) {
      return r2.then((r3) => handleRefineResult(r3, payload, input, inst));
    }
    handleRefineResult(r2, payload, input, inst);
    return;
  };
});
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      // incorporates params.error into issue reporting
      path: [...inst._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !inst._zod.def.abort
      // params: inst._zod.def.params,
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}
class $ZodRegistry {
  constructor() {
    this._map = /* @__PURE__ */ new Map();
    this._idmap = /* @__PURE__ */ new Map();
  }
  add(schema, ..._meta) {
    const meta = _meta[0];
    this._map.set(schema, meta);
    if (meta && typeof meta === "object" && "id" in meta) {
      if (this._idmap.has(meta.id)) {
        throw new Error(`ID ${meta.id} already exists in the registry`);
      }
      this._idmap.set(meta.id, schema);
    }
    return this;
  }
  clear() {
    this._map = /* @__PURE__ */ new Map();
    this._idmap = /* @__PURE__ */ new Map();
    return this;
  }
  remove(schema) {
    const meta = this._map.get(schema);
    if (meta && typeof meta === "object" && "id" in meta) {
      this._idmap.delete(meta.id);
    }
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    const p2 = schema._zod.parent;
    if (p2) {
      const pm2 = { ...this.get(p2) ?? {} };
      delete pm2.id;
      return { ...pm2, ...this._map.get(schema) };
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
}
function registry() {
  return new $ZodRegistry();
}
const globalRegistry = /* @__PURE__ */ registry();
function _string(Class, params) {
  return new Class({
    type: "string",
    ...normalizeParams(params)
  });
}
function _email(Class, params) {
  return new Class({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _guid(Class, params) {
  return new Class({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuid(Class, params) {
  return new Class({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuidv4(Class, params) {
  return new Class({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params)
  });
}
function _uuidv6(Class, params) {
  return new Class({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params)
  });
}
function _uuidv7(Class, params) {
  return new Class({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params)
  });
}
function _url$1(Class, params) {
  return new Class({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _emoji(Class, params) {
  return new Class({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _nanoid(Class, params) {
  return new Class({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid(Class, params) {
  return new Class({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid2(Class, params) {
  return new Class({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ulid(Class, params) {
  return new Class({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _xid(Class, params) {
  return new Class({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ksuid(Class, params) {
  return new Class({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv4(Class, params) {
  return new Class({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv6(Class, params) {
  return new Class({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv4(Class, params) {
  return new Class({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv6(Class, params) {
  return new Class({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64(Class, params) {
  return new Class({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64url(Class, params) {
  return new Class({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _e164(Class, params) {
  return new Class({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _jwt(Class, params) {
  return new Class({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _isoDateTime(Class, params) {
  return new Class({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDate(Class, params) {
  return new Class({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _isoTime(Class, params) {
  return new Class({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDuration(Class, params) {
  return new Class({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _number(Class, params) {
  return new Class({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
function _coercedNumber(Class, params) {
  return new Class({
    type: "number",
    coerce: true,
    checks: [],
    ...normalizeParams(params)
  });
}
function _int(Class, params) {
  return new Class({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams(params)
  });
}
function _boolean(Class, params) {
  return new Class({
    type: "boolean",
    ...normalizeParams(params)
  });
}
function _null$1(Class, params) {
  return new Class({
    type: "null",
    ...normalizeParams(params)
  });
}
function _any(Class) {
  return new Class({
    type: "any"
  });
}
function _unknown(Class) {
  return new Class({
    type: "unknown"
  });
}
function _never(Class, params) {
  return new Class({
    type: "never",
    ...normalizeParams(params)
  });
}
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
function _maxLength(maximum, params) {
  const ch2 = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
  return ch2;
}
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
function _regex(pattern2, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern: pattern2
  });
}
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
function _normalize(form) {
  return _overwrite((input) => input.normalize(form));
}
function _trim() {
  return _overwrite((input) => input.trim());
}
function _toLowerCase() {
  return _overwrite((input) => input.toLowerCase());
}
function _toUpperCase() {
  return _overwrite((input) => input.toUpperCase());
}
function _array(Class, element, params) {
  return new Class({
    type: "array",
    element,
    // get element() {
    //   return element;
    // },
    ...normalizeParams(params)
  });
}
function _custom(Class, fn2, _params) {
  const norm = normalizeParams(_params);
  norm.abort ?? (norm.abort = true);
  const schema = new Class({
    type: "custom",
    check: "custom",
    fn: fn2,
    ...norm
  });
  return schema;
}
function _refine(Class, fn2, _params) {
  const schema = new Class({
    type: "custom",
    check: "custom",
    fn: fn2,
    ...normalizeParams(_params)
  });
  return schema;
}
const ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
  $ZodISODateTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function datetime(params) {
  return _isoDateTime(ZodISODateTime, params);
}
const ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
  $ZodISODate.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function date(params) {
  return _isoDate(ZodISODate, params);
}
const ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function time(params) {
  return _isoTime(ZodISOTime, params);
}
const ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
  $ZodISODuration.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function duration(params) {
  return _isoDuration(ZodISODuration, params);
}
const initializer = (inst, issues) => {
  $ZodError.init(inst, issues);
  inst.name = "ZodError";
  Object.defineProperties(inst, {
    format: {
      value: (mapper) => formatError(inst, mapper)
      // enumerable: false,
    },
    flatten: {
      value: (mapper) => flattenError$1(inst, mapper)
      // enumerable: false,
    },
    addIssue: {
      value: (issue2) => inst.issues.push(issue2)
      // enumerable: false,
    },
    addIssues: {
      value: (issues2) => inst.issues.push(...issues2)
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
      // enumerable: false,
    }
  });
};
const ZodRealError = $constructor("ZodError", initializer, {
  Parent: Error
});
const parse$1 = /* @__PURE__ */ _parse(ZodRealError);
const parseAsync = /* @__PURE__ */ _parseAsync(ZodRealError);
const safeParse$1 = /* @__PURE__ */ _safeParse(ZodRealError);
const safeParseAsync = /* @__PURE__ */ _safeParseAsync(ZodRealError);
const ZodType$1 = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
  $ZodType.init(inst, def);
  inst.def = def;
  Object.defineProperty(inst, "_def", { value: def });
  inst.check = (...checks) => {
    return inst.clone(
      {
        ...def,
        checks: [
          ...def.checks ?? [],
          ...checks.map((ch2) => typeof ch2 === "function" ? { _zod: { check: ch2, def: { check: "custom" }, onattach: [] } } : ch2)
        ]
      }
      // { parent: true }
    );
  };
  inst.clone = (def2, params) => clone(inst, def2, params);
  inst.brand = () => inst;
  inst.register = ((reg, meta) => {
    reg.add(inst, meta);
    return inst;
  });
  inst.parse = (data2, params) => parse$1(inst, data2, params, { callee: inst.parse });
  inst.safeParse = (data2, params) => safeParse$1(inst, data2, params);
  inst.parseAsync = async (data2, params) => parseAsync(inst, data2, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data2, params) => safeParseAsync(inst, data2, params);
  inst.spa = inst.safeParseAsync;
  inst.refine = (check2, params) => inst.check(refine(check2, params));
  inst.superRefine = (refinement) => inst.check(superRefine(refinement));
  inst.overwrite = (fn2) => inst.check(_overwrite(fn2));
  inst.optional = () => optional(inst);
  inst.nullable = () => nullable(inst);
  inst.nullish = () => optional(nullable(inst));
  inst.nonoptional = (params) => nonoptional(inst, params);
  inst.array = () => array(inst);
  inst.or = (arg) => union([inst, arg]);
  inst.and = (arg) => intersection(inst, arg);
  inst.transform = (tx) => pipe(inst, transform(tx));
  inst.default = (def2) => _default(inst, def2);
  inst.prefault = (def2) => prefault(inst, def2);
  inst.catch = (params) => _catch(inst, params);
  inst.pipe = (target) => pipe(inst, target);
  inst.readonly = () => readonly(inst);
  inst.describe = (description2) => {
    const cl2 = inst.clone();
    globalRegistry.add(cl2, { description: description2 });
    return cl2;
  };
  Object.defineProperty(inst, "description", {
    get() {
      return globalRegistry.get(inst)?.description;
    },
    configurable: true
  });
  inst.meta = (...args) => {
    if (args.length === 0) {
      return globalRegistry.get(inst);
    }
    const cl2 = inst.clone();
    globalRegistry.add(cl2, args[0]);
    return cl2;
  };
  inst.isOptional = () => inst.safeParse(void 0).success;
  inst.isNullable = () => inst.safeParse(null).success;
  return inst;
});
const _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  ZodType$1.init(inst, def);
  const bag = inst._zod.bag;
  inst.format = bag.format ?? null;
  inst.minLength = bag.minimum ?? null;
  inst.maxLength = bag.maximum ?? null;
  inst.regex = (...args) => inst.check(_regex(...args));
  inst.includes = (...args) => inst.check(_includes(...args));
  inst.startsWith = (...args) => inst.check(_startsWith(...args));
  inst.endsWith = (...args) => inst.check(_endsWith(...args));
  inst.min = (...args) => inst.check(_minLength(...args));
  inst.max = (...args) => inst.check(_maxLength(...args));
  inst.length = (...args) => inst.check(_length(...args));
  inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
  inst.lowercase = (params) => inst.check(_lowercase(params));
  inst.uppercase = (params) => inst.check(_uppercase(params));
  inst.trim = () => inst.check(_trim());
  inst.normalize = (...args) => inst.check(_normalize(...args));
  inst.toLowerCase = () => inst.check(_toLowerCase());
  inst.toUpperCase = () => inst.check(_toUpperCase());
});
const ZodString$1 = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  _ZodString.init(inst, def);
  inst.email = (params) => inst.check(_email(ZodEmail, params));
  inst.url = (params) => inst.check(_url$1(ZodURL, params));
  inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
  inst.emoji = (params) => inst.check(_emoji(ZodEmoji, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
  inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
  inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
  inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
  inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
  inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
  inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
  inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
  inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
  inst.xid = (params) => inst.check(_xid(ZodXID, params));
  inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
  inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
  inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
  inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
  inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
  inst.e164 = (params) => inst.check(_e164(ZodE164, params));
  inst.datetime = (params) => inst.check(datetime(params));
  inst.date = (params) => inst.check(date(params));
  inst.time = (params) => inst.check(time(params));
  inst.duration = (params) => inst.check(duration(params));
});
function string(params) {
  return _string(ZodString$1, params);
}
const ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  _ZodString.init(inst, def);
});
const ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
  $ZodEmail.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
  $ZodGUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
  $ZodUUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
  $ZodURL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function url(params) {
  return _url$1(ZodURL, params);
}
const ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
  $ZodEmoji.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
  $ZodNanoID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
  $ZodCUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
  $ZodCUID2.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
  $ZodULID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
  $ZodXID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
  $ZodKSUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
  $ZodIPv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
  $ZodIPv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
  $ZodBase64.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
  $ZodBase64URL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
  $ZodE164.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
  $ZodJWT.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodNumber$1 = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
  $ZodNumber.init(inst, def);
  ZodType$1.init(inst, def);
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.int = (params) => inst.check(int(params));
  inst.safe = (params) => inst.check(int(params));
  inst.positive = (params) => inst.check(_gt(0, params));
  inst.nonnegative = (params) => inst.check(_gte(0, params));
  inst.negative = (params) => inst.check(_lt(0, params));
  inst.nonpositive = (params) => inst.check(_lte(0, params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  inst.step = (value, params) => inst.check(_multipleOf(value, params));
  inst.finite = () => inst;
  const bag = inst._zod.bag;
  inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
  inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
  inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
  inst.isFinite = true;
  inst.format = bag.format ?? null;
});
function number$1(params) {
  return _number(ZodNumber$1, params);
}
const ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
  $ZodNumberFormat.init(inst, def);
  ZodNumber$1.init(inst, def);
});
function int(params) {
  return _int(ZodNumberFormat, params);
}
const ZodBoolean$1 = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
  $ZodBoolean.init(inst, def);
  ZodType$1.init(inst, def);
});
function boolean(params) {
  return _boolean(ZodBoolean$1, params);
}
const ZodNull$1 = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {
  $ZodNull.init(inst, def);
  ZodType$1.init(inst, def);
});
function _null(params) {
  return _null$1(ZodNull$1, params);
}
const ZodAny$1 = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {
  $ZodAny.init(inst, def);
  ZodType$1.init(inst, def);
});
function any() {
  return _any(ZodAny$1);
}
const ZodUnknown$1 = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def);
  ZodType$1.init(inst, def);
});
function unknown() {
  return _unknown(ZodUnknown$1);
}
const ZodNever$1 = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
  $ZodNever.init(inst, def);
  ZodType$1.init(inst, def);
});
function never(params) {
  return _never(ZodNever$1, params);
}
const ZodArray$1 = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
  $ZodArray.init(inst, def);
  ZodType$1.init(inst, def);
  inst.element = def.element;
  inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
  inst.nonempty = (params) => inst.check(_minLength(1, params));
  inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
  inst.length = (len, params) => inst.check(_length(len, params));
  inst.unwrap = () => inst.element;
});
function array(element, params) {
  return _array(ZodArray$1, element, params);
}
const ZodObject$1 = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
  $ZodObject.init(inst, def);
  ZodType$1.init(inst, def);
  defineLazy(inst, "shape", () => def.shape);
  inst.keyof = () => _enum$3(Object.keys(inst._zod.def.shape));
  inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
  inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 });
  inst.extend = (incoming) => {
    return extend(inst, incoming);
  };
  inst.merge = (other) => merge(inst, other);
  inst.pick = (mask) => pick(inst, mask);
  inst.omit = (mask) => omit(inst, mask);
  inst.partial = (...args) => partial(ZodOptional$1, inst, args[0]);
  inst.required = (...args) => required$6(ZodNonOptional, inst, args[0]);
});
function object(shape, params) {
  const def = {
    type: "object",
    get shape() {
      assignProp(this, "shape", { ...shape });
      return this.shape;
    },
    ...normalizeParams(params)
  };
  return new ZodObject$1(def);
}
function looseObject(shape, params) {
  return new ZodObject$1({
    type: "object",
    get shape() {
      assignProp(this, "shape", { ...shape });
      return this.shape;
    },
    catchall: unknown(),
    ...normalizeParams(params)
  });
}
const ZodUnion$1 = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  ZodType$1.init(inst, def);
  inst.options = def.options;
});
function union(options, params) {
  return new ZodUnion$1({
    type: "union",
    options,
    ...normalizeParams(params)
  });
}
const ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def) => {
  ZodUnion$1.init(inst, def);
  $ZodDiscriminatedUnion.init(inst, def);
});
function discriminatedUnion(discriminator2, options, params) {
  return new ZodDiscriminatedUnion({
    type: "union",
    options,
    discriminator: discriminator2,
    ...normalizeParams(params)
  });
}
const ZodIntersection$1 = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
  $ZodIntersection.init(inst, def);
  ZodType$1.init(inst, def);
});
function intersection(left, right) {
  return new ZodIntersection$1({
    type: "intersection",
    left,
    right
  });
}
const ZodRecord = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {
  $ZodRecord.init(inst, def);
  ZodType$1.init(inst, def);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function record(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
const ZodEnum$1 = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
  $ZodEnum.init(inst, def);
  ZodType$1.init(inst, def);
  inst.enum = def.entries;
  inst.options = Object.values(def.entries);
  const keys = new Set(Object.keys(def.entries));
  inst.extract = (values, params) => {
    const newEntries = {};
    for (const value of values) {
      if (keys.has(value)) {
        newEntries[value] = def.entries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum$1({
      ...def,
      checks: [],
      ...normalizeParams(params),
      entries: newEntries
    });
  };
  inst.exclude = (values, params) => {
    const newEntries = { ...def.entries };
    for (const value of values) {
      if (keys.has(value)) {
        delete newEntries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum$1({
      ...def,
      checks: [],
      ...normalizeParams(params),
      entries: newEntries
    });
  };
});
function _enum$3(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodEnum$1({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
const ZodLiteral$1 = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
  $ZodLiteral.init(inst, def);
  ZodType$1.init(inst, def);
  inst.values = new Set(def.values);
  Object.defineProperty(inst, "value", {
    get() {
      if (def.values.length > 1) {
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      }
      return def.values[0];
    }
  });
});
function literal(value, params) {
  return new ZodLiteral$1({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams(params)
  });
}
const ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
  $ZodTransform.init(inst, def);
  ZodType$1.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.addIssue = (issue$1) => {
      if (typeof issue$1 === "string") {
        payload.issues.push(issue(issue$1, payload.value, def));
      } else {
        const _issue = issue$1;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = inst);
        _issue.continue ?? (_issue.continue = true);
        payload.issues.push(issue(_issue));
      }
    };
    const output = def.transform(payload.value, payload);
    if (output instanceof Promise) {
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    payload.value = output;
    return payload;
  };
});
function transform(fn2) {
  return new ZodTransform({
    type: "transform",
    transform: fn2
  });
}
const ZodOptional$1 = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  ZodType$1.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
  return new ZodOptional$1({
    type: "optional",
    innerType
  });
}
const ZodNullable$1 = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
  $ZodNullable.init(inst, def);
  ZodType$1.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
  return new ZodNullable$1({
    type: "nullable",
    innerType
  });
}
const ZodDefault$1 = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
  $ZodDefault.init(inst, def);
  ZodType$1.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeDefault = inst.unwrap;
});
function _default(innerType, defaultValue) {
  return new ZodDefault$1({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
  });
}
const ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
  $ZodPrefault.init(inst, def);
  ZodType$1.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
  });
}
const ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
  $ZodNonOptional.init(inst, def);
  ZodType$1.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...normalizeParams(params)
  });
}
const ZodCatch$1 = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
  $ZodCatch.init(inst, def);
  ZodType$1.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeCatch = inst.unwrap;
});
function _catch(innerType, catchValue) {
  return new ZodCatch$1({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
const ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
  $ZodPipe.init(inst, def);
  ZodType$1.init(inst, def);
  inst.in = def.in;
  inst.out = def.out;
});
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
    // ...util.normalizeParams(params),
  });
}
const ZodReadonly$1 = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
  $ZodReadonly.init(inst, def);
  ZodType$1.init(inst, def);
});
function readonly(innerType) {
  return new ZodReadonly$1({
    type: "readonly",
    innerType
  });
}
const ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
  $ZodCustom.init(inst, def);
  ZodType$1.init(inst, def);
});
function check(fn2) {
  const ch2 = new $ZodCheck({
    check: "custom"
    // ...util.normalizeParams(params),
  });
  ch2._zod.check = fn2;
  return ch2;
}
function custom$1(fn2, _params) {
  return _custom(ZodCustom, fn2 ?? (() => true), _params);
}
function refine(fn2, _params = {}) {
  return _refine(ZodCustom, fn2, _params);
}
function superRefine(fn2) {
  const ch2 = check((payload) => {
    payload.addIssue = (issue$1) => {
      if (typeof issue$1 === "string") {
        payload.issues.push(issue(issue$1, payload.value, ch2._zod.def));
      } else {
        const _issue = issue$1;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch2);
        _issue.continue ?? (_issue.continue = !ch2._zod.def.abort);
        payload.issues.push(issue(_issue));
      }
    };
    return fn2(payload.value, payload);
  });
  return ch2;
}
function preprocess(fn2, schema) {
  return pipe(transform(fn2), schema);
}
const ZodIssueCode$1 = {
  custom: "custom"
};
function number(params) {
  return _coercedNumber(ZodNumber$1, params);
}
const LATEST_PROTOCOL_VERSION = "2025-11-25";
const SUPPORTED_PROTOCOL_VERSIONS = [LATEST_PROTOCOL_VERSION, "2025-06-18", "2025-03-26", "2024-11-05", "2024-10-07"];
const RELATED_TASK_META_KEY = "io.modelcontextprotocol/related-task";
const JSONRPC_VERSION = "2.0";
const AssertObjectSchema = custom$1((v) => v !== null && (typeof v === "object" || typeof v === "function"));
const ProgressTokenSchema = union([string(), number$1().int()]);
const CursorSchema = string();
looseObject({
  /**
   * Time in milliseconds to keep task results available after completion.
   * If null, the task has unlimited lifetime until manually cleaned up.
   */
  ttl: union([number$1(), _null()]).optional(),
  /**
   * Time in milliseconds to wait between task status requests.
   */
  pollInterval: number$1().optional()
});
const TaskMetadataSchema = object({
  ttl: number$1().optional()
});
const RelatedTaskMetadataSchema = object({
  taskId: string()
});
const RequestMetaSchema = looseObject({
  /**
   * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
   */
  progressToken: ProgressTokenSchema.optional(),
  /**
   * If specified, this request is related to the provided task.
   */
  [RELATED_TASK_META_KEY]: RelatedTaskMetadataSchema.optional()
});
const BaseRequestParamsSchema = object({
  /**
   * See [General fields: `_meta`](/specification/draft/basic/index#meta) for notes on `_meta` usage.
   */
  _meta: RequestMetaSchema.optional()
});
const TaskAugmentedRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * If specified, the caller is requesting task-augmented execution for this request.
   * The request will return a CreateTaskResult immediately, and the actual result can be
   * retrieved later via tasks/result.
   *
   * Task augmentation is subject to capability negotiation - receivers MUST declare support
   * for task augmentation of specific request types in their capabilities.
   */
  task: TaskMetadataSchema.optional()
});
const isTaskAugmentedRequestParams = (value) => TaskAugmentedRequestParamsSchema.safeParse(value).success;
const RequestSchema = object({
  method: string(),
  params: BaseRequestParamsSchema.loose().optional()
});
const NotificationsParamsSchema = object({
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: RequestMetaSchema.optional()
});
const NotificationSchema = object({
  method: string(),
  params: NotificationsParamsSchema.loose().optional()
});
const ResultSchema = looseObject({
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: RequestMetaSchema.optional()
});
const RequestIdSchema = union([string(), number$1().int()]);
const JSONRPCRequestSchema = object({
  jsonrpc: literal(JSONRPC_VERSION),
  id: RequestIdSchema,
  ...RequestSchema.shape
}).strict();
const isJSONRPCRequest = (value) => JSONRPCRequestSchema.safeParse(value).success;
const JSONRPCNotificationSchema = object({
  jsonrpc: literal(JSONRPC_VERSION),
  ...NotificationSchema.shape
}).strict();
const isJSONRPCNotification = (value) => JSONRPCNotificationSchema.safeParse(value).success;
const JSONRPCResultResponseSchema = object({
  jsonrpc: literal(JSONRPC_VERSION),
  id: RequestIdSchema,
  result: ResultSchema
}).strict();
const isJSONRPCResultResponse = (value) => JSONRPCResultResponseSchema.safeParse(value).success;
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2[ErrorCode2["ConnectionClosed"] = -32e3] = "ConnectionClosed";
  ErrorCode2[ErrorCode2["RequestTimeout"] = -32001] = "RequestTimeout";
  ErrorCode2[ErrorCode2["ParseError"] = -32700] = "ParseError";
  ErrorCode2[ErrorCode2["InvalidRequest"] = -32600] = "InvalidRequest";
  ErrorCode2[ErrorCode2["MethodNotFound"] = -32601] = "MethodNotFound";
  ErrorCode2[ErrorCode2["InvalidParams"] = -32602] = "InvalidParams";
  ErrorCode2[ErrorCode2["InternalError"] = -32603] = "InternalError";
  ErrorCode2[ErrorCode2["UrlElicitationRequired"] = -32042] = "UrlElicitationRequired";
})(ErrorCode || (ErrorCode = {}));
const JSONRPCErrorResponseSchema = object({
  jsonrpc: literal(JSONRPC_VERSION),
  id: RequestIdSchema.optional(),
  error: object({
    /**
     * The error type that occurred.
     */
    code: number$1().int(),
    /**
     * A short description of the error. The message SHOULD be limited to a concise single sentence.
     */
    message: string(),
    /**
     * Additional information about the error. The value of this member is defined by the sender (e.g. detailed error information, nested errors etc.).
     */
    data: unknown().optional()
  })
}).strict();
const isJSONRPCErrorResponse = (value) => JSONRPCErrorResponseSchema.safeParse(value).success;
const JSONRPCMessageSchema = union([
  JSONRPCRequestSchema,
  JSONRPCNotificationSchema,
  JSONRPCResultResponseSchema,
  JSONRPCErrorResponseSchema
]);
union([JSONRPCResultResponseSchema, JSONRPCErrorResponseSchema]);
const EmptyResultSchema = ResultSchema.strict();
const CancelledNotificationParamsSchema = NotificationsParamsSchema.extend({
  /**
   * The ID of the request to cancel.
   *
   * This MUST correspond to the ID of a request previously issued in the same direction.
   */
  requestId: RequestIdSchema.optional(),
  /**
   * An optional string describing the reason for the cancellation. This MAY be logged or presented to the user.
   */
  reason: string().optional()
});
const CancelledNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/cancelled"),
  params: CancelledNotificationParamsSchema
});
const IconSchema = object({
  /**
   * URL or data URI for the icon.
   */
  src: string(),
  /**
   * Optional MIME type for the icon.
   */
  mimeType: string().optional(),
  /**
   * Optional array of strings that specify sizes at which the icon can be used.
   * Each string should be in WxH format (e.g., `"48x48"`, `"96x96"`) or `"any"` for scalable formats like SVG.
   *
   * If not provided, the client should assume that the icon can be used at any size.
   */
  sizes: array(string()).optional(),
  /**
   * Optional specifier for the theme this icon is designed for. `light` indicates
   * the icon is designed to be used with a light background, and `dark` indicates
   * the icon is designed to be used with a dark background.
   *
   * If not provided, the client should assume the icon can be used with any theme.
   */
  theme: _enum$3(["light", "dark"]).optional()
});
const IconsSchema = object({
  /**
   * Optional set of sized icons that the client can display in a user interface.
   *
   * Clients that support rendering icons MUST support at least the following MIME types:
   * - `image/png` - PNG images (safe, universal compatibility)
   * - `image/jpeg` (and `image/jpg`) - JPEG images (safe, universal compatibility)
   *
   * Clients that support rendering icons SHOULD also support:
   * - `image/svg+xml` - SVG images (scalable but requires security precautions)
   * - `image/webp` - WebP images (modern, efficient format)
   */
  icons: array(IconSchema).optional()
});
const BaseMetadataSchema = object({
  /** Intended for programmatic or logical use, but used as a display name in past specs or fallback */
  name: string(),
  /**
   * Intended for UI and end-user contexts  optimized to be human-readable and easily understood,
   * even by those unfamiliar with domain-specific terminology.
   *
   * If not provided, the name should be used for display (except for Tool,
   * where `annotations.title` should be given precedence over using `name`,
   * if present).
   */
  title: string().optional()
});
const ImplementationSchema = BaseMetadataSchema.extend({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  version: string(),
  /**
   * An optional URL of the website for this implementation.
   */
  websiteUrl: string().optional(),
  /**
   * An optional human-readable description of what this implementation does.
   *
   * This can be used by clients or servers to provide context about their purpose
   * and capabilities. For example, a server might describe the types of resources
   * or tools it provides, while a client might describe its intended use case.
   */
  description: string().optional()
});
const FormElicitationCapabilitySchema = intersection(object({
  applyDefaults: boolean().optional()
}), record(string(), unknown()));
const ElicitationCapabilitySchema = preprocess((value) => {
  if (value && typeof value === "object" && !Array.isArray(value)) {
    if (Object.keys(value).length === 0) {
      return { form: {} };
    }
  }
  return value;
}, intersection(object({
  form: FormElicitationCapabilitySchema.optional(),
  url: AssertObjectSchema.optional()
}), record(string(), unknown()).optional()));
const ClientTasksCapabilitySchema = looseObject({
  /**
   * Present if the client supports listing tasks.
   */
  list: AssertObjectSchema.optional(),
  /**
   * Present if the client supports cancelling tasks.
   */
  cancel: AssertObjectSchema.optional(),
  /**
   * Capabilities for task creation on specific request types.
   */
  requests: looseObject({
    /**
     * Task support for sampling requests.
     */
    sampling: looseObject({
      createMessage: AssertObjectSchema.optional()
    }).optional(),
    /**
     * Task support for elicitation requests.
     */
    elicitation: looseObject({
      create: AssertObjectSchema.optional()
    }).optional()
  }).optional()
});
const ServerTasksCapabilitySchema = looseObject({
  /**
   * Present if the server supports listing tasks.
   */
  list: AssertObjectSchema.optional(),
  /**
   * Present if the server supports cancelling tasks.
   */
  cancel: AssertObjectSchema.optional(),
  /**
   * Capabilities for task creation on specific request types.
   */
  requests: looseObject({
    /**
     * Task support for tool requests.
     */
    tools: looseObject({
      call: AssertObjectSchema.optional()
    }).optional()
  }).optional()
});
const ClientCapabilitiesSchema = object({
  /**
   * Experimental, non-standard capabilities that the client supports.
   */
  experimental: record(string(), AssertObjectSchema).optional(),
  /**
   * Present if the client supports sampling from an LLM.
   */
  sampling: object({
    /**
     * Present if the client supports context inclusion via includeContext parameter.
     * If not declared, servers SHOULD only use `includeContext: "none"` (or omit it).
     */
    context: AssertObjectSchema.optional(),
    /**
     * Present if the client supports tool use via tools and toolChoice parameters.
     */
    tools: AssertObjectSchema.optional()
  }).optional(),
  /**
   * Present if the client supports eliciting user input.
   */
  elicitation: ElicitationCapabilitySchema.optional(),
  /**
   * Present if the client supports listing roots.
   */
  roots: object({
    /**
     * Whether the client supports issuing notifications for changes to the roots list.
     */
    listChanged: boolean().optional()
  }).optional(),
  /**
   * Present if the client supports task creation.
   */
  tasks: ClientTasksCapabilitySchema.optional()
});
const InitializeRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * The latest version of the Model Context Protocol that the client supports. The client MAY decide to support older versions as well.
   */
  protocolVersion: string(),
  capabilities: ClientCapabilitiesSchema,
  clientInfo: ImplementationSchema
});
const InitializeRequestSchema = RequestSchema.extend({
  method: literal("initialize"),
  params: InitializeRequestParamsSchema
});
const ServerCapabilitiesSchema = object({
  /**
   * Experimental, non-standard capabilities that the server supports.
   */
  experimental: record(string(), AssertObjectSchema).optional(),
  /**
   * Present if the server supports sending log messages to the client.
   */
  logging: AssertObjectSchema.optional(),
  /**
   * Present if the server supports sending completions to the client.
   */
  completions: AssertObjectSchema.optional(),
  /**
   * Present if the server offers any prompt templates.
   */
  prompts: object({
    /**
     * Whether this server supports issuing notifications for changes to the prompt list.
     */
    listChanged: boolean().optional()
  }).optional(),
  /**
   * Present if the server offers any resources to read.
   */
  resources: object({
    /**
     * Whether this server supports clients subscribing to resource updates.
     */
    subscribe: boolean().optional(),
    /**
     * Whether this server supports issuing notifications for changes to the resource list.
     */
    listChanged: boolean().optional()
  }).optional(),
  /**
   * Present if the server offers any tools to call.
   */
  tools: object({
    /**
     * Whether this server supports issuing notifications for changes to the tool list.
     */
    listChanged: boolean().optional()
  }).optional(),
  /**
   * Present if the server supports task creation.
   */
  tasks: ServerTasksCapabilitySchema.optional()
});
const InitializeResultSchema = ResultSchema.extend({
  /**
   * The version of the Model Context Protocol that the server wants to use. This may not match the version that the client requested. If the client cannot support this version, it MUST disconnect.
   */
  protocolVersion: string(),
  capabilities: ServerCapabilitiesSchema,
  serverInfo: ImplementationSchema,
  /**
   * Instructions describing how to use the server and its features.
   *
   * This can be used by clients to improve the LLM's understanding of available tools, resources, etc. It can be thought of like a "hint" to the model. For example, this information MAY be added to the system prompt.
   */
  instructions: string().optional()
});
const InitializedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/initialized"),
  params: NotificationsParamsSchema.optional()
});
const isInitializedNotification = (value) => InitializedNotificationSchema.safeParse(value).success;
const PingRequestSchema = RequestSchema.extend({
  method: literal("ping"),
  params: BaseRequestParamsSchema.optional()
});
const ProgressSchema = object({
  /**
   * The progress thus far. This should increase every time progress is made, even if the total is unknown.
   */
  progress: number$1(),
  /**
   * Total number of items to process (or total progress required), if known.
   */
  total: optional(number$1()),
  /**
   * An optional message describing the current progress.
   */
  message: optional(string())
});
const ProgressNotificationParamsSchema = object({
  ...NotificationsParamsSchema.shape,
  ...ProgressSchema.shape,
  /**
   * The progress token which was given in the initial request, used to associate this notification with the request that is proceeding.
   */
  progressToken: ProgressTokenSchema
});
const ProgressNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/progress"),
  params: ProgressNotificationParamsSchema
});
const PaginatedRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * An opaque token representing the current pagination position.
   * If provided, the server should return results starting after this cursor.
   */
  cursor: CursorSchema.optional()
});
const PaginatedRequestSchema = RequestSchema.extend({
  params: PaginatedRequestParamsSchema.optional()
});
const PaginatedResultSchema = ResultSchema.extend({
  /**
   * An opaque token representing the pagination position after the last returned result.
   * If present, there may be more results available.
   */
  nextCursor: CursorSchema.optional()
});
const TaskStatusSchema = _enum$3(["working", "input_required", "completed", "failed", "cancelled"]);
const TaskSchema = object({
  taskId: string(),
  status: TaskStatusSchema,
  /**
   * Time in milliseconds to keep task results available after completion.
   * If null, the task has unlimited lifetime until manually cleaned up.
   */
  ttl: union([number$1(), _null()]),
  /**
   * ISO 8601 timestamp when the task was created.
   */
  createdAt: string(),
  /**
   * ISO 8601 timestamp when the task was last updated.
   */
  lastUpdatedAt: string(),
  pollInterval: optional(number$1()),
  /**
   * Optional diagnostic message for failed tasks or other status information.
   */
  statusMessage: optional(string())
});
const CreateTaskResultSchema = ResultSchema.extend({
  task: TaskSchema
});
const TaskStatusNotificationParamsSchema = NotificationsParamsSchema.merge(TaskSchema);
const TaskStatusNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/tasks/status"),
  params: TaskStatusNotificationParamsSchema
});
const GetTaskRequestSchema = RequestSchema.extend({
  method: literal("tasks/get"),
  params: BaseRequestParamsSchema.extend({
    taskId: string()
  })
});
const GetTaskResultSchema = ResultSchema.merge(TaskSchema);
const GetTaskPayloadRequestSchema = RequestSchema.extend({
  method: literal("tasks/result"),
  params: BaseRequestParamsSchema.extend({
    taskId: string()
  })
});
ResultSchema.loose();
const ListTasksRequestSchema = PaginatedRequestSchema.extend({
  method: literal("tasks/list")
});
const ListTasksResultSchema = PaginatedResultSchema.extend({
  tasks: array(TaskSchema)
});
const CancelTaskRequestSchema = RequestSchema.extend({
  method: literal("tasks/cancel"),
  params: BaseRequestParamsSchema.extend({
    taskId: string()
  })
});
const CancelTaskResultSchema = ResultSchema.merge(TaskSchema);
const ResourceContentsSchema = object({
  /**
   * The URI of this resource.
   */
  uri: string(),
  /**
   * The MIME type of this resource, if known.
   */
  mimeType: optional(string()),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string(), unknown()).optional()
});
const TextResourceContentsSchema = ResourceContentsSchema.extend({
  /**
   * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
   */
  text: string()
});
const Base64Schema = string().refine((val) => {
  try {
    atob(val);
    return true;
  } catch {
    return false;
  }
}, { message: "Invalid Base64 string" });
const BlobResourceContentsSchema = ResourceContentsSchema.extend({
  /**
   * A base64-encoded string representing the binary data of the item.
   */
  blob: Base64Schema
});
const RoleSchema = _enum$3(["user", "assistant"]);
const AnnotationsSchema = object({
  /**
   * Intended audience(s) for the resource.
   */
  audience: array(RoleSchema).optional(),
  /**
   * Importance hint for the resource, from 0 (least) to 1 (most).
   */
  priority: number$1().min(0).max(1).optional(),
  /**
   * ISO 8601 timestamp for the most recent modification.
   */
  lastModified: datetime({ offset: true }).optional()
});
const ResourceSchema = object({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  /**
   * The URI of this resource.
   */
  uri: string(),
  /**
   * A description of what this resource represents.
   *
   * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
   */
  description: optional(string()),
  /**
   * The MIME type of this resource, if known.
   */
  mimeType: optional(string()),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: optional(looseObject({}))
});
const ResourceTemplateSchema = object({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  /**
   * A URI template (according to RFC 6570) that can be used to construct resource URIs.
   */
  uriTemplate: string(),
  /**
   * A description of what this template is for.
   *
   * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
   */
  description: optional(string()),
  /**
   * The MIME type for all resources that match this template. This should only be included if all resources matching this template have the same type.
   */
  mimeType: optional(string()),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: optional(looseObject({}))
});
const ListResourcesRequestSchema = PaginatedRequestSchema.extend({
  method: literal("resources/list")
});
const ListResourcesResultSchema = PaginatedResultSchema.extend({
  resources: array(ResourceSchema)
});
const ListResourceTemplatesRequestSchema = PaginatedRequestSchema.extend({
  method: literal("resources/templates/list")
});
const ListResourceTemplatesResultSchema = PaginatedResultSchema.extend({
  resourceTemplates: array(ResourceTemplateSchema)
});
const ResourceRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * The URI of the resource to read. The URI can use any protocol; it is up to the server how to interpret it.
   *
   * @format uri
   */
  uri: string()
});
const ReadResourceRequestParamsSchema = ResourceRequestParamsSchema;
const ReadResourceRequestSchema = RequestSchema.extend({
  method: literal("resources/read"),
  params: ReadResourceRequestParamsSchema
});
const ReadResourceResultSchema = ResultSchema.extend({
  contents: array(union([TextResourceContentsSchema, BlobResourceContentsSchema]))
});
const ResourceListChangedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/resources/list_changed"),
  params: NotificationsParamsSchema.optional()
});
const SubscribeRequestParamsSchema = ResourceRequestParamsSchema;
const SubscribeRequestSchema = RequestSchema.extend({
  method: literal("resources/subscribe"),
  params: SubscribeRequestParamsSchema
});
const UnsubscribeRequestParamsSchema = ResourceRequestParamsSchema;
const UnsubscribeRequestSchema = RequestSchema.extend({
  method: literal("resources/unsubscribe"),
  params: UnsubscribeRequestParamsSchema
});
const ResourceUpdatedNotificationParamsSchema = NotificationsParamsSchema.extend({
  /**
   * The URI of the resource that has been updated. This might be a sub-resource of the one that the client actually subscribed to.
   */
  uri: string()
});
const ResourceUpdatedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/resources/updated"),
  params: ResourceUpdatedNotificationParamsSchema
});
const PromptArgumentSchema = object({
  /**
   * The name of the argument.
   */
  name: string(),
  /**
   * A human-readable description of the argument.
   */
  description: optional(string()),
  /**
   * Whether this argument must be provided.
   */
  required: optional(boolean())
});
const PromptSchema = object({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  /**
   * An optional description of what this prompt provides
   */
  description: optional(string()),
  /**
   * A list of arguments to use for templating the prompt.
   */
  arguments: optional(array(PromptArgumentSchema)),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: optional(looseObject({}))
});
const ListPromptsRequestSchema = PaginatedRequestSchema.extend({
  method: literal("prompts/list")
});
const ListPromptsResultSchema = PaginatedResultSchema.extend({
  prompts: array(PromptSchema)
});
const GetPromptRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * The name of the prompt or prompt template.
   */
  name: string(),
  /**
   * Arguments to use for templating the prompt.
   */
  arguments: record(string(), string()).optional()
});
const GetPromptRequestSchema = RequestSchema.extend({
  method: literal("prompts/get"),
  params: GetPromptRequestParamsSchema
});
const TextContentSchema = object({
  type: literal("text"),
  /**
   * The text content of the message.
   */
  text: string(),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string(), unknown()).optional()
});
const ImageContentSchema = object({
  type: literal("image"),
  /**
   * The base64-encoded image data.
   */
  data: Base64Schema,
  /**
   * The MIME type of the image. Different providers may support different image types.
   */
  mimeType: string(),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string(), unknown()).optional()
});
const AudioContentSchema = object({
  type: literal("audio"),
  /**
   * The base64-encoded audio data.
   */
  data: Base64Schema,
  /**
   * The MIME type of the audio. Different providers may support different audio types.
   */
  mimeType: string(),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string(), unknown()).optional()
});
const ToolUseContentSchema = object({
  type: literal("tool_use"),
  /**
   * The name of the tool to invoke.
   * Must match a tool name from the request's tools array.
   */
  name: string(),
  /**
   * Unique identifier for this tool call.
   * Used to correlate with ToolResultContent in subsequent messages.
   */
  id: string(),
  /**
   * Arguments to pass to the tool.
   * Must conform to the tool's inputSchema.
   */
  input: record(string(), unknown()),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string(), unknown()).optional()
});
const EmbeddedResourceSchema = object({
  type: literal("resource"),
  resource: union([TextResourceContentsSchema, BlobResourceContentsSchema]),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string(), unknown()).optional()
});
const ResourceLinkSchema = ResourceSchema.extend({
  type: literal("resource_link")
});
const ContentBlockSchema = union([
  TextContentSchema,
  ImageContentSchema,
  AudioContentSchema,
  ResourceLinkSchema,
  EmbeddedResourceSchema
]);
const PromptMessageSchema = object({
  role: RoleSchema,
  content: ContentBlockSchema
});
const GetPromptResultSchema = ResultSchema.extend({
  /**
   * An optional description for the prompt.
   */
  description: string().optional(),
  messages: array(PromptMessageSchema)
});
const PromptListChangedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/prompts/list_changed"),
  params: NotificationsParamsSchema.optional()
});
const ToolAnnotationsSchema = object({
  /**
   * A human-readable title for the tool.
   */
  title: string().optional(),
  /**
   * If true, the tool does not modify its environment.
   *
   * Default: false
   */
  readOnlyHint: boolean().optional(),
  /**
   * If true, the tool may perform destructive updates to its environment.
   * If false, the tool performs only additive updates.
   *
   * (This property is meaningful only when `readOnlyHint == false`)
   *
   * Default: true
   */
  destructiveHint: boolean().optional(),
  /**
   * If true, calling the tool repeatedly with the same arguments
   * will have no additional effect on the its environment.
   *
   * (This property is meaningful only when `readOnlyHint == false`)
   *
   * Default: false
   */
  idempotentHint: boolean().optional(),
  /**
   * If true, this tool may interact with an "open world" of external
   * entities. If false, the tool's domain of interaction is closed.
   * For example, the world of a web search tool is open, whereas that
   * of a memory tool is not.
   *
   * Default: true
   */
  openWorldHint: boolean().optional()
});
const ToolExecutionSchema = object({
  /**
   * Indicates the tool's preference for task-augmented execution.
   * - "required": Clients MUST invoke the tool as a task
   * - "optional": Clients MAY invoke the tool as a task or normal request
   * - "forbidden": Clients MUST NOT attempt to invoke the tool as a task
   *
   * If not present, defaults to "forbidden".
   */
  taskSupport: _enum$3(["required", "optional", "forbidden"]).optional()
});
const ToolSchema = object({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  /**
   * A human-readable description of the tool.
   */
  description: string().optional(),
  /**
   * A JSON Schema 2020-12 object defining the expected parameters for the tool.
   * Must have type: 'object' at the root level per MCP spec.
   */
  inputSchema: object({
    type: literal("object"),
    properties: record(string(), AssertObjectSchema).optional(),
    required: array(string()).optional()
  }).catchall(unknown()),
  /**
   * An optional JSON Schema 2020-12 object defining the structure of the tool's output
   * returned in the structuredContent field of a CallToolResult.
   * Must have type: 'object' at the root level per MCP spec.
   */
  outputSchema: object({
    type: literal("object"),
    properties: record(string(), AssertObjectSchema).optional(),
    required: array(string()).optional()
  }).catchall(unknown()).optional(),
  /**
   * Optional additional tool information.
   */
  annotations: ToolAnnotationsSchema.optional(),
  /**
   * Execution-related properties for this tool.
   */
  execution: ToolExecutionSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string(), unknown()).optional()
});
const ListToolsRequestSchema = PaginatedRequestSchema.extend({
  method: literal("tools/list")
});
const ListToolsResultSchema = PaginatedResultSchema.extend({
  tools: array(ToolSchema)
});
const CallToolResultSchema = ResultSchema.extend({
  /**
   * A list of content objects that represent the result of the tool call.
   *
   * If the Tool does not define an outputSchema, this field MUST be present in the result.
   * For backwards compatibility, this field is always present, but it may be empty.
   */
  content: array(ContentBlockSchema).default([]),
  /**
   * An object containing structured tool output.
   *
   * If the Tool defines an outputSchema, this field MUST be present in the result, and contain a JSON object that matches the schema.
   */
  structuredContent: record(string(), unknown()).optional(),
  /**
   * Whether the tool call ended in an error.
   *
   * If not set, this is assumed to be false (the call was successful).
   *
   * Any errors that originate from the tool SHOULD be reported inside the result
   * object, with `isError` set to true, _not_ as an MCP protocol-level error
   * response. Otherwise, the LLM would not be able to see that an error occurred
   * and self-correct.
   *
   * However, any errors in _finding_ the tool, an error indicating that the
   * server does not support tool calls, or any other exceptional conditions,
   * should be reported as an MCP error response.
   */
  isError: boolean().optional()
});
const CompatibilityCallToolResultSchema = CallToolResultSchema.or(ResultSchema.extend({
  toolResult: unknown()
}));
const CallToolRequestParamsSchema = TaskAugmentedRequestParamsSchema.extend({
  /**
   * The name of the tool to call.
   */
  name: string(),
  /**
   * Arguments to pass to the tool.
   */
  arguments: record(string(), unknown()).optional()
});
const CallToolRequestSchema = RequestSchema.extend({
  method: literal("tools/call"),
  params: CallToolRequestParamsSchema
});
const ToolListChangedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/tools/list_changed"),
  params: NotificationsParamsSchema.optional()
});
const ListChangedOptionsBaseSchema = object({
  /**
   * If true, the list will be refreshed automatically when a list changed notification is received.
   * The callback will be called with the updated list.
   *
   * If false, the callback will be called with null items, allowing manual refresh.
   *
   * @default true
   */
  autoRefresh: boolean().default(true),
  /**
   * Debounce time in milliseconds for list changed notification processing.
   *
   * Multiple notifications received within this timeframe will only trigger one refresh.
   * Set to 0 to disable debouncing.
   *
   * @default 300
   */
  debounceMs: number$1().int().nonnegative().default(300)
});
const LoggingLevelSchema = _enum$3(["debug", "info", "notice", "warning", "error", "critical", "alert", "emergency"]);
const SetLevelRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * The level of logging that the client wants to receive from the server. The server should send all logs at this level and higher (i.e., more severe) to the client as notifications/logging/message.
   */
  level: LoggingLevelSchema
});
const SetLevelRequestSchema = RequestSchema.extend({
  method: literal("logging/setLevel"),
  params: SetLevelRequestParamsSchema
});
const LoggingMessageNotificationParamsSchema = NotificationsParamsSchema.extend({
  /**
   * The severity of this log message.
   */
  level: LoggingLevelSchema,
  /**
   * An optional name of the logger issuing this message.
   */
  logger: string().optional(),
  /**
   * The data to be logged, such as a string message or an object. Any JSON serializable type is allowed here.
   */
  data: unknown()
});
const LoggingMessageNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/message"),
  params: LoggingMessageNotificationParamsSchema
});
const ModelHintSchema = object({
  /**
   * A hint for a model name.
   */
  name: string().optional()
});
const ModelPreferencesSchema = object({
  /**
   * Optional hints to use for model selection.
   */
  hints: array(ModelHintSchema).optional(),
  /**
   * How much to prioritize cost when selecting a model.
   */
  costPriority: number$1().min(0).max(1).optional(),
  /**
   * How much to prioritize sampling speed (latency) when selecting a model.
   */
  speedPriority: number$1().min(0).max(1).optional(),
  /**
   * How much to prioritize intelligence and capabilities when selecting a model.
   */
  intelligencePriority: number$1().min(0).max(1).optional()
});
const ToolChoiceSchema = object({
  /**
   * Controls when tools are used:
   * - "auto": Model decides whether to use tools (default)
   * - "required": Model MUST use at least one tool before completing
   * - "none": Model MUST NOT use any tools
   */
  mode: _enum$3(["auto", "required", "none"]).optional()
});
const ToolResultContentSchema = object({
  type: literal("tool_result"),
  toolUseId: string().describe("The unique identifier for the corresponding tool call."),
  content: array(ContentBlockSchema).default([]),
  structuredContent: object({}).loose().optional(),
  isError: boolean().optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string(), unknown()).optional()
});
const SamplingContentSchema = discriminatedUnion("type", [TextContentSchema, ImageContentSchema, AudioContentSchema]);
const SamplingMessageContentBlockSchema = discriminatedUnion("type", [
  TextContentSchema,
  ImageContentSchema,
  AudioContentSchema,
  ToolUseContentSchema,
  ToolResultContentSchema
]);
const SamplingMessageSchema = object({
  role: RoleSchema,
  content: union([SamplingMessageContentBlockSchema, array(SamplingMessageContentBlockSchema)]),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string(), unknown()).optional()
});
const CreateMessageRequestParamsSchema = TaskAugmentedRequestParamsSchema.extend({
  messages: array(SamplingMessageSchema),
  /**
   * The server's preferences for which model to select. The client MAY modify or omit this request.
   */
  modelPreferences: ModelPreferencesSchema.optional(),
  /**
   * An optional system prompt the server wants to use for sampling. The client MAY modify or omit this prompt.
   */
  systemPrompt: string().optional(),
  /**
   * A request to include context from one or more MCP servers (including the caller), to be attached to the prompt.
   * The client MAY ignore this request.
   *
   * Default is "none". Values "thisServer" and "allServers" are soft-deprecated. Servers SHOULD only use these values if the client
   * declares ClientCapabilities.sampling.context. These values may be removed in future spec releases.
   */
  includeContext: _enum$3(["none", "thisServer", "allServers"]).optional(),
  temperature: number$1().optional(),
  /**
   * The requested maximum number of tokens to sample (to prevent runaway completions).
   *
   * The client MAY choose to sample fewer tokens than the requested maximum.
   */
  maxTokens: number$1().int(),
  stopSequences: array(string()).optional(),
  /**
   * Optional metadata to pass through to the LLM provider. The format of this metadata is provider-specific.
   */
  metadata: AssertObjectSchema.optional(),
  /**
   * Tools that the model may use during generation.
   * The client MUST return an error if this field is provided but ClientCapabilities.sampling.tools is not declared.
   */
  tools: array(ToolSchema).optional(),
  /**
   * Controls how the model uses tools.
   * The client MUST return an error if this field is provided but ClientCapabilities.sampling.tools is not declared.
   * Default is `{ mode: "auto" }`.
   */
  toolChoice: ToolChoiceSchema.optional()
});
const CreateMessageRequestSchema = RequestSchema.extend({
  method: literal("sampling/createMessage"),
  params: CreateMessageRequestParamsSchema
});
const CreateMessageResultSchema = ResultSchema.extend({
  /**
   * The name of the model that generated the message.
   */
  model: string(),
  /**
   * The reason why sampling stopped, if known.
   *
   * Standard values:
   * - "endTurn": Natural end of the assistant's turn
   * - "stopSequence": A stop sequence was encountered
   * - "maxTokens": Maximum token limit was reached
   *
   * This field is an open string to allow for provider-specific stop reasons.
   */
  stopReason: optional(_enum$3(["endTurn", "stopSequence", "maxTokens"]).or(string())),
  role: RoleSchema,
  /**
   * Response content. Single content block (text, image, or audio).
   */
  content: SamplingContentSchema
});
const CreateMessageResultWithToolsSchema = ResultSchema.extend({
  /**
   * The name of the model that generated the message.
   */
  model: string(),
  /**
   * The reason why sampling stopped, if known.
   *
   * Standard values:
   * - "endTurn": Natural end of the assistant's turn
   * - "stopSequence": A stop sequence was encountered
   * - "maxTokens": Maximum token limit was reached
   * - "toolUse": The model wants to use one or more tools
   *
   * This field is an open string to allow for provider-specific stop reasons.
   */
  stopReason: optional(_enum$3(["endTurn", "stopSequence", "maxTokens", "toolUse"]).or(string())),
  role: RoleSchema,
  /**
   * Response content. May be a single block or array. May include ToolUseContent if stopReason is "toolUse".
   */
  content: union([SamplingMessageContentBlockSchema, array(SamplingMessageContentBlockSchema)])
});
const BooleanSchemaSchema = object({
  type: literal("boolean"),
  title: string().optional(),
  description: string().optional(),
  default: boolean().optional()
});
const StringSchemaSchema = object({
  type: literal("string"),
  title: string().optional(),
  description: string().optional(),
  minLength: number$1().optional(),
  maxLength: number$1().optional(),
  format: _enum$3(["email", "uri", "date", "date-time"]).optional(),
  default: string().optional()
});
const NumberSchemaSchema = object({
  type: _enum$3(["number", "integer"]),
  title: string().optional(),
  description: string().optional(),
  minimum: number$1().optional(),
  maximum: number$1().optional(),
  default: number$1().optional()
});
const UntitledSingleSelectEnumSchemaSchema = object({
  type: literal("string"),
  title: string().optional(),
  description: string().optional(),
  enum: array(string()),
  default: string().optional()
});
const TitledSingleSelectEnumSchemaSchema = object({
  type: literal("string"),
  title: string().optional(),
  description: string().optional(),
  oneOf: array(object({
    const: string(),
    title: string()
  })),
  default: string().optional()
});
const LegacyTitledEnumSchemaSchema = object({
  type: literal("string"),
  title: string().optional(),
  description: string().optional(),
  enum: array(string()),
  enumNames: array(string()).optional(),
  default: string().optional()
});
const SingleSelectEnumSchemaSchema = union([UntitledSingleSelectEnumSchemaSchema, TitledSingleSelectEnumSchemaSchema]);
const UntitledMultiSelectEnumSchemaSchema = object({
  type: literal("array"),
  title: string().optional(),
  description: string().optional(),
  minItems: number$1().optional(),
  maxItems: number$1().optional(),
  items: object({
    type: literal("string"),
    enum: array(string())
  }),
  default: array(string()).optional()
});
const TitledMultiSelectEnumSchemaSchema = object({
  type: literal("array"),
  title: string().optional(),
  description: string().optional(),
  minItems: number$1().optional(),
  maxItems: number$1().optional(),
  items: object({
    anyOf: array(object({
      const: string(),
      title: string()
    }))
  }),
  default: array(string()).optional()
});
const MultiSelectEnumSchemaSchema = union([UntitledMultiSelectEnumSchemaSchema, TitledMultiSelectEnumSchemaSchema]);
const EnumSchemaSchema = union([LegacyTitledEnumSchemaSchema, SingleSelectEnumSchemaSchema, MultiSelectEnumSchemaSchema]);
const PrimitiveSchemaDefinitionSchema = union([EnumSchemaSchema, BooleanSchemaSchema, StringSchemaSchema, NumberSchemaSchema]);
const ElicitRequestFormParamsSchema = TaskAugmentedRequestParamsSchema.extend({
  /**
   * The elicitation mode.
   *
   * Optional for backward compatibility. Clients MUST treat missing mode as "form".
   */
  mode: literal("form").optional(),
  /**
   * The message to present to the user describing what information is being requested.
   */
  message: string(),
  /**
   * A restricted subset of JSON Schema.
   * Only top-level properties are allowed, without nesting.
   */
  requestedSchema: object({
    type: literal("object"),
    properties: record(string(), PrimitiveSchemaDefinitionSchema),
    required: array(string()).optional()
  })
});
const ElicitRequestURLParamsSchema = TaskAugmentedRequestParamsSchema.extend({
  /**
   * The elicitation mode.
   */
  mode: literal("url"),
  /**
   * The message to present to the user explaining why the interaction is needed.
   */
  message: string(),
  /**
   * The ID of the elicitation, which must be unique within the context of the server.
   * The client MUST treat this ID as an opaque value.
   */
  elicitationId: string(),
  /**
   * The URL that the user should navigate to.
   */
  url: string().url()
});
const ElicitRequestParamsSchema = union([ElicitRequestFormParamsSchema, ElicitRequestURLParamsSchema]);
const ElicitRequestSchema = RequestSchema.extend({
  method: literal("elicitation/create"),
  params: ElicitRequestParamsSchema
});
const ElicitationCompleteNotificationParamsSchema = NotificationsParamsSchema.extend({
  /**
   * The ID of the elicitation that completed.
   */
  elicitationId: string()
});
const ElicitationCompleteNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/elicitation/complete"),
  params: ElicitationCompleteNotificationParamsSchema
});
const ElicitResultSchema = ResultSchema.extend({
  /**
   * The user action in response to the elicitation.
   * - "accept": User submitted the form/confirmed the action
   * - "decline": User explicitly decline the action
   * - "cancel": User dismissed without making an explicit choice
   */
  action: _enum$3(["accept", "decline", "cancel"]),
  /**
   * The submitted form data, only present when action is "accept".
   * Contains values matching the requested schema.
   * Per MCP spec, content is "typically omitted" for decline/cancel actions.
   * We normalize null to undefined for leniency while maintaining type compatibility.
   */
  content: preprocess((val) => val === null ? void 0 : val, record(string(), union([string(), number$1(), boolean(), array(string())])).optional())
});
const ResourceTemplateReferenceSchema = object({
  type: literal("ref/resource"),
  /**
   * The URI or URI template of the resource.
   */
  uri: string()
});
const PromptReferenceSchema = object({
  type: literal("ref/prompt"),
  /**
   * The name of the prompt or prompt template
   */
  name: string()
});
const CompleteRequestParamsSchema = BaseRequestParamsSchema.extend({
  ref: union([PromptReferenceSchema, ResourceTemplateReferenceSchema]),
  /**
   * The argument's information
   */
  argument: object({
    /**
     * The name of the argument
     */
    name: string(),
    /**
     * The value of the argument to use for completion matching.
     */
    value: string()
  }),
  context: object({
    /**
     * Previously-resolved variables in a URI template or prompt.
     */
    arguments: record(string(), string()).optional()
  }).optional()
});
const CompleteRequestSchema = RequestSchema.extend({
  method: literal("completion/complete"),
  params: CompleteRequestParamsSchema
});
const CompleteResultSchema = ResultSchema.extend({
  completion: looseObject({
    /**
     * An array of completion values. Must not exceed 100 items.
     */
    values: array(string()).max(100),
    /**
     * The total number of completion options available. This can exceed the number of values actually sent in the response.
     */
    total: optional(number$1().int()),
    /**
     * Indicates whether there are additional completion options beyond those provided in the current response, even if the exact total is unknown.
     */
    hasMore: optional(boolean())
  })
});
const RootSchema = object({
  /**
   * The URI identifying the root. This *must* start with file:// for now.
   */
  uri: string().startsWith("file://"),
  /**
   * An optional name for the root.
   */
  name: string().optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string(), unknown()).optional()
});
const ListRootsRequestSchema = RequestSchema.extend({
  method: literal("roots/list"),
  params: BaseRequestParamsSchema.optional()
});
const ListRootsResultSchema = ResultSchema.extend({
  roots: array(RootSchema)
});
const RootsListChangedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/roots/list_changed"),
  params: NotificationsParamsSchema.optional()
});
union([
  PingRequestSchema,
  InitializeRequestSchema,
  CompleteRequestSchema,
  SetLevelRequestSchema,
  GetPromptRequestSchema,
  ListPromptsRequestSchema,
  ListResourcesRequestSchema,
  ListResourceTemplatesRequestSchema,
  ReadResourceRequestSchema,
  SubscribeRequestSchema,
  UnsubscribeRequestSchema,
  CallToolRequestSchema,
  ListToolsRequestSchema,
  GetTaskRequestSchema,
  GetTaskPayloadRequestSchema,
  ListTasksRequestSchema,
  CancelTaskRequestSchema
]);
union([
  CancelledNotificationSchema,
  ProgressNotificationSchema,
  InitializedNotificationSchema,
  RootsListChangedNotificationSchema,
  TaskStatusNotificationSchema
]);
union([
  EmptyResultSchema,
  CreateMessageResultSchema,
  CreateMessageResultWithToolsSchema,
  ElicitResultSchema,
  ListRootsResultSchema,
  GetTaskResultSchema,
  ListTasksResultSchema,
  CreateTaskResultSchema
]);
union([
  PingRequestSchema,
  CreateMessageRequestSchema,
  ElicitRequestSchema,
  ListRootsRequestSchema,
  GetTaskRequestSchema,
  GetTaskPayloadRequestSchema,
  ListTasksRequestSchema,
  CancelTaskRequestSchema
]);
union([
  CancelledNotificationSchema,
  ProgressNotificationSchema,
  LoggingMessageNotificationSchema,
  ResourceUpdatedNotificationSchema,
  ResourceListChangedNotificationSchema,
  ToolListChangedNotificationSchema,
  PromptListChangedNotificationSchema,
  TaskStatusNotificationSchema,
  ElicitationCompleteNotificationSchema
]);
union([
  EmptyResultSchema,
  InitializeResultSchema,
  CompleteResultSchema,
  GetPromptResultSchema,
  ListPromptsResultSchema,
  ListResourcesResultSchema,
  ListResourceTemplatesResultSchema,
  ReadResourceResultSchema,
  CallToolResultSchema,
  ListToolsResultSchema,
  GetTaskResultSchema,
  ListTasksResultSchema,
  CreateTaskResultSchema
]);
class McpError extends Error {
  constructor(code2, message, data2) {
    super(`MCP error ${code2}: ${message}`);
    this.code = code2;
    this.data = data2;
    this.name = "McpError";
  }
  /**
   * Factory method to create the appropriate error type based on the error code and data
   */
  static fromError(code2, message, data2) {
    if (code2 === ErrorCode.UrlElicitationRequired && data2) {
      const errorData = data2;
      if (errorData.elicitations) {
        return new UrlElicitationRequiredError(errorData.elicitations, message);
      }
    }
    return new McpError(code2, message, data2);
  }
}
class UrlElicitationRequiredError extends McpError {
  constructor(elicitations, message = `URL elicitation${elicitations.length > 1 ? "s" : ""} required`) {
    super(ErrorCode.UrlElicitationRequired, message, {
      elicitations
    });
  }
  get elicitations() {
    return this.data?.elicitations ?? [];
  }
}
const SafeUrlSchema = url().superRefine((val, ctx) => {
  if (!URL.canParse(val)) {
    ctx.addIssue({
      code: ZodIssueCode$1.custom,
      message: "URL must be parseable",
      fatal: true
    });
    return NEVER;
  }
}).refine((url2) => {
  const u2 = new URL(url2);
  return u2.protocol !== "javascript:" && u2.protocol !== "data:" && u2.protocol !== "vbscript:";
}, { message: "URL cannot use javascript:, data:, or vbscript: scheme" });
const OAuthProtectedResourceMetadataSchema = looseObject({
  resource: string().url(),
  authorization_servers: array(SafeUrlSchema).optional(),
  jwks_uri: string().url().optional(),
  scopes_supported: array(string()).optional(),
  bearer_methods_supported: array(string()).optional(),
  resource_signing_alg_values_supported: array(string()).optional(),
  resource_name: string().optional(),
  resource_documentation: string().optional(),
  resource_policy_uri: string().url().optional(),
  resource_tos_uri: string().url().optional(),
  tls_client_certificate_bound_access_tokens: boolean().optional(),
  authorization_details_types_supported: array(string()).optional(),
  dpop_signing_alg_values_supported: array(string()).optional(),
  dpop_bound_access_tokens_required: boolean().optional()
});
const OAuthMetadataSchema = looseObject({
  issuer: string(),
  authorization_endpoint: SafeUrlSchema,
  token_endpoint: SafeUrlSchema,
  registration_endpoint: SafeUrlSchema.optional(),
  scopes_supported: array(string()).optional(),
  response_types_supported: array(string()),
  response_modes_supported: array(string()).optional(),
  grant_types_supported: array(string()).optional(),
  token_endpoint_auth_methods_supported: array(string()).optional(),
  token_endpoint_auth_signing_alg_values_supported: array(string()).optional(),
  service_documentation: SafeUrlSchema.optional(),
  revocation_endpoint: SafeUrlSchema.optional(),
  revocation_endpoint_auth_methods_supported: array(string()).optional(),
  revocation_endpoint_auth_signing_alg_values_supported: array(string()).optional(),
  introspection_endpoint: string().optional(),
  introspection_endpoint_auth_methods_supported: array(string()).optional(),
  introspection_endpoint_auth_signing_alg_values_supported: array(string()).optional(),
  code_challenge_methods_supported: array(string()).optional(),
  client_id_metadata_document_supported: boolean().optional()
});
const OpenIdProviderMetadataSchema = looseObject({
  issuer: string(),
  authorization_endpoint: SafeUrlSchema,
  token_endpoint: SafeUrlSchema,
  userinfo_endpoint: SafeUrlSchema.optional(),
  jwks_uri: SafeUrlSchema,
  registration_endpoint: SafeUrlSchema.optional(),
  scopes_supported: array(string()).optional(),
  response_types_supported: array(string()),
  response_modes_supported: array(string()).optional(),
  grant_types_supported: array(string()).optional(),
  acr_values_supported: array(string()).optional(),
  subject_types_supported: array(string()),
  id_token_signing_alg_values_supported: array(string()),
  id_token_encryption_alg_values_supported: array(string()).optional(),
  id_token_encryption_enc_values_supported: array(string()).optional(),
  userinfo_signing_alg_values_supported: array(string()).optional(),
  userinfo_encryption_alg_values_supported: array(string()).optional(),
  userinfo_encryption_enc_values_supported: array(string()).optional(),
  request_object_signing_alg_values_supported: array(string()).optional(),
  request_object_encryption_alg_values_supported: array(string()).optional(),
  request_object_encryption_enc_values_supported: array(string()).optional(),
  token_endpoint_auth_methods_supported: array(string()).optional(),
  token_endpoint_auth_signing_alg_values_supported: array(string()).optional(),
  display_values_supported: array(string()).optional(),
  claim_types_supported: array(string()).optional(),
  claims_supported: array(string()).optional(),
  service_documentation: string().optional(),
  claims_locales_supported: array(string()).optional(),
  ui_locales_supported: array(string()).optional(),
  claims_parameter_supported: boolean().optional(),
  request_parameter_supported: boolean().optional(),
  request_uri_parameter_supported: boolean().optional(),
  require_request_uri_registration: boolean().optional(),
  op_policy_uri: SafeUrlSchema.optional(),
  op_tos_uri: SafeUrlSchema.optional(),
  client_id_metadata_document_supported: boolean().optional()
});
const OpenIdProviderDiscoveryMetadataSchema = object({
  ...OpenIdProviderMetadataSchema.shape,
  ...OAuthMetadataSchema.pick({
    code_challenge_methods_supported: true
  }).shape
});
const OAuthTokensSchema = object({
  access_token: string(),
  id_token: string().optional(),
  // Optional for OAuth 2.1, but necessary in OpenID Connect
  token_type: string(),
  expires_in: number().optional(),
  scope: string().optional(),
  refresh_token: string().optional()
}).strip();
const OAuthErrorResponseSchema = object({
  error: string(),
  error_description: string().optional(),
  error_uri: string().optional()
});
const OptionalSafeUrlSchema = SafeUrlSchema.optional().or(literal("").transform(() => void 0));
const OAuthClientMetadataSchema = object({
  redirect_uris: array(SafeUrlSchema),
  token_endpoint_auth_method: string().optional(),
  grant_types: array(string()).optional(),
  response_types: array(string()).optional(),
  client_name: string().optional(),
  client_uri: SafeUrlSchema.optional(),
  logo_uri: OptionalSafeUrlSchema,
  scope: string().optional(),
  contacts: array(string()).optional(),
  tos_uri: OptionalSafeUrlSchema,
  policy_uri: string().optional(),
  jwks_uri: SafeUrlSchema.optional(),
  jwks: any().optional(),
  software_id: string().optional(),
  software_version: string().optional(),
  software_statement: string().optional()
}).strip();
const OAuthClientInformationSchema = object({
  client_id: string(),
  client_secret: string().optional(),
  client_id_issued_at: number$1().optional(),
  client_secret_expires_at: number$1().optional()
}).strip();
const OAuthClientInformationFullSchema = OAuthClientMetadataSchema.merge(OAuthClientInformationSchema);
object({
  error: string(),
  error_description: string().optional()
}).strip();
object({
  token: string(),
  token_type_hint: string().optional()
}).strip();
const name = "@modelcontextprotocol/inspector-client";
const version$1 = "0.21.0";
const packageJson = {
  name,
  version: version$1
};
const CLIENT_IDENTITY = (() => {
  const [, name2 = packageJson.name] = packageJson.name.split("/");
  const version2 = packageJson.version;
  return { name: name2, version: version2 };
})();
const SESSION_KEYS = {
  CODE_VERIFIER: "mcp_code_verifier",
  SERVER_URL: "mcp_server_url",
  TOKENS: "mcp_tokens",
  CLIENT_INFORMATION: "mcp_client_information",
  PREREGISTERED_CLIENT_INFORMATION: "mcp_preregistered_client_information",
  SERVER_METADATA: "mcp_server_metadata",
  AUTH_DEBUGGER_STATE: "mcp_auth_debugger_state",
  SCOPE: "mcp_scope"
};
const getServerSpecificKey = (baseKey, serverUrl) => {
  if (!serverUrl) return baseKey;
  return `[${serverUrl}] ${baseKey}`;
};
const DEFAULT_MCP_PROXY_LISTEN_PORT = "6277";
const DEFAULT_INSPECTOR_CONFIG = {
  MCP_SERVER_REQUEST_TIMEOUT: {
    label: "Request Timeout",
    description: "Client-side timeout (ms) - Inspector will cancel requests after this time",
    value: 3e5,
    // 5 minutes - increased to support elicitation and other long-running tools
    is_session_item: false
  },
  MCP_REQUEST_TIMEOUT_RESET_ON_PROGRESS: {
    label: "Reset Timeout on Progress",
    description: "Reset timeout on progress notifications",
    value: true,
    is_session_item: false
  },
  MCP_REQUEST_MAX_TOTAL_TIMEOUT: {
    label: "Maximum Total Timeout",
    description: "Maximum total timeout for requests sent to the MCP server (ms) (Use with progress notifications)",
    value: 6e4,
    is_session_item: false
  },
  MCP_PROXY_FULL_ADDRESS: {
    label: "Inspector Proxy Address",
    description: "Set this if you are running the MCP Inspector Proxy on a non-default address. Example: http://10.1.1.22:5577",
    value: "",
    is_session_item: false
  },
  MCP_PROXY_AUTH_TOKEN: {
    label: "Proxy Session Token",
    description: "Session token for authenticating with the MCP Proxy Server (displayed in proxy console on startup)",
    value: "",
    is_session_item: true
  },
  MCP_TASK_TTL: {
    label: "Task TTL",
    description: "Default Time-to-Live (TTL) in milliseconds for newly created tasks",
    value: 6e4,
    is_session_item: false
  }
};
const META_PREFIX_LABEL_REGEX = /^[a-z](?:[a-z\d-]*[a-z\d])?$/i;
const META_NAME_REGEX = /^[a-z\d](?:[a-z\d._-]*[a-z\d])?$/i;
const RESERVED_NAMESPACE_LABELS = ["modelcontextprotocol", "mcp"];
const RESERVED_NAMESPACE_MESSAGE = 'Keys using the "modelcontextprotocol.*" or "mcp.*" namespaces are reserved by MCP and cannot be used.';
const META_NAME_RULES_MESSAGE = "Names must begin and end with an alphanumeric character and may only contain alphanumerics, hyphens (-), underscores (_), or dots (.) in between.";
const META_PREFIX_RULES_MESSAGE = "Prefixes must be dot-separated labels that start with a letter and end with a letter or digit (e.g. example.domain/).";
const getPrefixSegment = (key) => {
  const trimmedKey = key.trim();
  const slashIndex = trimmedKey.indexOf("/");
  if (slashIndex === -1) {
    return null;
  }
  return trimmedKey.slice(0, slashIndex);
};
const normalizeSegment = (segment) => {
  if (!segment) return null;
  let normalized = segment.trim().toLowerCase();
  if (!normalized) return null;
  const schemeIndex = normalized.indexOf("://");
  if (schemeIndex !== -1) {
    normalized = normalized.slice(schemeIndex + 3);
  }
  const stopChars = ["?", "#", ":"];
  let endIndex = normalized.length;
  stopChars.forEach((char) => {
    const idx = normalized.indexOf(char);
    if (idx !== -1 && idx < endIndex) {
      endIndex = idx;
    }
  });
  return normalized.slice(0, endIndex) || null;
};
const splitLabels = (segment) => {
  const normalized = normalizeSegment(segment);
  if (!normalized) return null;
  const labels = normalized.split(".");
  if (labels.length === 0 || labels.some((label) => !label || !META_PREFIX_LABEL_REGEX.test(label))) {
    return null;
  }
  return labels;
};
const isReservedMetaKey = (key) => {
  const trimmedKey = key.trim();
  if (!trimmedKey) {
    return false;
  }
  const candidateSegment = getPrefixSegment(trimmedKey) ?? trimmedKey;
  const labels = splitLabels(candidateSegment);
  if (!labels || labels.length < 2) {
    return false;
  }
  for (let i = 0; i < labels.length - 1; i += 1) {
    const current = labels[i];
    const next = labels[i + 1];
    if (RESERVED_NAMESPACE_LABELS.includes(current) && META_PREFIX_LABEL_REGEX.test(next)) {
      return true;
    }
  }
  return false;
};
const hasValidMetaPrefix = (key) => {
  const prefixSegment = getPrefixSegment(key);
  if (prefixSegment === null) {
    return true;
  }
  return splitLabels(prefixSegment) !== null;
};
const extractMetaName = (key) => {
  const trimmedKey = key.trim();
  if (!trimmedKey) return "";
  const slashIndex = trimmedKey.lastIndexOf("/");
  if (slashIndex === -1) {
    return trimmedKey;
  }
  return trimmedKey.slice(slashIndex + 1);
};
const hasValidMetaName = (key) => {
  const name2 = extractMetaName(key);
  if (!name2) return false;
  return META_NAME_REGEX.test(name2);
};
var util$3;
(function(util2) {
  util2.assertEqual = (_2) => {
  };
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items2) => {
    const obj = {};
    for (const item of items2) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k2) => typeof obj[obj[k2]] !== "number");
    const filtered = {};
    for (const k2 of validKeys) {
      filtered[k2] = obj[k2];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object2) => {
    const keys = [];
    for (const key in object2) {
      if (Object.prototype.hasOwnProperty.call(object2, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues(array2, separator = " | ") {
    return array2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_2, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util$3 || (util$3 = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util$3.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType = (data2) => {
  const t = typeof data2;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return Number.isNaN(data2) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data2)) {
        return ZodParsedType.array;
      }
      if (data2 === null) {
        return ZodParsedType.null;
      }
      if (data2.then && typeof data2.then === "function" && data2.catch && typeof data2.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data2 instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data2 instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data2 instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
const ZodIssueCode = util$3.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
class ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue2) {
      return issue2.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue2 of error.issues) {
        if (issue2.code === "invalid_union") {
          issue2.unionErrors.map(processError);
        } else if (issue2.code === "invalid_return_type") {
          processError(issue2.returnTypeError);
        } else if (issue2.code === "invalid_arguments") {
          processError(issue2.argumentsError);
        } else if (issue2.path.length === 0) {
          fieldErrors._errors.push(mapper(issue2));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue2.path.length) {
            const el2 = issue2.path[i];
            const terminal = i === issue2.path.length - 1;
            if (!terminal) {
              curr[el2] = curr[el2] || { _errors: [] };
            } else {
              curr[el2] = curr[el2] || { _errors: [] };
              curr[el2]._errors.push(mapper(issue2));
            }
            curr = curr[el2];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util$3.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue2) => issue2.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        const firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [];
        fieldErrors[firstEl].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
const errorMap = (issue2, _ctx) => {
  let message;
  switch (issue2.code) {
    case ZodIssueCode.invalid_type:
      if (issue2.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue2.expected}, received ${issue2.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue2.expected, util$3.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util$3.joinValues(issue2.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util$3.joinValues(issue2.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util$3.joinValues(issue2.options)}, received '${issue2.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue2.validation === "object") {
        if ("includes" in issue2.validation) {
          message = `Invalid input: must include "${issue2.validation.includes}"`;
          if (typeof issue2.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue2.validation.position}`;
          }
        } else if ("startsWith" in issue2.validation) {
          message = `Invalid input: must start with "${issue2.validation.startsWith}"`;
        } else if ("endsWith" in issue2.validation) {
          message = `Invalid input: must end with "${issue2.validation.endsWith}"`;
        } else {
          util$3.assertNever(issue2.validation);
        }
      } else if (issue2.validation !== "regex") {
        message = `Invalid ${issue2.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue2.type === "array")
        message = `Array must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `more than`} ${issue2.minimum} element(s)`;
      else if (issue2.type === "string")
        message = `String must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `over`} ${issue2.minimum} character(s)`;
      else if (issue2.type === "number")
        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
      else if (issue2.type === "bigint")
        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
      else if (issue2.type === "date")
        message = `Date must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue2.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue2.type === "array")
        message = `Array must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `less than`} ${issue2.maximum} element(s)`;
      else if (issue2.type === "string")
        message = `String must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `under`} ${issue2.maximum} character(s)`;
      else if (issue2.type === "number")
        message = `Number must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
      else if (issue2.type === "bigint")
        message = `BigInt must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
      else if (issue2.type === "date")
        message = `Date must be ${issue2.exact ? `exactly` : issue2.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue2.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue2.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util$3.assertNever(issue2);
  }
  return { message };
};
let overrideErrorMap = errorMap;
function getErrorMap() {
  return overrideErrorMap;
}
const makeIssue = (params) => {
  const { data: data2, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m2) => !!m2).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data: data2, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue2 = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap ? void 0 : errorMap
      // then global default map
    ].filter((x2) => !!x2)
  });
  ctx.common.issues.push(issue2);
}
class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s2 of results) {
      if (s2.status === "aborted")
        return INVALID;
      if (s2.status === "dirty")
        status.dirty();
      arrayValue.push(s2.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
const INVALID = Object.freeze({
  status: "aborted"
});
const DIRTY = (value) => ({ status: "dirty", value });
const OK = (value) => ({ status: "valid", value });
const isAborted = (x2) => x2.status === "aborted";
const isDirty = (x2) => x2.status === "dirty";
const isValid = (x2) => x2.status === "valid";
const isAsync = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
})(errorUtil || (errorUtil = {}));
class ParseInputLazyPath {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
const handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description: description2 } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description: description2 };
  const customMap = (iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description: description2 };
}
class ZodType {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data2, params) {
    const result = this.safeParse(data2, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data2, params) {
    const ctx = {
      common: {
        issues: [],
        async: params?.async ?? false,
        contextualErrorMap: params?.errorMap
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: data2,
      parsedType: getParsedType(data2)
    };
    const result = this._parseSync({ data: data2, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data2) {
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: data2,
      parsedType: getParsedType(data2)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data: data2, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if (err?.message?.toLowerCase()?.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data: data2, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data2, params) {
    const result = await this.safeParseAsync(data2, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data2, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params?.errorMap,
        async: true
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: data2,
      parsedType: getParsedType(data2)
    };
    const maybeAsyncResult = this._parse({ data: data2, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check2, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check2(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data2) => {
          if (!data2) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check2, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check2(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data2) => this["~validate"](data2)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform2) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform: transform2 }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description2) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description: description2
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[0-9a-z]+$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex = /^[a-z0-9_-]{21}$/i;
const jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex;
const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip2, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip2)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip2)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base642 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base642));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && decoded?.typ !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr(ip2, version2) {
  if ((version2 === "v4" || !version2) && ipv4CidrRegex.test(ip2)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6CidrRegex.test(ip2)) {
    return true;
  }
  return false;
}
class ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check2 of this._def.checks) {
      if (check2.kind === "min") {
        if (input.data.length < check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check2.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        if (input.data.length > check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check2.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "length") {
        const tooBig = input.data.length > check2.value;
        const tooSmall = input.data.length < check2.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check2.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check2.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check2.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check2.message
            });
          }
          status.dirty();
        }
      } else if (check2.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "regex") {
        check2.regex.lastIndex = 0;
        const testResult = check2.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "trim") {
        input.data = input.data.trim();
      } else if (check2.kind === "includes") {
        if (!input.data.includes(check2.value, check2.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check2.value, position: check2.position },
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check2.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check2.kind === "startsWith") {
        if (!input.data.startsWith(check2.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check2.value },
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "endsWith") {
        if (!input.data.endsWith(check2.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check2.value },
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "datetime") {
        const regex = datetimeRegex(check2);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "time") {
        const regex = timeRegex(check2);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "ip") {
        if (!isValidIP(input.data, check2.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "jwt") {
        if (!isValidJWT(input.data, check2.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "cidr") {
        if (!isValidCidr(input.data, check2.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else {
        util$3.assertNever(check2);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation2, message) {
    return this.refinement((data2) => regex.test(data2), {
      validation: validation2,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check2) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      offset: options?.offset ?? false,
      local: options?.local ?? false,
      ...errorUtil.errToObj(options?.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      ...errorUtil.errToObj(options?.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options?.position,
      ...errorUtil.errToObj(options?.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch2) => ch2.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch2) => ch2.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch2) => ch2.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch2) => ch2.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch2) => ch2.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch2) => ch2.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch2) => ch2.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch2) => ch2.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch2) => ch2.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch2) => ch2.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch2) => ch2.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch2) => ch2.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch2) => ch2.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch2) => ch2.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch2) => ch2.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch2) => ch2.kind === "base64url");
  }
  get minLength() {
    let min2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min2 === null || ch2.value > min2)
          min2 = ch2.value;
      }
    }
    return min2;
  }
  get maxLength() {
    let max2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max2 === null || ch2.value < max2)
          max2 = ch2.value;
      }
    }
    return max2;
  }
}
ZodString.create = (params) => {
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check2 of this._def.checks) {
      if (check2.kind === "int") {
        if (!util$3.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "min") {
        const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check2.value,
            type: "number",
            inclusive: check2.inclusive,
            exact: false,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check2.value,
            type: "number",
            inclusive: check2.inclusive,
            exact: false,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check2.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check2.value,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check2.message
          });
          status.dirty();
        }
      } else {
        util$3.assertNever(check2);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check2) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min2 === null || ch2.value > min2)
          min2 = ch2.value;
      }
    }
    return min2;
  }
  get maxValue() {
    let max2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max2 === null || ch2.value < max2)
          max2 = ch2.value;
      }
    }
    return max2;
  }
  get isInt() {
    return !!this._def.checks.find((ch2) => ch2.kind === "int" || ch2.kind === "multipleOf" && util$3.isInteger(ch2.value));
  }
  get isFinite() {
    let max2 = null;
    let min2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "finite" || ch2.kind === "int" || ch2.kind === "multipleOf") {
        return true;
      } else if (ch2.kind === "min") {
        if (min2 === null || ch2.value > min2)
          min2 = ch2.value;
      } else if (ch2.kind === "max") {
        if (max2 === null || ch2.value < max2)
          max2 = ch2.value;
      }
    }
    return Number.isFinite(min2) && Number.isFinite(max2);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};
class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check2 of this._def.checks) {
      if (check2.kind === "min") {
        const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check2.value,
            inclusive: check2.inclusive,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check2.value,
            inclusive: check2.inclusive,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "multipleOf") {
        if (input.data % check2.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check2.value,
            message: check2.message
          });
          status.dirty();
        }
      } else {
        util$3.assertNever(check2);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check2) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min2 === null || ch2.value > min2)
          min2 = ch2.value;
      }
    }
    return min2;
  }
  get maxValue() {
    let max2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max2 === null || ch2.value < max2)
          max2 = ch2.value;
      }
    }
    return max2;
  }
}
ZodBigInt.create = (params) => {
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};
class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check2 of this._def.checks) {
      if (check2.kind === "min") {
        if (input.data.getTime() < check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check2.message,
            inclusive: true,
            exact: false,
            minimum: check2.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        if (input.data.getTime() > check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check2.message,
            inclusive: true,
            exact: false,
            maximum: check2.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util$3.assertNever(check2);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check2) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min2 === null || ch2.value > min2)
          min2 = ch2.value;
      }
    }
    return min2 != null ? new Date(min2) : null;
  }
  get maxDate() {
    let max2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max2 === null || ch2.value < max2)
          max2 = ch2.value;
      }
    }
    return max2 != null ? new Date(max2) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: params?.coerce || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util$3.objectKeys(shape);
    this._cached = { shape, keys };
    return this._cached;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue2, ctx) => {
          const defaultError = this._def.errorMap?.(issue2, ctx).message ?? ctx.defaultError;
          if (issue2.code === "unrecognized_keys")
            return {
              message: errorUtil.errToObj(message).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index2) {
    return new ZodObject({
      ...this._def,
      catchall: index2
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util$3.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util$3.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util$3.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util$3.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util$3.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types2, params) => {
  return new ZodUnion({
    options: types2,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
function mergeValues(a2, b) {
  const aType = getParsedType(a2);
  const bType = getParsedType(b);
  if (a2 === b) {
    return { valid: true, data: a2 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util$3.objectKeys(b);
    const sharedKeys = util$3.objectKeys(a2).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a2, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a2[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a2.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index2 = 0; index2 < a2.length; index2++) {
      const itemA = a2[index2];
      const itemB = b[index2];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a2 === +b) {
    return { valid: true, data: a2 };
  } else {
    return { valid: false };
  }
}
class ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
class ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items2 = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x2) => !!x2);
    if (ctx.common.async) {
      return Promise.all(items2).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items2);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index2) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index2, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index2, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
class ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size2, message) {
    return this.min(size2, message).max(size2, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
class ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util$3.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
}
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
  _parse(input) {
    const nativeEnumValues = util$3.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util$3.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util$3.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(util$3.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util$3.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data2) => {
      return this._def.type.parseAsync(data2, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return INVALID;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return INVALID;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util$3.assertNever(effect);
  }
}
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess2, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess2 },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type2, params) => {
  return new ZodOptional({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type2, params) => {
  return new ZodNullable({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data2 = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data2 = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data: data2,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type2, params) => {
  return new ZodDefault({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type2, params) => {
  return new ZodCatch({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data2 = ctx.data;
    return this._def.type._parse({
      data: data2,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a2, b) {
    return new ZodPipeline({
      in: a2,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}
class ZodReadonly extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data2) => {
      if (isValid(data2)) {
        data2.value = Object.freeze(data2.value);
      }
      return data2;
    };
    return isAsync(result) ? result.then((data2) => freeze(data2)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodReadonly.create = (type2, params) => {
  return new ZodReadonly({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
ZodNever.create;
ZodArray.create;
const objectType = ZodObject.create;
ZodUnion.create;
ZodIntersection.create;
ZodTuple.create;
ZodEnum.create;
ZodPromise.create;
ZodOptional.create;
ZodNullable.create;
function isZ4Schema(s2) {
  const schema = s2;
  return !!schema._zod;
}
function safeParse(schema, data2) {
  if (isZ4Schema(schema)) {
    const result2 = safeParse$2(schema, data2);
    return result2;
  }
  const v3Schema = schema;
  const result = v3Schema.safeParse(data2);
  return result;
}
function getObjectShape(schema) {
  if (!schema)
    return void 0;
  let rawShape;
  if (isZ4Schema(schema)) {
    const v4Schema = schema;
    rawShape = v4Schema._zod?.def?.shape;
  } else {
    const v3Schema = schema;
    rawShape = v3Schema.shape;
  }
  if (!rawShape)
    return void 0;
  if (typeof rawShape === "function") {
    try {
      return rawShape();
    } catch {
      return void 0;
    }
  }
  return rawShape;
}
function getLiteralValue(schema) {
  if (isZ4Schema(schema)) {
    const v4Schema = schema;
    const def2 = v4Schema._zod?.def;
    if (def2) {
      if (def2.value !== void 0)
        return def2.value;
      if (Array.isArray(def2.values) && def2.values.length > 0) {
        return def2.values[0];
      }
    }
  }
  const v3Schema = schema;
  const def = v3Schema._def;
  if (def) {
    if (def.value !== void 0)
      return def.value;
    if (Array.isArray(def.values) && def.values.length > 0) {
      return def.values[0];
    }
  }
  const directValue = schema.value;
  if (directValue !== void 0)
    return directValue;
  return void 0;
}
function isTerminal(status) {
  return status === "completed" || status === "failed" || status === "cancelled";
}
new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
function getMethodLiteral(schema) {
  const shape = getObjectShape(schema);
  const methodSchema = shape?.method;
  if (!methodSchema) {
    throw new Error("Schema is missing a method literal");
  }
  const value = getLiteralValue(methodSchema);
  if (typeof value !== "string") {
    throw new Error("Schema method literal must be a string");
  }
  return value;
}
function parseWithCompat(schema, data2) {
  const result = safeParse(schema, data2);
  if (!result.success) {
    throw result.error;
  }
  return result.data;
}
const DEFAULT_REQUEST_TIMEOUT_MSEC = 6e4;
class Protocol {
  constructor(_options) {
    this._options = _options;
    this._requestMessageId = 0;
    this._requestHandlers = /* @__PURE__ */ new Map();
    this._requestHandlerAbortControllers = /* @__PURE__ */ new Map();
    this._notificationHandlers = /* @__PURE__ */ new Map();
    this._responseHandlers = /* @__PURE__ */ new Map();
    this._progressHandlers = /* @__PURE__ */ new Map();
    this._timeoutInfo = /* @__PURE__ */ new Map();
    this._pendingDebouncedNotifications = /* @__PURE__ */ new Set();
    this._taskProgressTokens = /* @__PURE__ */ new Map();
    this._requestResolvers = /* @__PURE__ */ new Map();
    this.setNotificationHandler(CancelledNotificationSchema, (notification) => {
      this._oncancel(notification);
    });
    this.setNotificationHandler(ProgressNotificationSchema, (notification) => {
      this._onprogress(notification);
    });
    this.setRequestHandler(
      PingRequestSchema,
      // Automatic pong by default.
      (_request) => ({})
    );
    this._taskStore = _options?.taskStore;
    this._taskMessageQueue = _options?.taskMessageQueue;
    if (this._taskStore) {
      this.setRequestHandler(GetTaskRequestSchema, async (request, extra) => {
        const task = await this._taskStore.getTask(request.params.taskId, extra.sessionId);
        if (!task) {
          throw new McpError(ErrorCode.InvalidParams, "Failed to retrieve task: Task not found");
        }
        return {
          ...task
        };
      });
      this.setRequestHandler(GetTaskPayloadRequestSchema, async (request, extra) => {
        const handleTaskResult = async () => {
          const taskId = request.params.taskId;
          if (this._taskMessageQueue) {
            let queuedMessage;
            while (queuedMessage = await this._taskMessageQueue.dequeue(taskId, extra.sessionId)) {
              if (queuedMessage.type === "response" || queuedMessage.type === "error") {
                const message = queuedMessage.message;
                const requestId = message.id;
                const resolver = this._requestResolvers.get(requestId);
                if (resolver) {
                  this._requestResolvers.delete(requestId);
                  if (queuedMessage.type === "response") {
                    resolver(message);
                  } else {
                    const errorMessage = message;
                    const error = new McpError(errorMessage.error.code, errorMessage.error.message, errorMessage.error.data);
                    resolver(error);
                  }
                } else {
                  const messageType = queuedMessage.type === "response" ? "Response" : "Error";
                  this._onerror(new Error(`${messageType} handler missing for request ${requestId}`));
                }
                continue;
              }
              await this._transport?.send(queuedMessage.message, { relatedRequestId: extra.requestId });
            }
          }
          const task = await this._taskStore.getTask(taskId, extra.sessionId);
          if (!task) {
            throw new McpError(ErrorCode.InvalidParams, `Task not found: ${taskId}`);
          }
          if (!isTerminal(task.status)) {
            await this._waitForTaskUpdate(taskId, extra.signal);
            return await handleTaskResult();
          }
          if (isTerminal(task.status)) {
            const result = await this._taskStore.getTaskResult(taskId, extra.sessionId);
            this._clearTaskQueue(taskId);
            return {
              ...result,
              _meta: {
                ...result._meta,
                [RELATED_TASK_META_KEY]: {
                  taskId
                }
              }
            };
          }
          return await handleTaskResult();
        };
        return await handleTaskResult();
      });
      this.setRequestHandler(ListTasksRequestSchema, async (request, extra) => {
        try {
          const { tasks, nextCursor } = await this._taskStore.listTasks(request.params?.cursor, extra.sessionId);
          return {
            tasks,
            nextCursor,
            _meta: {}
          };
        } catch (error) {
          throw new McpError(ErrorCode.InvalidParams, `Failed to list tasks: ${error instanceof Error ? error.message : String(error)}`);
        }
      });
      this.setRequestHandler(CancelTaskRequestSchema, async (request, extra) => {
        try {
          const task = await this._taskStore.getTask(request.params.taskId, extra.sessionId);
          if (!task) {
            throw new McpError(ErrorCode.InvalidParams, `Task not found: ${request.params.taskId}`);
          }
          if (isTerminal(task.status)) {
            throw new McpError(ErrorCode.InvalidParams, `Cannot cancel task in terminal status: ${task.status}`);
          }
          await this._taskStore.updateTaskStatus(request.params.taskId, "cancelled", "Client cancelled task execution.", extra.sessionId);
          this._clearTaskQueue(request.params.taskId);
          const cancelledTask = await this._taskStore.getTask(request.params.taskId, extra.sessionId);
          if (!cancelledTask) {
            throw new McpError(ErrorCode.InvalidParams, `Task not found after cancellation: ${request.params.taskId}`);
          }
          return {
            _meta: {},
            ...cancelledTask
          };
        } catch (error) {
          if (error instanceof McpError) {
            throw error;
          }
          throw new McpError(ErrorCode.InvalidRequest, `Failed to cancel task: ${error instanceof Error ? error.message : String(error)}`);
        }
      });
    }
  }
  async _oncancel(notification) {
    if (!notification.params.requestId) {
      return;
    }
    const controller = this._requestHandlerAbortControllers.get(notification.params.requestId);
    controller?.abort(notification.params.reason);
  }
  _setupTimeout(messageId, timeout, maxTotalTimeout, onTimeout, resetTimeoutOnProgress = false) {
    this._timeoutInfo.set(messageId, {
      timeoutId: setTimeout(onTimeout, timeout),
      startTime: Date.now(),
      timeout,
      maxTotalTimeout,
      resetTimeoutOnProgress,
      onTimeout
    });
  }
  _resetTimeout(messageId) {
    const info = this._timeoutInfo.get(messageId);
    if (!info)
      return false;
    const totalElapsed = Date.now() - info.startTime;
    if (info.maxTotalTimeout && totalElapsed >= info.maxTotalTimeout) {
      this._timeoutInfo.delete(messageId);
      throw McpError.fromError(ErrorCode.RequestTimeout, "Maximum total timeout exceeded", {
        maxTotalTimeout: info.maxTotalTimeout,
        totalElapsed
      });
    }
    clearTimeout(info.timeoutId);
    info.timeoutId = setTimeout(info.onTimeout, info.timeout);
    return true;
  }
  _cleanupTimeout(messageId) {
    const info = this._timeoutInfo.get(messageId);
    if (info) {
      clearTimeout(info.timeoutId);
      this._timeoutInfo.delete(messageId);
    }
  }
  /**
   * Attaches to the given transport, starts it, and starts listening for messages.
   *
   * The Protocol object assumes ownership of the Transport, replacing any callbacks that have already been set, and expects that it is the only user of the Transport instance going forward.
   */
  async connect(transport) {
    if (this._transport) {
      throw new Error("Already connected to a transport. Call close() before connecting to a new transport, or use a separate Protocol instance per connection.");
    }
    this._transport = transport;
    const _onclose = this.transport?.onclose;
    this._transport.onclose = () => {
      _onclose?.();
      this._onclose();
    };
    const _onerror = this.transport?.onerror;
    this._transport.onerror = (error) => {
      _onerror?.(error);
      this._onerror(error);
    };
    const _onmessage = this._transport?.onmessage;
    this._transport.onmessage = (message, extra) => {
      _onmessage?.(message, extra);
      if (isJSONRPCResultResponse(message) || isJSONRPCErrorResponse(message)) {
        this._onresponse(message);
      } else if (isJSONRPCRequest(message)) {
        this._onrequest(message, extra);
      } else if (isJSONRPCNotification(message)) {
        this._onnotification(message);
      } else {
        this._onerror(new Error(`Unknown message type: ${JSON.stringify(message)}`));
      }
    };
    await this._transport.start();
  }
  _onclose() {
    const responseHandlers = this._responseHandlers;
    this._responseHandlers = /* @__PURE__ */ new Map();
    this._progressHandlers.clear();
    this._taskProgressTokens.clear();
    this._pendingDebouncedNotifications.clear();
    for (const controller of this._requestHandlerAbortControllers.values()) {
      controller.abort();
    }
    this._requestHandlerAbortControllers.clear();
    const error = McpError.fromError(ErrorCode.ConnectionClosed, "Connection closed");
    this._transport = void 0;
    this.onclose?.();
    for (const handler of responseHandlers.values()) {
      handler(error);
    }
  }
  _onerror(error) {
    this.onerror?.(error);
  }
  _onnotification(notification) {
    const handler = this._notificationHandlers.get(notification.method) ?? this.fallbackNotificationHandler;
    if (handler === void 0) {
      return;
    }
    Promise.resolve().then(() => handler(notification)).catch((error) => this._onerror(new Error(`Uncaught error in notification handler: ${error}`)));
  }
  _onrequest(request, extra) {
    const handler = this._requestHandlers.get(request.method) ?? this.fallbackRequestHandler;
    const capturedTransport = this._transport;
    const relatedTaskId = request.params?._meta?.[RELATED_TASK_META_KEY]?.taskId;
    if (handler === void 0) {
      const errorResponse = {
        jsonrpc: "2.0",
        id: request.id,
        error: {
          code: ErrorCode.MethodNotFound,
          message: "Method not found"
        }
      };
      if (relatedTaskId && this._taskMessageQueue) {
        this._enqueueTaskMessage(relatedTaskId, {
          type: "error",
          message: errorResponse,
          timestamp: Date.now()
        }, capturedTransport?.sessionId).catch((error) => this._onerror(new Error(`Failed to enqueue error response: ${error}`)));
      } else {
        capturedTransport?.send(errorResponse).catch((error) => this._onerror(new Error(`Failed to send an error response: ${error}`)));
      }
      return;
    }
    const abortController = new AbortController();
    this._requestHandlerAbortControllers.set(request.id, abortController);
    const taskCreationParams = isTaskAugmentedRequestParams(request.params) ? request.params.task : void 0;
    const taskStore = this._taskStore ? this.requestTaskStore(request, capturedTransport?.sessionId) : void 0;
    const fullExtra = {
      signal: abortController.signal,
      sessionId: capturedTransport?.sessionId,
      _meta: request.params?._meta,
      sendNotification: async (notification) => {
        if (abortController.signal.aborted)
          return;
        const notificationOptions = { relatedRequestId: request.id };
        if (relatedTaskId) {
          notificationOptions.relatedTask = { taskId: relatedTaskId };
        }
        await this.notification(notification, notificationOptions);
      },
      sendRequest: async (r2, resultSchema, options) => {
        if (abortController.signal.aborted) {
          throw new McpError(ErrorCode.ConnectionClosed, "Request was cancelled");
        }
        const requestOptions = { ...options, relatedRequestId: request.id };
        if (relatedTaskId && !requestOptions.relatedTask) {
          requestOptions.relatedTask = { taskId: relatedTaskId };
        }
        const effectiveTaskId = requestOptions.relatedTask?.taskId ?? relatedTaskId;
        if (effectiveTaskId && taskStore) {
          await taskStore.updateTaskStatus(effectiveTaskId, "input_required");
        }
        return await this.request(r2, resultSchema, requestOptions);
      },
      authInfo: extra?.authInfo,
      requestId: request.id,
      requestInfo: extra?.requestInfo,
      taskId: relatedTaskId,
      taskStore,
      taskRequestedTtl: taskCreationParams?.ttl,
      closeSSEStream: extra?.closeSSEStream,
      closeStandaloneSSEStream: extra?.closeStandaloneSSEStream
    };
    Promise.resolve().then(() => {
      if (taskCreationParams) {
        this.assertTaskHandlerCapability(request.method);
      }
    }).then(() => handler(request, fullExtra)).then(async (result) => {
      if (abortController.signal.aborted) {
        return;
      }
      const response = {
        result,
        jsonrpc: "2.0",
        id: request.id
      };
      if (relatedTaskId && this._taskMessageQueue) {
        await this._enqueueTaskMessage(relatedTaskId, {
          type: "response",
          message: response,
          timestamp: Date.now()
        }, capturedTransport?.sessionId);
      } else {
        await capturedTransport?.send(response);
      }
    }, async (error) => {
      if (abortController.signal.aborted) {
        return;
      }
      const errorResponse = {
        jsonrpc: "2.0",
        id: request.id,
        error: {
          code: Number.isSafeInteger(error["code"]) ? error["code"] : ErrorCode.InternalError,
          message: error.message ?? "Internal error",
          ...error["data"] !== void 0 && { data: error["data"] }
        }
      };
      if (relatedTaskId && this._taskMessageQueue) {
        await this._enqueueTaskMessage(relatedTaskId, {
          type: "error",
          message: errorResponse,
          timestamp: Date.now()
        }, capturedTransport?.sessionId);
      } else {
        await capturedTransport?.send(errorResponse);
      }
    }).catch((error) => this._onerror(new Error(`Failed to send response: ${error}`))).finally(() => {
      this._requestHandlerAbortControllers.delete(request.id);
    });
  }
  _onprogress(notification) {
    const { progressToken, ...params } = notification.params;
    const messageId = Number(progressToken);
    const handler = this._progressHandlers.get(messageId);
    if (!handler) {
      this._onerror(new Error(`Received a progress notification for an unknown token: ${JSON.stringify(notification)}`));
      return;
    }
    const responseHandler = this._responseHandlers.get(messageId);
    const timeoutInfo = this._timeoutInfo.get(messageId);
    if (timeoutInfo && responseHandler && timeoutInfo.resetTimeoutOnProgress) {
      try {
        this._resetTimeout(messageId);
      } catch (error) {
        this._responseHandlers.delete(messageId);
        this._progressHandlers.delete(messageId);
        this._cleanupTimeout(messageId);
        responseHandler(error);
        return;
      }
    }
    handler(params);
  }
  _onresponse(response) {
    const messageId = Number(response.id);
    const resolver = this._requestResolvers.get(messageId);
    if (resolver) {
      this._requestResolvers.delete(messageId);
      if (isJSONRPCResultResponse(response)) {
        resolver(response);
      } else {
        const error = new McpError(response.error.code, response.error.message, response.error.data);
        resolver(error);
      }
      return;
    }
    const handler = this._responseHandlers.get(messageId);
    if (handler === void 0) {
      this._onerror(new Error(`Received a response for an unknown message ID: ${JSON.stringify(response)}`));
      return;
    }
    this._responseHandlers.delete(messageId);
    this._cleanupTimeout(messageId);
    let isTaskResponse = false;
    if (isJSONRPCResultResponse(response) && response.result && typeof response.result === "object") {
      const result = response.result;
      if (result.task && typeof result.task === "object") {
        const task = result.task;
        if (typeof task.taskId === "string") {
          isTaskResponse = true;
          this._taskProgressTokens.set(task.taskId, messageId);
        }
      }
    }
    if (!isTaskResponse) {
      this._progressHandlers.delete(messageId);
    }
    if (isJSONRPCResultResponse(response)) {
      handler(response);
    } else {
      const error = McpError.fromError(response.error.code, response.error.message, response.error.data);
      handler(error);
    }
  }
  get transport() {
    return this._transport;
  }
  /**
   * Closes the connection.
   */
  async close() {
    await this._transport?.close();
  }
  /**
   * Sends a request and returns an AsyncGenerator that yields response messages.
   * The generator is guaranteed to end with either a 'result' or 'error' message.
   *
   * @example
   * ```typescript
   * const stream = protocol.requestStream(request, resultSchema, options);
   * for await (const message of stream) {
   *   switch (message.type) {
   *     case 'taskCreated':
   *       console.log('Task created:', message.task.taskId);
   *       break;
   *     case 'taskStatus':
   *       console.log('Task status:', message.task.status);
   *       break;
   *     case 'result':
   *       console.log('Final result:', message.result);
   *       break;
   *     case 'error':
   *       console.error('Error:', message.error);
   *       break;
   *   }
   * }
   * ```
   *
   * @experimental Use `client.experimental.tasks.requestStream()` to access this method.
   */
  async *requestStream(request, resultSchema, options) {
    const { task } = options ?? {};
    if (!task) {
      try {
        const result = await this.request(request, resultSchema, options);
        yield { type: "result", result };
      } catch (error) {
        yield {
          type: "error",
          error: error instanceof McpError ? error : new McpError(ErrorCode.InternalError, String(error))
        };
      }
      return;
    }
    let taskId;
    try {
      const createResult = await this.request(request, CreateTaskResultSchema, options);
      if (createResult.task) {
        taskId = createResult.task.taskId;
        yield { type: "taskCreated", task: createResult.task };
      } else {
        throw new McpError(ErrorCode.InternalError, "Task creation did not return a task");
      }
      while (true) {
        const task2 = await this.getTask({ taskId }, options);
        yield { type: "taskStatus", task: task2 };
        if (isTerminal(task2.status)) {
          if (task2.status === "completed") {
            const result = await this.getTaskResult({ taskId }, resultSchema, options);
            yield { type: "result", result };
          } else if (task2.status === "failed") {
            yield {
              type: "error",
              error: new McpError(ErrorCode.InternalError, `Task ${taskId} failed`)
            };
          } else if (task2.status === "cancelled") {
            yield {
              type: "error",
              error: new McpError(ErrorCode.InternalError, `Task ${taskId} was cancelled`)
            };
          }
          return;
        }
        if (task2.status === "input_required") {
          const result = await this.getTaskResult({ taskId }, resultSchema, options);
          yield { type: "result", result };
          return;
        }
        const pollInterval = task2.pollInterval ?? this._options?.defaultTaskPollInterval ?? 1e3;
        await new Promise((resolve2) => setTimeout(resolve2, pollInterval));
        options?.signal?.throwIfAborted();
      }
    } catch (error) {
      yield {
        type: "error",
        error: error instanceof McpError ? error : new McpError(ErrorCode.InternalError, String(error))
      };
    }
  }
  /**
   * Sends a request and waits for a response.
   *
   * Do not use this method to emit notifications! Use notification() instead.
   */
  request(request, resultSchema, options) {
    const { relatedRequestId, resumptionToken, onresumptiontoken, task, relatedTask } = options ?? {};
    return new Promise((resolve2, reject) => {
      const earlyReject = (error) => {
        reject(error);
      };
      if (!this._transport) {
        earlyReject(new Error("Not connected"));
        return;
      }
      if (this._options?.enforceStrictCapabilities === true) {
        try {
          this.assertCapabilityForMethod(request.method);
          if (task) {
            this.assertTaskCapability(request.method);
          }
        } catch (e) {
          earlyReject(e);
          return;
        }
      }
      options?.signal?.throwIfAborted();
      const messageId = this._requestMessageId++;
      const jsonrpcRequest = {
        ...request,
        jsonrpc: "2.0",
        id: messageId
      };
      if (options?.onprogress) {
        this._progressHandlers.set(messageId, options.onprogress);
        jsonrpcRequest.params = {
          ...request.params,
          _meta: {
            ...request.params?._meta || {},
            progressToken: messageId
          }
        };
      }
      if (task) {
        jsonrpcRequest.params = {
          ...jsonrpcRequest.params,
          task
        };
      }
      if (relatedTask) {
        jsonrpcRequest.params = {
          ...jsonrpcRequest.params,
          _meta: {
            ...jsonrpcRequest.params?._meta || {},
            [RELATED_TASK_META_KEY]: relatedTask
          }
        };
      }
      const cancel = (reason) => {
        this._responseHandlers.delete(messageId);
        this._progressHandlers.delete(messageId);
        this._cleanupTimeout(messageId);
        this._transport?.send({
          jsonrpc: "2.0",
          method: "notifications/cancelled",
          params: {
            requestId: messageId,
            reason: String(reason)
          }
        }, { relatedRequestId, resumptionToken, onresumptiontoken }).catch((error2) => this._onerror(new Error(`Failed to send cancellation: ${error2}`)));
        const error = reason instanceof McpError ? reason : new McpError(ErrorCode.RequestTimeout, String(reason));
        reject(error);
      };
      this._responseHandlers.set(messageId, (response) => {
        if (options?.signal?.aborted) {
          return;
        }
        if (response instanceof Error) {
          return reject(response);
        }
        try {
          const parseResult = safeParse(resultSchema, response.result);
          if (!parseResult.success) {
            reject(parseResult.error);
          } else {
            resolve2(parseResult.data);
          }
        } catch (error) {
          reject(error);
        }
      });
      options?.signal?.addEventListener("abort", () => {
        cancel(options?.signal?.reason);
      });
      const timeout = options?.timeout ?? DEFAULT_REQUEST_TIMEOUT_MSEC;
      const timeoutHandler = () => cancel(McpError.fromError(ErrorCode.RequestTimeout, "Request timed out", { timeout }));
      this._setupTimeout(messageId, timeout, options?.maxTotalTimeout, timeoutHandler, options?.resetTimeoutOnProgress ?? false);
      const relatedTaskId = relatedTask?.taskId;
      if (relatedTaskId) {
        const responseResolver = (response) => {
          const handler = this._responseHandlers.get(messageId);
          if (handler) {
            handler(response);
          } else {
            this._onerror(new Error(`Response handler missing for side-channeled request ${messageId}`));
          }
        };
        this._requestResolvers.set(messageId, responseResolver);
        this._enqueueTaskMessage(relatedTaskId, {
          type: "request",
          message: jsonrpcRequest,
          timestamp: Date.now()
        }).catch((error) => {
          this._cleanupTimeout(messageId);
          reject(error);
        });
      } else {
        this._transport.send(jsonrpcRequest, { relatedRequestId, resumptionToken, onresumptiontoken }).catch((error) => {
          this._cleanupTimeout(messageId);
          reject(error);
        });
      }
    });
  }
  /**
   * Gets the current status of a task.
   *
   * @experimental Use `client.experimental.tasks.getTask()` to access this method.
   */
  async getTask(params, options) {
    return this.request({ method: "tasks/get", params }, GetTaskResultSchema, options);
  }
  /**
   * Retrieves the result of a completed task.
   *
   * @experimental Use `client.experimental.tasks.getTaskResult()` to access this method.
   */
  async getTaskResult(params, resultSchema, options) {
    return this.request({ method: "tasks/result", params }, resultSchema, options);
  }
  /**
   * Lists tasks, optionally starting from a pagination cursor.
   *
   * @experimental Use `client.experimental.tasks.listTasks()` to access this method.
   */
  async listTasks(params, options) {
    return this.request({ method: "tasks/list", params }, ListTasksResultSchema, options);
  }
  /**
   * Cancels a specific task.
   *
   * @experimental Use `client.experimental.tasks.cancelTask()` to access this method.
   */
  async cancelTask(params, options) {
    return this.request({ method: "tasks/cancel", params }, CancelTaskResultSchema, options);
  }
  /**
   * Emits a notification, which is a one-way message that does not expect a response.
   */
  async notification(notification, options) {
    if (!this._transport) {
      throw new Error("Not connected");
    }
    this.assertNotificationCapability(notification.method);
    const relatedTaskId = options?.relatedTask?.taskId;
    if (relatedTaskId) {
      const jsonrpcNotification2 = {
        ...notification,
        jsonrpc: "2.0",
        params: {
          ...notification.params,
          _meta: {
            ...notification.params?._meta || {},
            [RELATED_TASK_META_KEY]: options.relatedTask
          }
        }
      };
      await this._enqueueTaskMessage(relatedTaskId, {
        type: "notification",
        message: jsonrpcNotification2,
        timestamp: Date.now()
      });
      return;
    }
    const debouncedMethods = this._options?.debouncedNotificationMethods ?? [];
    const canDebounce = debouncedMethods.includes(notification.method) && !notification.params && !options?.relatedRequestId && !options?.relatedTask;
    if (canDebounce) {
      if (this._pendingDebouncedNotifications.has(notification.method)) {
        return;
      }
      this._pendingDebouncedNotifications.add(notification.method);
      Promise.resolve().then(() => {
        this._pendingDebouncedNotifications.delete(notification.method);
        if (!this._transport) {
          return;
        }
        let jsonrpcNotification2 = {
          ...notification,
          jsonrpc: "2.0"
        };
        if (options?.relatedTask) {
          jsonrpcNotification2 = {
            ...jsonrpcNotification2,
            params: {
              ...jsonrpcNotification2.params,
              _meta: {
                ...jsonrpcNotification2.params?._meta || {},
                [RELATED_TASK_META_KEY]: options.relatedTask
              }
            }
          };
        }
        this._transport?.send(jsonrpcNotification2, options).catch((error) => this._onerror(error));
      });
      return;
    }
    let jsonrpcNotification = {
      ...notification,
      jsonrpc: "2.0"
    };
    if (options?.relatedTask) {
      jsonrpcNotification = {
        ...jsonrpcNotification,
        params: {
          ...jsonrpcNotification.params,
          _meta: {
            ...jsonrpcNotification.params?._meta || {},
            [RELATED_TASK_META_KEY]: options.relatedTask
          }
        }
      };
    }
    await this._transport.send(jsonrpcNotification, options);
  }
  /**
   * Registers a handler to invoke when this protocol object receives a request with the given method.
   *
   * Note that this will replace any previous request handler for the same method.
   */
  setRequestHandler(requestSchema, handler) {
    const method = getMethodLiteral(requestSchema);
    this.assertRequestHandlerCapability(method);
    this._requestHandlers.set(method, (request, extra) => {
      const parsed = parseWithCompat(requestSchema, request);
      return Promise.resolve(handler(parsed, extra));
    });
  }
  /**
   * Removes the request handler for the given method.
   */
  removeRequestHandler(method) {
    this._requestHandlers.delete(method);
  }
  /**
   * Asserts that a request handler has not already been set for the given method, in preparation for a new one being automatically installed.
   */
  assertCanSetRequestHandler(method) {
    if (this._requestHandlers.has(method)) {
      throw new Error(`A request handler for ${method} already exists, which would be overridden`);
    }
  }
  /**
   * Registers a handler to invoke when this protocol object receives a notification with the given method.
   *
   * Note that this will replace any previous notification handler for the same method.
   */
  setNotificationHandler(notificationSchema, handler) {
    const method = getMethodLiteral(notificationSchema);
    this._notificationHandlers.set(method, (notification) => {
      const parsed = parseWithCompat(notificationSchema, notification);
      return Promise.resolve(handler(parsed));
    });
  }
  /**
   * Removes the notification handler for the given method.
   */
  removeNotificationHandler(method) {
    this._notificationHandlers.delete(method);
  }
  /**
   * Cleans up the progress handler associated with a task.
   * This should be called when a task reaches a terminal status.
   */
  _cleanupTaskProgressHandler(taskId) {
    const progressToken = this._taskProgressTokens.get(taskId);
    if (progressToken !== void 0) {
      this._progressHandlers.delete(progressToken);
      this._taskProgressTokens.delete(taskId);
    }
  }
  /**
   * Enqueues a task-related message for side-channel delivery via tasks/result.
   * @param taskId The task ID to associate the message with
   * @param message The message to enqueue
   * @param sessionId Optional session ID for binding the operation to a specific session
   * @throws Error if taskStore is not configured or if enqueue fails (e.g., queue overflow)
   *
   * Note: If enqueue fails, it's the TaskMessageQueue implementation's responsibility to handle
   * the error appropriately (e.g., by failing the task, logging, etc.). The Protocol layer
   * simply propagates the error.
   */
  async _enqueueTaskMessage(taskId, message, sessionId) {
    if (!this._taskStore || !this._taskMessageQueue) {
      throw new Error("Cannot enqueue task message: taskStore and taskMessageQueue are not configured");
    }
    const maxQueueSize = this._options?.maxTaskQueueSize;
    await this._taskMessageQueue.enqueue(taskId, message, sessionId, maxQueueSize);
  }
  /**
   * Clears the message queue for a task and rejects any pending request resolvers.
   * @param taskId The task ID whose queue should be cleared
   * @param sessionId Optional session ID for binding the operation to a specific session
   */
  async _clearTaskQueue(taskId, sessionId) {
    if (this._taskMessageQueue) {
      const messages = await this._taskMessageQueue.dequeueAll(taskId, sessionId);
      for (const message of messages) {
        if (message.type === "request" && isJSONRPCRequest(message.message)) {
          const requestId = message.message.id;
          const resolver = this._requestResolvers.get(requestId);
          if (resolver) {
            resolver(new McpError(ErrorCode.InternalError, "Task cancelled or completed"));
            this._requestResolvers.delete(requestId);
          } else {
            this._onerror(new Error(`Resolver missing for request ${requestId} during task ${taskId} cleanup`));
          }
        }
      }
    }
  }
  /**
   * Waits for a task update (new messages or status change) with abort signal support.
   * Uses polling to check for updates at the task's configured poll interval.
   * @param taskId The task ID to wait for
   * @param signal Abort signal to cancel the wait
   * @returns Promise that resolves when an update occurs or rejects if aborted
   */
  async _waitForTaskUpdate(taskId, signal) {
    let interval = this._options?.defaultTaskPollInterval ?? 1e3;
    try {
      const task = await this._taskStore?.getTask(taskId);
      if (task?.pollInterval) {
        interval = task.pollInterval;
      }
    } catch {
    }
    return new Promise((resolve2, reject) => {
      if (signal.aborted) {
        reject(new McpError(ErrorCode.InvalidRequest, "Request cancelled"));
        return;
      }
      const timeoutId = setTimeout(resolve2, interval);
      signal.addEventListener("abort", () => {
        clearTimeout(timeoutId);
        reject(new McpError(ErrorCode.InvalidRequest, "Request cancelled"));
      }, { once: true });
    });
  }
  requestTaskStore(request, sessionId) {
    const taskStore = this._taskStore;
    if (!taskStore) {
      throw new Error("No task store configured");
    }
    return {
      createTask: async (taskParams) => {
        if (!request) {
          throw new Error("No request provided");
        }
        return await taskStore.createTask(taskParams, request.id, {
          method: request.method,
          params: request.params
        }, sessionId);
      },
      getTask: async (taskId) => {
        const task = await taskStore.getTask(taskId, sessionId);
        if (!task) {
          throw new McpError(ErrorCode.InvalidParams, "Failed to retrieve task: Task not found");
        }
        return task;
      },
      storeTaskResult: async (taskId, status, result) => {
        await taskStore.storeTaskResult(taskId, status, result, sessionId);
        const task = await taskStore.getTask(taskId, sessionId);
        if (task) {
          const notification = TaskStatusNotificationSchema.parse({
            method: "notifications/tasks/status",
            params: task
          });
          await this.notification(notification);
          if (isTerminal(task.status)) {
            this._cleanupTaskProgressHandler(taskId);
          }
        }
      },
      getTaskResult: (taskId) => {
        return taskStore.getTaskResult(taskId, sessionId);
      },
      updateTaskStatus: async (taskId, status, statusMessage) => {
        const task = await taskStore.getTask(taskId, sessionId);
        if (!task) {
          throw new McpError(ErrorCode.InvalidParams, `Task "${taskId}" not found - it may have been cleaned up`);
        }
        if (isTerminal(task.status)) {
          throw new McpError(ErrorCode.InvalidParams, `Cannot update task "${taskId}" from terminal status "${task.status}" to "${status}". Terminal states (completed, failed, cancelled) cannot transition to other states.`);
        }
        await taskStore.updateTaskStatus(taskId, status, statusMessage, sessionId);
        const updatedTask = await taskStore.getTask(taskId, sessionId);
        if (updatedTask) {
          const notification = TaskStatusNotificationSchema.parse({
            method: "notifications/tasks/status",
            params: updatedTask
          });
          await this.notification(notification);
          if (isTerminal(updatedTask.status)) {
            this._cleanupTaskProgressHandler(taskId);
          }
        }
      },
      listTasks: (cursor) => {
        return taskStore.listTasks(cursor, sessionId);
      }
    };
  }
}
function isPlainObject(value) {
  return value !== null && typeof value === "object" && !Array.isArray(value);
}
function mergeCapabilities(base, additional) {
  const result = { ...base };
  for (const key in additional) {
    const k2 = key;
    const addValue = additional[k2];
    if (addValue === void 0)
      continue;
    const baseValue = result[k2];
    if (isPlainObject(baseValue) && isPlainObject(addValue)) {
      result[k2] = { ...baseValue, ...addValue };
    } else {
      result[k2] = addValue;
    }
  }
  return result;
}
var RI = Object.defineProperty;
var s = (r2, i) => {
  for (var o in i) RI(r2, o, { get: i[o], enumerable: true, configurable: true, set: (t) => i[o] = () => t });
};
var g = {};
s(g, { xor: () => $I, xid: () => Wl$1, void: () => rI, uuidv7: () => Sl$1, uuidv6: () => Ol$1, uuidv4: () => Nl$1, uuid: () => wl$1, util: () => k$3, url: () => zl$1, uppercase: () => Yr$1, unknown: () => Nr$1, union: () => lv$1, undefined: () => pl$1, ulid: () => Gl$1, uint64: () => hl$1, uint32: () => Cl$1, tuple: () => Fg$1, trim: () => Hr$1, treeifyError: () => Av$1, transform: () => cv$1, toUpperCase: () => mr$1, toLowerCase: () => Mr$1, toJSONSchema: () => Fi$1, templateLiteral: () => NI, symbol: () => al$1, superRefine: () => le$2, success: () => DI, stringbool: () => EI, stringFormat: () => Hl$1, string: () => Ri$1, strictObject: () => oI, startsWith: () => Tr$1, slugify: () => Rr$1, size: () => Dr$1, setErrorMap: () => Yc$1, set: () => II, safeParseAsync: () => Ig$1, safeParse: () => lg$1, safeEncodeAsync: () => wg$1, safeEncode: () => Dg$1, safeDecodeAsync: () => Ng$1, safeDecode: () => kg$1, registry: () => gi$1, regexes: () => x$1, regex: () => Vr$1, refine: () => ee$2, record: () => qg$1, readonly: () => ve$1, property: () => Ki$1, promise: () => OI, prettifyError: () => Vv$1, preprocess: () => WI, prefault: () => hg$1, positive: () => Wi$1, pipe: () => Gn$1, partialRecord: () => gI, parseAsync: () => eg$1, parse: () => gg$1, overwrite: () => d, optional: () => Ln$1, object: () => vI, number: () => Sg$1, nullish: () => UI, nullable: () => En$1, null: () => Lg$1, normalize: () => Br$1, nonpositive: () => Ai$1, nonoptional: () => ag$1, nonnegative: () => Vi$1, never: () => ev$1, negative: () => Xi$1, nativeEnum: () => cI, nanoid: () => Jl$1, nan: () => kI, multipleOf: () => ur, minSize: () => a, minLength: () => nr, mime: () => qr$1, meta: () => JI, maxSize: () => gr$1, maxLength: () => kr$1, map: () => lI, mac: () => Vl$1, lte: () => m$2, lt: () => y$1, lowercase: () => Kr$1, looseRecord: () => eI, looseObject: () => tI, locales: () => Sn$1, literal: () => _I, length: () => wr$1, lazy: () => $e$1, ksuid: () => Xl$1, keyof: () => iI, jwt: () => Bl$1, json: () => GI, iso: () => dr, ipv6: () => Kl$1, ipv4: () => Al$1, intersection: () => Qg$1, int64: () => yl$1, int32: () => dl$1, int: () => xi$1, instanceof: () => LI, includes: () => Qr$1, httpUrl: () => Pl$1, hostname: () => Ml$1, hex: () => ml$1, hash: () => Rl$1, guid: () => kl$1, gte: () => Q, gt: () => h$1, globalRegistry: () => V, getErrorMap: () => Qc$1, function: () => SI, fromJSONSchema: () => AI, formatError: () => ln$1, float64: () => Zl$1, float32: () => xl$1, flattenError: () => en$1, file: () => bI, exactOptional: () => Zg$1, enum: () => Iv$1, endsWith: () => Fr$1, encodeAsync: () => bg$1, encode: () => cg$1, emoji: () => jl$1, email: () => Dl$1, e164: () => ql$1, discriminatedUnion: () => uI, describe: () => jI, decodeAsync: () => Ug$1, decode: () => _g$1, date: () => nI, custom: () => PI, cuid2: () => El$1, cuid: () => Ll$1, core: () => ir, config: () => A$1, coerce: () => ce$1, codec: () => wI, clone: () => Y$2, cidrv6: () => Ql$1, cidrv4: () => Yl$1, check: () => zI, catch: () => re$1, boolean: () => zg$1, bigint: () => fl$1, base64url: () => Fl$1, base64: () => Tl$1, array: () => An$1, any: () => sl$1, _function: () => SI, _default: () => fg$1, _ZodString: () => Zi$1, ZodXor: () => Vg$1, ZodXID: () => pi$1, ZodVoid: () => Xg$1, ZodUnknown: () => Gg$1, ZodUnion: () => Kn$1, ZodUndefined: () => jg$1, ZodUUID: () => p$2, ZodURL: () => Wn$1, ZodULID: () => ai$1, ZodType: () => P$1, ZodTuple: () => Tg$1, ZodTransform: () => Rg$1, ZodTemplateLiteral: () => oe, ZodSymbol: () => Pg$1, ZodSuccess: () => pg$1, ZodStringFormat: () => G$1, ZodString: () => fr$1, ZodSet: () => Hg$1, ZodRecord: () => Yn$1, ZodRealError: () => H$2, ZodReadonly: () => ie$1, ZodPromise: () => ue$2, ZodPrefault: () => yg$1, ZodPipe: () => Uv$1, ZodOptional: () => _v$1, ZodObject: () => Vn$1, ZodNumberFormat: () => Or$1, ZodNumber: () => hr$1, ZodNullable: () => dg$1, ZodNull: () => Jg$1, ZodNonOptional: () => bv$1, ZodNever: () => Wg$1, ZodNanoID: () => fi$1, ZodNaN: () => ne, ZodMap: () => Bg$1, ZodMAC: () => Og$1, ZodLiteral: () => Mg$1, ZodLazy: () => te, ZodKSUID: () => si, ZodJWT: () => uv$1, ZodIssueCode: () => Kc$1, ZodIntersection: () => Yg$1, ZodISOTime: () => Mi$1, ZodISODuration: () => mi$1, ZodISODateTime: () => Bi$1, ZodISODate: () => Hi$1, ZodIPv6: () => nv$1, ZodIPv4: () => rv$1, ZodGUID: () => Jn$1, ZodFunction: () => ge, ZodFirstPartyTypeKind: () => Ie$2, ZodFile: () => mg$1, ZodExactOptional: () => xg$1, ZodError: () => Ac$1, ZodEnum: () => Cr$1, ZodEmoji: () => Ci$1, ZodEmail: () => di$1, ZodE164: () => $v$1, ZodDiscriminatedUnion: () => Kg$1, ZodDefault: () => Cg$1, ZodDate: () => Xn$1, ZodCustomStringFormat: () => yr, ZodCustom: () => Qn$1, ZodCodec: () => Dv$1, ZodCatch: () => sg$1, ZodCUID2: () => hi$1, ZodCUID: () => yi$1, ZodCIDRv6: () => vv$1, ZodCIDRv4: () => iv$1, ZodBoolean: () => ar, ZodBigIntFormat: () => gv$1, ZodBigInt: () => pr$1, ZodBase64URL: () => tv$1, ZodBase64: () => ov$1, ZodArray: () => Ag$1, ZodAny: () => Eg$1, TimePrecision: () => F$, NEVER: () => Ov$1, $output: () => A$, $input: () => V$, $brand: () => Sv$1 });
var ir = {};
s(ir, { version: () => Eo$1, util: () => k$3, treeifyError: () => Av$1, toJSONSchema: () => Fi$1, toDotPath: () => Be, safeParseAsync: () => Yv$1, safeParse: () => Kv$1, safeEncodeAsync: () => T4, safeEncode: () => Y4, safeDecodeAsync: () => F4, safeDecode: () => Q4, registry: () => gi$1, regexes: () => x$1, process: () => L$1, prettifyError: () => Vv$1, parseAsync: () => Hn$1, parse: () => Bn$1, meta: () => ku$1, locales: () => Sn$1, isValidJWT: () => ol$1, isValidBase64URL: () => vl$1, isValidBase64: () => ho$1, initializeContext: () => er, globalRegistry: () => V, globalConfig: () => rn$1, formatError: () => ln$1, flattenError: () => en$1, finalize: () => Ir$1, extractDefs: () => lr, encodeAsync: () => V4, encode: () => X4, describe: () => Du$1, decodeAsync: () => K4, decode: () => A4, createToJSONSchemaMethod: () => Nu$1, createStandardJSONSchemaMethod: () => Zr$1, config: () => A$1, clone: () => Y$2, _xor: () => uc$1, _xid: () => Ni$1, _void: () => uu$1, _uuidv7: () => _i$1, _uuidv6: () => ci$1, _uuidv4: () => Ii$1, _uuid: () => li$1, _url: () => Pn$1, _uppercase: () => Yr$1, _unknown: () => tu$1, _union: () => $c$1, _undefined: () => iu$1, _ulid: () => wi$1, _uint64: () => ru$1, _uint32: () => f$, _tuple: () => lc$1, _trim: () => Hr$1, _transform: () => kc$1, _toUpperCase: () => mr$1, _toLowerCase: () => Mr$1, _templateLiteral: () => Lc$1, _symbol: () => nu$1, _superRefine: () => Uu$1, _success: () => zc$1, _stringbool: () => wu$1, _stringFormat: () => xr$1, _string: () => Y$, _startsWith: () => Tr$1, _slugify: () => Rr$1, _size: () => Dr$1, _set: () => _c$1, _safeParseAsync: () => Wr$1, _safeParse: () => Gr$1, _safeEncodeAsync: () => Cn$1, _safeEncode: () => Zn$1, _safeDecodeAsync: () => fn$1, _safeDecode: () => dn$1, _regex: () => Vr$1, _refine: () => bu$1, _record: () => Ic$1, _readonly: () => Jc$1, _property: () => Ki$1, _promise: () => Gc$1, _positive: () => Wi$1, _pipe: () => jc$1, _parseAsync: () => Er$1, _parse: () => Lr$1, _overwrite: () => d, _optional: () => wc$1, _number: () => m$, _nullable: () => Nc$1, _null: () => vu$1, _normalize: () => Br$1, _nonpositive: () => Ai$1, _nonoptional: () => Sc$1, _nonnegative: () => Vi$1, _never: () => $u$1, _negative: () => Xi$1, _nativeEnum: () => Uc$1, _nanoid: () => Ui$1, _nan: () => lu$1, _multipleOf: () => ur, _minSize: () => a, _minLength: () => nr, _min: () => Q, _mime: () => qr$1, _maxSize: () => gr$1, _maxLength: () => kr$1, _max: () => m$2, _map: () => cc$1, _mac: () => T$, _lte: () => m$2, _lt: () => y$1, _lowercase: () => Kr$1, _literal: () => Dc$1, _length: () => wr$1, _lazy: () => Ec$1, _ksuid: () => Oi$1, _jwt: () => Gi$1, _isoTime: () => H$, _isoDuration: () => M$, _isoDateTime: () => q$, _isoDate: () => B$, _ipv6: () => zi$1, _ipv4: () => Si$1, _intersection: () => ec$1, _int64: () => s$, _int32: () => C$, _int: () => x$, _includes: () => Qr$1, _guid: () => zn$1, _gte: () => Q, _gt: () => h$1, _float64: () => d$, _float32: () => Z$, _file: () => cu$1, _enum: () => bc$1, _endsWith: () => Fr$1, _encodeAsync: () => Rn$1, _encode: () => Mn$1, _emoji: () => bi$1, _email: () => ei$1, _e164: () => Ei$1, _discriminatedUnion: () => gc$1, _default: () => Oc$1, _decodeAsync: () => xn$1, _decode: () => mn$1, _date: () => gu$1, _custom: () => _u$1, _cuid2: () => ki$1, _cuid: () => Di$1, _coercedString: () => Q$, _coercedNumber: () => R$, _coercedDate: () => eu$1, _coercedBoolean: () => h$, _coercedBigint: () => p$, _cidrv6: () => ji$1, _cidrv4: () => Pi$1, _check: () => _l$1, _catch: () => Pc$1, _boolean: () => y$, _bigint: () => a$, _base64url: () => Li$1, _base64: () => Ji$1, _array: () => Iu$1, _any: () => ou$1, TimePrecision: () => F$, NEVER: () => Ov$1, JSONSchemaGenerator: () => vg$1, JSONSchema: () => bl$1, Doc: () => pn$1, $output: () => A$, $input: () => V$, $constructor: () => I, $brand: () => Sv$1, $ZodXor: () => bt, $ZodXID: () => qo$1, $ZodVoid: () => lt$1, $ZodUnknown: () => gt$1, $ZodUnion: () => Un$1, $ZodUndefined: () => tt$1, $ZodUUID: () => Xo$1, $ZodURL: () => Vo$1, $ZodULID: () => Fo$1, $ZodType: () => z$1, $ZodTuple: () => $i$1, $ZodTransform: () => Pt$1, $ZodTemplateLiteral: () => Yt$1, $ZodSymbol: () => ot$1, $ZodSuccess: () => Wt$1, $ZodStringFormat: () => E, $ZodString: () => Ur$1, $ZodSet: () => Nt$1, $ZodRegistry: () => K$, $ZodRecord: () => kt$1, $ZodRealError: () => B$3, $ZodReadonly: () => Kt$1, $ZodPromise: () => Tt$1, $ZodPrefault: () => Et$1, $ZodPipe: () => Vt, $ZodOptional: () => ui, $ZodObjectJIT: () => _t, $ZodObject: () => ul$1, $ZodNumberFormat: () => it$1, $ZodNumber: () => oi, $ZodNullable: () => Jt, $ZodNull: () => $t$1, $ZodNonOptional: () => Gt, $ZodNever: () => et$1, $ZodNanoID: () => Yo$1, $ZodNaN: () => At$1, $ZodMap: () => wt$1, $ZodMAC: () => Co$1, $ZodLiteral: () => St$1, $ZodLazy: () => Ft$1, $ZodKSUID: () => Bo$1, $ZodJWT: () => rt$1, $ZodIntersection: () => Dt$1, $ZodISOTime: () => mo, $ZodISODuration: () => Ro$1, $ZodISODateTime: () => Ho$1, $ZodISODate: () => Mo$1, $ZodIPv6: () => Zo$1, $ZodIPv4: () => xo$1, $ZodGUID: () => Wo$1, $ZodFunction: () => Qt$1, $ZodFile: () => zt$1, $ZodExactOptional: () => jt$1, $ZodError: () => gn$1, $ZodEnum: () => Ot$1, $ZodEncodeError: () => cr, $ZodEmoji: () => Ko$1, $ZodEmail: () => Ao$1, $ZodE164: () => so, $ZodDiscriminatedUnion: () => Ut$1, $ZodDefault: () => Lt$1, $ZodDate: () => It$1, $ZodCustomStringFormat: () => nt$1, $ZodCustom: () => qt$1, $ZodCodec: () => Dn$1, $ZodCheckUpperCase: () => Oo$1, $ZodCheckStringFormat: () => Xr$1, $ZodCheckStartsWith: () => zo$1, $ZodCheckSizeEquals: () => bo$1, $ZodCheckRegex: () => wo$1, $ZodCheckProperty: () => jo$1, $ZodCheckOverwrite: () => Lo$1, $ZodCheckNumberFormat: () => lo, $ZodCheckMultipleOf: () => eo$1, $ZodCheckMinSize: () => _o$1, $ZodCheckMinLength: () => Do$1, $ZodCheckMimeType: () => Jo$1, $ZodCheckMaxSize: () => co, $ZodCheckMaxLength: () => Uo$1, $ZodCheckLowerCase: () => No$1, $ZodCheckLessThan: () => hn$1, $ZodCheckLengthEquals: () => ko$1, $ZodCheckIncludes: () => So$1, $ZodCheckGreaterThan: () => an$1, $ZodCheckEndsWith: () => Po$1, $ZodCheckBigIntFormat: () => Io$1, $ZodCheck: () => W$1, $ZodCatch: () => Xt$1, $ZodCUID2: () => To$1, $ZodCUID: () => Qo$1, $ZodCIDRv6: () => yo$1, $ZodCIDRv4: () => fo, $ZodBoolean: () => bn$1, $ZodBigIntFormat: () => vt$1, $ZodBigInt: () => ti$1, $ZodBase64URL: () => po, $ZodBase64: () => ao, $ZodAsyncError: () => f, $ZodArray: () => ct, $ZodAny: () => ut });
var Ov$1 = Object.freeze({ status: "aborted" });
function I(r2, i, o) {
  function t(u2, l) {
    if (!u2._zod) Object.defineProperty(u2, "_zod", { value: { def: l, constr: $2, traits: /* @__PURE__ */ new Set() }, enumerable: false });
    if (u2._zod.traits.has(r2)) return;
    u2._zod.traits.add(r2), i(u2, l);
    let e = $2.prototype, c = Object.keys(e);
    for (let b = 0; b < c.length; b++) {
      let N2 = c[b];
      if (!(N2 in u2)) u2[N2] = e[N2].bind(u2);
    }
  }
  let n = o?.Parent ?? Object;
  class v extends n {
  }
  Object.defineProperty(v, "name", { value: r2 });
  function $2(u2) {
    var l;
    let e = o?.Parent ? new v() : this;
    t(e, u2), (l = e._zod).deferred ?? (l.deferred = []);
    for (let c of e._zod.deferred) c();
    return e;
  }
  return Object.defineProperty($2, "init", { value: t }), Object.defineProperty($2, Symbol.hasInstance, { value: (u2) => {
    if (o?.Parent && u2 instanceof o.Parent) return true;
    return u2?._zod?.traits?.has(r2);
  } }), Object.defineProperty($2, "name", { value: r2 }), $2;
}
var Sv$1 = /* @__PURE__ */ Symbol("zod_brand");
class f extends Error {
  constructor() {
    super("Encountered Promise during synchronous parse. Use .parseAsync() instead.");
  }
}
class cr extends Error {
  constructor(r2) {
    super(`Encountered unidirectional transform during encode: ${r2}`);
    this.name = "ZodEncodeError";
  }
}
var rn$1 = {};
function A$1(r2) {
  if (r2) Object.assign(rn$1, r2);
  return rn$1;
}
var k$3 = {};
s(k$3, { unwrapMessage: () => nn$1, uint8ArrayToHex: () => G4, uint8ArrayToBase64url: () => L4, uint8ArrayToBase64: () => Te$2, stringifyPrimitive: () => U$1, slugify: () => jv$1, shallowClone: () => Lv$1, safeExtend: () => O4, required: () => P4, randomString: () => _4, propertyKeyTypes: () => tn$1, promiseAllObject: () => c4, primitiveTypes: () => Ev$1, prefixIssues: () => M$1, pick: () => k4, partial: () => z4, parsedType: () => D$2, optionalKeys: () => Gv$1, omit: () => w4, objectClone: () => e4, numKeys: () => b4, nullish: () => vr$1, normalizeParams: () => w$1, mergeDefs: () => rr, merge: () => S4, jsonStringifyReplacer: () => Pr$1, joinValues: () => _$1, issue: () => Jr$1, isPlainObject: () => tr, isObject: () => _r, hexToUint8Array: () => E4, getSizableOrigin: () => $n$1, getParsedType: () => U4, getLengthableOrigin: () => un$1, getEnumValues: () => vn$1, getElementAtPath: () => I4, floatSafeRemainder: () => Pv$1, finalizeIssue: () => q, extend: () => N4, escapeRegex: () => R, esc: () => Fn$1, defineLazy: () => j, createTransparentProxy: () => D4, cloneDef: () => l4, clone: () => Y$2, cleanRegex: () => on$1, cleanEnum: () => j4, captureStackTrace: () => qn$1, cached: () => jr$1, base64urlToUint8Array: () => J4, base64ToUint8Array: () => Qe$1, assignProp: () => or, assertNotEqual: () => t4, assertNever: () => u4, assertIs: () => $4, assertEqual: () => o4, assert: () => g4, allowsEval: () => Jv$1, aborted: () => $r$1, NUMBER_FORMAT_RANGES: () => Wv$1, Class: () => Fe$1, BIGINT_FORMAT_RANGES: () => Xv$1 });
function o4(r2) {
  return r2;
}
function t4(r2) {
  return r2;
}
function $4(r2) {
}
function u4(r2) {
  throw Error("Unexpected value in exhaustive check");
}
function g4(r2) {
}
function vn$1(r2) {
  let i = Object.values(r2).filter((t) => typeof t === "number");
  return Object.entries(r2).filter(([t, n]) => i.indexOf(+t) === -1).map(([t, n]) => n);
}
function _$1(r2, i = "|") {
  return r2.map((o) => U$1(o)).join(i);
}
function Pr$1(r2, i) {
  if (typeof i === "bigint") return i.toString();
  return i;
}
function jr$1(r2) {
  return { get value() {
    {
      let o = r2();
      return Object.defineProperty(this, "value", { value: o }), o;
    }
  } };
}
function vr$1(r2) {
  return r2 === null || r2 === void 0;
}
function on$1(r2) {
  let i = r2.startsWith("^") ? 1 : 0, o = r2.endsWith("$") ? r2.length - 1 : r2.length;
  return r2.slice(i, o);
}
function Pv$1(r2, i) {
  let o = (r2.toString().split(".")[1] || "").length, t = i.toString(), n = (t.split(".")[1] || "").length;
  if (n === 0 && /\d?e-\d?/.test(t)) {
    let l = t.match(/\d?e-(\d?)/);
    if (l?.[1]) n = Number.parseInt(l[1]);
  }
  let v = o > n ? o : n, $2 = Number.parseInt(r2.toFixed(v).replace(".", "")), u2 = Number.parseInt(i.toFixed(v).replace(".", ""));
  return $2 % u2 / 10 ** v;
}
var Ye$1 = /* @__PURE__ */ Symbol("evaluating");
function j(r2, i, o) {
  let t = void 0;
  Object.defineProperty(r2, i, { get() {
    if (t === Ye$1) return;
    if (t === void 0) t = Ye$1, t = o();
    return t;
  }, set(n) {
    Object.defineProperty(r2, i, { value: n });
  }, configurable: true });
}
function e4(r2) {
  return Object.create(Object.getPrototypeOf(r2), Object.getOwnPropertyDescriptors(r2));
}
function or(r2, i, o) {
  Object.defineProperty(r2, i, { value: o, writable: true, enumerable: true, configurable: true });
}
function rr(...r2) {
  let i = {};
  for (let o of r2) {
    let t = Object.getOwnPropertyDescriptors(o);
    Object.assign(i, t);
  }
  return Object.defineProperties({}, i);
}
function l4(r2) {
  return rr(r2._zod.def);
}
function I4(r2, i) {
  if (!i) return r2;
  return i.reduce((o, t) => o?.[t], r2);
}
function c4(r2) {
  let i = Object.keys(r2), o = i.map((t) => r2[t]);
  return Promise.all(o).then((t) => {
    let n = {};
    for (let v = 0; v < i.length; v++) n[i[v]] = t[v];
    return n;
  });
}
function _4(r2 = 10) {
  let o = "";
  for (let t = 0; t < r2; t++) o += "abcdefghijklmnopqrstuvwxyz"[Math.floor(Math.random() * 26)];
  return o;
}
function Fn$1(r2) {
  return JSON.stringify(r2);
}
function jv$1(r2) {
  return r2.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
var qn$1 = "captureStackTrace" in Error ? Error.captureStackTrace : (...r2) => {
};
function _r(r2) {
  return typeof r2 === "object" && r2 !== null && !Array.isArray(r2);
}
var Jv$1 = jr$1(() => {
  if (typeof navigator < "u" && navigator?.userAgent?.includes("Cloudflare")) return false;
  try {
    return new Function(""), true;
  } catch (r2) {
    return false;
  }
});
function tr(r2) {
  if (_r(r2) === false) return false;
  let i = r2.constructor;
  if (i === void 0) return true;
  if (typeof i !== "function") return true;
  let o = i.prototype;
  if (_r(o) === false) return false;
  if (Object.prototype.hasOwnProperty.call(o, "isPrototypeOf") === false) return false;
  return true;
}
function Lv$1(r2) {
  if (tr(r2)) return { ...r2 };
  if (Array.isArray(r2)) return [...r2];
  return r2;
}
function b4(r2) {
  let i = 0;
  for (let o in r2) if (Object.prototype.hasOwnProperty.call(r2, o)) i++;
  return i;
}
var U4 = (r2) => {
  let i = typeof r2;
  switch (i) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(r2) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(r2)) return "array";
      if (r2 === null) return "null";
      if (r2.then && typeof r2.then === "function" && r2.catch && typeof r2.catch === "function") return "promise";
      if (typeof Map < "u" && r2 instanceof Map) return "map";
      if (typeof Set < "u" && r2 instanceof Set) return "set";
      if (typeof Date < "u" && r2 instanceof Date) return "date";
      if (typeof File < "u" && r2 instanceof File) return "file";
      return "object";
    default:
      throw Error(`Unknown data type: ${i}`);
  }
}, tn$1 = /* @__PURE__ */ new Set(["string", "number", "symbol"]), Ev$1 = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function R(r2) {
  return r2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Y$2(r2, i, o) {
  let t = new r2._zod.constr(i ?? r2._zod.def);
  if (!i || o?.parent) t._zod.parent = r2;
  return t;
}
function w$1(r2) {
  let i = r2;
  if (!i) return {};
  if (typeof i === "string") return { error: () => i };
  if (i?.message !== void 0) {
    if (i?.error !== void 0) throw Error("Cannot specify both `message` and `error` params");
    i.error = i.message;
  }
  if (delete i.message, typeof i.error === "string") return { ...i, error: () => i.error };
  return i;
}
function D4(r2) {
  let i;
  return new Proxy({}, { get(o, t, n) {
    return i ?? (i = r2()), Reflect.get(i, t, n);
  }, set(o, t, n, v) {
    return i ?? (i = r2()), Reflect.set(i, t, n, v);
  }, has(o, t) {
    return i ?? (i = r2()), Reflect.has(i, t);
  }, deleteProperty(o, t) {
    return i ?? (i = r2()), Reflect.deleteProperty(i, t);
  }, ownKeys(o) {
    return i ?? (i = r2()), Reflect.ownKeys(i);
  }, getOwnPropertyDescriptor(o, t) {
    return i ?? (i = r2()), Reflect.getOwnPropertyDescriptor(i, t);
  }, defineProperty(o, t, n) {
    return i ?? (i = r2()), Reflect.defineProperty(i, t, n);
  } });
}
function U$1(r2) {
  if (typeof r2 === "bigint") return r2.toString() + "n";
  if (typeof r2 === "string") return `"${r2}"`;
  return `${r2}`;
}
function Gv$1(r2) {
  return Object.keys(r2).filter((i) => {
    return r2[i]._zod.optin === "optional" && r2[i]._zod.optout === "optional";
  });
}
var Wv$1 = { safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER], int32: [-2147483648, 2147483647], uint32: [0, 4294967295], float32: [-34028234663852886e22, 34028234663852886e22], float64: [-Number.MAX_VALUE, Number.MAX_VALUE] }, Xv$1 = { int64: [BigInt("-9223372036854775808"), BigInt("9223372036854775807")], uint64: [BigInt(0), BigInt("18446744073709551615")] };
function k4(r2, i) {
  let o = r2._zod.def, t = o.checks;
  if (t && t.length > 0) throw Error(".pick() cannot be used on object schemas containing refinements");
  let v = rr(r2._zod.def, { get shape() {
    let $2 = {};
    for (let u2 in i) {
      if (!(u2 in o.shape)) throw Error(`Unrecognized key: "${u2}"`);
      if (!i[u2]) continue;
      $2[u2] = o.shape[u2];
    }
    return or(this, "shape", $2), $2;
  }, checks: [] });
  return Y$2(r2, v);
}
function w4(r2, i) {
  let o = r2._zod.def, t = o.checks;
  if (t && t.length > 0) throw Error(".omit() cannot be used on object schemas containing refinements");
  let v = rr(r2._zod.def, { get shape() {
    let $2 = { ...r2._zod.def.shape };
    for (let u2 in i) {
      if (!(u2 in o.shape)) throw Error(`Unrecognized key: "${u2}"`);
      if (!i[u2]) continue;
      delete $2[u2];
    }
    return or(this, "shape", $2), $2;
  }, checks: [] });
  return Y$2(r2, v);
}
function N4(r2, i) {
  if (!tr(i)) throw Error("Invalid input to extend: expected a plain object");
  let o = r2._zod.def.checks;
  if (o && o.length > 0) {
    let v = r2._zod.def.shape;
    for (let $2 in i) if (Object.getOwnPropertyDescriptor(v, $2) !== void 0) throw Error("Cannot overwrite keys on object schemas containing refinements. Use `.safeExtend()` instead.");
  }
  let n = rr(r2._zod.def, { get shape() {
    let v = { ...r2._zod.def.shape, ...i };
    return or(this, "shape", v), v;
  } });
  return Y$2(r2, n);
}
function O4(r2, i) {
  if (!tr(i)) throw Error("Invalid input to safeExtend: expected a plain object");
  let o = rr(r2._zod.def, { get shape() {
    let t = { ...r2._zod.def.shape, ...i };
    return or(this, "shape", t), t;
  } });
  return Y$2(r2, o);
}
function S4(r2, i) {
  let o = rr(r2._zod.def, { get shape() {
    let t = { ...r2._zod.def.shape, ...i._zod.def.shape };
    return or(this, "shape", t), t;
  }, get catchall() {
    return i._zod.def.catchall;
  }, checks: [] });
  return Y$2(r2, o);
}
function z4(r2, i, o) {
  let n = i._zod.def.checks;
  if (n && n.length > 0) throw Error(".partial() cannot be used on object schemas containing refinements");
  let $2 = rr(i._zod.def, { get shape() {
    let u2 = i._zod.def.shape, l = { ...u2 };
    if (o) for (let e in o) {
      if (!(e in u2)) throw Error(`Unrecognized key: "${e}"`);
      if (!o[e]) continue;
      l[e] = r2 ? new r2({ type: "optional", innerType: u2[e] }) : u2[e];
    }
    else for (let e in u2) l[e] = r2 ? new r2({ type: "optional", innerType: u2[e] }) : u2[e];
    return or(this, "shape", l), l;
  }, checks: [] });
  return Y$2(i, $2);
}
function P4(r2, i, o) {
  let t = rr(i._zod.def, { get shape() {
    let n = i._zod.def.shape, v = { ...n };
    if (o) for (let $2 in o) {
      if (!($2 in v)) throw Error(`Unrecognized key: "${$2}"`);
      if (!o[$2]) continue;
      v[$2] = new r2({ type: "nonoptional", innerType: n[$2] });
    }
    else for (let $2 in n) v[$2] = new r2({ type: "nonoptional", innerType: n[$2] });
    return or(this, "shape", v), v;
  } });
  return Y$2(i, t);
}
function $r$1(r2, i = 0) {
  if (r2.aborted === true) return true;
  for (let o = i; o < r2.issues.length; o++) if (r2.issues[o]?.continue !== true) return true;
  return false;
}
function M$1(r2, i) {
  return i.map((o) => {
    var t;
    return (t = o).path ?? (t.path = []), o.path.unshift(r2), o;
  });
}
function nn$1(r2) {
  return typeof r2 === "string" ? r2 : r2?.message;
}
function q(r2, i, o) {
  let t = { ...r2, path: r2.path ?? [] };
  if (!r2.message) {
    let n = nn$1(r2.inst?._zod.def?.error?.(r2)) ?? nn$1(i?.error?.(r2)) ?? nn$1(o.customError?.(r2)) ?? nn$1(o.localeError?.(r2)) ?? "Invalid input";
    t.message = n;
  }
  if (delete t.inst, delete t.continue, !i?.reportInput) delete t.input;
  return t;
}
function $n$1(r2) {
  if (r2 instanceof Set) return "set";
  if (r2 instanceof Map) return "map";
  if (r2 instanceof File) return "file";
  return "unknown";
}
function un$1(r2) {
  if (Array.isArray(r2)) return "array";
  if (typeof r2 === "string") return "string";
  return "unknown";
}
function D$2(r2) {
  let i = typeof r2;
  switch (i) {
    case "number":
      return Number.isNaN(r2) ? "nan" : "number";
    case "object": {
      if (r2 === null) return "null";
      if (Array.isArray(r2)) return "array";
      let o = r2;
      if (o && Object.getPrototypeOf(o) !== Object.prototype && "constructor" in o && o.constructor) return o.constructor.name;
    }
  }
  return i;
}
function Jr$1(...r2) {
  let [i, o, t] = r2;
  if (typeof i === "string") return { message: i, code: "custom", input: o, inst: t };
  return { ...i };
}
function j4(r2) {
  return Object.entries(r2).filter(([i, o]) => {
    return Number.isNaN(Number.parseInt(i, 10));
  }).map((i) => i[1]);
}
function Qe$1(r2) {
  let i = atob(r2), o = new Uint8Array(i.length);
  for (let t = 0; t < i.length; t++) o[t] = i.charCodeAt(t);
  return o;
}
function Te$2(r2) {
  let i = "";
  for (let o = 0; o < r2.length; o++) i += String.fromCharCode(r2[o]);
  return btoa(i);
}
function J4(r2) {
  let i = r2.replace(/-/g, "+").replace(/_/g, "/"), o = "=".repeat((4 - i.length % 4) % 4);
  return Qe$1(i + o);
}
function L4(r2) {
  return Te$2(r2).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function E4(r2) {
  let i = r2.replace(/^0x/, "");
  if (i.length % 2 !== 0) throw Error("Invalid hex string length");
  let o = new Uint8Array(i.length / 2);
  for (let t = 0; t < i.length; t += 2) o[t / 2] = Number.parseInt(i.slice(t, t + 2), 16);
  return o;
}
function G4(r2) {
  return Array.from(r2).map((i) => i.toString(16).padStart(2, "0")).join("");
}
let Fe$1 = class Fe {
  constructor(...r2) {
  }
};
var qe = (r2, i) => {
  r2.name = "$ZodError", Object.defineProperty(r2, "_zod", { value: r2._zod, enumerable: false }), Object.defineProperty(r2, "issues", { value: i, enumerable: false }), r2.message = JSON.stringify(i, Pr$1, 2), Object.defineProperty(r2, "toString", { value: () => r2.message, enumerable: false });
}, gn$1 = I("$ZodError", qe), B$3 = I("$ZodError", qe, { Parent: Error });
function en$1(r2, i = (o) => o.message) {
  let o = {}, t = [];
  for (let n of r2.issues) if (n.path.length > 0) o[n.path[0]] = o[n.path[0]] || [], o[n.path[0]].push(i(n));
  else t.push(i(n));
  return { formErrors: t, fieldErrors: o };
}
function ln$1(r2, i = (o) => o.message) {
  let o = { _errors: [] }, t = (n) => {
    for (let v of n.issues) if (v.code === "invalid_union" && v.errors.length) v.errors.map(($2) => t({ issues: $2 }));
    else if (v.code === "invalid_key") t({ issues: v.issues });
    else if (v.code === "invalid_element") t({ issues: v.issues });
    else if (v.path.length === 0) o._errors.push(i(v));
    else {
      let $2 = o, u2 = 0;
      while (u2 < v.path.length) {
        let l = v.path[u2];
        if (u2 !== v.path.length - 1) $2[l] = $2[l] || { _errors: [] };
        else $2[l] = $2[l] || { _errors: [] }, $2[l]._errors.push(i(v));
        $2 = $2[l], u2++;
      }
    }
  };
  return t(r2), o;
}
function Av$1(r2, i = (o) => o.message) {
  let o = { errors: [] }, t = (n, v = []) => {
    var $2, u2;
    for (let l of n.issues) if (l.code === "invalid_union" && l.errors.length) l.errors.map((e) => t({ issues: e }, l.path));
    else if (l.code === "invalid_key") t({ issues: l.issues }, l.path);
    else if (l.code === "invalid_element") t({ issues: l.issues }, l.path);
    else {
      let e = [...v, ...l.path];
      if (e.length === 0) {
        o.errors.push(i(l));
        continue;
      }
      let c = o, b = 0;
      while (b < e.length) {
        let N2 = e[b], O = b === e.length - 1;
        if (typeof N2 === "string") c.properties ?? (c.properties = {}), ($2 = c.properties)[N2] ?? ($2[N2] = { errors: [] }), c = c.properties[N2];
        else c.items ?? (c.items = []), (u2 = c.items)[N2] ?? (u2[N2] = { errors: [] }), c = c.items[N2];
        if (O) c.errors.push(i(l));
        b++;
      }
    }
  };
  return t(r2), o;
}
function Be(r2) {
  let i = [], o = r2.map((t) => typeof t === "object" ? t.key : t);
  for (let t of o) if (typeof t === "number") i.push(`[${t}]`);
  else if (typeof t === "symbol") i.push(`[${JSON.stringify(String(t))}]`);
  else if (/[^\w$]/.test(t)) i.push(`[${JSON.stringify(t)}]`);
  else {
    if (i.length) i.push(".");
    i.push(t);
  }
  return i.join("");
}
function Vv$1(r2) {
  let i = [], o = [...r2.issues].sort((t, n) => (t.path ?? []).length - (n.path ?? []).length);
  for (let t of o) if (i.push(` ${t.message}`), t.path?.length) i.push(`   at ${Be(t.path)}`);
  return i.join(`
`);
}
var Lr$1 = (r2) => (i, o, t, n) => {
  let v = t ? Object.assign(t, { async: false }) : { async: false }, $2 = i._zod.run({ value: o, issues: [] }, v);
  if ($2 instanceof Promise) throw new f();
  if ($2.issues.length) {
    let u2 = new (n?.Err ?? r2)($2.issues.map((l) => q(l, v, A$1())));
    throw qn$1(u2, n?.callee), u2;
  }
  return $2.value;
}, Bn$1 = Lr$1(B$3), Er$1 = (r2) => async (i, o, t, n) => {
  let v = t ? Object.assign(t, { async: true }) : { async: true }, $2 = i._zod.run({ value: o, issues: [] }, v);
  if ($2 instanceof Promise) $2 = await $2;
  if ($2.issues.length) {
    let u2 = new (n?.Err ?? r2)($2.issues.map((l) => q(l, v, A$1())));
    throw qn$1(u2, n?.callee), u2;
  }
  return $2.value;
}, Hn$1 = Er$1(B$3), Gr$1 = (r2) => (i, o, t) => {
  let n = t ? { ...t, async: false } : { async: false }, v = i._zod.run({ value: o, issues: [] }, n);
  if (v instanceof Promise) throw new f();
  return v.issues.length ? { success: false, error: new (r2 ?? gn$1)(v.issues.map(($2) => q($2, n, A$1()))) } : { success: true, data: v.value };
}, Kv$1 = Gr$1(B$3), Wr$1 = (r2) => async (i, o, t) => {
  let n = t ? Object.assign(t, { async: true }) : { async: true }, v = i._zod.run({ value: o, issues: [] }, n);
  if (v instanceof Promise) v = await v;
  return v.issues.length ? { success: false, error: new r2(v.issues.map(($2) => q($2, n, A$1()))) } : { success: true, data: v.value };
}, Yv$1 = Wr$1(B$3), Mn$1 = (r2) => (i, o, t) => {
  let n = t ? Object.assign(t, { direction: "backward" }) : { direction: "backward" };
  return Lr$1(r2)(i, o, n);
}, X4 = Mn$1(B$3), mn$1 = (r2) => (i, o, t) => {
  return Lr$1(r2)(i, o, t);
}, A4 = mn$1(B$3), Rn$1 = (r2) => async (i, o, t) => {
  let n = t ? Object.assign(t, { direction: "backward" }) : { direction: "backward" };
  return Er$1(r2)(i, o, n);
}, V4 = Rn$1(B$3), xn$1 = (r2) => async (i, o, t) => {
  return Er$1(r2)(i, o, t);
}, K4 = xn$1(B$3), Zn$1 = (r2) => (i, o, t) => {
  let n = t ? Object.assign(t, { direction: "backward" }) : { direction: "backward" };
  return Gr$1(r2)(i, o, n);
}, Y4 = Zn$1(B$3), dn$1 = (r2) => (i, o, t) => {
  return Gr$1(r2)(i, o, t);
}, Q4 = dn$1(B$3), Cn$1 = (r2) => async (i, o, t) => {
  let n = t ? Object.assign(t, { direction: "backward" }) : { direction: "backward" };
  return Wr$1(r2)(i, o, n);
}, T4 = Cn$1(B$3), fn$1 = (r2) => async (i, o, t) => {
  return Wr$1(r2)(i, o, t);
}, F4 = fn$1(B$3);
var x$1 = {};
s(x$1, { xid: () => qv$1, uuid7: () => M4, uuid6: () => H4, uuid4: () => B4, uuid: () => br, uppercase: () => go, unicodeEmail: () => He, undefined: () => $o, ulid: () => Fv$1, time: () => sv$1, string: () => no, sha512_hex: () => g6, sha512_base64url: () => l6, sha512_base64: () => e6, sha384_hex: () => t6, sha384_base64url: () => u6, sha384_base64: () => $6, sha256_hex: () => i6, sha256_base64url: () => o6, sha256_base64: () => v6, sha1_hex: () => s4, sha1_base64url: () => n6, sha1_base64: () => r6, rfc5322Email: () => R4, number: () => In$1, null: () => to, nanoid: () => Hv$1, md5_hex: () => h4, md5_base64url: () => p4, md5_base64: () => a4, mac: () => Cv$1, lowercase: () => uo, ksuid: () => Bv$1, ipv6: () => dv$1, ipv4: () => Zv$1, integer: () => vo, idnEmail: () => x4, html5Email: () => m4, hostname: () => C4, hex: () => y4, guid: () => mv$1, extendedDuration: () => q4, emoji: () => xv$1, email: () => Rv$1, e164: () => av$1, duration: () => Mv$1, domain: () => f4, datetime: () => ro, date: () => pv$1, cuid2: () => Tv$1, cuid: () => Qv$1, cidrv6: () => yv$1, cidrv4: () => fv$1, browserEmail: () => Z4, boolean: () => oo, bigint: () => io, base64url: () => yn$1, base64: () => hv$1 });
var Qv$1 = /^[cC][^\s-]{8,}$/, Tv$1 = /^[0-9a-z]+$/, Fv$1 = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/, qv$1 = /^[0-9a-vA-V]{20}$/, Bv$1 = /^[A-Za-z0-9]{27}$/, Hv$1 = /^[a-zA-Z0-9_-]{21}$/, Mv$1 = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/, q4 = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, mv$1 = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/, br = (r2) => {
  if (!r2) return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${r2}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
}, B4 = br(4), H4 = br(6), M4 = br(7), Rv$1 = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/, m4 = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/, R4 = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/, He = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u, x4 = He, Z4 = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/, d4 = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
function xv$1() {
  return new RegExp(d4, "u");
}
var Zv$1 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, dv$1 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/, Cv$1 = (r2) => {
  let i = R(r2 ?? ":");
  return new RegExp(`^(?:[0-9A-F]{2}${i}){5}[0-9A-F]{2}$|^(?:[0-9a-f]{2}${i}){5}[0-9a-f]{2}$`);
}, fv$1 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/, yv$1 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, hv$1 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/, yn$1 = /^[A-Za-z0-9_-]*$/, C4 = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/, f4 = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/, av$1 = /^\+[1-9]\d{6,14}$/, Me$2 = "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))", pv$1 = new RegExp(`^${Me$2}$`);
function me$2(r2) {
  return typeof r2.precision === "number" ? r2.precision === -1 ? "(?:[01]\\d|2[0-3]):[0-5]\\d" : r2.precision === 0 ? "(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d" : `(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d\\.\\d{${r2.precision}}` : "(?:[01]\\d|2[0-3]):[0-5]\\d(?::[0-5]\\d(?:\\.\\d+)?)?";
}
function sv$1(r2) {
  return new RegExp(`^${me$2(r2)}$`);
}
function ro(r2) {
  let i = me$2({ precision: r2.precision }), o = ["Z"];
  if (r2.local) o.push("");
  if (r2.offset) o.push("([+-](?:[01]\\d|2[0-3]):[0-5]\\d)");
  let t = `${i}(?:${o.join("|")})`;
  return new RegExp(`^${Me$2}T(?:${t})$`);
}
var no = (r2) => {
  let i = r2 ? `[\\s\\S]{${r2?.minimum ?? 0},${r2?.maximum ?? ""}}` : "[\\s\\S]*";
  return new RegExp(`^${i}$`);
}, io = /^-?\d+n?$/, vo = /^-?\d+$/, In$1 = /^-?\d+(?:\.\d+)?$/, oo = /^(?:true|false)$/i, to = /^null$/i;
var $o = /^undefined$/i;
var uo = /^[^A-Z]*$/, go = /^[^a-z]*$/, y4 = /^[0-9a-fA-F]*$/;
function cn$1(r2, i) {
  return new RegExp(`^[A-Za-z0-9+/]{${r2}}${i}$`);
}
function _n$1(r2) {
  return new RegExp(`^[A-Za-z0-9_-]{${r2}}$`);
}
var h4 = /^[0-9a-fA-F]{32}$/, a4 = cn$1(22, "=="), p4 = _n$1(22), s4 = /^[0-9a-fA-F]{40}$/, r6 = cn$1(27, "="), n6 = _n$1(27), i6 = /^[0-9a-fA-F]{64}$/, v6 = cn$1(43, "="), o6 = _n$1(43), t6 = /^[0-9a-fA-F]{96}$/, $6 = cn$1(64, ""), u6 = _n$1(64), g6 = /^[0-9a-fA-F]{128}$/, e6 = cn$1(86, "=="), l6 = _n$1(86);
var W$1 = I("$ZodCheck", (r2, i) => {
  var o;
  r2._zod ?? (r2._zod = {}), r2._zod.def = i, (o = r2._zod).onattach ?? (o.onattach = []);
}), xe$2 = { number: "number", bigint: "bigint", object: "date" }, hn$1 = I("$ZodCheckLessThan", (r2, i) => {
  W$1.init(r2, i);
  let o = xe$2[typeof i.value];
  r2._zod.onattach.push((t) => {
    let n = t._zod.bag, v = (i.inclusive ? n.maximum : n.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (i.value < v) if (i.inclusive) n.maximum = i.value;
    else n.exclusiveMaximum = i.value;
  }), r2._zod.check = (t) => {
    if (i.inclusive ? t.value <= i.value : t.value < i.value) return;
    t.issues.push({ origin: o, code: "too_big", maximum: typeof i.value === "object" ? i.value.getTime() : i.value, input: t.value, inclusive: i.inclusive, inst: r2, continue: !i.abort });
  };
}), an$1 = I("$ZodCheckGreaterThan", (r2, i) => {
  W$1.init(r2, i);
  let o = xe$2[typeof i.value];
  r2._zod.onattach.push((t) => {
    let n = t._zod.bag, v = (i.inclusive ? n.minimum : n.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (i.value > v) if (i.inclusive) n.minimum = i.value;
    else n.exclusiveMinimum = i.value;
  }), r2._zod.check = (t) => {
    if (i.inclusive ? t.value >= i.value : t.value > i.value) return;
    t.issues.push({ origin: o, code: "too_small", minimum: typeof i.value === "object" ? i.value.getTime() : i.value, input: t.value, inclusive: i.inclusive, inst: r2, continue: !i.abort });
  };
}), eo$1 = I("$ZodCheckMultipleOf", (r2, i) => {
  W$1.init(r2, i), r2._zod.onattach.push((o) => {
    var t;
    (t = o._zod.bag).multipleOf ?? (t.multipleOf = i.value);
  }), r2._zod.check = (o) => {
    if (typeof o.value !== typeof i.value) throw Error("Cannot mix number and bigint in multiple_of check.");
    if (typeof o.value === "bigint" ? o.value % i.value === BigInt(0) : Pv$1(o.value, i.value) === 0) return;
    o.issues.push({ origin: typeof o.value, code: "not_multiple_of", divisor: i.value, input: o.value, inst: r2, continue: !i.abort });
  };
}), lo = I("$ZodCheckNumberFormat", (r2, i) => {
  W$1.init(r2, i), i.format = i.format || "float64";
  let o = i.format?.includes("int"), t = o ? "int" : "number", [n, v] = Wv$1[i.format];
  r2._zod.onattach.push(($2) => {
    let u2 = $2._zod.bag;
    if (u2.format = i.format, u2.minimum = n, u2.maximum = v, o) u2.pattern = vo;
  }), r2._zod.check = ($2) => {
    let u2 = $2.value;
    if (o) {
      if (!Number.isInteger(u2)) {
        $2.issues.push({ expected: t, format: i.format, code: "invalid_type", continue: false, input: u2, inst: r2 });
        return;
      }
      if (!Number.isSafeInteger(u2)) {
        if (u2 > 0) $2.issues.push({ input: u2, code: "too_big", maximum: Number.MAX_SAFE_INTEGER, note: "Integers must be within the safe integer range.", inst: r2, origin: t, inclusive: true, continue: !i.abort });
        else $2.issues.push({ input: u2, code: "too_small", minimum: Number.MIN_SAFE_INTEGER, note: "Integers must be within the safe integer range.", inst: r2, origin: t, inclusive: true, continue: !i.abort });
        return;
      }
    }
    if (u2 < n) $2.issues.push({ origin: "number", input: u2, code: "too_small", minimum: n, inclusive: true, inst: r2, continue: !i.abort });
    if (u2 > v) $2.issues.push({ origin: "number", input: u2, code: "too_big", maximum: v, inclusive: true, inst: r2, continue: !i.abort });
  };
}), Io$1 = I("$ZodCheckBigIntFormat", (r2, i) => {
  W$1.init(r2, i);
  let [o, t] = Xv$1[i.format];
  r2._zod.onattach.push((n) => {
    let v = n._zod.bag;
    v.format = i.format, v.minimum = o, v.maximum = t;
  }), r2._zod.check = (n) => {
    let v = n.value;
    if (v < o) n.issues.push({ origin: "bigint", input: v, code: "too_small", minimum: o, inclusive: true, inst: r2, continue: !i.abort });
    if (v > t) n.issues.push({ origin: "bigint", input: v, code: "too_big", maximum: t, inclusive: true, inst: r2, continue: !i.abort });
  };
}), co = I("$ZodCheckMaxSize", (r2, i) => {
  var o;
  W$1.init(r2, i), (o = r2._zod.def).when ?? (o.when = (t) => {
    let n = t.value;
    return !vr$1(n) && n.size !== void 0;
  }), r2._zod.onattach.push((t) => {
    let n = t._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (i.maximum < n) t._zod.bag.maximum = i.maximum;
  }), r2._zod.check = (t) => {
    let n = t.value;
    if (n.size <= i.maximum) return;
    t.issues.push({ origin: $n$1(n), code: "too_big", maximum: i.maximum, inclusive: true, input: n, inst: r2, continue: !i.abort });
  };
}), _o$1 = I("$ZodCheckMinSize", (r2, i) => {
  var o;
  W$1.init(r2, i), (o = r2._zod.def).when ?? (o.when = (t) => {
    let n = t.value;
    return !vr$1(n) && n.size !== void 0;
  }), r2._zod.onattach.push((t) => {
    let n = t._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (i.minimum > n) t._zod.bag.minimum = i.minimum;
  }), r2._zod.check = (t) => {
    let n = t.value;
    if (n.size >= i.minimum) return;
    t.issues.push({ origin: $n$1(n), code: "too_small", minimum: i.minimum, inclusive: true, input: n, inst: r2, continue: !i.abort });
  };
}), bo$1 = I("$ZodCheckSizeEquals", (r2, i) => {
  var o;
  W$1.init(r2, i), (o = r2._zod.def).when ?? (o.when = (t) => {
    let n = t.value;
    return !vr$1(n) && n.size !== void 0;
  }), r2._zod.onattach.push((t) => {
    let n = t._zod.bag;
    n.minimum = i.size, n.maximum = i.size, n.size = i.size;
  }), r2._zod.check = (t) => {
    let n = t.value, v = n.size;
    if (v === i.size) return;
    let $2 = v > i.size;
    t.issues.push({ origin: $n$1(n), ...$2 ? { code: "too_big", maximum: i.size } : { code: "too_small", minimum: i.size }, inclusive: true, exact: true, input: t.value, inst: r2, continue: !i.abort });
  };
}), Uo$1 = I("$ZodCheckMaxLength", (r2, i) => {
  var o;
  W$1.init(r2, i), (o = r2._zod.def).when ?? (o.when = (t) => {
    let n = t.value;
    return !vr$1(n) && n.length !== void 0;
  }), r2._zod.onattach.push((t) => {
    let n = t._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (i.maximum < n) t._zod.bag.maximum = i.maximum;
  }), r2._zod.check = (t) => {
    let n = t.value;
    if (n.length <= i.maximum) return;
    let $2 = un$1(n);
    t.issues.push({ origin: $2, code: "too_big", maximum: i.maximum, inclusive: true, input: n, inst: r2, continue: !i.abort });
  };
}), Do$1 = I("$ZodCheckMinLength", (r2, i) => {
  var o;
  W$1.init(r2, i), (o = r2._zod.def).when ?? (o.when = (t) => {
    let n = t.value;
    return !vr$1(n) && n.length !== void 0;
  }), r2._zod.onattach.push((t) => {
    let n = t._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (i.minimum > n) t._zod.bag.minimum = i.minimum;
  }), r2._zod.check = (t) => {
    let n = t.value;
    if (n.length >= i.minimum) return;
    let $2 = un$1(n);
    t.issues.push({ origin: $2, code: "too_small", minimum: i.minimum, inclusive: true, input: n, inst: r2, continue: !i.abort });
  };
}), ko$1 = I("$ZodCheckLengthEquals", (r2, i) => {
  var o;
  W$1.init(r2, i), (o = r2._zod.def).when ?? (o.when = (t) => {
    let n = t.value;
    return !vr$1(n) && n.length !== void 0;
  }), r2._zod.onattach.push((t) => {
    let n = t._zod.bag;
    n.minimum = i.length, n.maximum = i.length, n.length = i.length;
  }), r2._zod.check = (t) => {
    let n = t.value, v = n.length;
    if (v === i.length) return;
    let $2 = un$1(n), u2 = v > i.length;
    t.issues.push({ origin: $2, ...u2 ? { code: "too_big", maximum: i.length } : { code: "too_small", minimum: i.length }, inclusive: true, exact: true, input: t.value, inst: r2, continue: !i.abort });
  };
}), Xr$1 = I("$ZodCheckStringFormat", (r2, i) => {
  var o, t;
  if (W$1.init(r2, i), r2._zod.onattach.push((n) => {
    let v = n._zod.bag;
    if (v.format = i.format, i.pattern) v.patterns ?? (v.patterns = /* @__PURE__ */ new Set()), v.patterns.add(i.pattern);
  }), i.pattern) (o = r2._zod).check ?? (o.check = (n) => {
    if (i.pattern.lastIndex = 0, i.pattern.test(n.value)) return;
    n.issues.push({ origin: "string", code: "invalid_format", format: i.format, input: n.value, ...i.pattern ? { pattern: i.pattern.toString() } : {}, inst: r2, continue: !i.abort });
  });
  else (t = r2._zod).check ?? (t.check = () => {
  });
}), wo$1 = I("$ZodCheckRegex", (r2, i) => {
  Xr$1.init(r2, i), r2._zod.check = (o) => {
    if (i.pattern.lastIndex = 0, i.pattern.test(o.value)) return;
    o.issues.push({ origin: "string", code: "invalid_format", format: "regex", input: o.value, pattern: i.pattern.toString(), inst: r2, continue: !i.abort });
  };
}), No$1 = I("$ZodCheckLowerCase", (r2, i) => {
  i.pattern ?? (i.pattern = uo), Xr$1.init(r2, i);
}), Oo$1 = I("$ZodCheckUpperCase", (r2, i) => {
  i.pattern ?? (i.pattern = go), Xr$1.init(r2, i);
}), So$1 = I("$ZodCheckIncludes", (r2, i) => {
  W$1.init(r2, i);
  let o = R(i.includes), t = new RegExp(typeof i.position === "number" ? `^.{${i.position}}${o}` : o);
  i.pattern = t, r2._zod.onattach.push((n) => {
    let v = n._zod.bag;
    v.patterns ?? (v.patterns = /* @__PURE__ */ new Set()), v.patterns.add(t);
  }), r2._zod.check = (n) => {
    if (n.value.includes(i.includes, i.position)) return;
    n.issues.push({ origin: "string", code: "invalid_format", format: "includes", includes: i.includes, input: n.value, inst: r2, continue: !i.abort });
  };
}), zo$1 = I("$ZodCheckStartsWith", (r2, i) => {
  W$1.init(r2, i);
  let o = new RegExp(`^${R(i.prefix)}.*`);
  i.pattern ?? (i.pattern = o), r2._zod.onattach.push((t) => {
    let n = t._zod.bag;
    n.patterns ?? (n.patterns = /* @__PURE__ */ new Set()), n.patterns.add(o);
  }), r2._zod.check = (t) => {
    if (t.value.startsWith(i.prefix)) return;
    t.issues.push({ origin: "string", code: "invalid_format", format: "starts_with", prefix: i.prefix, input: t.value, inst: r2, continue: !i.abort });
  };
}), Po$1 = I("$ZodCheckEndsWith", (r2, i) => {
  W$1.init(r2, i);
  let o = new RegExp(`.*${R(i.suffix)}$`);
  i.pattern ?? (i.pattern = o), r2._zod.onattach.push((t) => {
    let n = t._zod.bag;
    n.patterns ?? (n.patterns = /* @__PURE__ */ new Set()), n.patterns.add(o);
  }), r2._zod.check = (t) => {
    if (t.value.endsWith(i.suffix)) return;
    t.issues.push({ origin: "string", code: "invalid_format", format: "ends_with", suffix: i.suffix, input: t.value, inst: r2, continue: !i.abort });
  };
});
function Re$1(r2, i, o) {
  if (r2.issues.length) i.issues.push(...M$1(o, r2.issues));
}
var jo$1 = I("$ZodCheckProperty", (r2, i) => {
  W$1.init(r2, i), r2._zod.check = (o) => {
    let t = i.schema._zod.run({ value: o.value[i.property], issues: [] }, {});
    if (t instanceof Promise) return t.then((n) => Re$1(n, o, i.property));
    Re$1(t, o, i.property);
    return;
  };
}), Jo$1 = I("$ZodCheckMimeType", (r2, i) => {
  W$1.init(r2, i);
  let o = new Set(i.mime);
  r2._zod.onattach.push((t) => {
    t._zod.bag.mime = i.mime;
  }), r2._zod.check = (t) => {
    if (o.has(t.value.type)) return;
    t.issues.push({ code: "invalid_value", values: i.mime, input: t.value.type, inst: r2, continue: !i.abort });
  };
}), Lo$1 = I("$ZodCheckOverwrite", (r2, i) => {
  W$1.init(r2, i), r2._zod.check = (o) => {
    o.value = i.tx(o.value);
  };
});
let pn$1 = class pn {
  constructor(r2 = []) {
    if (this.content = [], this.indent = 0, this) this.args = r2;
  }
  indented(r2) {
    this.indent += 1, r2(this), this.indent -= 1;
  }
  write(r2) {
    if (typeof r2 === "function") {
      r2(this, { execution: "sync" }), r2(this, { execution: "async" });
      return;
    }
    let o = r2.split(`
`).filter((v) => v), t = Math.min(...o.map((v) => v.length - v.trimStart().length)), n = o.map((v) => v.slice(t)).map((v) => " ".repeat(this.indent * 2) + v);
    for (let v of n) this.content.push(v);
  }
  compile() {
    let r2 = Function, i = this?.args, t = [...(this?.content ?? [""]).map((n) => `  ${n}`)];
    return new r2(...i, t.join(`
`));
  }
};
var Eo$1 = { major: 4, minor: 3, patch: 5 };
var z$1 = I("$ZodType", (r2, i) => {
  var o;
  r2 ?? (r2 = {}), r2._zod.def = i, r2._zod.bag = r2._zod.bag || {}, r2._zod.version = Eo$1;
  let t = [...r2._zod.def.checks ?? []];
  if (r2._zod.traits.has("$ZodCheck")) t.unshift(r2);
  for (let n of t) for (let v of n._zod.onattach) v(r2);
  if (t.length === 0) (o = r2._zod).deferred ?? (o.deferred = []), r2._zod.deferred?.push(() => {
    r2._zod.run = r2._zod.parse;
  });
  else {
    let n = ($2, u2, l) => {
      let e = $r$1($2), c;
      for (let b of u2) {
        if (b._zod.def.when) {
          if (!b._zod.def.when($2)) continue;
        } else if (e) continue;
        let N2 = $2.issues.length, O = b._zod.check($2);
        if (O instanceof Promise && l?.async === false) throw new f();
        if (c || O instanceof Promise) c = (c ?? Promise.resolve()).then(async () => {
          if (await O, $2.issues.length === N2) return;
          if (!e) e = $r$1($2, N2);
        });
        else {
          if ($2.issues.length === N2) continue;
          if (!e) e = $r$1($2, N2);
        }
      }
      if (c) return c.then(() => {
        return $2;
      });
      return $2;
    }, v = ($2, u2, l) => {
      if ($r$1($2)) return $2.aborted = true, $2;
      let e = n(u2, t, l);
      if (e instanceof Promise) {
        if (l.async === false) throw new f();
        return e.then((c) => r2._zod.parse(c, l));
      }
      return r2._zod.parse(e, l);
    };
    r2._zod.run = ($2, u2) => {
      if (u2.skipChecks) return r2._zod.parse($2, u2);
      if (u2.direction === "backward") {
        let e = r2._zod.parse({ value: $2.value, issues: [] }, { ...u2, skipChecks: true });
        if (e instanceof Promise) return e.then((c) => {
          return v(c, $2, u2);
        });
        return v(e, $2, u2);
      }
      let l = r2._zod.parse($2, u2);
      if (l instanceof Promise) {
        if (u2.async === false) throw new f();
        return l.then((e) => n(e, t, u2));
      }
      return n(l, t, u2);
    };
  }
  j(r2, "~standard", () => ({ validate: (n) => {
    try {
      let v = Kv$1(r2, n);
      return v.success ? { value: v.data } : { issues: v.error?.issues };
    } catch (v) {
      return Yv$1(r2, n).then(($2) => $2.success ? { value: $2.data } : { issues: $2.error?.issues });
    }
  }, vendor: "zod", version: 1 }));
}), Ur$1 = I("$ZodString", (r2, i) => {
  z$1.init(r2, i), r2._zod.pattern = [...r2?._zod.bag?.patterns ?? []].pop() ?? no(r2._zod.bag), r2._zod.parse = (o, t) => {
    if (i.coerce) try {
      o.value = String(o.value);
    } catch (n) {
    }
    if (typeof o.value === "string") return o;
    return o.issues.push({ expected: "string", code: "invalid_type", input: o.value, inst: r2 }), o;
  };
}), E = I("$ZodStringFormat", (r2, i) => {
  Xr$1.init(r2, i), Ur$1.init(r2, i);
}), Wo$1 = I("$ZodGUID", (r2, i) => {
  i.pattern ?? (i.pattern = mv$1), E.init(r2, i);
}), Xo$1 = I("$ZodUUID", (r2, i) => {
  if (i.version) {
    let t = { v1: 1, v2: 2, v3: 3, v4: 4, v5: 5, v6: 6, v7: 7, v8: 8 }[i.version];
    if (t === void 0) throw Error(`Invalid UUID version: "${i.version}"`);
    i.pattern ?? (i.pattern = br(t));
  } else i.pattern ?? (i.pattern = br());
  E.init(r2, i);
}), Ao$1 = I("$ZodEmail", (r2, i) => {
  i.pattern ?? (i.pattern = Rv$1), E.init(r2, i);
}), Vo$1 = I("$ZodURL", (r2, i) => {
  E.init(r2, i), r2._zod.check = (o) => {
    try {
      let t = o.value.trim(), n = new URL(t);
      if (i.hostname) {
        if (i.hostname.lastIndex = 0, !i.hostname.test(n.hostname)) o.issues.push({ code: "invalid_format", format: "url", note: "Invalid hostname", pattern: i.hostname.source, input: o.value, inst: r2, continue: !i.abort });
      }
      if (i.protocol) {
        if (i.protocol.lastIndex = 0, !i.protocol.test(n.protocol.endsWith(":") ? n.protocol.slice(0, -1) : n.protocol)) o.issues.push({ code: "invalid_format", format: "url", note: "Invalid protocol", pattern: i.protocol.source, input: o.value, inst: r2, continue: !i.abort });
      }
      if (i.normalize) o.value = n.href;
      else o.value = t;
      return;
    } catch (t) {
      o.issues.push({ code: "invalid_format", format: "url", input: o.value, inst: r2, continue: !i.abort });
    }
  };
}), Ko$1 = I("$ZodEmoji", (r2, i) => {
  i.pattern ?? (i.pattern = xv$1()), E.init(r2, i);
}), Yo$1 = I("$ZodNanoID", (r2, i) => {
  i.pattern ?? (i.pattern = Hv$1), E.init(r2, i);
}), Qo$1 = I("$ZodCUID", (r2, i) => {
  i.pattern ?? (i.pattern = Qv$1), E.init(r2, i);
}), To$1 = I("$ZodCUID2", (r2, i) => {
  i.pattern ?? (i.pattern = Tv$1), E.init(r2, i);
}), Fo$1 = I("$ZodULID", (r2, i) => {
  i.pattern ?? (i.pattern = Fv$1), E.init(r2, i);
}), qo$1 = I("$ZodXID", (r2, i) => {
  i.pattern ?? (i.pattern = qv$1), E.init(r2, i);
}), Bo$1 = I("$ZodKSUID", (r2, i) => {
  i.pattern ?? (i.pattern = Bv$1), E.init(r2, i);
}), Ho$1 = I("$ZodISODateTime", (r2, i) => {
  i.pattern ?? (i.pattern = ro(i)), E.init(r2, i);
}), Mo$1 = I("$ZodISODate", (r2, i) => {
  i.pattern ?? (i.pattern = pv$1), E.init(r2, i);
}), mo = I("$ZodISOTime", (r2, i) => {
  i.pattern ?? (i.pattern = sv$1(i)), E.init(r2, i);
}), Ro$1 = I("$ZodISODuration", (r2, i) => {
  i.pattern ?? (i.pattern = Mv$1), E.init(r2, i);
}), xo$1 = I("$ZodIPv4", (r2, i) => {
  i.pattern ?? (i.pattern = Zv$1), E.init(r2, i), r2._zod.bag.format = "ipv4";
}), Zo$1 = I("$ZodIPv6", (r2, i) => {
  i.pattern ?? (i.pattern = dv$1), E.init(r2, i), r2._zod.bag.format = "ipv6", r2._zod.check = (o) => {
    try {
      new URL(`http://[${o.value}]`);
    } catch {
      o.issues.push({ code: "invalid_format", format: "ipv6", input: o.value, inst: r2, continue: !i.abort });
    }
  };
}), Co$1 = I("$ZodMAC", (r2, i) => {
  i.pattern ?? (i.pattern = Cv$1(i.delimiter)), E.init(r2, i), r2._zod.bag.format = "mac";
}), fo = I("$ZodCIDRv4", (r2, i) => {
  i.pattern ?? (i.pattern = fv$1), E.init(r2, i);
}), yo$1 = I("$ZodCIDRv6", (r2, i) => {
  i.pattern ?? (i.pattern = yv$1), E.init(r2, i), r2._zod.check = (o) => {
    let t = o.value.split("/");
    try {
      if (t.length !== 2) throw Error();
      let [n, v] = t;
      if (!v) throw Error();
      let $2 = Number(v);
      if (`${$2}` !== v) throw Error();
      if ($2 < 0 || $2 > 128) throw Error();
      new URL(`http://[${n}]`);
    } catch {
      o.issues.push({ code: "invalid_format", format: "cidrv6", input: o.value, inst: r2, continue: !i.abort });
    }
  };
});
function ho$1(r2) {
  if (r2 === "") return true;
  if (r2.length % 4 !== 0) return false;
  try {
    return atob(r2), true;
  } catch {
    return false;
  }
}
var ao = I("$ZodBase64", (r2, i) => {
  i.pattern ?? (i.pattern = hv$1), E.init(r2, i), r2._zod.bag.contentEncoding = "base64", r2._zod.check = (o) => {
    if (ho$1(o.value)) return;
    o.issues.push({ code: "invalid_format", format: "base64", input: o.value, inst: r2, continue: !i.abort });
  };
});
function vl$1(r2) {
  if (!yn$1.test(r2)) return false;
  let i = r2.replace(/[-_]/g, (t) => t === "-" ? "+" : "/"), o = i.padEnd(Math.ceil(i.length / 4) * 4, "=");
  return ho$1(o);
}
var po = I("$ZodBase64URL", (r2, i) => {
  i.pattern ?? (i.pattern = yn$1), E.init(r2, i), r2._zod.bag.contentEncoding = "base64url", r2._zod.check = (o) => {
    if (vl$1(o.value)) return;
    o.issues.push({ code: "invalid_format", format: "base64url", input: o.value, inst: r2, continue: !i.abort });
  };
}), so = I("$ZodE164", (r2, i) => {
  i.pattern ?? (i.pattern = av$1), E.init(r2, i);
});
function ol$1(r2, i = null) {
  try {
    let o = r2.split(".");
    if (o.length !== 3) return false;
    let [t] = o;
    if (!t) return false;
    let n = JSON.parse(atob(t));
    if ("typ" in n && n?.typ !== "JWT") return false;
    if (!n.alg) return false;
    if (i && (!("alg" in n) || n.alg !== i)) return false;
    return true;
  } catch {
    return false;
  }
}
var rt$1 = I("$ZodJWT", (r2, i) => {
  E.init(r2, i), r2._zod.check = (o) => {
    if (ol$1(o.value, i.alg)) return;
    o.issues.push({ code: "invalid_format", format: "jwt", input: o.value, inst: r2, continue: !i.abort });
  };
}), nt$1 = I("$ZodCustomStringFormat", (r2, i) => {
  E.init(r2, i), r2._zod.check = (o) => {
    if (i.fn(o.value)) return;
    o.issues.push({ code: "invalid_format", format: i.format, input: o.value, inst: r2, continue: !i.abort });
  };
}), oi = I("$ZodNumber", (r2, i) => {
  z$1.init(r2, i), r2._zod.pattern = r2._zod.bag.pattern ?? In$1, r2._zod.parse = (o, t) => {
    if (i.coerce) try {
      o.value = Number(o.value);
    } catch ($2) {
    }
    let n = o.value;
    if (typeof n === "number" && !Number.isNaN(n) && Number.isFinite(n)) return o;
    let v = typeof n === "number" ? Number.isNaN(n) ? "NaN" : !Number.isFinite(n) ? "Infinity" : void 0 : void 0;
    return o.issues.push({ expected: "number", code: "invalid_type", input: n, inst: r2, ...v ? { received: v } : {} }), o;
  };
}), it$1 = I("$ZodNumberFormat", (r2, i) => {
  lo.init(r2, i), oi.init(r2, i);
}), bn$1 = I("$ZodBoolean", (r2, i) => {
  z$1.init(r2, i), r2._zod.pattern = oo, r2._zod.parse = (o, t) => {
    if (i.coerce) try {
      o.value = Boolean(o.value);
    } catch (v) {
    }
    let n = o.value;
    if (typeof n === "boolean") return o;
    return o.issues.push({ expected: "boolean", code: "invalid_type", input: n, inst: r2 }), o;
  };
}), ti$1 = I("$ZodBigInt", (r2, i) => {
  z$1.init(r2, i), r2._zod.pattern = io, r2._zod.parse = (o, t) => {
    if (i.coerce) try {
      o.value = BigInt(o.value);
    } catch (n) {
    }
    if (typeof o.value === "bigint") return o;
    return o.issues.push({ expected: "bigint", code: "invalid_type", input: o.value, inst: r2 }), o;
  };
}), vt$1 = I("$ZodBigIntFormat", (r2, i) => {
  Io$1.init(r2, i), ti$1.init(r2, i);
}), ot$1 = I("$ZodSymbol", (r2, i) => {
  z$1.init(r2, i), r2._zod.parse = (o, t) => {
    let n = o.value;
    if (typeof n === "symbol") return o;
    return o.issues.push({ expected: "symbol", code: "invalid_type", input: n, inst: r2 }), o;
  };
}), tt$1 = I("$ZodUndefined", (r2, i) => {
  z$1.init(r2, i), r2._zod.pattern = $o, r2._zod.values = /* @__PURE__ */ new Set([void 0]), r2._zod.optin = "optional", r2._zod.optout = "optional", r2._zod.parse = (o, t) => {
    let n = o.value;
    if (typeof n > "u") return o;
    return o.issues.push({ expected: "undefined", code: "invalid_type", input: n, inst: r2 }), o;
  };
}), $t$1 = I("$ZodNull", (r2, i) => {
  z$1.init(r2, i), r2._zod.pattern = to, r2._zod.values = /* @__PURE__ */ new Set([null]), r2._zod.parse = (o, t) => {
    let n = o.value;
    if (n === null) return o;
    return o.issues.push({ expected: "null", code: "invalid_type", input: n, inst: r2 }), o;
  };
}), ut = I("$ZodAny", (r2, i) => {
  z$1.init(r2, i), r2._zod.parse = (o) => o;
}), gt$1 = I("$ZodUnknown", (r2, i) => {
  z$1.init(r2, i), r2._zod.parse = (o) => o;
}), et$1 = I("$ZodNever", (r2, i) => {
  z$1.init(r2, i), r2._zod.parse = (o, t) => {
    return o.issues.push({ expected: "never", code: "invalid_type", input: o.value, inst: r2 }), o;
  };
}), lt$1 = I("$ZodVoid", (r2, i) => {
  z$1.init(r2, i), r2._zod.parse = (o, t) => {
    let n = o.value;
    if (typeof n > "u") return o;
    return o.issues.push({ expected: "void", code: "invalid_type", input: n, inst: r2 }), o;
  };
}), It$1 = I("$ZodDate", (r2, i) => {
  z$1.init(r2, i), r2._zod.parse = (o, t) => {
    if (i.coerce) try {
      o.value = new Date(o.value);
    } catch (u2) {
    }
    let n = o.value, v = n instanceof Date;
    if (v && !Number.isNaN(n.getTime())) return o;
    return o.issues.push({ expected: "date", code: "invalid_type", input: n, ...v ? { received: "Invalid Date" } : {}, inst: r2 }), o;
  };
});
function de$2(r2, i, o) {
  if (r2.issues.length) i.issues.push(...M$1(o, r2.issues));
  i.value[o] = r2.value;
}
var ct = I("$ZodArray", (r2, i) => {
  z$1.init(r2, i), r2._zod.parse = (o, t) => {
    let n = o.value;
    if (!Array.isArray(n)) return o.issues.push({ expected: "array", code: "invalid_type", input: n, inst: r2 }), o;
    o.value = Array(n.length);
    let v = [];
    for (let $2 = 0; $2 < n.length; $2++) {
      let u2 = n[$2], l = i.element._zod.run({ value: u2, issues: [] }, t);
      if (l instanceof Promise) v.push(l.then((e) => de$2(e, o, $2)));
      else de$2(l, o, $2);
    }
    if (v.length) return Promise.all(v).then(() => o);
    return o;
  };
});
function vi$1(r2, i, o, t, n) {
  if (r2.issues.length) {
    if (n && !(o in t)) return;
    i.issues.push(...M$1(o, r2.issues));
  }
  if (r2.value === void 0) {
    if (o in t) i.value[o] = void 0;
  } else i.value[o] = r2.value;
}
function tl$1(r2) {
  let i = Object.keys(r2.shape);
  for (let t of i) if (!r2.shape?.[t]?._zod?.traits?.has("$ZodType")) throw Error(`Invalid element at key "${t}": expected a Zod schema`);
  let o = Gv$1(r2.shape);
  return { ...r2, keys: i, keySet: new Set(i), numKeys: i.length, optionalKeys: new Set(o) };
}
function $l$1(r2, i, o, t, n, v) {
  let $2 = [], u2 = n.keySet, l = n.catchall._zod, e = l.def.type, c = l.optout === "optional";
  for (let b in i) {
    if (u2.has(b)) continue;
    if (e === "never") {
      $2.push(b);
      continue;
    }
    let N2 = l.run({ value: i[b], issues: [] }, t);
    if (N2 instanceof Promise) r2.push(N2.then((O) => vi$1(O, o, b, i, c)));
    else vi$1(N2, o, b, i, c);
  }
  if ($2.length) o.issues.push({ code: "unrecognized_keys", keys: $2, input: i, inst: v });
  if (!r2.length) return o;
  return Promise.all(r2).then(() => {
    return o;
  });
}
var ul$1 = I("$ZodObject", (r2, i) => {
  if (z$1.init(r2, i), !Object.getOwnPropertyDescriptor(i, "shape")?.get) {
    let u2 = i.shape;
    Object.defineProperty(i, "shape", { get: () => {
      let l = { ...u2 };
      return Object.defineProperty(i, "shape", { value: l }), l;
    } });
  }
  let t = jr$1(() => tl$1(i));
  j(r2._zod, "propValues", () => {
    let u2 = i.shape, l = {};
    for (let e in u2) {
      let c = u2[e]._zod;
      if (c.values) {
        l[e] ?? (l[e] = /* @__PURE__ */ new Set());
        for (let b of c.values) l[e].add(b);
      }
    }
    return l;
  });
  let n = _r, v = i.catchall, $2;
  r2._zod.parse = (u2, l) => {
    $2 ?? ($2 = t.value);
    let e = u2.value;
    if (!n(e)) return u2.issues.push({ expected: "object", code: "invalid_type", input: e, inst: r2 }), u2;
    u2.value = {};
    let c = [], b = $2.shape;
    for (let N2 of $2.keys) {
      let O = b[N2], J2 = O._zod.optout === "optional", X2 = O._zod.run({ value: e[N2], issues: [] }, l);
      if (X2 instanceof Promise) c.push(X2.then((Sr2) => vi$1(Sr2, u2, N2, e, J2)));
      else vi$1(X2, u2, N2, e, J2);
    }
    if (!v) return c.length ? Promise.all(c).then(() => u2) : u2;
    return $l$1(c, e, u2, l, t.value, r2);
  };
}), _t = I("$ZodObjectJIT", (r2, i) => {
  ul$1.init(r2, i);
  let o = r2._zod.parse, t = jr$1(() => tl$1(i)), n = (N2) => {
    let O = new pn$1(["shape", "payload", "ctx"]), J2 = t.value, X2 = (C) => {
      let F2 = Fn$1(C);
      return `shape[${F2}]._zod.run({ value: input[${F2}], issues: [] }, ctx)`;
    };
    O.write("const input = payload.value;");
    let Sr2 = /* @__PURE__ */ Object.create(null), HI = 0;
    for (let C of J2.keys) Sr2[C] = `key_${HI++}`;
    O.write("const newResult = {};");
    for (let C of J2.keys) {
      let F2 = Sr2[C], Z2 = Fn$1(C), mI = N2[C]?._zod?.optout === "optional";
      if (O.write(`const ${F2} = ${X2(C)};`), mI) O.write(`
        if (${F2}.issues.length) {
          if (${Z2} in input) {
            payload.issues = payload.issues.concat(${F2}.issues.map(iss => ({
              ...iss,
              path: iss.path ? [${Z2}, ...iss.path] : [${Z2}]
            })));
          }
        }
        
        if (${F2}.value === undefined) {
          if (${Z2} in input) {
            newResult[${Z2}] = undefined;
          }
        } else {
          newResult[${Z2}] = ${F2}.value;
        }
        
      `);
      else O.write(`
        if (${F2}.issues.length) {
          payload.issues = payload.issues.concat(${F2}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${Z2}, ...iss.path] : [${Z2}]
          })));
        }
        
        if (${F2}.value === undefined) {
          if (${Z2} in input) {
            newResult[${Z2}] = undefined;
          }
        } else {
          newResult[${Z2}] = ${F2}.value;
        }
        
      `);
    }
    O.write("payload.value = newResult;"), O.write("return payload;");
    let MI = O.compile();
    return (C, F2) => MI(N2, C, F2);
  }, v, $2 = _r, u2 = !rn$1.jitless, e = u2 && Jv$1.value, c = i.catchall, b;
  r2._zod.parse = (N2, O) => {
    b ?? (b = t.value);
    let J2 = N2.value;
    if (!$2(J2)) return N2.issues.push({ expected: "object", code: "invalid_type", input: J2, inst: r2 }), N2;
    if (u2 && e && O?.async === false && O.jitless !== true) {
      if (!v) v = n(i.shape);
      if (N2 = v(N2, O), !c) return N2;
      return $l$1([], J2, N2, O, b, r2);
    }
    return o(N2, O);
  };
});
function Ce$2(r2, i, o, t) {
  for (let v of r2) if (v.issues.length === 0) return i.value = v.value, i;
  let n = r2.filter((v) => !$r$1(v));
  if (n.length === 1) return i.value = n[0].value, n[0];
  return i.issues.push({ code: "invalid_union", input: i.value, inst: o, errors: r2.map((v) => v.issues.map(($2) => q($2, t, A$1()))) }), i;
}
var Un$1 = I("$ZodUnion", (r2, i) => {
  z$1.init(r2, i), j(r2._zod, "optin", () => i.options.some((n) => n._zod.optin === "optional") ? "optional" : void 0), j(r2._zod, "optout", () => i.options.some((n) => n._zod.optout === "optional") ? "optional" : void 0), j(r2._zod, "values", () => {
    if (i.options.every((n) => n._zod.values)) return new Set(i.options.flatMap((n) => Array.from(n._zod.values)));
    return;
  }), j(r2._zod, "pattern", () => {
    if (i.options.every((n) => n._zod.pattern)) {
      let n = i.options.map((v) => v._zod.pattern);
      return new RegExp(`^(${n.map((v) => on$1(v.source)).join("|")})$`);
    }
    return;
  });
  let o = i.options.length === 1, t = i.options[0]._zod.run;
  r2._zod.parse = (n, v) => {
    if (o) return t(n, v);
    let $2 = false, u2 = [];
    for (let l of i.options) {
      let e = l._zod.run({ value: n.value, issues: [] }, v);
      if (e instanceof Promise) u2.push(e), $2 = true;
      else {
        if (e.issues.length === 0) return e;
        u2.push(e);
      }
    }
    if (!$2) return Ce$2(u2, n, r2, v);
    return Promise.all(u2).then((l) => {
      return Ce$2(l, n, r2, v);
    });
  };
});
function fe$1(r2, i, o, t) {
  let n = r2.filter((v) => v.issues.length === 0);
  if (n.length === 1) return i.value = n[0].value, i;
  if (n.length === 0) i.issues.push({ code: "invalid_union", input: i.value, inst: o, errors: r2.map((v) => v.issues.map(($2) => q($2, t, A$1()))) });
  else i.issues.push({ code: "invalid_union", input: i.value, inst: o, errors: [], inclusive: false });
  return i;
}
var bt = I("$ZodXor", (r2, i) => {
  Un$1.init(r2, i), i.inclusive = false;
  let o = i.options.length === 1, t = i.options[0]._zod.run;
  r2._zod.parse = (n, v) => {
    if (o) return t(n, v);
    let $2 = false, u2 = [];
    for (let l of i.options) {
      let e = l._zod.run({ value: n.value, issues: [] }, v);
      if (e instanceof Promise) u2.push(e), $2 = true;
      else u2.push(e);
    }
    if (!$2) return fe$1(u2, n, r2, v);
    return Promise.all(u2).then((l) => {
      return fe$1(l, n, r2, v);
    });
  };
}), Ut$1 = I("$ZodDiscriminatedUnion", (r2, i) => {
  i.inclusive = false, Un$1.init(r2, i);
  let o = r2._zod.parse;
  j(r2._zod, "propValues", () => {
    let n = {};
    for (let v of i.options) {
      let $2 = v._zod.propValues;
      if (!$2 || Object.keys($2).length === 0) throw Error(`Invalid discriminated union option at index "${i.options.indexOf(v)}"`);
      for (let [u2, l] of Object.entries($2)) {
        if (!n[u2]) n[u2] = /* @__PURE__ */ new Set();
        for (let e of l) n[u2].add(e);
      }
    }
    return n;
  });
  let t = jr$1(() => {
    let n = i.options, v = /* @__PURE__ */ new Map();
    for (let $2 of n) {
      let u2 = $2._zod.propValues?.[i.discriminator];
      if (!u2 || u2.size === 0) throw Error(`Invalid discriminated union option at index "${i.options.indexOf($2)}"`);
      for (let l of u2) {
        if (v.has(l)) throw Error(`Duplicate discriminator value "${String(l)}"`);
        v.set(l, $2);
      }
    }
    return v;
  });
  r2._zod.parse = (n, v) => {
    let $2 = n.value;
    if (!_r($2)) return n.issues.push({ code: "invalid_type", expected: "object", input: $2, inst: r2 }), n;
    let u2 = t.value.get($2?.[i.discriminator]);
    if (u2) return u2._zod.run(n, v);
    if (i.unionFallback) return o(n, v);
    return n.issues.push({ code: "invalid_union", errors: [], note: "No matching discriminator", discriminator: i.discriminator, input: $2, path: [i.discriminator], inst: r2 }), n;
  };
}), Dt$1 = I("$ZodIntersection", (r2, i) => {
  z$1.init(r2, i), r2._zod.parse = (o, t) => {
    let n = o.value, v = i.left._zod.run({ value: n, issues: [] }, t), $2 = i.right._zod.run({ value: n, issues: [] }, t);
    if (v instanceof Promise || $2 instanceof Promise) return Promise.all([v, $2]).then(([l, e]) => {
      return ye$2(o, l, e);
    });
    return ye$2(o, v, $2);
  };
});
function Go$1(r2, i) {
  if (r2 === i) return { valid: true, data: r2 };
  if (r2 instanceof Date && i instanceof Date && +r2 === +i) return { valid: true, data: r2 };
  if (tr(r2) && tr(i)) {
    let o = Object.keys(i), t = Object.keys(r2).filter((v) => o.indexOf(v) !== -1), n = { ...r2, ...i };
    for (let v of t) {
      let $2 = Go$1(r2[v], i[v]);
      if (!$2.valid) return { valid: false, mergeErrorPath: [v, ...$2.mergeErrorPath] };
      n[v] = $2.data;
    }
    return { valid: true, data: n };
  }
  if (Array.isArray(r2) && Array.isArray(i)) {
    if (r2.length !== i.length) return { valid: false, mergeErrorPath: [] };
    let o = [];
    for (let t = 0; t < r2.length; t++) {
      let n = r2[t], v = i[t], $2 = Go$1(n, v);
      if (!$2.valid) return { valid: false, mergeErrorPath: [t, ...$2.mergeErrorPath] };
      o.push($2.data);
    }
    return { valid: true, data: o };
  }
  return { valid: false, mergeErrorPath: [] };
}
function ye$2(r2, i, o) {
  let t = /* @__PURE__ */ new Map(), n;
  for (let u2 of i.issues) if (u2.code === "unrecognized_keys") {
    n ?? (n = u2);
    for (let l of u2.keys) {
      if (!t.has(l)) t.set(l, {});
      t.get(l).l = true;
    }
  } else r2.issues.push(u2);
  for (let u2 of o.issues) if (u2.code === "unrecognized_keys") for (let l of u2.keys) {
    if (!t.has(l)) t.set(l, {});
    t.get(l).r = true;
  }
  else r2.issues.push(u2);
  let v = [...t].filter(([, u2]) => u2.l && u2.r).map(([u2]) => u2);
  if (v.length && n) r2.issues.push({ ...n, keys: v });
  if ($r$1(r2)) return r2;
  let $2 = Go$1(i.value, o.value);
  if (!$2.valid) throw Error(`Unmergable intersection. Error path: ${JSON.stringify($2.mergeErrorPath)}`);
  return r2.value = $2.data, r2;
}
var $i$1 = I("$ZodTuple", (r2, i) => {
  z$1.init(r2, i);
  let o = i.items;
  r2._zod.parse = (t, n) => {
    let v = t.value;
    if (!Array.isArray(v)) return t.issues.push({ input: v, inst: r2, expected: "tuple", code: "invalid_type" }), t;
    t.value = [];
    let $2 = [], u2 = [...o].reverse().findIndex((c) => c._zod.optin !== "optional"), l = u2 === -1 ? 0 : o.length - u2;
    if (!i.rest) {
      let c = v.length > o.length, b = v.length < l - 1;
      if (c || b) return t.issues.push({ ...c ? { code: "too_big", maximum: o.length, inclusive: true } : { code: "too_small", minimum: o.length }, input: v, inst: r2, origin: "array" }), t;
    }
    let e = -1;
    for (let c of o) {
      if (e++, e >= v.length) {
        if (e >= l) continue;
      }
      let b = c._zod.run({ value: v[e], issues: [] }, n);
      if (b instanceof Promise) $2.push(b.then((N2) => sn$1(N2, t, e)));
      else sn$1(b, t, e);
    }
    if (i.rest) {
      let c = v.slice(o.length);
      for (let b of c) {
        e++;
        let N2 = i.rest._zod.run({ value: b, issues: [] }, n);
        if (N2 instanceof Promise) $2.push(N2.then((O) => sn$1(O, t, e)));
        else sn$1(N2, t, e);
      }
    }
    if ($2.length) return Promise.all($2).then(() => t);
    return t;
  };
});
function sn$1(r2, i, o) {
  if (r2.issues.length) i.issues.push(...M$1(o, r2.issues));
  i.value[o] = r2.value;
}
var kt$1 = I("$ZodRecord", (r2, i) => {
  z$1.init(r2, i), r2._zod.parse = (o, t) => {
    let n = o.value;
    if (!tr(n)) return o.issues.push({ expected: "record", code: "invalid_type", input: n, inst: r2 }), o;
    let v = [], $2 = i.keyType._zod.values;
    if ($2) {
      o.value = {};
      let u2 = /* @__PURE__ */ new Set();
      for (let e of $2) if (typeof e === "string" || typeof e === "number" || typeof e === "symbol") {
        u2.add(typeof e === "number" ? e.toString() : e);
        let c = i.valueType._zod.run({ value: n[e], issues: [] }, t);
        if (c instanceof Promise) v.push(c.then((b) => {
          if (b.issues.length) o.issues.push(...M$1(e, b.issues));
          o.value[e] = b.value;
        }));
        else {
          if (c.issues.length) o.issues.push(...M$1(e, c.issues));
          o.value[e] = c.value;
        }
      }
      let l;
      for (let e in n) if (!u2.has(e)) l = l ?? [], l.push(e);
      if (l && l.length > 0) o.issues.push({ code: "unrecognized_keys", input: n, inst: r2, keys: l });
    } else {
      o.value = {};
      for (let u2 of Reflect.ownKeys(n)) {
        if (u2 === "__proto__") continue;
        let l = i.keyType._zod.run({ value: u2, issues: [] }, t);
        if (l instanceof Promise) throw Error("Async schemas not supported in object keys currently");
        if (typeof u2 === "string" && In$1.test(u2) && l.issues.length && l.issues.some((b) => b.code === "invalid_type" && b.expected === "number")) {
          let b = i.keyType._zod.run({ value: Number(u2), issues: [] }, t);
          if (b instanceof Promise) throw Error("Async schemas not supported in object keys currently");
          if (b.issues.length === 0) l = b;
        }
        if (l.issues.length) {
          if (i.mode === "loose") o.value[u2] = n[u2];
          else o.issues.push({ code: "invalid_key", origin: "record", issues: l.issues.map((b) => q(b, t, A$1())), input: u2, path: [u2], inst: r2 });
          continue;
        }
        let c = i.valueType._zod.run({ value: n[u2], issues: [] }, t);
        if (c instanceof Promise) v.push(c.then((b) => {
          if (b.issues.length) o.issues.push(...M$1(u2, b.issues));
          o.value[l.value] = b.value;
        }));
        else {
          if (c.issues.length) o.issues.push(...M$1(u2, c.issues));
          o.value[l.value] = c.value;
        }
      }
    }
    if (v.length) return Promise.all(v).then(() => o);
    return o;
  };
}), wt$1 = I("$ZodMap", (r2, i) => {
  z$1.init(r2, i), r2._zod.parse = (o, t) => {
    let n = o.value;
    if (!(n instanceof Map)) return o.issues.push({ expected: "map", code: "invalid_type", input: n, inst: r2 }), o;
    let v = [];
    o.value = /* @__PURE__ */ new Map();
    for (let [$2, u2] of n) {
      let l = i.keyType._zod.run({ value: $2, issues: [] }, t), e = i.valueType._zod.run({ value: u2, issues: [] }, t);
      if (l instanceof Promise || e instanceof Promise) v.push(Promise.all([l, e]).then(([c, b]) => {
        he$2(c, b, o, $2, n, r2, t);
      }));
      else he$2(l, e, o, $2, n, r2, t);
    }
    if (v.length) return Promise.all(v).then(() => o);
    return o;
  };
});
function he$2(r2, i, o, t, n, v, $2) {
  if (r2.issues.length) if (tn$1.has(typeof t)) o.issues.push(...M$1(t, r2.issues));
  else o.issues.push({ code: "invalid_key", origin: "map", input: n, inst: v, issues: r2.issues.map((u2) => q(u2, $2, A$1())) });
  if (i.issues.length) if (tn$1.has(typeof t)) o.issues.push(...M$1(t, i.issues));
  else o.issues.push({ origin: "map", code: "invalid_element", input: n, inst: v, key: t, issues: i.issues.map((u2) => q(u2, $2, A$1())) });
  o.value.set(r2.value, i.value);
}
var Nt$1 = I("$ZodSet", (r2, i) => {
  z$1.init(r2, i), r2._zod.parse = (o, t) => {
    let n = o.value;
    if (!(n instanceof Set)) return o.issues.push({ input: n, inst: r2, expected: "set", code: "invalid_type" }), o;
    let v = [];
    o.value = /* @__PURE__ */ new Set();
    for (let $2 of n) {
      let u2 = i.valueType._zod.run({ value: $2, issues: [] }, t);
      if (u2 instanceof Promise) v.push(u2.then((l) => ae(l, o)));
      else ae(u2, o);
    }
    if (v.length) return Promise.all(v).then(() => o);
    return o;
  };
});
function ae(r2, i) {
  if (r2.issues.length) i.issues.push(...r2.issues);
  i.value.add(r2.value);
}
var Ot$1 = I("$ZodEnum", (r2, i) => {
  z$1.init(r2, i);
  let o = vn$1(i.entries), t = new Set(o);
  r2._zod.values = t, r2._zod.pattern = new RegExp(`^(${o.filter((n) => tn$1.has(typeof n)).map((n) => typeof n === "string" ? R(n) : n.toString()).join("|")})$`), r2._zod.parse = (n, v) => {
    let $2 = n.value;
    if (t.has($2)) return n;
    return n.issues.push({ code: "invalid_value", values: o, input: $2, inst: r2 }), n;
  };
}), St$1 = I("$ZodLiteral", (r2, i) => {
  if (z$1.init(r2, i), i.values.length === 0) throw Error("Cannot create literal schema with no valid values");
  let o = new Set(i.values);
  r2._zod.values = o, r2._zod.pattern = new RegExp(`^(${i.values.map((t) => typeof t === "string" ? R(t) : t ? R(t.toString()) : String(t)).join("|")})$`), r2._zod.parse = (t, n) => {
    let v = t.value;
    if (o.has(v)) return t;
    return t.issues.push({ code: "invalid_value", values: i.values, input: v, inst: r2 }), t;
  };
}), zt$1 = I("$ZodFile", (r2, i) => {
  z$1.init(r2, i), r2._zod.parse = (o, t) => {
    let n = o.value;
    if (n instanceof File) return o;
    return o.issues.push({ expected: "file", code: "invalid_type", input: n, inst: r2 }), o;
  };
}), Pt$1 = I("$ZodTransform", (r2, i) => {
  z$1.init(r2, i), r2._zod.parse = (o, t) => {
    if (t.direction === "backward") throw new cr(r2.constructor.name);
    let n = i.transform(o.value, o);
    if (t.async) return (n instanceof Promise ? n : Promise.resolve(n)).then(($2) => {
      return o.value = $2, o;
    });
    if (n instanceof Promise) throw new f();
    return o.value = n, o;
  };
});
function pe$2(r2, i) {
  if (r2.issues.length && i === void 0) return { issues: [], value: void 0 };
  return r2;
}
var ui = I("$ZodOptional", (r2, i) => {
  z$1.init(r2, i), r2._zod.optin = "optional", r2._zod.optout = "optional", j(r2._zod, "values", () => {
    return i.innerType._zod.values ? /* @__PURE__ */ new Set([...i.innerType._zod.values, void 0]) : void 0;
  }), j(r2._zod, "pattern", () => {
    let o = i.innerType._zod.pattern;
    return o ? new RegExp(`^(${on$1(o.source)})?$`) : void 0;
  }), r2._zod.parse = (o, t) => {
    if (i.innerType._zod.optin === "optional") {
      let n = i.innerType._zod.run(o, t);
      if (n instanceof Promise) return n.then((v) => pe$2(v, o.value));
      return pe$2(n, o.value);
    }
    if (o.value === void 0) return o;
    return i.innerType._zod.run(o, t);
  };
}), jt$1 = I("$ZodExactOptional", (r2, i) => {
  ui.init(r2, i), j(r2._zod, "values", () => i.innerType._zod.values), j(r2._zod, "pattern", () => i.innerType._zod.pattern), r2._zod.parse = (o, t) => {
    return i.innerType._zod.run(o, t);
  };
}), Jt = I("$ZodNullable", (r2, i) => {
  z$1.init(r2, i), j(r2._zod, "optin", () => i.innerType._zod.optin), j(r2._zod, "optout", () => i.innerType._zod.optout), j(r2._zod, "pattern", () => {
    let o = i.innerType._zod.pattern;
    return o ? new RegExp(`^(${on$1(o.source)}|null)$`) : void 0;
  }), j(r2._zod, "values", () => {
    return i.innerType._zod.values ? /* @__PURE__ */ new Set([...i.innerType._zod.values, null]) : void 0;
  }), r2._zod.parse = (o, t) => {
    if (o.value === null) return o;
    return i.innerType._zod.run(o, t);
  };
}), Lt$1 = I("$ZodDefault", (r2, i) => {
  z$1.init(r2, i), r2._zod.optin = "optional", j(r2._zod, "values", () => i.innerType._zod.values), r2._zod.parse = (o, t) => {
    if (t.direction === "backward") return i.innerType._zod.run(o, t);
    if (o.value === void 0) return o.value = i.defaultValue, o;
    let n = i.innerType._zod.run(o, t);
    if (n instanceof Promise) return n.then((v) => se(v, i));
    return se(n, i);
  };
});
function se(r2, i) {
  if (r2.value === void 0) r2.value = i.defaultValue;
  return r2;
}
var Et$1 = I("$ZodPrefault", (r2, i) => {
  z$1.init(r2, i), r2._zod.optin = "optional", j(r2._zod, "values", () => i.innerType._zod.values), r2._zod.parse = (o, t) => {
    if (t.direction === "backward") return i.innerType._zod.run(o, t);
    if (o.value === void 0) o.value = i.defaultValue;
    return i.innerType._zod.run(o, t);
  };
}), Gt = I("$ZodNonOptional", (r2, i) => {
  z$1.init(r2, i), j(r2._zod, "values", () => {
    let o = i.innerType._zod.values;
    return o ? new Set([...o].filter((t) => t !== void 0)) : void 0;
  }), r2._zod.parse = (o, t) => {
    let n = i.innerType._zod.run(o, t);
    if (n instanceof Promise) return n.then((v) => rl$1(v, r2));
    return rl$1(n, r2);
  };
});
function rl$1(r2, i) {
  if (!r2.issues.length && r2.value === void 0) r2.issues.push({ code: "invalid_type", expected: "nonoptional", input: r2.value, inst: i });
  return r2;
}
var Wt$1 = I("$ZodSuccess", (r2, i) => {
  z$1.init(r2, i), r2._zod.parse = (o, t) => {
    if (t.direction === "backward") throw new cr("ZodSuccess");
    let n = i.innerType._zod.run(o, t);
    if (n instanceof Promise) return n.then((v) => {
      return o.value = v.issues.length === 0, o;
    });
    return o.value = n.issues.length === 0, o;
  };
}), Xt$1 = I("$ZodCatch", (r2, i) => {
  z$1.init(r2, i), j(r2._zod, "optin", () => i.innerType._zod.optin), j(r2._zod, "optout", () => i.innerType._zod.optout), j(r2._zod, "values", () => i.innerType._zod.values), r2._zod.parse = (o, t) => {
    if (t.direction === "backward") return i.innerType._zod.run(o, t);
    let n = i.innerType._zod.run(o, t);
    if (n instanceof Promise) return n.then((v) => {
      if (o.value = v.value, v.issues.length) o.value = i.catchValue({ ...o, error: { issues: v.issues.map(($2) => q($2, t, A$1())) }, input: o.value }), o.issues = [];
      return o;
    });
    if (o.value = n.value, n.issues.length) o.value = i.catchValue({ ...o, error: { issues: n.issues.map((v) => q(v, t, A$1())) }, input: o.value }), o.issues = [];
    return o;
  };
}), At$1 = I("$ZodNaN", (r2, i) => {
  z$1.init(r2, i), r2._zod.parse = (o, t) => {
    if (typeof o.value !== "number" || !Number.isNaN(o.value)) return o.issues.push({ input: o.value, inst: r2, expected: "nan", code: "invalid_type" }), o;
    return o;
  };
}), Vt = I("$ZodPipe", (r2, i) => {
  z$1.init(r2, i), j(r2._zod, "values", () => i.in._zod.values), j(r2._zod, "optin", () => i.in._zod.optin), j(r2._zod, "optout", () => i.out._zod.optout), j(r2._zod, "propValues", () => i.in._zod.propValues), r2._zod.parse = (o, t) => {
    if (t.direction === "backward") {
      let v = i.out._zod.run(o, t);
      if (v instanceof Promise) return v.then(($2) => ri$1($2, i.in, t));
      return ri$1(v, i.in, t);
    }
    let n = i.in._zod.run(o, t);
    if (n instanceof Promise) return n.then((v) => ri$1(v, i.out, t));
    return ri$1(n, i.out, t);
  };
});
function ri$1(r2, i, o) {
  if (r2.issues.length) return r2.aborted = true, r2;
  return i._zod.run({ value: r2.value, issues: r2.issues }, o);
}
var Dn$1 = I("$ZodCodec", (r2, i) => {
  z$1.init(r2, i), j(r2._zod, "values", () => i.in._zod.values), j(r2._zod, "optin", () => i.in._zod.optin), j(r2._zod, "optout", () => i.out._zod.optout), j(r2._zod, "propValues", () => i.in._zod.propValues), r2._zod.parse = (o, t) => {
    if ((t.direction || "forward") === "forward") {
      let v = i.in._zod.run(o, t);
      if (v instanceof Promise) return v.then(($2) => ni$1($2, i, t));
      return ni$1(v, i, t);
    } else {
      let v = i.out._zod.run(o, t);
      if (v instanceof Promise) return v.then(($2) => ni$1($2, i, t));
      return ni$1(v, i, t);
    }
  };
});
function ni$1(r2, i, o) {
  if (r2.issues.length) return r2.aborted = true, r2;
  if ((o.direction || "forward") === "forward") {
    let n = i.transform(r2.value, r2);
    if (n instanceof Promise) return n.then((v) => ii$1(r2, v, i.out, o));
    return ii$1(r2, n, i.out, o);
  } else {
    let n = i.reverseTransform(r2.value, r2);
    if (n instanceof Promise) return n.then((v) => ii$1(r2, v, i.in, o));
    return ii$1(r2, n, i.in, o);
  }
}
function ii$1(r2, i, o, t) {
  if (r2.issues.length) return r2.aborted = true, r2;
  return o._zod.run({ value: i, issues: r2.issues }, t);
}
var Kt$1 = I("$ZodReadonly", (r2, i) => {
  z$1.init(r2, i), j(r2._zod, "propValues", () => i.innerType._zod.propValues), j(r2._zod, "values", () => i.innerType._zod.values), j(r2._zod, "optin", () => i.innerType?._zod?.optin), j(r2._zod, "optout", () => i.innerType?._zod?.optout), r2._zod.parse = (o, t) => {
    if (t.direction === "backward") return i.innerType._zod.run(o, t);
    let n = i.innerType._zod.run(o, t);
    if (n instanceof Promise) return n.then(nl$1);
    return nl$1(n);
  };
});
function nl$1(r2) {
  return r2.value = Object.freeze(r2.value), r2;
}
var Yt$1 = I("$ZodTemplateLiteral", (r2, i) => {
  z$1.init(r2, i);
  let o = [];
  for (let t of i.parts) if (typeof t === "object" && t !== null) {
    if (!t._zod.pattern) throw Error(`Invalid template literal part, no pattern found: ${[...t._zod.traits].shift()}`);
    let n = t._zod.pattern instanceof RegExp ? t._zod.pattern.source : t._zod.pattern;
    if (!n) throw Error(`Invalid template literal part: ${t._zod.traits}`);
    let v = n.startsWith("^") ? 1 : 0, $2 = n.endsWith("$") ? n.length - 1 : n.length;
    o.push(n.slice(v, $2));
  } else if (t === null || Ev$1.has(typeof t)) o.push(R(`${t}`));
  else throw Error(`Invalid template literal part: ${t}`);
  r2._zod.pattern = new RegExp(`^${o.join("")}$`), r2._zod.parse = (t, n) => {
    if (typeof t.value !== "string") return t.issues.push({ input: t.value, inst: r2, expected: "string", code: "invalid_type" }), t;
    if (r2._zod.pattern.lastIndex = 0, !r2._zod.pattern.test(t.value)) return t.issues.push({ input: t.value, inst: r2, code: "invalid_format", format: i.format ?? "template_literal", pattern: r2._zod.pattern.source }), t;
    return t;
  };
}), Qt$1 = I("$ZodFunction", (r2, i) => {
  return z$1.init(r2, i), r2._def = i, r2._zod.def = i, r2.implement = (o) => {
    if (typeof o !== "function") throw Error("implement() must be called with a function");
    return function(...t) {
      let n = r2._def.input ? Bn$1(r2._def.input, t) : t, v = Reflect.apply(o, this, n);
      if (r2._def.output) return Bn$1(r2._def.output, v);
      return v;
    };
  }, r2.implementAsync = (o) => {
    if (typeof o !== "function") throw Error("implementAsync() must be called with a function");
    return async function(...t) {
      let n = r2._def.input ? await Hn$1(r2._def.input, t) : t, v = await Reflect.apply(o, this, n);
      if (r2._def.output) return await Hn$1(r2._def.output, v);
      return v;
    };
  }, r2._zod.parse = (o, t) => {
    if (typeof o.value !== "function") return o.issues.push({ code: "invalid_type", expected: "function", input: o.value, inst: r2 }), o;
    if (r2._def.output && r2._def.output._zod.def.type === "promise") o.value = r2.implementAsync(o.value);
    else o.value = r2.implement(o.value);
    return o;
  }, r2.input = (...o) => {
    let t = r2.constructor;
    if (Array.isArray(o[0])) return new t({ type: "function", input: new $i$1({ type: "tuple", items: o[0], rest: o[1] }), output: r2._def.output });
    return new t({ type: "function", input: o[0], output: r2._def.output });
  }, r2.output = (o) => {
    return new r2.constructor({ type: "function", input: r2._def.input, output: o });
  }, r2;
}), Tt$1 = I("$ZodPromise", (r2, i) => {
  z$1.init(r2, i), r2._zod.parse = (o, t) => {
    return Promise.resolve(o.value).then((n) => i.innerType._zod.run({ value: n, issues: [] }, t));
  };
}), Ft$1 = I("$ZodLazy", (r2, i) => {
  z$1.init(r2, i), j(r2._zod, "innerType", () => i.getter()), j(r2._zod, "pattern", () => r2._zod.innerType?._zod?.pattern), j(r2._zod, "propValues", () => r2._zod.innerType?._zod?.propValues), j(r2._zod, "optin", () => r2._zod.innerType?._zod?.optin ?? void 0), j(r2._zod, "optout", () => r2._zod.innerType?._zod?.optout ?? void 0), r2._zod.parse = (o, t) => {
    return r2._zod.innerType._zod.run(o, t);
  };
}), qt$1 = I("$ZodCustom", (r2, i) => {
  W$1.init(r2, i), z$1.init(r2, i), r2._zod.parse = (o, t) => {
    return o;
  }, r2._zod.check = (o) => {
    let t = o.value, n = i.fn(t);
    if (n instanceof Promise) return n.then((v) => il$1(v, o, t, r2));
    il$1(n, o, t, r2);
    return;
  };
});
function il$1(r2, i, o, t) {
  if (!r2) {
    let n = { code: "custom", input: o, inst: t, path: [...t._zod.def.path ?? []], continue: !t._zod.def.abort };
    if (t._zod.def.params) n.params = t._zod.def.params;
    i.issues.push(Jr$1(n));
  }
}
var Sn$1 = {};
s(Sn$1, { zhTW: () => W$, zhCN: () => G$, yo: () => X$, vi: () => E$, uz: () => L$, ur: () => J$, uk: () => On$1, ua: () => j$, tr: () => P$, th: () => z$, ta: () => S$, sv: () => O$, sl: () => N$, ru: () => w$, pt: () => k$, ps: () => U$, pl: () => D$, ota: () => b$, no: () => _$, nl: () => c$, ms: () => I$, mk: () => l$, lt: () => e$, ko: () => g$, km: () => wn$1, kh: () => u$, ka: () => $$, ja: () => t$, it: () => o$, is: () => v$, id: () => i$, hy: () => n$, hu: () => r$, he: () => st$1, frCA: () => pt$1, fr: () => at$1, fi: () => ht$1, fa: () => yt$1, es: () => ft$1, eo: () => Ct$1, en: () => kn$1, de: () => dt$1, da: () => Zt$1, cs: () => xt$1, ca: () => Rt$1, bg: () => mt, be: () => Mt$1, az: () => Ht, ar: () => Bt$1 });
var c6 = () => {
  let r2 = { string: { unit: "", verb: " " }, file: { unit: "", verb: " " }, array: { unit: "", verb: " " }, set: { unit: "", verb: " " } };
  function i(n) {
    return r2[n] ?? null;
  }
  let o = { regex: "", email: " ", url: "", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "   ISO", date: "  ISO", time: "  ISO", duration: "  ISO", ipv4: " IPv4", ipv6: " IPv6", cidrv4: "   IPv4", cidrv6: "   IPv6", base64: "  base64-encoded", base64url: "  base64url-encoded", json_string: "   JSON", e164: "   E.164", jwt: "JWT", template_literal: "" }, t = { nan: "NaN" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, $2 = D$2(n.input), u2 = t[$2] ?? $2;
        if (/^[A-Z]/.test(n.expected)) return `  :   instanceof ${n.expected}    ${u2}`;
        return `  :   ${v}    ${u2}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `  :   ${U$1(n.values[0])}`;
        return `  :     : ${_$1(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", $2 = i(n.origin);
        if ($2) return `   :    ${n.origin ?? ""} ${v} ${n.maximum.toString()} ${$2.unit ?? ""}`;
        return `  :    ${n.origin ?? ""} ${v} ${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", $2 = i(n.origin);
        if ($2) return `  :   ${n.origin}   ${v} ${n.minimum.toString()} ${$2.unit}`;
        return `  :   ${n.origin}   ${v} ${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `  :     "${n.prefix}"`;
        if (v.format === "ends_with") return `  :     "${v.suffix}"`;
        if (v.format === "includes") return `  :    "${v.includes}"`;
        if (v.format === "regex") return `  :     ${v.pattern}`;
        return `${o[v.format] ?? n.format}  `;
      }
      case "not_multiple_of":
        return `  :      ${n.divisor}`;
      case "unrecognized_keys":
        return `${n.keys.length > 1 ? "" : ""} ${n.keys.length > 1 ? "" : ""}: ${_$1(n.keys, " ")}`;
      case "invalid_key":
        return `    ${n.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `    ${n.origin}`;
      default:
        return "  ";
    }
  };
};
function Bt$1() {
  return { localeError: c6() };
}
var _6 = () => {
  let r2 = { string: { unit: "simvol", verb: "olmaldr" }, file: { unit: "bayt", verb: "olmaldr" }, array: { unit: "element", verb: "olmaldr" }, set: { unit: "element", verb: "olmaldr" } };
  function i(n) {
    return r2[n] ?? null;
  }
  let o = { regex: "input", email: "email address", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO datetime", date: "ISO date", time: "ISO time", duration: "ISO duration", ipv4: "IPv4 address", ipv6: "IPv6 address", cidrv4: "IPv4 range", cidrv6: "IPv6 range", base64: "base64-encoded string", base64url: "base64url-encoded string", json_string: "JSON string", e164: "E.164 number", jwt: "JWT", template_literal: "input" }, t = { nan: "NaN" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, $2 = D$2(n.input), u2 = t[$2] ?? $2;
        if (/^[A-Z]/.test(n.expected)) return `Yanl dyr: gzlniln instanceof ${n.expected}, daxil olan ${u2}`;
        return `Yanl dyr: gzlniln ${v}, daxil olan ${u2}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Yanl dyr: gzlniln ${U$1(n.values[0])}`;
        return `Yanl seim: aadaklardan biri olmaldr: ${_$1(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", $2 = i(n.origin);
        if ($2) return `ox byk: gzlniln ${n.origin ?? "dyr"} ${v}${n.maximum.toString()} ${$2.unit ?? "element"}`;
        return `ox byk: gzlniln ${n.origin ?? "dyr"} ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", $2 = i(n.origin);
        if ($2) return `ox kiik: gzlniln ${n.origin} ${v}${n.minimum.toString()} ${$2.unit}`;
        return `ox kiik: gzlniln ${n.origin} ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `Yanl mtn: "${v.prefix}" il balamaldr`;
        if (v.format === "ends_with") return `Yanl mtn: "${v.suffix}" il bitmlidir`;
        if (v.format === "includes") return `Yanl mtn: "${v.includes}" daxil olmaldr`;
        if (v.format === "regex") return `Yanl mtn: ${v.pattern} ablonuna uyun olmaldr`;
        return `Yanl ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Yanl dd: ${n.divisor} il bln biln olmaldr`;
      case "unrecognized_keys":
        return `Tannmayan aar${n.keys.length > 1 ? "lar" : ""}: ${_$1(n.keys, ", ")}`;
      case "invalid_key":
        return `${n.origin} daxilind yanl aar`;
      case "invalid_union":
        return "Yanl dyr";
      case "invalid_element":
        return `${n.origin} daxilind yanl dyr`;
      default:
        return "Yanl dyr";
    }
  };
};
function Ht() {
  return { localeError: _6() };
}
function gl$1(r2, i, o, t) {
  let n = Math.abs(r2), v = n % 10, $2 = n % 100;
  if ($2 >= 11 && $2 <= 19) return t;
  if (v === 1) return i;
  if (v >= 2 && v <= 4) return o;
  return t;
}
var b6 = () => {
  let r2 = { string: { unit: { one: "", few: "", many: "" }, verb: "" }, array: { unit: { one: "", few: "", many: "" }, verb: "" }, set: { unit: { one: "", few: "", many: "" }, verb: "" }, file: { unit: { one: "", few: "", many: "" }, verb: "" } };
  function i(n) {
    return r2[n] ?? null;
  }
  let o = { regex: "", email: "email ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO   ", date: "ISO ", time: "ISO ", duration: "ISO ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "   base64", base64url: "   base64url", json_string: "JSON ", e164: " E.164", jwt: "JWT", template_literal: "" }, t = { nan: "NaN", number: "", array: "" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, $2 = D$2(n.input), u2 = t[$2] ?? $2;
        if (/^[A-Z]/.test(n.expected)) return ` :  instanceof ${n.expected},  ${u2}`;
        return ` :  ${v},  ${u2}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return ` :  ${U$1(n.values[0])}`;
        return ` :    ${_$1(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", $2 = i(n.origin);
        if ($2) {
          let u2 = Number(n.maximum), l = gl$1(u2, $2.unit.one, $2.unit.few, $2.unit.many);
          return ` : ,  ${n.origin ?? ""}  ${$2.verb} ${v}${n.maximum.toString()} ${l}`;
        }
        return ` : ,  ${n.origin ?? ""}   ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", $2 = i(n.origin);
        if ($2) {
          let u2 = Number(n.minimum), l = gl$1(u2, $2.unit.one, $2.unit.few, $2.unit.many);
          return ` : ,  ${n.origin}  ${$2.verb} ${v}${n.minimum.toString()} ${l}`;
        }
        return ` : ,  ${n.origin}   ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return ` :    "${v.prefix}"`;
        if (v.format === "ends_with") return ` :    "${v.suffix}"`;
        if (v.format === "includes") return ` :   "${v.includes}"`;
        if (v.format === "regex") return ` :    ${v.pattern}`;
        return ` ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return ` :    ${n.divisor}`;
      case "unrecognized_keys":
        return ` ${n.keys.length > 1 ? "" : ""}: ${_$1(n.keys, ", ")}`;
      case "invalid_key":
        return `   ${n.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${n.origin}`;
      default:
        return " ";
    }
  };
};
function Mt$1() {
  return { localeError: b6() };
}
var U6 = () => {
  let r2 = { string: { unit: "", verb: " " }, file: { unit: "", verb: " " }, array: { unit: "", verb: " " }, set: { unit: "", verb: " " } };
  function i(n) {
    return r2[n] ?? null;
  }
  let o = { regex: "", email: " ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO ", date: "ISO ", time: "ISO ", duration: "ISO ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64- ", base64url: "base64url- ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "" }, t = { nan: "NaN", number: "", array: "" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, $2 = D$2(n.input), u2 = t[$2] ?? $2;
        if (/^[A-Z]/.test(n.expected)) return ` :  instanceof ${n.expected},  ${u2}`;
        return ` :  ${v},  ${u2}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return ` :  ${U$1(n.values[0])}`;
        return ` :    ${_$1(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", $2 = i(n.origin);
        if ($2) return ` :   ${n.origin ?? ""}   ${v}${n.maximum.toString()} ${$2.unit ?? ""}`;
        return ` :   ${n.origin ?? ""}   ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", $2 = i(n.origin);
        if ($2) return ` :   ${n.origin}   ${v}${n.minimum.toString()} ${$2.unit}`;
        return ` :   ${n.origin}   ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return ` :     "${v.prefix}"`;
        if (v.format === "ends_with") return ` :     "${v.suffix}"`;
        if (v.format === "includes") return ` :    "${v.includes}"`;
        if (v.format === "regex") return ` :     ${v.pattern}`;
        let $2 = "";
        if (v.format === "emoji") $2 = "";
        if (v.format === "datetime") $2 = "";
        if (v.format === "date") $2 = "";
        if (v.format === "time") $2 = "";
        if (v.format === "duration") $2 = "";
        return `${$2} ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return ` :      ${n.divisor}`;
      case "unrecognized_keys":
        return `${n.keys.length > 1 ? "" : ""} ${n.keys.length > 1 ? "" : ""}: ${_$1(n.keys, ", ")}`;
      case "invalid_key":
        return `   ${n.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${n.origin}`;
      default:
        return " ";
    }
  };
};
function mt() {
  return { localeError: U6() };
}
var D6 = () => {
  let r2 = { string: { unit: "carcters", verb: "contenir" }, file: { unit: "bytes", verb: "contenir" }, array: { unit: "elements", verb: "contenir" }, set: { unit: "elements", verb: "contenir" } };
  function i(n) {
    return r2[n] ?? null;
  }
  let o = { regex: "entrada", email: "adrea electrnica", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "data i hora ISO", date: "data ISO", time: "hora ISO", duration: "durada ISO", ipv4: "adrea IPv4", ipv6: "adrea IPv6", cidrv4: "rang IPv4", cidrv6: "rang IPv6", base64: "cadena codificada en base64", base64url: "cadena codificada en base64url", json_string: "cadena JSON", e164: "nmero E.164", jwt: "JWT", template_literal: "entrada" }, t = { nan: "NaN" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, $2 = D$2(n.input), u2 = t[$2] ?? $2;
        if (/^[A-Z]/.test(n.expected)) return `Tipus invlid: s'esperava instanceof ${n.expected}, s'ha rebut ${u2}`;
        return `Tipus invlid: s'esperava ${v}, s'ha rebut ${u2}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Valor invlid: s'esperava ${U$1(n.values[0])}`;
        return `Opci invlida: s'esperava una de ${_$1(n.values, " o ")}`;
      case "too_big": {
        let v = n.inclusive ? "com a mxim" : "menys de", $2 = i(n.origin);
        if ($2) return `Massa gran: s'esperava que ${n.origin ?? "el valor"} contingus ${v} ${n.maximum.toString()} ${$2.unit ?? "elements"}`;
        return `Massa gran: s'esperava que ${n.origin ?? "el valor"} fos ${v} ${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? "com a mnim" : "ms de", $2 = i(n.origin);
        if ($2) return `Massa petit: s'esperava que ${n.origin} contingus ${v} ${n.minimum.toString()} ${$2.unit}`;
        return `Massa petit: s'esperava que ${n.origin} fos ${v} ${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `Format invlid: ha de comenar amb "${v.prefix}"`;
        if (v.format === "ends_with") return `Format invlid: ha d'acabar amb "${v.suffix}"`;
        if (v.format === "includes") return `Format invlid: ha d'incloure "${v.includes}"`;
        if (v.format === "regex") return `Format invlid: ha de coincidir amb el patr ${v.pattern}`;
        return `Format invlid per a ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Nmero invlid: ha de ser mltiple de ${n.divisor}`;
      case "unrecognized_keys":
        return `Clau${n.keys.length > 1 ? "s" : ""} no reconeguda${n.keys.length > 1 ? "s" : ""}: ${_$1(n.keys, ", ")}`;
      case "invalid_key":
        return `Clau invlida a ${n.origin}`;
      case "invalid_union":
        return "Entrada invlida";
      case "invalid_element":
        return `Element invlid a ${n.origin}`;
      default:
        return "Entrada invlida";
    }
  };
};
function Rt$1() {
  return { localeError: D6() };
}
var k6 = () => {
  let r2 = { string: { unit: "znak", verb: "mt" }, file: { unit: "bajt", verb: "mt" }, array: { unit: "prvk", verb: "mt" }, set: { unit: "prvk", verb: "mt" } };
  function i(n) {
    return r2[n] ?? null;
  }
  let o = { regex: "regulrn vraz", email: "e-mailov adresa", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "datum a as ve formtu ISO", date: "datum ve formtu ISO", time: "as ve formtu ISO", duration: "doba trvn ISO", ipv4: "IPv4 adresa", ipv6: "IPv6 adresa", cidrv4: "rozsah IPv4", cidrv6: "rozsah IPv6", base64: "etzec zakdovan ve formtu base64", base64url: "etzec zakdovan ve formtu base64url", json_string: "etzec ve formtu JSON", e164: "slo E.164", jwt: "JWT", template_literal: "vstup" }, t = { nan: "NaN", number: "slo", string: "etzec", function: "funkce", array: "pole" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, $2 = D$2(n.input), u2 = t[$2] ?? $2;
        if (/^[A-Z]/.test(n.expected)) return `Neplatn vstup: oekvno instanceof ${n.expected}, obdreno ${u2}`;
        return `Neplatn vstup: oekvno ${v}, obdreno ${u2}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Neplatn vstup: oekvno ${U$1(n.values[0])}`;
        return `Neplatn monost: oekvna jedna z hodnot ${_$1(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", $2 = i(n.origin);
        if ($2) return `Hodnota je pli velk: ${n.origin ?? "hodnota"} mus mt ${v}${n.maximum.toString()} ${$2.unit ?? "prvk"}`;
        return `Hodnota je pli velk: ${n.origin ?? "hodnota"} mus bt ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", $2 = i(n.origin);
        if ($2) return `Hodnota je pli mal: ${n.origin ?? "hodnota"} mus mt ${v}${n.minimum.toString()} ${$2.unit ?? "prvk"}`;
        return `Hodnota je pli mal: ${n.origin ?? "hodnota"} mus bt ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `Neplatn etzec: mus zanat na "${v.prefix}"`;
        if (v.format === "ends_with") return `Neplatn etzec: mus konit na "${v.suffix}"`;
        if (v.format === "includes") return `Neplatn etzec: mus obsahovat "${v.includes}"`;
        if (v.format === "regex") return `Neplatn etzec: mus odpovdat vzoru ${v.pattern}`;
        return `Neplatn formt ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Neplatn slo: mus bt nsobkem ${n.divisor}`;
      case "unrecognized_keys":
        return `Neznm kle: ${_$1(n.keys, ", ")}`;
      case "invalid_key":
        return `Neplatn kl v ${n.origin}`;
      case "invalid_union":
        return "Neplatn vstup";
      case "invalid_element":
        return `Neplatn hodnota v ${n.origin}`;
      default:
        return "Neplatn vstup";
    }
  };
};
function xt$1() {
  return { localeError: k6() };
}
var w6 = () => {
  let r2 = { string: { unit: "tegn", verb: "havde" }, file: { unit: "bytes", verb: "havde" }, array: { unit: "elementer", verb: "indeholdt" }, set: { unit: "elementer", verb: "indeholdt" } };
  function i(n) {
    return r2[n] ?? null;
  }
  let o = { regex: "input", email: "e-mailadresse", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO dato- og klokkeslt", date: "ISO-dato", time: "ISO-klokkeslt", duration: "ISO-varighed", ipv4: "IPv4-omrde", ipv6: "IPv6-omrde", cidrv4: "IPv4-spektrum", cidrv6: "IPv6-spektrum", base64: "base64-kodet streng", base64url: "base64url-kodet streng", json_string: "JSON-streng", e164: "E.164-nummer", jwt: "JWT", template_literal: "input" }, t = { nan: "NaN", string: "streng", number: "tal", boolean: "boolean", array: "liste", object: "objekt", set: "st", file: "fil" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, $2 = D$2(n.input), u2 = t[$2] ?? $2;
        if (/^[A-Z]/.test(n.expected)) return `Ugyldigt input: forventede instanceof ${n.expected}, fik ${u2}`;
        return `Ugyldigt input: forventede ${v}, fik ${u2}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Ugyldig vrdi: forventede ${U$1(n.values[0])}`;
        return `Ugyldigt valg: forventede en af flgende ${_$1(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", $2 = i(n.origin), u2 = t[n.origin] ?? n.origin;
        if ($2) return `For stor: forventede ${u2 ?? "value"} ${$2.verb} ${v} ${n.maximum.toString()} ${$2.unit ?? "elementer"}`;
        return `For stor: forventede ${u2 ?? "value"} havde ${v} ${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", $2 = i(n.origin), u2 = t[n.origin] ?? n.origin;
        if ($2) return `For lille: forventede ${u2} ${$2.verb} ${v} ${n.minimum.toString()} ${$2.unit}`;
        return `For lille: forventede ${u2} havde ${v} ${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `Ugyldig streng: skal starte med "${v.prefix}"`;
        if (v.format === "ends_with") return `Ugyldig streng: skal ende med "${v.suffix}"`;
        if (v.format === "includes") return `Ugyldig streng: skal indeholde "${v.includes}"`;
        if (v.format === "regex") return `Ugyldig streng: skal matche mnsteret ${v.pattern}`;
        return `Ugyldig ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Ugyldigt tal: skal vre deleligt med ${n.divisor}`;
      case "unrecognized_keys":
        return `${n.keys.length > 1 ? "Ukendte ngler" : "Ukendt ngle"}: ${_$1(n.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig ngle i ${n.origin}`;
      case "invalid_union":
        return "Ugyldigt input: matcher ingen af de tilladte typer";
      case "invalid_element":
        return `Ugyldig vrdi i ${n.origin}`;
      default:
        return "Ugyldigt input";
    }
  };
};
function Zt$1() {
  return { localeError: w6() };
}
var N6 = () => {
  let r2 = { string: { unit: "Zeichen", verb: "zu haben" }, file: { unit: "Bytes", verb: "zu haben" }, array: { unit: "Elemente", verb: "zu haben" }, set: { unit: "Elemente", verb: "zu haben" } };
  function i(n) {
    return r2[n] ?? null;
  }
  let o = { regex: "Eingabe", email: "E-Mail-Adresse", url: "URL", emoji: "Emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO-Datum und -Uhrzeit", date: "ISO-Datum", time: "ISO-Uhrzeit", duration: "ISO-Dauer", ipv4: "IPv4-Adresse", ipv6: "IPv6-Adresse", cidrv4: "IPv4-Bereich", cidrv6: "IPv6-Bereich", base64: "Base64-codierter String", base64url: "Base64-URL-codierter String", json_string: "JSON-String", e164: "E.164-Nummer", jwt: "JWT", template_literal: "Eingabe" }, t = { nan: "NaN", number: "Zahl", array: "Array" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, $2 = D$2(n.input), u2 = t[$2] ?? $2;
        if (/^[A-Z]/.test(n.expected)) return `Ungltige Eingabe: erwartet instanceof ${n.expected}, erhalten ${u2}`;
        return `Ungltige Eingabe: erwartet ${v}, erhalten ${u2}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Ungltige Eingabe: erwartet ${U$1(n.values[0])}`;
        return `Ungltige Option: erwartet eine von ${_$1(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", $2 = i(n.origin);
        if ($2) return `Zu gro: erwartet, dass ${n.origin ?? "Wert"} ${v}${n.maximum.toString()} ${$2.unit ?? "Elemente"} hat`;
        return `Zu gro: erwartet, dass ${n.origin ?? "Wert"} ${v}${n.maximum.toString()} ist`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", $2 = i(n.origin);
        if ($2) return `Zu klein: erwartet, dass ${n.origin} ${v}${n.minimum.toString()} ${$2.unit} hat`;
        return `Zu klein: erwartet, dass ${n.origin} ${v}${n.minimum.toString()} ist`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `Ungltiger String: muss mit "${v.prefix}" beginnen`;
        if (v.format === "ends_with") return `Ungltiger String: muss mit "${v.suffix}" enden`;
        if (v.format === "includes") return `Ungltiger String: muss "${v.includes}" enthalten`;
        if (v.format === "regex") return `Ungltiger String: muss dem Muster ${v.pattern} entsprechen`;
        return `Ungltig: ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Ungltige Zahl: muss ein Vielfaches von ${n.divisor} sein`;
      case "unrecognized_keys":
        return `${n.keys.length > 1 ? "Unbekannte Schlssel" : "Unbekannter Schlssel"}: ${_$1(n.keys, ", ")}`;
      case "invalid_key":
        return `Ungltiger Schlssel in ${n.origin}`;
      case "invalid_union":
        return "Ungltige Eingabe";
      case "invalid_element":
        return `Ungltiger Wert in ${n.origin}`;
      default:
        return "Ungltige Eingabe";
    }
  };
};
function dt$1() {
  return { localeError: N6() };
}
var O6 = () => {
  let r2 = { string: { unit: "characters", verb: "to have" }, file: { unit: "bytes", verb: "to have" }, array: { unit: "items", verb: "to have" }, set: { unit: "items", verb: "to have" }, map: { unit: "entries", verb: "to have" } };
  function i(n) {
    return r2[n] ?? null;
  }
  let o = { regex: "input", email: "email address", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO datetime", date: "ISO date", time: "ISO time", duration: "ISO duration", ipv4: "IPv4 address", ipv6: "IPv6 address", mac: "MAC address", cidrv4: "IPv4 range", cidrv6: "IPv6 range", base64: "base64-encoded string", base64url: "base64url-encoded string", json_string: "JSON string", e164: "E.164 number", jwt: "JWT", template_literal: "input" }, t = { nan: "NaN" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, $2 = D$2(n.input), u2 = t[$2] ?? $2;
        return `Invalid input: expected ${v}, received ${u2}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Invalid input: expected ${U$1(n.values[0])}`;
        return `Invalid option: expected one of ${_$1(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", $2 = i(n.origin);
        if ($2) return `Too big: expected ${n.origin ?? "value"} to have ${v}${n.maximum.toString()} ${$2.unit ?? "elements"}`;
        return `Too big: expected ${n.origin ?? "value"} to be ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", $2 = i(n.origin);
        if ($2) return `Too small: expected ${n.origin} to have ${v}${n.minimum.toString()} ${$2.unit}`;
        return `Too small: expected ${n.origin} to be ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `Invalid string: must start with "${v.prefix}"`;
        if (v.format === "ends_with") return `Invalid string: must end with "${v.suffix}"`;
        if (v.format === "includes") return `Invalid string: must include "${v.includes}"`;
        if (v.format === "regex") return `Invalid string: must match pattern ${v.pattern}`;
        return `Invalid ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${n.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${n.keys.length > 1 ? "s" : ""}: ${_$1(n.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${n.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${n.origin}`;
      default:
        return "Invalid input";
    }
  };
};
function kn$1() {
  return { localeError: O6() };
}
var S6 = () => {
  let r2 = { string: { unit: "karaktrojn", verb: "havi" }, file: { unit: "bajtojn", verb: "havi" }, array: { unit: "elementojn", verb: "havi" }, set: { unit: "elementojn", verb: "havi" } };
  function i(n) {
    return r2[n] ?? null;
  }
  let o = { regex: "enigo", email: "retadreso", url: "URL", emoji: "emoio", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO-datotempo", date: "ISO-dato", time: "ISO-tempo", duration: "ISO-daro", ipv4: "IPv4-adreso", ipv6: "IPv6-adreso", cidrv4: "IPv4-rango", cidrv6: "IPv6-rango", base64: "64-ume kodita karaktraro", base64url: "URL-64-ume kodita karaktraro", json_string: "JSON-karaktraro", e164: "E.164-nombro", jwt: "JWT", template_literal: "enigo" }, t = { nan: "NaN", number: "nombro", array: "tabelo", null: "senvalora" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, $2 = D$2(n.input), u2 = t[$2] ?? $2;
        if (/^[A-Z]/.test(n.expected)) return `Nevalida enigo: atendiis instanceof ${n.expected}, riceviis ${u2}`;
        return `Nevalida enigo: atendiis ${v}, riceviis ${u2}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Nevalida enigo: atendiis ${U$1(n.values[0])}`;
        return `Nevalida opcio: atendiis unu el ${_$1(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", $2 = i(n.origin);
        if ($2) return `Tro granda: atendiis ke ${n.origin ?? "valoro"} havu ${v}${n.maximum.toString()} ${$2.unit ?? "elementojn"}`;
        return `Tro granda: atendiis ke ${n.origin ?? "valoro"} havu ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", $2 = i(n.origin);
        if ($2) return `Tro malgranda: atendiis ke ${n.origin} havu ${v}${n.minimum.toString()} ${$2.unit}`;
        return `Tro malgranda: atendiis ke ${n.origin} estu ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `Nevalida karaktraro: devas komencii per "${v.prefix}"`;
        if (v.format === "ends_with") return `Nevalida karaktraro: devas finii per "${v.suffix}"`;
        if (v.format === "includes") return `Nevalida karaktraro: devas inkluzivi "${v.includes}"`;
        if (v.format === "regex") return `Nevalida karaktraro: devas kongrui kun la modelo ${v.pattern}`;
        return `Nevalida ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${n.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${n.keys.length > 1 ? "j" : ""} losilo${n.keys.length > 1 ? "j" : ""}: ${_$1(n.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida losilo en ${n.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${n.origin}`;
      default:
        return "Nevalida enigo";
    }
  };
};
function Ct$1() {
  return { localeError: S6() };
}
var z6 = () => {
  let r2 = { string: { unit: "caracteres", verb: "tener" }, file: { unit: "bytes", verb: "tener" }, array: { unit: "elementos", verb: "tener" }, set: { unit: "elementos", verb: "tener" } };
  function i(n) {
    return r2[n] ?? null;
  }
  let o = { regex: "entrada", email: "direccin de correo electrnico", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "fecha y hora ISO", date: "fecha ISO", time: "hora ISO", duration: "duracin ISO", ipv4: "direccin IPv4", ipv6: "direccin IPv6", cidrv4: "rango IPv4", cidrv6: "rango IPv6", base64: "cadena codificada en base64", base64url: "URL codificada en base64", json_string: "cadena JSON", e164: "nmero E.164", jwt: "JWT", template_literal: "entrada" }, t = { nan: "NaN", string: "texto", number: "nmero", boolean: "booleano", array: "arreglo", object: "objeto", set: "conjunto", file: "archivo", date: "fecha", bigint: "nmero grande", symbol: "smbolo", undefined: "indefinido", null: "nulo", function: "funcin", map: "mapa", record: "registro", tuple: "tupla", enum: "enumeracin", union: "unin", literal: "literal", promise: "promesa", void: "vaco", never: "nunca", unknown: "desconocido", any: "cualquiera" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, $2 = D$2(n.input), u2 = t[$2] ?? $2;
        if (/^[A-Z]/.test(n.expected)) return `Entrada invlida: se esperaba instanceof ${n.expected}, recibido ${u2}`;
        return `Entrada invlida: se esperaba ${v}, recibido ${u2}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Entrada invlida: se esperaba ${U$1(n.values[0])}`;
        return `Opcin invlida: se esperaba una de ${_$1(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", $2 = i(n.origin), u2 = t[n.origin] ?? n.origin;
        if ($2) return `Demasiado grande: se esperaba que ${u2 ?? "valor"} tuviera ${v}${n.maximum.toString()} ${$2.unit ?? "elementos"}`;
        return `Demasiado grande: se esperaba que ${u2 ?? "valor"} fuera ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", $2 = i(n.origin), u2 = t[n.origin] ?? n.origin;
        if ($2) return `Demasiado pequeo: se esperaba que ${u2} tuviera ${v}${n.minimum.toString()} ${$2.unit}`;
        return `Demasiado pequeo: se esperaba que ${u2} fuera ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `Cadena invlida: debe comenzar con "${v.prefix}"`;
        if (v.format === "ends_with") return `Cadena invlida: debe terminar en "${v.suffix}"`;
        if (v.format === "includes") return `Cadena invlida: debe incluir "${v.includes}"`;
        if (v.format === "regex") return `Cadena invlida: debe coincidir con el patrn ${v.pattern}`;
        return `Invlido ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Nmero invlido: debe ser mltiplo de ${n.divisor}`;
      case "unrecognized_keys":
        return `Llave${n.keys.length > 1 ? "s" : ""} desconocida${n.keys.length > 1 ? "s" : ""}: ${_$1(n.keys, ", ")}`;
      case "invalid_key":
        return `Llave invlida en ${t[n.origin] ?? n.origin}`;
      case "invalid_union":
        return "Entrada invlida";
      case "invalid_element":
        return `Valor invlido en ${t[n.origin] ?? n.origin}`;
      default:
        return "Entrada invlida";
    }
  };
};
function ft$1() {
  return { localeError: z6() };
}
var P6 = () => {
  let r2 = { string: { unit: "", verb: " " }, file: { unit: "", verb: " " }, array: { unit: "", verb: " " }, set: { unit: "", verb: " " } };
  function i(n) {
    return r2[n] ?? null;
  }
  let o = { regex: "", email: " ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "   ", date: " ", time: " ", duration: "  ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64-encoded ", base64url: "base64url-encoded ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "" }, t = { nan: "NaN", number: "", array: "" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, $2 = D$2(n.input), u2 = t[$2] ?? $2;
        if (/^[A-Z]/.test(n.expected)) return ` :  instanceof ${n.expected}  ${u2}  `;
        return ` :  ${v}  ${u2}  `;
      }
      case "invalid_value":
        if (n.values.length === 1) return ` :  ${U$1(n.values[0])} `;
        return ` :    ${_$1(n.values, "|")} `;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", $2 = i(n.origin);
        if ($2) return ` : ${n.origin ?? ""}  ${v}${n.maximum.toString()} ${$2.unit ?? ""} `;
        return ` : ${n.origin ?? ""}  ${v}${n.maximum.toString()} `;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", $2 = i(n.origin);
        if ($2) return ` : ${n.origin}  ${v}${n.minimum.toString()} ${$2.unit} `;
        return ` : ${n.origin}  ${v}${n.minimum.toString()} `;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return ` :   "${v.prefix}"  `;
        if (v.format === "ends_with") return ` :   "${v.suffix}"  `;
        if (v.format === "includes") return ` :   "${v.includes}" `;
        if (v.format === "regex") return ` :    ${v.pattern}   `;
        return `${o[v.format] ?? n.format} `;
      }
      case "not_multiple_of":
        return ` :   ${n.divisor} `;
      case "unrecognized_keys":
        return `${n.keys.length > 1 ? "" : ""} : ${_$1(n.keys, ", ")}`;
      case "invalid_key":
        return `   ${n.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${n.origin}`;
      default:
        return " ";
    }
  };
};
function yt$1() {
  return { localeError: P6() };
}
var j6 = () => {
  let r2 = { string: { unit: "merkki", subject: "merkkijonon" }, file: { unit: "tavua", subject: "tiedoston" }, array: { unit: "alkiota", subject: "listan" }, set: { unit: "alkiota", subject: "joukon" }, number: { unit: "", subject: "luvun" }, bigint: { unit: "", subject: "suuren kokonaisluvun" }, int: { unit: "", subject: "kokonaisluvun" }, date: { unit: "", subject: "pivmrn" } };
  function i(n) {
    return r2[n] ?? null;
  }
  let o = { regex: "snnllinen lauseke", email: "shkpostiosoite", url: "URL-osoite", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO-aikaleima", date: "ISO-pivmr", time: "ISO-aika", duration: "ISO-kesto", ipv4: "IPv4-osoite", ipv6: "IPv6-osoite", cidrv4: "IPv4-alue", cidrv6: "IPv6-alue", base64: "base64-koodattu merkkijono", base64url: "base64url-koodattu merkkijono", json_string: "JSON-merkkijono", e164: "E.164-luku", jwt: "JWT", template_literal: "templaattimerkkijono" }, t = { nan: "NaN" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, $2 = D$2(n.input), u2 = t[$2] ?? $2;
        if (/^[A-Z]/.test(n.expected)) return `Virheellinen tyyppi: odotettiin instanceof ${n.expected}, oli ${u2}`;
        return `Virheellinen tyyppi: odotettiin ${v}, oli ${u2}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Virheellinen syte: tytyy olla ${U$1(n.values[0])}`;
        return `Virheellinen valinta: tytyy olla yksi seuraavista: ${_$1(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", $2 = i(n.origin);
        if ($2) return `Liian suuri: ${$2.subject} tytyy olla ${v}${n.maximum.toString()} ${$2.unit}`.trim();
        return `Liian suuri: arvon tytyy olla ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", $2 = i(n.origin);
        if ($2) return `Liian pieni: ${$2.subject} tytyy olla ${v}${n.minimum.toString()} ${$2.unit}`.trim();
        return `Liian pieni: arvon tytyy olla ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `Virheellinen syte: tytyy alkaa "${v.prefix}"`;
        if (v.format === "ends_with") return `Virheellinen syte: tytyy loppua "${v.suffix}"`;
        if (v.format === "includes") return `Virheellinen syte: tytyy sislt "${v.includes}"`;
        if (v.format === "regex") return `Virheellinen syte: tytyy vastata snnllist lauseketta ${v.pattern}`;
        return `Virheellinen ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: tytyy olla luvun ${n.divisor} monikerta`;
      case "unrecognized_keys":
        return `${n.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${_$1(n.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return "Virheellinen syte";
    }
  };
};
function ht$1() {
  return { localeError: j6() };
}
var J6 = () => {
  let r2 = { string: { unit: "caractres", verb: "avoir" }, file: { unit: "octets", verb: "avoir" }, array: { unit: "lments", verb: "avoir" }, set: { unit: "lments", verb: "avoir" } };
  function i(n) {
    return r2[n] ?? null;
  }
  let o = { regex: "entre", email: "adresse e-mail", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "date et heure ISO", date: "date ISO", time: "heure ISO", duration: "dure ISO", ipv4: "adresse IPv4", ipv6: "adresse IPv6", cidrv4: "plage IPv4", cidrv6: "plage IPv6", base64: "chane encode en base64", base64url: "chane encode en base64url", json_string: "chane JSON", e164: "numro E.164", jwt: "JWT", template_literal: "entre" }, t = { nan: "NaN", number: "nombre", array: "tableau" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, $2 = D$2(n.input), u2 = t[$2] ?? $2;
        if (/^[A-Z]/.test(n.expected)) return `Entre invalide : instanceof ${n.expected} attendu, ${u2} reu`;
        return `Entre invalide : ${v} attendu, ${u2} reu`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Entre invalide : ${U$1(n.values[0])} attendu`;
        return `Option invalide : une valeur parmi ${_$1(n.values, "|")} attendue`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", $2 = i(n.origin);
        if ($2) return `Trop grand : ${n.origin ?? "valeur"} doit ${$2.verb} ${v}${n.maximum.toString()} ${$2.unit ?? "lment(s)"}`;
        return `Trop grand : ${n.origin ?? "valeur"} doit tre ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", $2 = i(n.origin);
        if ($2) return `Trop petit : ${n.origin} doit ${$2.verb} ${v}${n.minimum.toString()} ${$2.unit}`;
        return `Trop petit : ${n.origin} doit tre ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `Chane invalide : doit commencer par "${v.prefix}"`;
        if (v.format === "ends_with") return `Chane invalide : doit se terminer par "${v.suffix}"`;
        if (v.format === "includes") return `Chane invalide : doit inclure "${v.includes}"`;
        if (v.format === "regex") return `Chane invalide : doit correspondre au modle ${v.pattern}`;
        return `${o[v.format] ?? n.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit tre un multiple de ${n.divisor}`;
      case "unrecognized_keys":
        return `Cl${n.keys.length > 1 ? "s" : ""} non reconnue${n.keys.length > 1 ? "s" : ""} : ${_$1(n.keys, ", ")}`;
      case "invalid_key":
        return `Cl invalide dans ${n.origin}`;
      case "invalid_union":
        return "Entre invalide";
      case "invalid_element":
        return `Valeur invalide dans ${n.origin}`;
      default:
        return "Entre invalide";
    }
  };
};
function at$1() {
  return { localeError: J6() };
}
var L6 = () => {
  let r2 = { string: { unit: "caractres", verb: "avoir" }, file: { unit: "octets", verb: "avoir" }, array: { unit: "lments", verb: "avoir" }, set: { unit: "lments", verb: "avoir" } };
  function i(n) {
    return r2[n] ?? null;
  }
  let o = { regex: "entre", email: "adresse courriel", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "date-heure ISO", date: "date ISO", time: "heure ISO", duration: "dure ISO", ipv4: "adresse IPv4", ipv6: "adresse IPv6", cidrv4: "plage IPv4", cidrv6: "plage IPv6", base64: "chane encode en base64", base64url: "chane encode en base64url", json_string: "chane JSON", e164: "numro E.164", jwt: "JWT", template_literal: "entre" }, t = { nan: "NaN" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, $2 = D$2(n.input), u2 = t[$2] ?? $2;
        if (/^[A-Z]/.test(n.expected)) return `Entre invalide : attendu instanceof ${n.expected}, reu ${u2}`;
        return `Entre invalide : attendu ${v}, reu ${u2}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Entre invalide : attendu ${U$1(n.values[0])}`;
        return `Option invalide : attendu l'une des valeurs suivantes ${_$1(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "" : "<", $2 = i(n.origin);
        if ($2) return `Trop grand : attendu que ${n.origin ?? "la valeur"} ait ${v}${n.maximum.toString()} ${$2.unit}`;
        return `Trop grand : attendu que ${n.origin ?? "la valeur"} soit ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? "" : ">", $2 = i(n.origin);
        if ($2) return `Trop petit : attendu que ${n.origin} ait ${v}${n.minimum.toString()} ${$2.unit}`;
        return `Trop petit : attendu que ${n.origin} soit ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `Chane invalide : doit commencer par "${v.prefix}"`;
        if (v.format === "ends_with") return `Chane invalide : doit se terminer par "${v.suffix}"`;
        if (v.format === "includes") return `Chane invalide : doit inclure "${v.includes}"`;
        if (v.format === "regex") return `Chane invalide : doit correspondre au motif ${v.pattern}`;
        return `${o[v.format] ?? n.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit tre un multiple de ${n.divisor}`;
      case "unrecognized_keys":
        return `Cl${n.keys.length > 1 ? "s" : ""} non reconnue${n.keys.length > 1 ? "s" : ""} : ${_$1(n.keys, ", ")}`;
      case "invalid_key":
        return `Cl invalide dans ${n.origin}`;
      case "invalid_union":
        return "Entre invalide";
      case "invalid_element":
        return `Valeur invalide dans ${n.origin}`;
      default:
        return "Entre invalide";
    }
  };
};
function pt$1() {
  return { localeError: L6() };
}
var E6 = () => {
  let r2 = { string: { label: "", gender: "f" }, number: { label: "", gender: "m" }, boolean: { label: " ", gender: "m" }, bigint: { label: "BigInt", gender: "m" }, date: { label: "", gender: "m" }, array: { label: "", gender: "m" }, object: { label: "", gender: "m" }, null: { label: "  (null)", gender: "m" }, undefined: { label: "   (undefined)", gender: "m" }, symbol: { label: " (Symbol)", gender: "m" }, function: { label: "", gender: "f" }, map: { label: " (Map)", gender: "f" }, set: { label: " (Set)", gender: "f" }, file: { label: "", gender: "m" }, promise: { label: "Promise", gender: "m" }, NaN: { label: "NaN", gender: "m" }, unknown: { label: "  ", gender: "m" }, value: { label: "", gender: "m" } }, i = { string: { unit: "", shortLabel: "", longLabel: "" }, file: { unit: "", shortLabel: "", longLabel: "" }, array: { unit: "", shortLabel: "", longLabel: "" }, set: { unit: "", shortLabel: "", longLabel: "" }, number: { unit: "", shortLabel: "", longLabel: "" } }, o = (e) => e ? r2[e] : void 0, t = (e) => {
    let c = o(e);
    if (c) return c.label;
    return e ?? r2.unknown.label;
  }, n = (e) => `${t(e)}`, v = (e) => {
    return (o(e)?.gender ?? "m") === "f" ? " " : " ";
  }, $2 = (e) => {
    if (!e) return null;
    return i[e] ?? null;
  }, u2 = { regex: { label: "", gender: "m" }, email: { label: " ", gender: "f" }, url: { label: " ", gender: "f" }, emoji: { label: "'", gender: "m" }, uuid: { label: "UUID", gender: "m" }, nanoid: { label: "nanoid", gender: "m" }, guid: { label: "GUID", gender: "m" }, cuid: { label: "cuid", gender: "m" }, cuid2: { label: "cuid2", gender: "m" }, ulid: { label: "ULID", gender: "m" }, xid: { label: "XID", gender: "m" }, ksuid: { label: "KSUID", gender: "m" }, datetime: { label: "  ISO", gender: "m" }, date: { label: " ISO", gender: "m" }, time: { label: " ISO", gender: "m" }, duration: { label: "  ISO", gender: "m" }, ipv4: { label: " IPv4", gender: "f" }, ipv6: { label: " IPv6", gender: "f" }, cidrv4: { label: " IPv4", gender: "m" }, cidrv6: { label: " IPv6", gender: "m" }, base64: { label: "  64", gender: "f" }, base64url: { label: "  64  ", gender: "f" }, json_string: { label: " JSON", gender: "f" }, e164: { label: " E.164", gender: "m" }, jwt: { label: "JWT", gender: "m" }, ends_with: { label: "", gender: "m" }, includes: { label: "", gender: "m" }, lowercase: { label: "", gender: "m" }, starts_with: { label: "", gender: "m" }, uppercase: { label: "", gender: "m" } }, l = { nan: "NaN" };
  return (e) => {
    switch (e.code) {
      case "invalid_type": {
        let c = e.expected, b = l[c ?? ""] ?? t(c), N2 = D$2(e.input), O = l[N2] ?? r2[N2]?.label ?? N2;
        if (/^[A-Z]/.test(e.expected)) return `  :   instanceof ${e.expected},  ${O}`;
        return `  :   ${b},  ${O}`;
      }
      case "invalid_value": {
        if (e.values.length === 1) return `  :    ${U$1(e.values[0])}`;
        let c = e.values.map((O) => U$1(O));
        if (e.values.length === 2) return `  :    ${c[0]}  ${c[1]}`;
        let b = c[c.length - 1];
        return `  :    ${c.slice(0, -1).join(", ")}  ${b}`;
      }
      case "too_big": {
        let c = $2(e.origin), b = n(e.origin ?? "value");
        if (e.origin === "string") return `${c?.longLabel ?? ""} : ${b}   ${e.maximum.toString()} ${c?.unit ?? ""} ${e.inclusive ? " " : " "}`.trim();
        if (e.origin === "number") {
          let J2 = e.inclusive ? `   -${e.maximum}` : ` -${e.maximum}`;
          return ` : ${b}   ${J2}`;
        }
        if (e.origin === "array" || e.origin === "set") {
          let J2 = e.origin === "set" ? "" : "", X2 = e.inclusive ? `${e.maximum} ${c?.unit ?? ""}  ` : ` -${e.maximum} ${c?.unit ?? ""}`;
          return ` : ${b} ${J2}  ${X2}`.trim();
        }
        let N2 = e.inclusive ? "<=" : "<", O = v(e.origin ?? "value");
        if (c?.unit) return `${c.longLabel} : ${b} ${O} ${N2}${e.maximum.toString()} ${c.unit}`;
        return `${c?.longLabel ?? ""} : ${b} ${O} ${N2}${e.maximum.toString()}`;
      }
      case "too_small": {
        let c = $2(e.origin), b = n(e.origin ?? "value");
        if (e.origin === "string") return `${c?.shortLabel ?? ""} : ${b}   ${e.minimum.toString()} ${c?.unit ?? ""} ${e.inclusive ? " " : ""}`.trim();
        if (e.origin === "number") {
          let J2 = e.inclusive ? `   -${e.minimum}` : ` -${e.minimum}`;
          return ` : ${b}   ${J2}`;
        }
        if (e.origin === "array" || e.origin === "set") {
          let J2 = e.origin === "set" ? "" : "";
          if (e.minimum === 1 && e.inclusive) {
            let Sr2 = e.origin === "set" ? "  " : "  ";
            return ` : ${b} ${J2}  ${Sr2}`;
          }
          let X2 = e.inclusive ? `${e.minimum} ${c?.unit ?? ""}  ` : ` -${e.minimum} ${c?.unit ?? ""}`;
          return ` : ${b} ${J2}  ${X2}`.trim();
        }
        let N2 = e.inclusive ? ">=" : ">", O = v(e.origin ?? "value");
        if (c?.unit) return `${c.shortLabel} : ${b} ${O} ${N2}${e.minimum.toString()} ${c.unit}`;
        return `${c?.shortLabel ?? ""} : ${b} ${O} ${N2}${e.minimum.toString()}`;
      }
      case "invalid_format": {
        let c = e;
        if (c.format === "starts_with") return `    "${c.prefix}"`;
        if (c.format === "ends_with") return `    "${c.suffix}"`;
        if (c.format === "includes") return `   "${c.includes}"`;
        if (c.format === "regex") return `    ${c.pattern}`;
        let b = u2[c.format], N2 = b?.label ?? c.format, J2 = (b?.gender ?? "m") === "f" ? "" : "";
        return `${N2}  ${J2}`;
      }
      case "not_multiple_of":
        return `  :     ${e.divisor}`;
      case "unrecognized_keys":
        return `${e.keys.length > 1 ? "" : ""}  ${e.keys.length > 1 ? "" : ""}: ${_$1(e.keys, ", ")}`;
      case "invalid_key":
        return "   ";
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `   ${n(e.origin ?? "array")}`;
      default:
        return "  ";
    }
  };
};
function st$1() {
  return { localeError: E6() };
}
var G6 = () => {
  let r2 = { string: { unit: "karakter", verb: "legyen" }, file: { unit: "byte", verb: "legyen" }, array: { unit: "elem", verb: "legyen" }, set: { unit: "elem", verb: "legyen" } };
  function i(n) {
    return r2[n] ?? null;
  }
  let o = { regex: "bemenet", email: "email cm", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO idblyeg", date: "ISO dtum", time: "ISO id", duration: "ISO idintervallum", ipv4: "IPv4 cm", ipv6: "IPv6 cm", cidrv4: "IPv4 tartomny", cidrv6: "IPv6 tartomny", base64: "base64-kdolt string", base64url: "base64url-kdolt string", json_string: "JSON string", e164: "E.164 szm", jwt: "JWT", template_literal: "bemenet" }, t = { nan: "NaN", number: "szm", array: "tmb" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, $2 = D$2(n.input), u2 = t[$2] ?? $2;
        if (/^[A-Z]/.test(n.expected)) return `rvnytelen bemenet: a vrt rtk instanceof ${n.expected}, a kapott rtk ${u2}`;
        return `rvnytelen bemenet: a vrt rtk ${v}, a kapott rtk ${u2}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `rvnytelen bemenet: a vrt rtk ${U$1(n.values[0])}`;
        return `rvnytelen opci: valamelyik rtk vrt ${_$1(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", $2 = i(n.origin);
        if ($2) return `Tl nagy: ${n.origin ?? "rtk"} mrete tl nagy ${v}${n.maximum.toString()} ${$2.unit ?? "elem"}`;
        return `Tl nagy: a bemeneti rtk ${n.origin ?? "rtk"} tl nagy: ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", $2 = i(n.origin);
        if ($2) return `Tl kicsi: a bemeneti rtk ${n.origin} mrete tl kicsi ${v}${n.minimum.toString()} ${$2.unit}`;
        return `Tl kicsi: a bemeneti rtk ${n.origin} tl kicsi ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `rvnytelen string: "${v.prefix}" rtkkel kell kezddnie`;
        if (v.format === "ends_with") return `rvnytelen string: "${v.suffix}" rtkkel kell vgzdnie`;
        if (v.format === "includes") return `rvnytelen string: "${v.includes}" rtket kell tartalmaznia`;
        if (v.format === "regex") return `rvnytelen string: ${v.pattern} mintnak kell megfelelnie`;
        return `rvnytelen ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `rvnytelen szm: ${n.divisor} tbbszrsnek kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${n.keys.length > 1 ? "s" : ""}: ${_$1(n.keys, ", ")}`;
      case "invalid_key":
        return `rvnytelen kulcs ${n.origin}`;
      case "invalid_union":
        return "rvnytelen bemenet";
      case "invalid_element":
        return `rvnytelen rtk: ${n.origin}`;
      default:
        return "rvnytelen bemenet";
    }
  };
};
function r$() {
  return { localeError: G6() };
}
function el$1(r2, i, o) {
  return Math.abs(r2) === 1 ? i : o;
}
function Ar$1(r2) {
  if (!r2) return "";
  let i = ["", "", "", "", "", "", ""], o = r2[r2.length - 1];
  return r2 + (i.includes(o) ? "" : "");
}
var W6 = () => {
  let r2 = { string: { unit: { one: "", many: "" }, verb: "" }, file: { unit: { one: "", many: "" }, verb: "" }, array: { unit: { one: "", many: "" }, verb: "" }, set: { unit: { one: "", many: "" }, verb: "" } };
  function i(n) {
    return r2[n] ?? null;
  }
  let o = { regex: "", email: ". ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO   ", date: "ISO ", time: "ISO ", duration: "ISO ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64  ", base64url: "base64url  ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "" }, t = { nan: "NaN", number: "", array: "" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, $2 = D$2(n.input), u2 = t[$2] ?? $2;
        if (/^[A-Z]/.test(n.expected)) return `    instanceof ${n.expected},   ${u2}`;
        return `    ${v},   ${u2}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `    ${U$1(n.values[1])}`;
        return `      ${_$1(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", $2 = i(n.origin);
        if ($2) {
          let u2 = Number(n.maximum), l = el$1(u2, $2.unit.one, $2.unit.many);
          return `    ,  ${Ar$1(n.origin ?? "")}  ${v}${n.maximum.toString()} ${l}`;
        }
        return `    ,  ${Ar$1(n.origin ?? "")}  ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", $2 = i(n.origin);
        if ($2) {
          let u2 = Number(n.minimum), l = el$1(u2, $2.unit.one, $2.unit.many);
          return `    ,  ${Ar$1(n.origin)}  ${v}${n.minimum.toString()} ${l}`;
        }
        return `    ,  ${Ar$1(n.origin)}  ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `     "${v.prefix}"-`;
        if (v.format === "ends_with") return `     "${v.suffix}"-`;
        if (v.format === "includes") return `     "${v.includes}"`;
        if (v.format === "regex") return `     ${v.pattern} `;
        return ` ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `      ${n.divisor}-`;
      case "unrecognized_keys":
        return ` ${n.keys.length > 1 ? "" : ""}. ${_$1(n.keys, ", ")}`;
      case "invalid_key":
        return `  ${Ar$1(n.origin)}-`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `  ${Ar$1(n.origin)}-`;
      default:
        return " ";
    }
  };
};
function n$() {
  return { localeError: W6() };
}
var X6 = () => {
  let r2 = { string: { unit: "karakter", verb: "memiliki" }, file: { unit: "byte", verb: "memiliki" }, array: { unit: "item", verb: "memiliki" }, set: { unit: "item", verb: "memiliki" } };
  function i(n) {
    return r2[n] ?? null;
  }
  let o = { regex: "input", email: "alamat email", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "tanggal dan waktu format ISO", date: "tanggal format ISO", time: "jam format ISO", duration: "durasi format ISO", ipv4: "alamat IPv4", ipv6: "alamat IPv6", cidrv4: "rentang alamat IPv4", cidrv6: "rentang alamat IPv6", base64: "string dengan enkode base64", base64url: "string dengan enkode base64url", json_string: "string JSON", e164: "angka E.164", jwt: "JWT", template_literal: "input" }, t = { nan: "NaN" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, $2 = D$2(n.input), u2 = t[$2] ?? $2;
        if (/^[A-Z]/.test(n.expected)) return `Input tidak valid: diharapkan instanceof ${n.expected}, diterima ${u2}`;
        return `Input tidak valid: diharapkan ${v}, diterima ${u2}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Input tidak valid: diharapkan ${U$1(n.values[0])}`;
        return `Pilihan tidak valid: diharapkan salah satu dari ${_$1(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", $2 = i(n.origin);
        if ($2) return `Terlalu besar: diharapkan ${n.origin ?? "value"} memiliki ${v}${n.maximum.toString()} ${$2.unit ?? "elemen"}`;
        return `Terlalu besar: diharapkan ${n.origin ?? "value"} menjadi ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", $2 = i(n.origin);
        if ($2) return `Terlalu kecil: diharapkan ${n.origin} memiliki ${v}${n.minimum.toString()} ${$2.unit}`;
        return `Terlalu kecil: diharapkan ${n.origin} menjadi ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `String tidak valid: harus dimulai dengan "${v.prefix}"`;
        if (v.format === "ends_with") return `String tidak valid: harus berakhir dengan "${v.suffix}"`;
        if (v.format === "includes") return `String tidak valid: harus menyertakan "${v.includes}"`;
        if (v.format === "regex") return `String tidak valid: harus sesuai pola ${v.pattern}`;
        return `${o[v.format] ?? n.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${n.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${n.keys.length > 1 ? "s" : ""}: ${_$1(n.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${n.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${n.origin}`;
      default:
        return "Input tidak valid";
    }
  };
};
function i$() {
  return { localeError: X6() };
}
var A6 = () => {
  let r2 = { string: { unit: "stafi", verb: "a hafa" }, file: { unit: "bti", verb: "a hafa" }, array: { unit: "hluti", verb: "a hafa" }, set: { unit: "hluti", verb: "a hafa" } };
  function i(n) {
    return r2[n] ?? null;
  }
  let o = { regex: "gildi", email: "netfang", url: "vefsl", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO dagsetning og tmi", date: "ISO dagsetning", time: "ISO tmi", duration: "ISO tmalengd", ipv4: "IPv4 address", ipv6: "IPv6 address", cidrv4: "IPv4 range", cidrv6: "IPv6 range", base64: "base64-encoded strengur", base64url: "base64url-encoded strengur", json_string: "JSON strengur", e164: "E.164 tlugildi", jwt: "JWT", template_literal: "gildi" }, t = { nan: "NaN", number: "nmer", array: "fylki" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, $2 = D$2(n.input), u2 = t[$2] ?? $2;
        if (/^[A-Z]/.test(n.expected)) return `Rangt gildi:  slst inn ${u2} ar sem  a vera instanceof ${n.expected}`;
        return `Rangt gildi:  slst inn ${u2} ar sem  a vera ${v}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Rangt gildi: gert r fyrir ${U$1(n.values[0])}`;
        return `gilt val: m vera eitt af eftirfarandi ${_$1(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", $2 = i(n.origin);
        if ($2) return `Of strt: gert er r fyrir a ${n.origin ?? "gildi"} hafi ${v}${n.maximum.toString()} ${$2.unit ?? "hluti"}`;
        return `Of strt: gert er r fyrir a ${n.origin ?? "gildi"} s ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", $2 = i(n.origin);
        if ($2) return `Of lti: gert er r fyrir a ${n.origin} hafi ${v}${n.minimum.toString()} ${$2.unit}`;
        return `Of lti: gert er r fyrir a ${n.origin} s ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `gildur strengur: verur a byrja  "${v.prefix}"`;
        if (v.format === "ends_with") return `gildur strengur: verur a enda  "${v.suffix}"`;
        if (v.format === "includes") return `gildur strengur: verur a innihalda "${v.includes}"`;
        if (v.format === "regex") return `gildur strengur: verur a fylgja mynstri ${v.pattern}`;
        return `Rangt ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Rng tala: verur a vera margfeldi af ${n.divisor}`;
      case "unrecognized_keys":
        return `ekkt ${n.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${_$1(n.keys, ", ")}`;
      case "invalid_key":
        return `Rangur lykill  ${n.origin}`;
      case "invalid_union":
        return "Rangt gildi";
      case "invalid_element":
        return `Rangt gildi  ${n.origin}`;
      default:
        return "Rangt gildi";
    }
  };
};
function v$() {
  return { localeError: A6() };
}
var V6 = () => {
  let r2 = { string: { unit: "caratteri", verb: "avere" }, file: { unit: "byte", verb: "avere" }, array: { unit: "elementi", verb: "avere" }, set: { unit: "elementi", verb: "avere" } };
  function i(n) {
    return r2[n] ?? null;
  }
  let o = { regex: "input", email: "indirizzo email", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "data e ora ISO", date: "data ISO", time: "ora ISO", duration: "durata ISO", ipv4: "indirizzo IPv4", ipv6: "indirizzo IPv6", cidrv4: "intervallo IPv4", cidrv6: "intervallo IPv6", base64: "stringa codificata in base64", base64url: "URL codificata in base64", json_string: "stringa JSON", e164: "numero E.164", jwt: "JWT", template_literal: "input" }, t = { nan: "NaN", number: "numero", array: "vettore" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, $2 = D$2(n.input), u2 = t[$2] ?? $2;
        if (/^[A-Z]/.test(n.expected)) return `Input non valido: atteso instanceof ${n.expected}, ricevuto ${u2}`;
        return `Input non valido: atteso ${v}, ricevuto ${u2}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Input non valido: atteso ${U$1(n.values[0])}`;
        return `Opzione non valida: atteso uno tra ${_$1(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", $2 = i(n.origin);
        if ($2) return `Troppo grande: ${n.origin ?? "valore"} deve avere ${v}${n.maximum.toString()} ${$2.unit ?? "elementi"}`;
        return `Troppo grande: ${n.origin ?? "valore"} deve essere ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", $2 = i(n.origin);
        if ($2) return `Troppo piccolo: ${n.origin} deve avere ${v}${n.minimum.toString()} ${$2.unit}`;
        return `Troppo piccolo: ${n.origin} deve essere ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `Stringa non valida: deve iniziare con "${v.prefix}"`;
        if (v.format === "ends_with") return `Stringa non valida: deve terminare con "${v.suffix}"`;
        if (v.format === "includes") return `Stringa non valida: deve includere "${v.includes}"`;
        if (v.format === "regex") return `Stringa non valida: deve corrispondere al pattern ${v.pattern}`;
        return `Invalid ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${n.divisor}`;
      case "unrecognized_keys":
        return `Chiav${n.keys.length > 1 ? "i" : "e"} non riconosciut${n.keys.length > 1 ? "e" : "a"}: ${_$1(n.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${n.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${n.origin}`;
      default:
        return "Input non valido";
    }
  };
};
function o$() {
  return { localeError: V6() };
}
var K6 = () => {
  let r2 = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function i(n) {
    return r2[n] ?? null;
  }
  let o = { regex: "", email: "", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO", date: "ISO", time: "ISO", duration: "ISO", ipv4: "IPv4", ipv6: "IPv6", cidrv4: "IPv4", cidrv6: "IPv6", base64: "base64", base64url: "base64url", json_string: "JSON", e164: "E.164", jwt: "JWT", template_literal: "" }, t = { nan: "NaN", number: "", array: "" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, $2 = D$2(n.input), u2 = t[$2] ?? $2;
        if (/^[A-Z]/.test(n.expected)) return `: instanceof ${n.expected}${u2}`;
        return `: ${v}${u2}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `: ${U$1(n.values[0])}`;
        return `: ${_$1(n.values, "")}`;
      case "too_big": {
        let v = n.inclusive ? "" : "", $2 = i(n.origin);
        if ($2) return `: ${n.origin ?? ""}${n.maximum.toString()}${$2.unit ?? ""}${v}`;
        return `: ${n.origin ?? ""}${n.maximum.toString()}${v}`;
      }
      case "too_small": {
        let v = n.inclusive ? "" : "", $2 = i(n.origin);
        if ($2) return `: ${n.origin}${n.minimum.toString()}${$2.unit}${v}`;
        return `: ${n.origin}${n.minimum.toString()}${v}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `: "${v.prefix}"`;
        if (v.format === "ends_with") return `: "${v.suffix}"`;
        if (v.format === "includes") return `: "${v.includes}"`;
        if (v.format === "regex") return `: ${v.pattern}`;
        return `${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `: ${n.divisor}`;
      case "unrecognized_keys":
        return `${n.keys.length > 1 ? "" : ""}: ${_$1(n.keys, "")}`;
      case "invalid_key":
        return `${n.origin}`;
      case "invalid_union":
        return "";
      case "invalid_element":
        return `${n.origin}`;
      default:
        return "";
    }
  };
};
function t$() {
  return { localeError: K6() };
}
var Y6 = () => {
  let r2 = { string: { unit: "", verb: " " }, file: { unit: "", verb: " " }, array: { unit: "", verb: " " }, set: { unit: "", verb: " " } };
  function i(n) {
    return r2[n] ?? null;
  }
  let o = { regex: "", email: "- ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "-", date: "", time: "", duration: "", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64- ", base64url: "base64url- ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "" }, t = { nan: "NaN", number: "", string: "", boolean: "", function: "", array: "" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, $2 = D$2(n.input), u2 = t[$2] ?? $2;
        if (/^[A-Z]/.test(n.expected)) return ` :  instanceof ${n.expected},  ${u2}`;
        return ` :  ${v},  ${u2}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return ` :  ${U$1(n.values[0])}`;
        return ` :  - ${_$1(n.values, "|")}-`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", $2 = i(n.origin);
        if ($2) return ` :  ${n.origin ?? ""} ${$2.verb} ${v}${n.maximum.toString()} ${$2.unit}`;
        return ` :  ${n.origin ?? ""}  ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", $2 = i(n.origin);
        if ($2) return ` :  ${n.origin} ${$2.verb} ${v}${n.minimum.toString()} ${$2.unit}`;
        return ` :  ${n.origin}  ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return ` :   "${v.prefix}"-`;
        if (v.format === "ends_with") return ` :   "${v.suffix}"-`;
        if (v.format === "includes") return ` :   "${v.includes}"-`;
        if (v.format === "regex") return ` :    ${v.pattern}`;
        return ` ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return ` :   ${n.divisor}- `;
      case "unrecognized_keys":
        return ` ${n.keys.length > 1 ? "" : ""}: ${_$1(n.keys, ", ")}`;
      case "invalid_key":
        return `  ${n.origin}-`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `  ${n.origin}-`;
      default:
        return " ";
    }
  };
};
function $$() {
  return { localeError: Y6() };
}
var Q6 = () => {
  let r2 = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function i(n) {
    return r2[n] ?? null;
  }
  let o = { regex: "", email: "", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "  ISO", date: " ISO", time: " ISO", duration: " ISO", ipv4: " IPv4", ipv6: " IPv6", cidrv4: " IPv4", cidrv6: " IPv6", base64: " base64", base64url: " base64url", json_string: " JSON", e164: " E.164", jwt: "JWT", template_literal: "" }, t = { nan: "NaN", number: "", array: " (Array)", null: " (null)" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, $2 = D$2(n.input), u2 = t[$2] ?? $2;
        if (/^[A-Z]/.test(n.expected)) return `  instanceof ${n.expected}  ${u2}`;
        return `  ${v}  ${u2}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `  ${U$1(n.values[0])}`;
        return `  ${_$1(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", $2 = i(n.origin);
        if ($2) return `  ${n.origin ?? ""} ${v} ${n.maximum.toString()} ${$2.unit ?? ""}`;
        return `  ${n.origin ?? ""} ${v} ${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", $2 = i(n.origin);
        if ($2) return `  ${n.origin} ${v} ${n.minimum.toString()} ${$2.unit}`;
        return `  ${n.origin} ${v} ${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `  "${v.prefix}"`;
        if (v.format === "ends_with") return `  "${v.suffix}"`;
        if (v.format === "includes") return `  "${v.includes}"`;
        if (v.format === "regex") return `  ${v.pattern}`;
        return ` ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `  ${n.divisor}`;
      case "unrecognized_keys":
        return ` ${_$1(n.keys, ", ")}`;
      case "invalid_key":
        return ` ${n.origin}`;
      case "invalid_union":
        return "";
      case "invalid_element":
        return ` ${n.origin}`;
      default:
        return "";
    }
  };
};
function wn$1() {
  return { localeError: Q6() };
}
function u$() {
  return wn$1();
}
var T6 = () => {
  let r2 = { string: { unit: "", verb: "to have" }, file: { unit: "", verb: "to have" }, array: { unit: "", verb: "to have" }, set: { unit: "", verb: "to have" } };
  function i(n) {
    return r2[n] ?? null;
  }
  let o = { regex: "", email: " ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO ", date: "ISO ", time: "ISO ", duration: "ISO ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64  ", base64url: "base64url  ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "" }, t = { nan: "NaN" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, $2 = D$2(n.input), u2 = t[$2] ?? $2;
        if (/^[A-Z]/.test(n.expected)) return ` :   instanceof ${n.expected},   ${u2}`;
        return ` :   ${v},   ${u2}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return ` :  ${U$1(n.values[0])}  `;
        return ` : ${_$1(n.values, " ")}   `;
      case "too_big": {
        let v = n.inclusive ? "" : "", $2 = v === "" ? " " : " ", u2 = i(n.origin), l = u2?.unit ?? "";
        if (u2) return `${n.origin ?? ""}  : ${n.maximum.toString()}${l} ${v}${$2}`;
        return `${n.origin ?? ""}  : ${n.maximum.toString()} ${v}${$2}`;
      }
      case "too_small": {
        let v = n.inclusive ? "" : "", $2 = v === "" ? " " : " ", u2 = i(n.origin), l = u2?.unit ?? "";
        if (u2) return `${n.origin ?? ""}  : ${n.minimum.toString()}${l} ${v}${$2}`;
        return `${n.origin ?? ""}  : ${n.minimum.toString()} ${v}${$2}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return ` : "${v.prefix}"()  `;
        if (v.format === "ends_with") return ` : "${v.suffix}"()  `;
        if (v.format === "includes") return ` : "${v.includes}"()  `;
        if (v.format === "regex") return ` :  ${v.pattern}   `;
        return ` ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return ` : ${n.divisor}  `;
      case "unrecognized_keys":
        return `   : ${_$1(n.keys, ", ")}`;
      case "invalid_key":
        return ` : ${n.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return ` : ${n.origin}`;
      default:
        return " ";
    }
  };
};
function g$() {
  return { localeError: T6() };
}
var Nn$1 = (r2) => {
  return r2.charAt(0).toUpperCase() + r2.slice(1);
};
function ll$1(r2) {
  let i = Math.abs(r2), o = i % 10, t = i % 100;
  if (t >= 11 && t <= 19 || o === 0) return "many";
  if (o === 1) return "one";
  return "few";
}
var F6 = () => {
  let r2 = { string: { unit: { one: "simbolis", few: "simboliai", many: "simboli" }, verb: { smaller: { inclusive: "turi bti ne ilgesn kaip", notInclusive: "turi bti trumpesn kaip" }, bigger: { inclusive: "turi bti ne trumpesn kaip", notInclusive: "turi bti ilgesn kaip" } } }, file: { unit: { one: "baitas", few: "baitai", many: "bait" }, verb: { smaller: { inclusive: "turi bti ne didesnis kaip", notInclusive: "turi bti maesnis kaip" }, bigger: { inclusive: "turi bti ne maesnis kaip", notInclusive: "turi bti didesnis kaip" } } }, array: { unit: { one: "element", few: "elementus", many: "element" }, verb: { smaller: { inclusive: "turi turti ne daugiau kaip", notInclusive: "turi turti maiau kaip" }, bigger: { inclusive: "turi turti ne maiau kaip", notInclusive: "turi turti daugiau kaip" } } }, set: { unit: { one: "element", few: "elementus", many: "element" }, verb: { smaller: { inclusive: "turi turti ne daugiau kaip", notInclusive: "turi turti maiau kaip" }, bigger: { inclusive: "turi turti ne maiau kaip", notInclusive: "turi turti daugiau kaip" } } } };
  function i(n, v, $2, u2) {
    let l = r2[n] ?? null;
    if (l === null) return l;
    return { unit: l.unit[v], verb: l.verb[u2][$2 ? "inclusive" : "notInclusive"] };
  }
  let o = { regex: "vestis", email: "el. pato adresas", url: "URL", emoji: "jaustukas", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO data ir laikas", date: "ISO data", time: "ISO laikas", duration: "ISO trukm", ipv4: "IPv4 adresas", ipv6: "IPv6 adresas", cidrv4: "IPv4 tinklo prefiksas (CIDR)", cidrv6: "IPv6 tinklo prefiksas (CIDR)", base64: "base64 ukoduota eilut", base64url: "base64url ukoduota eilut", json_string: "JSON eilut", e164: "E.164 numeris", jwt: "JWT", template_literal: "vestis" }, t = { nan: "NaN", number: "skaiius", bigint: "sveikasis skaiius", string: "eilut", boolean: "login reikm", undefined: "neapibrta reikm", function: "funkcija", symbol: "simbolis", array: "masyvas", object: "objektas", null: "nulin reikm" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, $2 = D$2(n.input), u2 = t[$2] ?? $2;
        if (/^[A-Z]/.test(n.expected)) return `Gautas tipas ${u2}, o tiktasi - instanceof ${n.expected}`;
        return `Gautas tipas ${u2}, o tiktasi - ${v}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Privalo bti ${U$1(n.values[0])}`;
        return `Privalo bti vienas i ${_$1(n.values, "|")} pasirinkim`;
      case "too_big": {
        let v = t[n.origin] ?? n.origin, $2 = i(n.origin, ll$1(Number(n.maximum)), n.inclusive ?? false, "smaller");
        if ($2?.verb) return `${Nn$1(v ?? n.origin ?? "reikm")} ${$2.verb} ${n.maximum.toString()} ${$2.unit ?? "element"}`;
        let u2 = n.inclusive ? "ne didesnis kaip" : "maesnis kaip";
        return `${Nn$1(v ?? n.origin ?? "reikm")} turi bti ${u2} ${n.maximum.toString()} ${$2?.unit}`;
      }
      case "too_small": {
        let v = t[n.origin] ?? n.origin, $2 = i(n.origin, ll$1(Number(n.minimum)), n.inclusive ?? false, "bigger");
        if ($2?.verb) return `${Nn$1(v ?? n.origin ?? "reikm")} ${$2.verb} ${n.minimum.toString()} ${$2.unit ?? "element"}`;
        let u2 = n.inclusive ? "ne maesnis kaip" : "didesnis kaip";
        return `${Nn$1(v ?? n.origin ?? "reikm")} turi bti ${u2} ${n.minimum.toString()} ${$2?.unit}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `Eilut privalo prasidti "${v.prefix}"`;
        if (v.format === "ends_with") return `Eilut privalo pasibaigti "${v.suffix}"`;
        if (v.format === "includes") return `Eilut privalo traukti "${v.includes}"`;
        if (v.format === "regex") return `Eilut privalo atitikti ${v.pattern}`;
        return `Neteisingas ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Skaiius privalo bti ${n.divisor} kartotinis.`;
      case "unrecognized_keys":
        return `Neatpaint${n.keys.length > 1 ? "i" : "as"} rakt${n.keys.length > 1 ? "ai" : "as"}: ${_$1(n.keys, ", ")}`;
      case "invalid_key":
        return "Rastas klaidingas raktas";
      case "invalid_union":
        return "Klaidinga vestis";
      case "invalid_element": {
        let v = t[n.origin] ?? n.origin;
        return `${Nn$1(v ?? n.origin ?? "reikm")} turi klaiding vest`;
      }
      default:
        return "Klaidinga vestis";
    }
  };
};
function e$() {
  return { localeError: F6() };
}
var q6 = () => {
  let r2 = { string: { unit: "", verb: " " }, file: { unit: "", verb: " " }, array: { unit: "", verb: " " }, set: { unit: "", verb: " " } };
  function i(n) {
    return r2[n] ?? null;
  }
  let o = { regex: "", email: "  -", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO   ", date: "ISO ", time: "ISO ", duration: "ISO ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64- ", base64url: "base64url- ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "" }, t = { nan: "NaN", number: "", array: "" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, $2 = D$2(n.input), u2 = t[$2] ?? $2;
        if (/^[A-Z]/.test(n.expected)) return ` :   instanceof ${n.expected},  ${u2}`;
        return ` :   ${v},  ${u2}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Invalid input: expected ${U$1(n.values[0])}`;
        return ` :    ${_$1(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", $2 = i(n.origin);
        if ($2) return ` :   ${n.origin ?? ""}   ${v}${n.maximum.toString()} ${$2.unit ?? ""}`;
        return ` :   ${n.origin ?? ""}   ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", $2 = i(n.origin);
        if ($2) return ` :   ${n.origin}   ${v}${n.minimum.toString()} ${$2.unit}`;
        return ` :   ${n.origin}   ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return ` :     "${v.prefix}"`;
        if (v.format === "ends_with") return ` :     "${v.suffix}"`;
        if (v.format === "includes") return ` :    "${v.includes}"`;
        if (v.format === "regex") return ` :      ${v.pattern}`;
        return `Invalid ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return ` :      ${n.divisor}`;
      case "unrecognized_keys":
        return `${n.keys.length > 1 ? " " : " "}: ${_$1(n.keys, ", ")}`;
      case "invalid_key":
        return `   ${n.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${n.origin}`;
      default:
        return " ";
    }
  };
};
function l$() {
  return { localeError: q6() };
}
var B6 = () => {
  let r2 = { string: { unit: "aksara", verb: "mempunyai" }, file: { unit: "bait", verb: "mempunyai" }, array: { unit: "elemen", verb: "mempunyai" }, set: { unit: "elemen", verb: "mempunyai" } };
  function i(n) {
    return r2[n] ?? null;
  }
  let o = { regex: "input", email: "alamat e-mel", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "tarikh masa ISO", date: "tarikh ISO", time: "masa ISO", duration: "tempoh ISO", ipv4: "alamat IPv4", ipv6: "alamat IPv6", cidrv4: "julat IPv4", cidrv6: "julat IPv6", base64: "string dikodkan base64", base64url: "string dikodkan base64url", json_string: "string JSON", e164: "nombor E.164", jwt: "JWT", template_literal: "input" }, t = { nan: "NaN", number: "nombor" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, $2 = D$2(n.input), u2 = t[$2] ?? $2;
        if (/^[A-Z]/.test(n.expected)) return `Input tidak sah: dijangka instanceof ${n.expected}, diterima ${u2}`;
        return `Input tidak sah: dijangka ${v}, diterima ${u2}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Input tidak sah: dijangka ${U$1(n.values[0])}`;
        return `Pilihan tidak sah: dijangka salah satu daripada ${_$1(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", $2 = i(n.origin);
        if ($2) return `Terlalu besar: dijangka ${n.origin ?? "nilai"} ${$2.verb} ${v}${n.maximum.toString()} ${$2.unit ?? "elemen"}`;
        return `Terlalu besar: dijangka ${n.origin ?? "nilai"} adalah ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", $2 = i(n.origin);
        if ($2) return `Terlalu kecil: dijangka ${n.origin} ${$2.verb} ${v}${n.minimum.toString()} ${$2.unit}`;
        return `Terlalu kecil: dijangka ${n.origin} adalah ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `String tidak sah: mesti bermula dengan "${v.prefix}"`;
        if (v.format === "ends_with") return `String tidak sah: mesti berakhir dengan "${v.suffix}"`;
        if (v.format === "includes") return `String tidak sah: mesti mengandungi "${v.includes}"`;
        if (v.format === "regex") return `String tidak sah: mesti sepadan dengan corak ${v.pattern}`;
        return `${o[v.format] ?? n.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${n.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${_$1(n.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${n.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${n.origin}`;
      default:
        return "Input tidak sah";
    }
  };
};
function I$() {
  return { localeError: B6() };
}
var H6 = () => {
  let r2 = { string: { unit: "tekens", verb: "heeft" }, file: { unit: "bytes", verb: "heeft" }, array: { unit: "elementen", verb: "heeft" }, set: { unit: "elementen", verb: "heeft" } };
  function i(n) {
    return r2[n] ?? null;
  }
  let o = { regex: "invoer", email: "emailadres", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO datum en tijd", date: "ISO datum", time: "ISO tijd", duration: "ISO duur", ipv4: "IPv4-adres", ipv6: "IPv6-adres", cidrv4: "IPv4-bereik", cidrv6: "IPv6-bereik", base64: "base64-gecodeerde tekst", base64url: "base64 URL-gecodeerde tekst", json_string: "JSON string", e164: "E.164-nummer", jwt: "JWT", template_literal: "invoer" }, t = { nan: "NaN", number: "getal" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, $2 = D$2(n.input), u2 = t[$2] ?? $2;
        if (/^[A-Z]/.test(n.expected)) return `Ongeldige invoer: verwacht instanceof ${n.expected}, ontving ${u2}`;
        return `Ongeldige invoer: verwacht ${v}, ontving ${u2}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Ongeldige invoer: verwacht ${U$1(n.values[0])}`;
        return `Ongeldige optie: verwacht n van ${_$1(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", $2 = i(n.origin), u2 = n.origin === "date" ? "laat" : n.origin === "string" ? "lang" : "groot";
        if ($2) return `Te ${u2}: verwacht dat ${n.origin ?? "waarde"} ${v}${n.maximum.toString()} ${$2.unit ?? "elementen"} ${$2.verb}`;
        return `Te ${u2}: verwacht dat ${n.origin ?? "waarde"} ${v}${n.maximum.toString()} is`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", $2 = i(n.origin), u2 = n.origin === "date" ? "vroeg" : n.origin === "string" ? "kort" : "klein";
        if ($2) return `Te ${u2}: verwacht dat ${n.origin} ${v}${n.minimum.toString()} ${$2.unit} ${$2.verb}`;
        return `Te ${u2}: verwacht dat ${n.origin} ${v}${n.minimum.toString()} is`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `Ongeldige tekst: moet met "${v.prefix}" beginnen`;
        if (v.format === "ends_with") return `Ongeldige tekst: moet op "${v.suffix}" eindigen`;
        if (v.format === "includes") return `Ongeldige tekst: moet "${v.includes}" bevatten`;
        if (v.format === "regex") return `Ongeldige tekst: moet overeenkomen met patroon ${v.pattern}`;
        return `Ongeldig: ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${n.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${n.keys.length > 1 ? "s" : ""}: ${_$1(n.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${n.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${n.origin}`;
      default:
        return "Ongeldige invoer";
    }
  };
};
function c$() {
  return { localeError: H6() };
}
var M6 = () => {
  let r2 = { string: { unit: "tegn", verb: " ha" }, file: { unit: "bytes", verb: " ha" }, array: { unit: "elementer", verb: " inneholde" }, set: { unit: "elementer", verb: " inneholde" } };
  function i(n) {
    return r2[n] ?? null;
  }
  let o = { regex: "input", email: "e-postadresse", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO dato- og klokkeslett", date: "ISO-dato", time: "ISO-klokkeslett", duration: "ISO-varighet", ipv4: "IPv4-omrde", ipv6: "IPv6-omrde", cidrv4: "IPv4-spekter", cidrv6: "IPv6-spekter", base64: "base64-enkodet streng", base64url: "base64url-enkodet streng", json_string: "JSON-streng", e164: "E.164-nummer", jwt: "JWT", template_literal: "input" }, t = { nan: "NaN", number: "tall", array: "liste" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, $2 = D$2(n.input), u2 = t[$2] ?? $2;
        if (/^[A-Z]/.test(n.expected)) return `Ugyldig input: forventet instanceof ${n.expected}, fikk ${u2}`;
        return `Ugyldig input: forventet ${v}, fikk ${u2}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Ugyldig verdi: forventet ${U$1(n.values[0])}`;
        return `Ugyldig valg: forventet en av ${_$1(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", $2 = i(n.origin);
        if ($2) return `For stor(t): forventet ${n.origin ?? "value"} til  ha ${v}${n.maximum.toString()} ${$2.unit ?? "elementer"}`;
        return `For stor(t): forventet ${n.origin ?? "value"} til  ha ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", $2 = i(n.origin);
        if ($2) return `For lite(n): forventet ${n.origin} til  ha ${v}${n.minimum.toString()} ${$2.unit}`;
        return `For lite(n): forventet ${n.origin} til  ha ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `Ugyldig streng: m starte med "${v.prefix}"`;
        if (v.format === "ends_with") return `Ugyldig streng: m ende med "${v.suffix}"`;
        if (v.format === "includes") return `Ugyldig streng: m inneholde "${v.includes}"`;
        if (v.format === "regex") return `Ugyldig streng: m matche mnsteret ${v.pattern}`;
        return `Ugyldig ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: m vre et multiplum av ${n.divisor}`;
      case "unrecognized_keys":
        return `${n.keys.length > 1 ? "Ukjente nkler" : "Ukjent nkkel"}: ${_$1(n.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig nkkel i ${n.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${n.origin}`;
      default:
        return "Ugyldig input";
    }
  };
};
function _$() {
  return { localeError: M6() };
}
var m6 = () => {
  let r2 = { string: { unit: "harf", verb: "olmaldr" }, file: { unit: "bayt", verb: "olmaldr" }, array: { unit: "unsur", verb: "olmaldr" }, set: { unit: "unsur", verb: "olmaldr" } };
  function i(n) {
    return r2[n] ?? null;
  }
  let o = { regex: "giren", email: "epostagh", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO hengm", date: "ISO tarihi", time: "ISO zaman", duration: "ISO mddeti", ipv4: "IPv4 nin", ipv6: "IPv6 nin", cidrv4: "IPv4 menzili", cidrv6: "IPv6 menzili", base64: "base64-ifreli metin", base64url: "base64url-ifreli metin", json_string: "JSON metin", e164: "E.164 says", jwt: "JWT", template_literal: "giren" }, t = { nan: "NaN", number: "numara", array: "saf", null: "gayb" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, $2 = D$2(n.input), u2 = t[$2] ?? $2;
        if (/^[A-Z]/.test(n.expected)) return `Fsit giren: umulan instanceof ${n.expected}, alnan ${u2}`;
        return `Fsit giren: umulan ${v}, alnan ${u2}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Fsit giren: umulan ${U$1(n.values[0])}`;
        return `Fsit tercih: mteberler ${_$1(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", $2 = i(n.origin);
        if ($2) return `Fazla byk: ${n.origin ?? "value"}, ${v}${n.maximum.toString()} ${$2.unit ?? "elements"} sahip olmalyd.`;
        return `Fazla byk: ${n.origin ?? "value"}, ${v}${n.maximum.toString()} olmalyd.`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", $2 = i(n.origin);
        if ($2) return `Fazla kk: ${n.origin}, ${v}${n.minimum.toString()} ${$2.unit} sahip olmalyd.`;
        return `Fazla kk: ${n.origin}, ${v}${n.minimum.toString()} olmalyd.`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `Fsit metin: "${v.prefix}" ile balamal.`;
        if (v.format === "ends_with") return `Fsit metin: "${v.suffix}" ile bitmeli.`;
        if (v.format === "includes") return `Fsit metin: "${v.includes}" ihtiv etmeli.`;
        if (v.format === "regex") return `Fsit metin: ${v.pattern} nakna uymal.`;
        return `Fsit ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Fsit say: ${n.divisor} kat olmalyd.`;
      case "unrecognized_keys":
        return `Tannmayan anahtar ${n.keys.length > 1 ? "s" : ""}: ${_$1(n.keys, ", ")}`;
      case "invalid_key":
        return `${n.origin} iin tannmayan anahtar var.`;
      case "invalid_union":
        return "Giren tannamad.";
      case "invalid_element":
        return `${n.origin} iin tannmayan kymet var.`;
      default:
        return "Kymet tannamad.";
    }
  };
};
function b$() {
  return { localeError: m6() };
}
var R6 = () => {
  let r2 = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function i(n) {
    return r2[n] ?? null;
  }
  let o = { regex: "", email: "", url: "  ", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "  ", date: "", time: "", duration: "", ipv4: " IPv4 ", ipv6: " IPv6 ", cidrv4: " IPv4 ", cidrv6: " IPv6 ", base64: "base64-encoded ", base64url: "base64url-encoded ", json_string: "JSON ", e164: " E.164 ", jwt: "JWT", template_literal: "" }, t = { nan: "NaN", number: "", array: "" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, $2 = D$2(n.input), u2 = t[$2] ?? $2;
        if (/^[A-Z]/.test(n.expected)) return ` :  instanceof ${n.expected} ,  ${u2}  `;
        return ` :  ${v} ,  ${u2}  `;
      }
      case "invalid_value":
        if (n.values.length === 1) return ` :  ${U$1(n.values[0])} `;
        return ` :    ${_$1(n.values, "|")}  `;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", $2 = i(n.origin);
        if ($2) return ` : ${n.origin ?? ""}  ${v}${n.maximum.toString()} ${$2.unit ?? ""} `;
        return ` : ${n.origin ?? ""}  ${v}${n.maximum.toString()} `;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", $2 = i(n.origin);
        if ($2) return ` : ${n.origin}  ${v}${n.minimum.toString()} ${$2.unit} `;
        return ` : ${n.origin}  ${v}${n.minimum.toString()} `;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return ` :   "${v.prefix}"   `;
        if (v.format === "ends_with") return ` :   "${v.suffix}"    `;
        if (v.format === "includes") return ` :  "${v.includes}" `;
        if (v.format === "regex") return ` :   ${v.pattern}   `;
        return `${o[v.format] ?? n.format}  `;
      }
      case "not_multiple_of":
        return ` :   ${n.divisor}  `;
      case "unrecognized_keys":
        return ` ${n.keys.length > 1 ? "" : ""}: ${_$1(n.keys, ", ")}`;
      case "invalid_key":
        return `   ${n.origin} `;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${n.origin} `;
      default:
        return " ";
    }
  };
};
function U$() {
  return { localeError: R6() };
}
var x6 = () => {
  let r2 = { string: { unit: "znakw", verb: "mie" }, file: { unit: "bajtw", verb: "mie" }, array: { unit: "elementw", verb: "mie" }, set: { unit: "elementw", verb: "mie" } };
  function i(n) {
    return r2[n] ?? null;
  }
  let o = { regex: "wyraenie", email: "adres email", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "data i godzina w formacie ISO", date: "data w formacie ISO", time: "godzina w formacie ISO", duration: "czas trwania ISO", ipv4: "adres IPv4", ipv6: "adres IPv6", cidrv4: "zakres IPv4", cidrv6: "zakres IPv6", base64: "cig znakw zakodowany w formacie base64", base64url: "cig znakw zakodowany w formacie base64url", json_string: "cig znakw w formacie JSON", e164: "liczba E.164", jwt: "JWT", template_literal: "wejcie" }, t = { nan: "NaN", number: "liczba", array: "tablica" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, $2 = D$2(n.input), u2 = t[$2] ?? $2;
        if (/^[A-Z]/.test(n.expected)) return `Nieprawidowe dane wejciowe: oczekiwano instanceof ${n.expected}, otrzymano ${u2}`;
        return `Nieprawidowe dane wejciowe: oczekiwano ${v}, otrzymano ${u2}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Nieprawidowe dane wejciowe: oczekiwano ${U$1(n.values[0])}`;
        return `Nieprawidowa opcja: oczekiwano jednej z wartoci ${_$1(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", $2 = i(n.origin);
        if ($2) return `Za dua warto: oczekiwano, e ${n.origin ?? "warto"} bdzie mie ${v}${n.maximum.toString()} ${$2.unit ?? "elementw"}`;
        return `Zbyt du(y/a/e): oczekiwano, e ${n.origin ?? "warto"} bdzie wynosi ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", $2 = i(n.origin);
        if ($2) return `Za maa warto: oczekiwano, e ${n.origin ?? "warto"} bdzie mie ${v}${n.minimum.toString()} ${$2.unit ?? "elementw"}`;
        return `Zbyt ma(y/a/e): oczekiwano, e ${n.origin ?? "warto"} bdzie wynosi ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `Nieprawidowy cig znakw: musi zaczyna si od "${v.prefix}"`;
        if (v.format === "ends_with") return `Nieprawidowy cig znakw: musi koczy si na "${v.suffix}"`;
        if (v.format === "includes") return `Nieprawidowy cig znakw: musi zawiera "${v.includes}"`;
        if (v.format === "regex") return `Nieprawidowy cig znakw: musi odpowiada wzorcowi ${v.pattern}`;
        return `Nieprawidow(y/a/e) ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Nieprawidowa liczba: musi by wielokrotnoci ${n.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${n.keys.length > 1 ? "s" : ""}: ${_$1(n.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawidowy klucz w ${n.origin}`;
      case "invalid_union":
        return "Nieprawidowe dane wejciowe";
      case "invalid_element":
        return `Nieprawidowa warto w ${n.origin}`;
      default:
        return "Nieprawidowe dane wejciowe";
    }
  };
};
function D$() {
  return { localeError: x6() };
}
var Z6 = () => {
  let r2 = { string: { unit: "caracteres", verb: "ter" }, file: { unit: "bytes", verb: "ter" }, array: { unit: "itens", verb: "ter" }, set: { unit: "itens", verb: "ter" } };
  function i(n) {
    return r2[n] ?? null;
  }
  let o = { regex: "padro", email: "endereo de e-mail", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "data e hora ISO", date: "data ISO", time: "hora ISO", duration: "durao ISO", ipv4: "endereo IPv4", ipv6: "endereo IPv6", cidrv4: "faixa de IPv4", cidrv6: "faixa de IPv6", base64: "texto codificado em base64", base64url: "URL codificada em base64", json_string: "texto JSON", e164: "nmero E.164", jwt: "JWT", template_literal: "entrada" }, t = { nan: "NaN", number: "nmero", null: "nulo" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, $2 = D$2(n.input), u2 = t[$2] ?? $2;
        if (/^[A-Z]/.test(n.expected)) return `Tipo invlido: esperado instanceof ${n.expected}, recebido ${u2}`;
        return `Tipo invlido: esperado ${v}, recebido ${u2}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Entrada invlida: esperado ${U$1(n.values[0])}`;
        return `Opo invlida: esperada uma das ${_$1(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", $2 = i(n.origin);
        if ($2) return `Muito grande: esperado que ${n.origin ?? "valor"} tivesse ${v}${n.maximum.toString()} ${$2.unit ?? "elementos"}`;
        return `Muito grande: esperado que ${n.origin ?? "valor"} fosse ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", $2 = i(n.origin);
        if ($2) return `Muito pequeno: esperado que ${n.origin} tivesse ${v}${n.minimum.toString()} ${$2.unit}`;
        return `Muito pequeno: esperado que ${n.origin} fosse ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `Texto invlido: deve comear com "${v.prefix}"`;
        if (v.format === "ends_with") return `Texto invlido: deve terminar com "${v.suffix}"`;
        if (v.format === "includes") return `Texto invlido: deve incluir "${v.includes}"`;
        if (v.format === "regex") return `Texto invlido: deve corresponder ao padro ${v.pattern}`;
        return `${o[v.format] ?? n.format} invlido`;
      }
      case "not_multiple_of":
        return `Nmero invlido: deve ser mltiplo de ${n.divisor}`;
      case "unrecognized_keys":
        return `Chave${n.keys.length > 1 ? "s" : ""} desconhecida${n.keys.length > 1 ? "s" : ""}: ${_$1(n.keys, ", ")}`;
      case "invalid_key":
        return `Chave invlida em ${n.origin}`;
      case "invalid_union":
        return "Entrada invlida";
      case "invalid_element":
        return `Valor invlido em ${n.origin}`;
      default:
        return "Campo invlido";
    }
  };
};
function k$() {
  return { localeError: Z6() };
}
function Il$1(r2, i, o, t) {
  let n = Math.abs(r2), v = n % 10, $2 = n % 100;
  if ($2 >= 11 && $2 <= 19) return t;
  if (v === 1) return i;
  if (v >= 2 && v <= 4) return o;
  return t;
}
var d6 = () => {
  let r2 = { string: { unit: { one: "", few: "", many: "" }, verb: "" }, file: { unit: { one: "", few: "", many: "" }, verb: "" }, array: { unit: { one: "", few: "", many: "" }, verb: "" }, set: { unit: { one: "", few: "", many: "" }, verb: "" } };
  function i(n) {
    return r2[n] ?? null;
  }
  let o = { regex: "", email: "email ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO   ", date: "ISO ", time: "ISO ", duration: "ISO ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "   base64", base64url: "   base64url", json_string: "JSON ", e164: " E.164", jwt: "JWT", template_literal: "" }, t = { nan: "NaN", number: "", array: "" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, $2 = D$2(n.input), u2 = t[$2] ?? $2;
        if (/^[A-Z]/.test(n.expected)) return ` :  instanceof ${n.expected},  ${u2}`;
        return ` :  ${v},  ${u2}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return ` :  ${U$1(n.values[0])}`;
        return ` :    ${_$1(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", $2 = i(n.origin);
        if ($2) {
          let u2 = Number(n.maximum), l = Il$1(u2, $2.unit.one, $2.unit.few, $2.unit.many);
          return `  : ,  ${n.origin ?? ""}   ${v}${n.maximum.toString()} ${l}`;
        }
        return `  : ,  ${n.origin ?? ""}  ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", $2 = i(n.origin);
        if ($2) {
          let u2 = Number(n.minimum), l = Il$1(u2, $2.unit.one, $2.unit.few, $2.unit.many);
          return `  : ,  ${n.origin}   ${v}${n.minimum.toString()} ${l}`;
        }
        return `  : ,  ${n.origin}  ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return ` :    "${v.prefix}"`;
        if (v.format === "ends_with") return ` :    "${v.suffix}"`;
        if (v.format === "includes") return ` :   "${v.includes}"`;
        if (v.format === "regex") return ` :    ${v.pattern}`;
        return ` ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return ` :    ${n.divisor}`;
      case "unrecognized_keys":
        return `${n.keys.length > 1 ? "" : ""} ${n.keys.length > 1 ? "" : ""}: ${_$1(n.keys, ", ")}`;
      case "invalid_key":
        return `   ${n.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `   ${n.origin}`;
      default:
        return "  ";
    }
  };
};
function w$() {
  return { localeError: d6() };
}
var C6 = () => {
  let r2 = { string: { unit: "znakov", verb: "imeti" }, file: { unit: "bajtov", verb: "imeti" }, array: { unit: "elementov", verb: "imeti" }, set: { unit: "elementov", verb: "imeti" } };
  function i(n) {
    return r2[n] ?? null;
  }
  let o = { regex: "vnos", email: "e-potni naslov", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO datum in as", date: "ISO datum", time: "ISO as", duration: "ISO trajanje", ipv4: "IPv4 naslov", ipv6: "IPv6 naslov", cidrv4: "obseg IPv4", cidrv6: "obseg IPv6", base64: "base64 kodiran niz", base64url: "base64url kodiran niz", json_string: "JSON niz", e164: "E.164 tevilka", jwt: "JWT", template_literal: "vnos" }, t = { nan: "NaN", number: "tevilo", array: "tabela" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, $2 = D$2(n.input), u2 = t[$2] ?? $2;
        if (/^[A-Z]/.test(n.expected)) return `Neveljaven vnos: priakovano instanceof ${n.expected}, prejeto ${u2}`;
        return `Neveljaven vnos: priakovano ${v}, prejeto ${u2}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Neveljaven vnos: priakovano ${U$1(n.values[0])}`;
        return `Neveljavna monost: priakovano eno izmed ${_$1(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", $2 = i(n.origin);
        if ($2) return `Preveliko: priakovano, da bo ${n.origin ?? "vrednost"} imelo ${v}${n.maximum.toString()} ${$2.unit ?? "elementov"}`;
        return `Preveliko: priakovano, da bo ${n.origin ?? "vrednost"} ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", $2 = i(n.origin);
        if ($2) return `Premajhno: priakovano, da bo ${n.origin} imelo ${v}${n.minimum.toString()} ${$2.unit}`;
        return `Premajhno: priakovano, da bo ${n.origin} ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `Neveljaven niz: mora se zaeti z "${v.prefix}"`;
        if (v.format === "ends_with") return `Neveljaven niz: mora se konati z "${v.suffix}"`;
        if (v.format === "includes") return `Neveljaven niz: mora vsebovati "${v.includes}"`;
        if (v.format === "regex") return `Neveljaven niz: mora ustrezati vzorcu ${v.pattern}`;
        return `Neveljaven ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno tevilo: mora biti vekratnik ${n.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${n.keys.length > 1 ? "i kljui" : " klju"}: ${_$1(n.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven klju v ${n.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${n.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
};
function N$() {
  return { localeError: C6() };
}
var f6 = () => {
  let r2 = { string: { unit: "tecken", verb: "att ha" }, file: { unit: "bytes", verb: "att ha" }, array: { unit: "objekt", verb: "att innehlla" }, set: { unit: "objekt", verb: "att innehlla" } };
  function i(n) {
    return r2[n] ?? null;
  }
  let o = { regex: "reguljrt uttryck", email: "e-postadress", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO-datum och tid", date: "ISO-datum", time: "ISO-tid", duration: "ISO-varaktighet", ipv4: "IPv4-intervall", ipv6: "IPv6-intervall", cidrv4: "IPv4-spektrum", cidrv6: "IPv6-spektrum", base64: "base64-kodad strng", base64url: "base64url-kodad strng", json_string: "JSON-strng", e164: "E.164-nummer", jwt: "JWT", template_literal: "mall-literal" }, t = { nan: "NaN", number: "antal", array: "lista" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, $2 = D$2(n.input), u2 = t[$2] ?? $2;
        if (/^[A-Z]/.test(n.expected)) return `Ogiltig inmatning: frvntat instanceof ${n.expected}, fick ${u2}`;
        return `Ogiltig inmatning: frvntat ${v}, fick ${u2}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Ogiltig inmatning: frvntat ${U$1(n.values[0])}`;
        return `Ogiltigt val: frvntade en av ${_$1(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", $2 = i(n.origin);
        if ($2) return `Fr stor(t): frvntade ${n.origin ?? "vrdet"} att ha ${v}${n.maximum.toString()} ${$2.unit ?? "element"}`;
        return `Fr stor(t): frvntat ${n.origin ?? "vrdet"} att ha ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", $2 = i(n.origin);
        if ($2) return `Fr lite(t): frvntade ${n.origin ?? "vrdet"} att ha ${v}${n.minimum.toString()} ${$2.unit}`;
        return `Fr lite(t): frvntade ${n.origin ?? "vrdet"} att ha ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `Ogiltig strng: mste brja med "${v.prefix}"`;
        if (v.format === "ends_with") return `Ogiltig strng: mste sluta med "${v.suffix}"`;
        if (v.format === "includes") return `Ogiltig strng: mste innehlla "${v.includes}"`;
        if (v.format === "regex") return `Ogiltig strng: mste matcha mnstret "${v.pattern}"`;
        return `Ogiltig(t) ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: mste vara en multipel av ${n.divisor}`;
      case "unrecognized_keys":
        return `${n.keys.length > 1 ? "Oknda nycklar" : "Oknd nyckel"}: ${_$1(n.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${n.origin ?? "vrdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt vrde i ${n.origin ?? "vrdet"}`;
      default:
        return "Ogiltig input";
    }
  };
};
function O$() {
  return { localeError: f6() };
}
var y6 = () => {
  let r2 = { string: { unit: "", verb: " " }, file: { unit: "", verb: " " }, array: { unit: "", verb: " " }, set: { unit: "", verb: " " } };
  function i(n) {
    return r2[n] ?? null;
  }
  let o = { regex: "", email: " ", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO  ", date: "ISO ", time: "ISO ", duration: "ISO  ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64-encoded ", base64url: "base64url-encoded ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "input" }, t = { nan: "NaN", number: "", array: "", null: "" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, $2 = D$2(n.input), u2 = t[$2] ?? $2;
        if (/^[A-Z]/.test(n.expected)) return ` :  instanceof ${n.expected},  ${u2}`;
        return ` :  ${v},  ${u2}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return ` :  ${U$1(n.values[0])}`;
        return ` :  ${_$1(n.values, "|")}  `;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", $2 = i(n.origin);
        if ($2) return ` :  ${n.origin ?? ""} ${v}${n.maximum.toString()} ${$2.unit ?? ""}   `;
        return ` :  ${n.origin ?? ""} ${v}${n.maximum.toString()}   `;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", $2 = i(n.origin);
        if ($2) return ` :  ${n.origin} ${v}${n.minimum.toString()} ${$2.unit}   `;
        return ` :  ${n.origin} ${v}${n.minimum.toString()}   `;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return ` : "${v.prefix}"   `;
        if (v.format === "ends_with") return ` : "${v.suffix}"   `;
        if (v.format === "includes") return ` : "${v.includes}"   `;
        if (v.format === "regex") return ` : ${v.pattern}   `;
        return ` ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return ` : ${n.divisor}    `;
      case "unrecognized_keys":
        return `  ${n.keys.length > 1 ? "" : ""}: ${_$1(n.keys, ", ")}`;
      case "invalid_key":
        return `${n.origin}   `;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `${n.origin}   `;
      default:
        return " ";
    }
  };
};
function S$() {
  return { localeError: y6() };
}
var h6 = () => {
  let r2 = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function i(n) {
    return r2[n] ?? null;
  }
  let o = { regex: "", email: "", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: " ISO", date: " ISO", time: " ISO", duration: " ISO", ipv4: " IPv4", ipv6: " IPv6", cidrv4: " IP  IPv4", cidrv6: " IP  IPv6", base64: " Base64", base64url: " Base64  URL", json_string: " JSON", e164: " (E.164)", jwt: " JWT", template_literal: "" }, t = { nan: "NaN", number: "", array: " (Array)", null: " (null)" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, $2 = D$2(n.input), u2 = t[$2] ?? $2;
        if (/^[A-Z]/.test(n.expected)) return `:  instanceof ${n.expected}  ${u2}`;
        return `:  ${v}  ${u2}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `:  ${U$1(n.values[0])}`;
        return `:  ${_$1(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "" : "", $2 = i(n.origin);
        if ($2) return `: ${n.origin ?? ""} ${v} ${n.maximum.toString()} ${$2.unit ?? ""}`;
        return `: ${n.origin ?? ""} ${v} ${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? "" : "", $2 = i(n.origin);
        if ($2) return `: ${n.origin} ${v} ${n.minimum.toString()} ${$2.unit}`;
        return `: ${n.origin} ${v} ${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `:  "${v.prefix}"`;
        if (v.format === "ends_with") return `:  "${v.suffix}"`;
        if (v.format === "includes") return `:  "${v.includes}" `;
        if (v.format === "regex") return `:  ${v.pattern}`;
        return `: ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `:  ${n.divisor} `;
      case "unrecognized_keys":
        return `: ${_$1(n.keys, ", ")}`;
      case "invalid_key":
        return ` ${n.origin}`;
      case "invalid_union":
        return ": ";
      case "invalid_element":
        return ` ${n.origin}`;
      default:
        return "";
    }
  };
};
function z$() {
  return { localeError: h6() };
}
var a6 = () => {
  let r2 = { string: { unit: "karakter", verb: "olmal" }, file: { unit: "bayt", verb: "olmal" }, array: { unit: "e", verb: "olmal" }, set: { unit: "e", verb: "olmal" } };
  function i(n) {
    return r2[n] ?? null;
  }
  let o = { regex: "girdi", email: "e-posta adresi", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO tarih ve saat", date: "ISO tarih", time: "ISO saat", duration: "ISO sre", ipv4: "IPv4 adresi", ipv6: "IPv6 adresi", cidrv4: "IPv4 aral", cidrv6: "IPv6 aral", base64: "base64 ile ifrelenmi metin", base64url: "base64url ile ifrelenmi metin", json_string: "JSON dizesi", e164: "E.164 says", jwt: "JWT", template_literal: "ablon dizesi" }, t = { nan: "NaN" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, $2 = D$2(n.input), u2 = t[$2] ?? $2;
        if (/^[A-Z]/.test(n.expected)) return `Geersiz deer: beklenen instanceof ${n.expected}, alnan ${u2}`;
        return `Geersiz deer: beklenen ${v}, alnan ${u2}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Geersiz deer: beklenen ${U$1(n.values[0])}`;
        return `Geersiz seenek: aadakilerden biri olmal: ${_$1(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", $2 = i(n.origin);
        if ($2) return `ok byk: beklenen ${n.origin ?? "deer"} ${v}${n.maximum.toString()} ${$2.unit ?? "e"}`;
        return `ok byk: beklenen ${n.origin ?? "deer"} ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", $2 = i(n.origin);
        if ($2) return `ok kk: beklenen ${n.origin} ${v}${n.minimum.toString()} ${$2.unit}`;
        return `ok kk: beklenen ${n.origin} ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `Geersiz metin: "${v.prefix}" ile balamal`;
        if (v.format === "ends_with") return `Geersiz metin: "${v.suffix}" ile bitmeli`;
        if (v.format === "includes") return `Geersiz metin: "${v.includes}" iermeli`;
        if (v.format === "regex") return `Geersiz metin: ${v.pattern} desenine uymal`;
        return `Geersiz ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Geersiz say: ${n.divisor} ile tam blnebilmeli`;
      case "unrecognized_keys":
        return `Tannmayan anahtar${n.keys.length > 1 ? "lar" : ""}: ${_$1(n.keys, ", ")}`;
      case "invalid_key":
        return `${n.origin} iinde geersiz anahtar`;
      case "invalid_union":
        return "Geersiz deer";
      case "invalid_element":
        return `${n.origin} iinde geersiz deer`;
      default:
        return "Geersiz deer";
    }
  };
};
function P$() {
  return { localeError: a6() };
}
var p6 = () => {
  let r2 = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function i(n) {
    return r2[n] ?? null;
  }
  let o = { regex: " ", email: "  ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "   ISO", date: " ISO", time: " ISO", duration: " ISO", ipv4: " IPv4", ipv6: " IPv6", cidrv4: " IPv4", cidrv6: " IPv6", base64: "   base64", base64url: "   base64url", json_string: " JSON", e164: " E.164", jwt: "JWT", template_literal: " " }, t = { nan: "NaN", number: "", array: "" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, $2 = D$2(n.input), u2 = t[$2] ?? $2;
        if (/^[A-Z]/.test(n.expected)) return `  :  instanceof ${n.expected},  ${u2}`;
        return `  :  ${v},  ${u2}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `  :  ${U$1(n.values[0])}`;
        return ` :    ${_$1(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", $2 = i(n.origin);
        if ($2) return ` : ,  ${n.origin ?? ""} ${$2.verb} ${v}${n.maximum.toString()} ${$2.unit ?? ""}`;
        return ` : ,  ${n.origin ?? ""}  ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", $2 = i(n.origin);
        if ($2) return ` : ,  ${n.origin} ${$2.verb} ${v}${n.minimum.toString()} ${$2.unit}`;
        return ` : ,  ${n.origin}  ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return ` :    "${v.prefix}"`;
        if (v.format === "ends_with") return ` :    "${v.suffix}"`;
        if (v.format === "includes") return ` :   "${v.includes}"`;
        if (v.format === "regex") return ` :    ${v.pattern}`;
        return ` ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return ` :    ${n.divisor}`;
      case "unrecognized_keys":
        return ` ${n.keys.length > 1 ? "" : ""}: ${_$1(n.keys, ", ")}`;
      case "invalid_key":
        return `   ${n.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `   ${n.origin}`;
      default:
        return "  ";
    }
  };
};
function On$1() {
  return { localeError: p6() };
}
function j$() {
  return On$1();
}
var s6 = () => {
  let r2 = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function i(n) {
    return r2[n] ?? null;
  }
  let o = { regex: " ", email: "  ", url: "  ", emoji: "", uuid: "   ", uuidv4: "     4", uuidv6: "     6", nanoid: "  ", guid: "   ", cuid: "   ", cuid2: "    2", ulid: "   ", xid: "  ", ksuid: "    ", datetime: "    ", date: "   ", time: "   ", duration: "   ", ipv4: "   4 ", ipv6: "   6 ", cidrv4: "   4 ", cidrv6: "   6 ", base64: " 64   ", base64url: " 64      ", json_string: "    ", e164: " 164 ", jwt: "  ", template_literal: " " }, t = { nan: "NaN", number: "", array: "", null: "" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, $2 = D$2(n.input), u2 = t[$2] ?? $2;
        if (/^[A-Z]/.test(n.expected)) return `  : instanceof ${n.expected}   ${u2}  `;
        return `  : ${v}   ${u2}  `;
      }
      case "invalid_value":
        if (n.values.length === 1) return `  : ${U$1(n.values[0])}  `;
        return ` : ${_$1(n.values, "|")}     `;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", $2 = i(n.origin);
        if ($2) return ` : ${n.origin ?? ""}  ${v}${n.maximum.toString()} ${$2.unit ?? ""}   `;
        return ` : ${n.origin ?? ""}  ${v}${n.maximum.toString()}   `;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", $2 = i(n.origin);
        if ($2) return ` : ${n.origin}  ${v}${n.minimum.toString()} ${$2.unit}   `;
        return ` : ${n.origin}  ${v}${n.minimum.toString()}   `;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return ` : "${v.prefix}"    `;
        if (v.format === "ends_with") return ` : "${v.suffix}"    `;
        if (v.format === "includes") return ` : "${v.includes}"   `;
        if (v.format === "regex") return ` :  ${v.pattern}    `;
        return ` ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return ` : ${n.divisor}    `;
      case "unrecognized_keys":
        return `   ${n.keys.length > 1 ? "" : ""}: ${_$1(n.keys, " ")}`;
      case "invalid_key":
        return `${n.origin}   `;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `${n.origin}   `;
      default:
        return "  ";
    }
  };
};
function J$() {
  return { localeError: s6() };
}
var rc$1 = () => {
  let r2 = { string: { unit: "belgi", verb: "bolishi kerak" }, file: { unit: "bayt", verb: "bolishi kerak" }, array: { unit: "element", verb: "bolishi kerak" }, set: { unit: "element", verb: "bolishi kerak" } };
  function i(n) {
    return r2[n] ?? null;
  }
  let o = { regex: "kirish", email: "elektron pochta manzili", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO sana va vaqti", date: "ISO sana", time: "ISO vaqt", duration: "ISO davomiylik", ipv4: "IPv4 manzil", ipv6: "IPv6 manzil", mac: "MAC manzil", cidrv4: "IPv4 diapazon", cidrv6: "IPv6 diapazon", base64: "base64 kodlangan satr", base64url: "base64url kodlangan satr", json_string: "JSON satr", e164: "E.164 raqam", jwt: "JWT", template_literal: "kirish" }, t = { nan: "NaN", number: "raqam", array: "massiv" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, $2 = D$2(n.input), u2 = t[$2] ?? $2;
        if (/^[A-Z]/.test(n.expected)) return `Notogri kirish: kutilgan instanceof ${n.expected}, qabul qilingan ${u2}`;
        return `Notogri kirish: kutilgan ${v}, qabul qilingan ${u2}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Notogri kirish: kutilgan ${U$1(n.values[0])}`;
        return `Notogri variant: quyidagilardan biri kutilgan ${_$1(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", $2 = i(n.origin);
        if ($2) return `Juda katta: kutilgan ${n.origin ?? "qiymat"} ${v}${n.maximum.toString()} ${$2.unit} ${$2.verb}`;
        return `Juda katta: kutilgan ${n.origin ?? "qiymat"} ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", $2 = i(n.origin);
        if ($2) return `Juda kichik: kutilgan ${n.origin} ${v}${n.minimum.toString()} ${$2.unit} ${$2.verb}`;
        return `Juda kichik: kutilgan ${n.origin} ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `Notogri satr: "${v.prefix}" bilan boshlanishi kerak`;
        if (v.format === "ends_with") return `Notogri satr: "${v.suffix}" bilan tugashi kerak`;
        if (v.format === "includes") return `Notogri satr: "${v.includes}" ni oz ichiga olishi kerak`;
        if (v.format === "regex") return `Notogri satr: ${v.pattern} shabloniga mos kelishi kerak`;
        return `Notogri ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Notogri raqam: ${n.divisor} ning karralisi bolishi kerak`;
      case "unrecognized_keys":
        return `Nomalum kalit${n.keys.length > 1 ? "lar" : ""}: ${_$1(n.keys, ", ")}`;
      case "invalid_key":
        return `${n.origin} dagi kalit notogri`;
      case "invalid_union":
        return "Notogri kirish";
      case "invalid_element":
        return `${n.origin} da notogri qiymat`;
      default:
        return "Notogri kirish";
    }
  };
};
function L$() {
  return { localeError: rc$1() };
}
var nc$1 = () => {
  let r2 = { string: { unit: "k t", verb: "c" }, file: { unit: "byte", verb: "c" }, array: { unit: "phn t", verb: "c" }, set: { unit: "phn t", verb: "c" } };
  function i(n) {
    return r2[n] ?? null;
  }
  let o = { regex: "u vo", email: "a ch email", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ngy gi ISO", date: "ngy ISO", time: "gi ISO", duration: "khong thi gian ISO", ipv4: "a ch IPv4", ipv6: "a ch IPv6", cidrv4: "di IPv4", cidrv6: "di IPv6", base64: "chui m ha base64", base64url: "chui m ha base64url", json_string: "chui JSON", e164: "s E.164", jwt: "JWT", template_literal: "u vo" }, t = { nan: "NaN", number: "s", array: "mng" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, $2 = D$2(n.input), u2 = t[$2] ?? $2;
        if (/^[A-Z]/.test(n.expected)) return `u vo khng hp l: mong i instanceof ${n.expected}, nhn c ${u2}`;
        return `u vo khng hp l: mong i ${v}, nhn c ${u2}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `u vo khng hp l: mong i ${U$1(n.values[0])}`;
        return `Ty chn khng hp l: mong i mt trong cc gi tr ${_$1(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", $2 = i(n.origin);
        if ($2) return `Qu ln: mong i ${n.origin ?? "gi tr"} ${$2.verb} ${v}${n.maximum.toString()} ${$2.unit ?? "phn t"}`;
        return `Qu ln: mong i ${n.origin ?? "gi tr"} ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", $2 = i(n.origin);
        if ($2) return `Qu nh: mong i ${n.origin} ${$2.verb} ${v}${n.minimum.toString()} ${$2.unit}`;
        return `Qu nh: mong i ${n.origin} ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `Chui khng hp l: phi bt u bng "${v.prefix}"`;
        if (v.format === "ends_with") return `Chui khng hp l: phi kt thc bng "${v.suffix}"`;
        if (v.format === "includes") return `Chui khng hp l: phi bao gm "${v.includes}"`;
        if (v.format === "regex") return `Chui khng hp l: phi khp vi mu ${v.pattern}`;
        return `${o[v.format] ?? n.format} khng hp l`;
      }
      case "not_multiple_of":
        return `S khng hp l: phi l bi s ca ${n.divisor}`;
      case "unrecognized_keys":
        return `Kha khng c nhn dng: ${_$1(n.keys, ", ")}`;
      case "invalid_key":
        return `Kha khng hp l trong ${n.origin}`;
      case "invalid_union":
        return "u vo khng hp l";
      case "invalid_element":
        return `Gi tr khng hp l trong ${n.origin}`;
      default:
        return "u vo khng hp l";
    }
  };
};
function E$() {
  return { localeError: nc$1() };
}
var ic$1 = () => {
  let r2 = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function i(n) {
    return r2[n] ?? null;
  }
  let o = { regex: "", email: "", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO", date: "ISO", time: "ISO", duration: "ISO", ipv4: "IPv4", ipv6: "IPv6", cidrv4: "IPv4", cidrv6: "IPv6", base64: "base64", base64url: "base64url", json_string: "JSON", e164: "E.164", jwt: "JWT", template_literal: "" }, t = { nan: "NaN", number: "", array: "", null: "(null)" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, $2 = D$2(n.input), u2 = t[$2] ?? $2;
        if (/^[A-Z]/.test(n.expected)) return ` instanceof ${n.expected} ${u2}`;
        return ` ${v} ${u2}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return ` ${U$1(n.values[0])}`;
        return ` ${_$1(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", $2 = i(n.origin);
        if ($2) return ` ${n.origin ?? ""} ${v}${n.maximum.toString()} ${$2.unit ?? ""}`;
        return ` ${n.origin ?? ""} ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", $2 = i(n.origin);
        if ($2) return ` ${n.origin} ${v}${n.minimum.toString()} ${$2.unit}`;
        return ` ${n.origin} ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return ` "${v.prefix}" `;
        if (v.format === "ends_with") return ` "${v.suffix}" `;
        if (v.format === "includes") return ` "${v.includes}"`;
        if (v.format === "regex") return ` ${v.pattern}`;
        return `${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return ` ${n.divisor} `;
      case "unrecognized_keys":
        return `(key): ${_$1(n.keys, ", ")}`;
      case "invalid_key":
        return `${n.origin} (key)`;
      case "invalid_union":
        return "";
      case "invalid_element":
        return `${n.origin} (value)`;
      default:
        return "";
    }
  };
};
function G$() {
  return { localeError: ic$1() };
}
var vc$1 = () => {
  let r2 = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function i(n) {
    return r2[n] ?? null;
  }
  let o = { regex: "", email: "", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO ", date: "ISO ", time: "ISO ", duration: "ISO ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64 ", base64url: "base64url ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "" }, t = { nan: "NaN" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, $2 = D$2(n.input), u2 = t[$2] ?? $2;
        if (/^[A-Z]/.test(n.expected)) return ` instanceof ${n.expected} ${u2}`;
        return ` ${v} ${u2}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return ` ${U$1(n.values[0])}`;
        return ` ${_$1(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", $2 = i(n.origin);
        if ($2) return ` ${n.origin ?? ""}  ${v}${n.maximum.toString()} ${$2.unit ?? ""}`;
        return ` ${n.origin ?? ""}  ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", $2 = i(n.origin);
        if ($2) return ` ${n.origin}  ${v}${n.minimum.toString()} ${$2.unit}`;
        return ` ${n.origin}  ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return ` "${v.prefix}" `;
        if (v.format === "ends_with") return ` "${v.suffix}" `;
        if (v.format === "includes") return ` "${v.includes}"`;
        if (v.format === "regex") return ` ${v.pattern}`;
        return ` ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return ` ${n.divisor} `;
      case "unrecognized_keys":
        return `${n.keys.length > 1 ? "" : ""}${_$1(n.keys, "")}`;
      case "invalid_key":
        return `${n.origin} `;
      case "invalid_union":
        return "";
      case "invalid_element":
        return `${n.origin} `;
      default:
        return "";
    }
  };
};
function W$() {
  return { localeError: vc$1() };
}
var oc$1 = () => {
  let r2 = { string: { unit: "mi", verb: "n" }, file: { unit: "bytes", verb: "n" }, array: { unit: "nkan", verb: "n" }, set: { unit: "nkan", verb: "n" } };
  function i(n) {
    return r2[n] ?? null;
  }
  let o = { regex: "r bwl", email: "drs ml", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "kk ISO", date: "j ISO", time: "kk ISO", duration: "kk t p ISO", ipv4: "drs IPv4", ipv6: "drs IPv6", cidrv4: "gbgb IPv4", cidrv6: "gbgb IPv6", base64: "r t a k n base64", base64url: "r base64url", json_string: "r JSON", e164: "nmb E.164", jwt: "JWT", template_literal: "r bwl" }, t = { nan: "NaN", number: "nmb", array: "akop" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, $2 = D$2(n.input), u2 = t[$2] ?? $2;
        if (/^[A-Z]/.test(n.expected)) return `bwl ae: a n lti fi instanceof ${n.expected}, m a r ${u2}`;
        return `bwl ae: a n lti fi ${v}, m a r ${u2}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `bwl ae: a n lti fi ${U$1(n.values[0])}`;
        return `yn ae: yan kan lra ${_$1(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", $2 = i(n.origin);
        if ($2) return `T p j: a n lti j p ${n.origin ?? "iye"} ${$2.verb} ${v}${n.maximum} ${$2.unit}`;
        return `T p j: a n lti j ${v}${n.maximum}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", $2 = i(n.origin);
        if ($2) return `Kr ju: a n lti j p ${n.origin} ${$2.verb} ${v}${n.minimum} ${$2.unit}`;
        return `Kr ju: a n lti j ${v}${n.minimum}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `r ae: gbd br pl "${v.prefix}"`;
        if (v.format === "ends_with") return `r ae: gbd par pl "${v.suffix}"`;
        if (v.format === "includes") return `r ae: gbd n "${v.includes}"`;
        if (v.format === "regex") return `r ae: gbd b pr mu ${v.pattern}`;
        return `Ae: ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Nmb ae: gbd j y ppn ti ${n.divisor}`;
      case "unrecognized_keys":
        return `Btn m: ${_$1(n.keys, ", ")}`;
      case "invalid_key":
        return `Btn ae nn ${n.origin}`;
      case "invalid_union":
        return "bwl ae";
      case "invalid_element":
        return `Iye ae nn ${n.origin}`;
      default:
        return "bwl ae";
    }
  };
};
function X$() {
  return { localeError: oc$1() };
}
var cl$1, A$ = /* @__PURE__ */ Symbol("ZodOutput"), V$ = /* @__PURE__ */ Symbol("ZodInput");
class K$ {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map();
  }
  add(r2, ...i) {
    let o = i[0];
    if (this._map.set(r2, o), o && typeof o === "object" && "id" in o) this._idmap.set(o.id, r2);
    return this;
  }
  clear() {
    return this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map(), this;
  }
  remove(r2) {
    let i = this._map.get(r2);
    if (i && typeof i === "object" && "id" in i) this._idmap.delete(i.id);
    return this._map.delete(r2), this;
  }
  get(r2) {
    let i = r2._zod.parent;
    if (i) {
      let o = { ...this.get(i) ?? {} };
      delete o.id;
      let t = { ...o, ...this._map.get(r2) };
      return Object.keys(t).length ? t : void 0;
    }
    return this._map.get(r2);
  }
  has(r2) {
    return this._map.has(r2);
  }
}
function gi$1() {
  return new K$();
}
(cl$1 = globalThis).__zod_globalRegistry ?? (cl$1.__zod_globalRegistry = gi$1());
var V = globalThis.__zod_globalRegistry;
function Y$(r2, i) {
  return new r2({ type: "string", ...w$1(i) });
}
function Q$(r2, i) {
  return new r2({ type: "string", coerce: true, ...w$1(i) });
}
function ei$1(r2, i) {
  return new r2({ type: "string", format: "email", check: "string_format", abort: false, ...w$1(i) });
}
function zn$1(r2, i) {
  return new r2({ type: "string", format: "guid", check: "string_format", abort: false, ...w$1(i) });
}
function li$1(r2, i) {
  return new r2({ type: "string", format: "uuid", check: "string_format", abort: false, ...w$1(i) });
}
function Ii$1(r2, i) {
  return new r2({ type: "string", format: "uuid", check: "string_format", abort: false, version: "v4", ...w$1(i) });
}
function ci$1(r2, i) {
  return new r2({ type: "string", format: "uuid", check: "string_format", abort: false, version: "v6", ...w$1(i) });
}
function _i$1(r2, i) {
  return new r2({ type: "string", format: "uuid", check: "string_format", abort: false, version: "v7", ...w$1(i) });
}
function Pn$1(r2, i) {
  return new r2({ type: "string", format: "url", check: "string_format", abort: false, ...w$1(i) });
}
function bi$1(r2, i) {
  return new r2({ type: "string", format: "emoji", check: "string_format", abort: false, ...w$1(i) });
}
function Ui$1(r2, i) {
  return new r2({ type: "string", format: "nanoid", check: "string_format", abort: false, ...w$1(i) });
}
function Di$1(r2, i) {
  return new r2({ type: "string", format: "cuid", check: "string_format", abort: false, ...w$1(i) });
}
function ki$1(r2, i) {
  return new r2({ type: "string", format: "cuid2", check: "string_format", abort: false, ...w$1(i) });
}
function wi$1(r2, i) {
  return new r2({ type: "string", format: "ulid", check: "string_format", abort: false, ...w$1(i) });
}
function Ni$1(r2, i) {
  return new r2({ type: "string", format: "xid", check: "string_format", abort: false, ...w$1(i) });
}
function Oi$1(r2, i) {
  return new r2({ type: "string", format: "ksuid", check: "string_format", abort: false, ...w$1(i) });
}
function Si$1(r2, i) {
  return new r2({ type: "string", format: "ipv4", check: "string_format", abort: false, ...w$1(i) });
}
function zi$1(r2, i) {
  return new r2({ type: "string", format: "ipv6", check: "string_format", abort: false, ...w$1(i) });
}
function T$(r2, i) {
  return new r2({ type: "string", format: "mac", check: "string_format", abort: false, ...w$1(i) });
}
function Pi$1(r2, i) {
  return new r2({ type: "string", format: "cidrv4", check: "string_format", abort: false, ...w$1(i) });
}
function ji$1(r2, i) {
  return new r2({ type: "string", format: "cidrv6", check: "string_format", abort: false, ...w$1(i) });
}
function Ji$1(r2, i) {
  return new r2({ type: "string", format: "base64", check: "string_format", abort: false, ...w$1(i) });
}
function Li$1(r2, i) {
  return new r2({ type: "string", format: "base64url", check: "string_format", abort: false, ...w$1(i) });
}
function Ei$1(r2, i) {
  return new r2({ type: "string", format: "e164", check: "string_format", abort: false, ...w$1(i) });
}
function Gi$1(r2, i) {
  return new r2({ type: "string", format: "jwt", check: "string_format", abort: false, ...w$1(i) });
}
var F$ = { Any: null, Minute: -1, Second: 0, Millisecond: 3, Microsecond: 6 };
function q$(r2, i) {
  return new r2({ type: "string", format: "datetime", check: "string_format", offset: false, local: false, precision: null, ...w$1(i) });
}
function B$(r2, i) {
  return new r2({ type: "string", format: "date", check: "string_format", ...w$1(i) });
}
function H$(r2, i) {
  return new r2({ type: "string", format: "time", check: "string_format", precision: null, ...w$1(i) });
}
function M$(r2, i) {
  return new r2({ type: "string", format: "duration", check: "string_format", ...w$1(i) });
}
function m$(r2, i) {
  return new r2({ type: "number", checks: [], ...w$1(i) });
}
function R$(r2, i) {
  return new r2({ type: "number", coerce: true, checks: [], ...w$1(i) });
}
function x$(r2, i) {
  return new r2({ type: "number", check: "number_format", abort: false, format: "safeint", ...w$1(i) });
}
function Z$(r2, i) {
  return new r2({ type: "number", check: "number_format", abort: false, format: "float32", ...w$1(i) });
}
function d$(r2, i) {
  return new r2({ type: "number", check: "number_format", abort: false, format: "float64", ...w$1(i) });
}
function C$(r2, i) {
  return new r2({ type: "number", check: "number_format", abort: false, format: "int32", ...w$1(i) });
}
function f$(r2, i) {
  return new r2({ type: "number", check: "number_format", abort: false, format: "uint32", ...w$1(i) });
}
function y$(r2, i) {
  return new r2({ type: "boolean", ...w$1(i) });
}
function h$(r2, i) {
  return new r2({ type: "boolean", coerce: true, ...w$1(i) });
}
function a$(r2, i) {
  return new r2({ type: "bigint", ...w$1(i) });
}
function p$(r2, i) {
  return new r2({ type: "bigint", coerce: true, ...w$1(i) });
}
function s$(r2, i) {
  return new r2({ type: "bigint", check: "bigint_format", abort: false, format: "int64", ...w$1(i) });
}
function ru$1(r2, i) {
  return new r2({ type: "bigint", check: "bigint_format", abort: false, format: "uint64", ...w$1(i) });
}
function nu$1(r2, i) {
  return new r2({ type: "symbol", ...w$1(i) });
}
function iu$1(r2, i) {
  return new r2({ type: "undefined", ...w$1(i) });
}
function vu$1(r2, i) {
  return new r2({ type: "null", ...w$1(i) });
}
function ou$1(r2) {
  return new r2({ type: "any" });
}
function tu$1(r2) {
  return new r2({ type: "unknown" });
}
function $u$1(r2, i) {
  return new r2({ type: "never", ...w$1(i) });
}
function uu$1(r2, i) {
  return new r2({ type: "void", ...w$1(i) });
}
function gu$1(r2, i) {
  return new r2({ type: "date", ...w$1(i) });
}
function eu$1(r2, i) {
  return new r2({ type: "date", coerce: true, ...w$1(i) });
}
function lu$1(r2, i) {
  return new r2({ type: "nan", ...w$1(i) });
}
function y$1(r2, i) {
  return new hn$1({ check: "less_than", ...w$1(i), value: r2, inclusive: false });
}
function m$2(r2, i) {
  return new hn$1({ check: "less_than", ...w$1(i), value: r2, inclusive: true });
}
function h$1(r2, i) {
  return new an$1({ check: "greater_than", ...w$1(i), value: r2, inclusive: false });
}
function Q(r2, i) {
  return new an$1({ check: "greater_than", ...w$1(i), value: r2, inclusive: true });
}
function Wi$1(r2) {
  return h$1(0, r2);
}
function Xi$1(r2) {
  return y$1(0, r2);
}
function Ai$1(r2) {
  return m$2(0, r2);
}
function Vi$1(r2) {
  return Q(0, r2);
}
function ur(r2, i) {
  return new eo$1({ check: "multiple_of", ...w$1(i), value: r2 });
}
function gr$1(r2, i) {
  return new co({ check: "max_size", ...w$1(i), maximum: r2 });
}
function a(r2, i) {
  return new _o$1({ check: "min_size", ...w$1(i), minimum: r2 });
}
function Dr$1(r2, i) {
  return new bo$1({ check: "size_equals", ...w$1(i), size: r2 });
}
function kr$1(r2, i) {
  return new Uo$1({ check: "max_length", ...w$1(i), maximum: r2 });
}
function nr(r2, i) {
  return new Do$1({ check: "min_length", ...w$1(i), minimum: r2 });
}
function wr$1(r2, i) {
  return new ko$1({ check: "length_equals", ...w$1(i), length: r2 });
}
function Vr$1(r2, i) {
  return new wo$1({ check: "string_format", format: "regex", ...w$1(i), pattern: r2 });
}
function Kr$1(r2) {
  return new No$1({ check: "string_format", format: "lowercase", ...w$1(r2) });
}
function Yr$1(r2) {
  return new Oo$1({ check: "string_format", format: "uppercase", ...w$1(r2) });
}
function Qr$1(r2, i) {
  return new So$1({ check: "string_format", format: "includes", ...w$1(i), includes: r2 });
}
function Tr$1(r2, i) {
  return new zo$1({ check: "string_format", format: "starts_with", ...w$1(i), prefix: r2 });
}
function Fr$1(r2, i) {
  return new Po$1({ check: "string_format", format: "ends_with", ...w$1(i), suffix: r2 });
}
function Ki$1(r2, i, o) {
  return new jo$1({ check: "property", property: r2, schema: i, ...w$1(o) });
}
function qr$1(r2, i) {
  return new Jo$1({ check: "mime_type", mime: r2, ...w$1(i) });
}
function d(r2) {
  return new Lo$1({ check: "overwrite", tx: r2 });
}
function Br$1(r2) {
  return d((i) => i.normalize(r2));
}
function Hr$1() {
  return d((r2) => r2.trim());
}
function Mr$1() {
  return d((r2) => r2.toLowerCase());
}
function mr$1() {
  return d((r2) => r2.toUpperCase());
}
function Rr$1() {
  return d((r2) => jv$1(r2));
}
function Iu$1(r2, i, o) {
  return new r2({ type: "array", element: i, ...w$1(o) });
}
function $c$1(r2, i, o) {
  return new r2({ type: "union", options: i, ...w$1(o) });
}
function uc$1(r2, i, o) {
  return new r2({ type: "union", options: i, inclusive: false, ...w$1(o) });
}
function gc$1(r2, i, o, t) {
  return new r2({ type: "union", options: o, discriminator: i, ...w$1(t) });
}
function ec$1(r2, i, o) {
  return new r2({ type: "intersection", left: i, right: o });
}
function lc$1(r2, i, o, t) {
  let n = o instanceof z$1;
  return new r2({ type: "tuple", items: i, rest: n ? o : null, ...w$1(n ? t : o) });
}
function Ic$1(r2, i, o, t) {
  return new r2({ type: "record", keyType: i, valueType: o, ...w$1(t) });
}
function cc$1(r2, i, o, t) {
  return new r2({ type: "map", keyType: i, valueType: o, ...w$1(t) });
}
function _c$1(r2, i, o) {
  return new r2({ type: "set", valueType: i, ...w$1(o) });
}
function bc$1(r2, i, o) {
  let t = Array.isArray(i) ? Object.fromEntries(i.map((n) => [n, n])) : i;
  return new r2({ type: "enum", entries: t, ...w$1(o) });
}
function Uc$1(r2, i, o) {
  return new r2({ type: "enum", entries: i, ...w$1(o) });
}
function Dc$1(r2, i, o) {
  return new r2({ type: "literal", values: Array.isArray(i) ? i : [i], ...w$1(o) });
}
function cu$1(r2, i) {
  return new r2({ type: "file", ...w$1(i) });
}
function kc$1(r2, i) {
  return new r2({ type: "transform", transform: i });
}
function wc$1(r2, i) {
  return new r2({ type: "optional", innerType: i });
}
function Nc$1(r2, i) {
  return new r2({ type: "nullable", innerType: i });
}
function Oc$1(r2, i, o) {
  return new r2({ type: "default", innerType: i, get defaultValue() {
    return typeof o === "function" ? o() : Lv$1(o);
  } });
}
function Sc$1(r2, i, o) {
  return new r2({ type: "nonoptional", innerType: i, ...w$1(o) });
}
function zc$1(r2, i) {
  return new r2({ type: "success", innerType: i });
}
function Pc$1(r2, i, o) {
  return new r2({ type: "catch", innerType: i, catchValue: typeof o === "function" ? o : () => o });
}
function jc$1(r2, i, o) {
  return new r2({ type: "pipe", in: i, out: o });
}
function Jc$1(r2, i) {
  return new r2({ type: "readonly", innerType: i });
}
function Lc$1(r2, i, o) {
  return new r2({ type: "template_literal", parts: i, ...w$1(o) });
}
function Ec$1(r2, i) {
  return new r2({ type: "lazy", getter: i });
}
function Gc$1(r2, i) {
  return new r2({ type: "promise", innerType: i });
}
function _u$1(r2, i, o) {
  let t = w$1(o);
  return t.abort ?? (t.abort = true), new r2({ type: "custom", check: "custom", fn: i, ...t });
}
function bu$1(r2, i, o) {
  return new r2({ type: "custom", check: "custom", fn: i, ...w$1(o) });
}
function Uu$1(r2) {
  let i = _l$1((o) => {
    return o.addIssue = (t) => {
      if (typeof t === "string") o.issues.push(Jr$1(t, o.value, i._zod.def));
      else {
        let n = t;
        if (n.fatal) n.continue = false;
        n.code ?? (n.code = "custom"), n.input ?? (n.input = o.value), n.inst ?? (n.inst = i), n.continue ?? (n.continue = !i._zod.def.abort), o.issues.push(Jr$1(n));
      }
    }, r2(o.value, o);
  });
  return i;
}
function _l$1(r2, i) {
  let o = new W$1({ check: "custom", ...w$1(i) });
  return o._zod.check = r2, o;
}
function Du$1(r2) {
  let i = new W$1({ check: "describe" });
  return i._zod.onattach = [(o) => {
    let t = V.get(o) ?? {};
    V.add(o, { ...t, description: r2 });
  }], i._zod.check = () => {
  }, i;
}
function ku$1(r2) {
  let i = new W$1({ check: "meta" });
  return i._zod.onattach = [(o) => {
    let t = V.get(o) ?? {};
    V.add(o, { ...t, ...r2 });
  }], i._zod.check = () => {
  }, i;
}
function wu$1(r2, i) {
  let o = w$1(i), t = o.truthy ?? ["true", "1", "yes", "on", "y", "enabled"], n = o.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (o.case !== "sensitive") t = t.map((O) => typeof O === "string" ? O.toLowerCase() : O), n = n.map((O) => typeof O === "string" ? O.toLowerCase() : O);
  let v = new Set(t), $2 = new Set(n), u2 = r2.Codec ?? Dn$1, l = r2.Boolean ?? bn$1, c = new (r2.String ?? Ur$1)({ type: "string", error: o.error }), b = new l({ type: "boolean", error: o.error }), N2 = new u2({ type: "pipe", in: c, out: b, transform: (O, J2) => {
    let X2 = O;
    if (o.case !== "sensitive") X2 = X2.toLowerCase();
    if (v.has(X2)) return true;
    else if ($2.has(X2)) return false;
    else return J2.issues.push({ code: "invalid_value", expected: "stringbool", values: [...v, ...$2], input: J2.value, inst: N2, continue: false }), {};
  }, reverseTransform: (O, J2) => {
    if (O === true) return t[0] || "true";
    else return n[0] || "false";
  }, error: o.error });
  return N2;
}
function xr$1(r2, i, o, t = {}) {
  let n = w$1(t), v = { ...w$1(t), check: "string_format", type: "string", format: i, fn: typeof o === "function" ? o : (u2) => o.test(u2), ...n };
  if (o instanceof RegExp) v.pattern = o;
  return new r2(v);
}
function er(r2) {
  let i = r2?.target ?? "draft-2020-12";
  if (i === "draft-4") i = "draft-04";
  if (i === "draft-7") i = "draft-07";
  return { processors: r2.processors ?? {}, metadataRegistry: r2?.metadata ?? V, target: i, unrepresentable: r2?.unrepresentable ?? "throw", override: r2?.override ?? (() => {
  }), io: r2?.io ?? "output", counter: 0, seen: /* @__PURE__ */ new Map(), cycles: r2?.cycles ?? "ref", reused: r2?.reused ?? "inline", external: r2?.external ?? void 0 };
}
function L$1(r2, i, o = { path: [], schemaPath: [] }) {
  var t;
  let n = r2._zod.def, v = i.seen.get(r2);
  if (v) {
    if (v.count++, o.schemaPath.includes(r2)) v.cycle = o.path;
    return v.schema;
  }
  let $2 = { schema: {}, count: 1, cycle: void 0, path: o.path };
  i.seen.set(r2, $2);
  let u2 = r2._zod.toJSONSchema?.();
  if (u2) $2.schema = u2;
  else {
    let c = { ...o, schemaPath: [...o.schemaPath, r2], path: o.path };
    if (r2._zod.processJSONSchema) r2._zod.processJSONSchema(i, $2.schema, c);
    else {
      let N2 = $2.schema, O = i.processors[n.type];
      if (!O) throw Error(`[toJSONSchema]: Non-representable type encountered: ${n.type}`);
      O(r2, i, N2, c);
    }
    let b = r2._zod.parent;
    if (b) {
      if (!$2.ref) $2.ref = b;
      L$1(b, i, c), i.seen.get(b).isParent = true;
    }
  }
  let l = i.metadataRegistry.get(r2);
  if (l) Object.assign($2.schema, l);
  if (i.io === "input" && T$2(r2)) delete $2.schema.examples, delete $2.schema.default;
  if (i.io === "input" && $2.schema._prefault) (t = $2.schema).default ?? (t.default = $2.schema._prefault);
  return delete $2.schema._prefault, i.seen.get(r2).schema;
}
function lr(r2, i) {
  let o = r2.seen.get(i);
  if (!o) throw Error("Unprocessed schema. This is a bug in Zod.");
  let t = /* @__PURE__ */ new Map();
  for (let $2 of r2.seen.entries()) {
    let u2 = r2.metadataRegistry.get($2[0])?.id;
    if (u2) {
      let l = t.get(u2);
      if (l && l !== $2[0]) throw Error(`Duplicate schema id "${u2}" detected during JSON Schema conversion. Two different schemas cannot share the same id when converted together.`);
      t.set(u2, $2[0]);
    }
  }
  let n = ($2) => {
    let u2 = r2.target === "draft-2020-12" ? "$defs" : "definitions";
    if (r2.external) {
      let b = r2.external.registry.get($2[0])?.id, N2 = r2.external.uri ?? ((J2) => J2);
      if (b) return { ref: N2(b) };
      let O = $2[1].defId ?? $2[1].schema.id ?? `schema${r2.counter++}`;
      return $2[1].defId = O, { defId: O, ref: `${N2("__shared")}#/${u2}/${O}` };
    }
    if ($2[1] === o) return { ref: "#" };
    let e = `${"#"}/${u2}/`, c = $2[1].schema.id ?? `__schema${r2.counter++}`;
    return { defId: c, ref: e + c };
  }, v = ($2) => {
    if ($2[1].schema.$ref) return;
    let u2 = $2[1], { ref: l, defId: e } = n($2);
    if (u2.def = { ...u2.schema }, e) u2.defId = e;
    let c = u2.schema;
    for (let b in c) delete c[b];
    c.$ref = l;
  };
  if (r2.cycles === "throw") for (let $2 of r2.seen.entries()) {
    let u2 = $2[1];
    if (u2.cycle) throw Error(`Cycle detected: #/${u2.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
  }
  for (let $2 of r2.seen.entries()) {
    let u2 = $2[1];
    if (i === $2[0]) {
      v($2);
      continue;
    }
    if (r2.external) {
      let e = r2.external.registry.get($2[0])?.id;
      if (i !== $2[0] && e) {
        v($2);
        continue;
      }
    }
    if (r2.metadataRegistry.get($2[0])?.id) {
      v($2);
      continue;
    }
    if (u2.cycle) {
      v($2);
      continue;
    }
    if (u2.count > 1) {
      if (r2.reused === "ref") {
        v($2);
        continue;
      }
    }
  }
}
function Ir$1(r2, i) {
  let o = r2.seen.get(i);
  if (!o) throw Error("Unprocessed schema. This is a bug in Zod.");
  let t = ($2) => {
    let u2 = r2.seen.get($2);
    if (u2.ref === null) return;
    let l = u2.def ?? u2.schema, e = { ...l }, c = u2.ref;
    if (u2.ref = null, c) {
      t(c);
      let N2 = r2.seen.get(c), O = N2.schema;
      if (O.$ref && (r2.target === "draft-07" || r2.target === "draft-04" || r2.target === "openapi-3.0")) l.allOf = l.allOf ?? [], l.allOf.push(O);
      else Object.assign(l, O);
      if (Object.assign(l, e), $2._zod.parent === c) for (let X2 in l) {
        if (X2 === "$ref" || X2 === "allOf") continue;
        if (!(X2 in e)) delete l[X2];
      }
      if (O.$ref) for (let X2 in l) {
        if (X2 === "$ref" || X2 === "allOf") continue;
        if (X2 in N2.def && JSON.stringify(l[X2]) === JSON.stringify(N2.def[X2])) delete l[X2];
      }
    }
    let b = $2._zod.parent;
    if (b && b !== c) {
      t(b);
      let N2 = r2.seen.get(b);
      if (N2?.schema.$ref) {
        if (l.$ref = N2.schema.$ref, N2.def) for (let O in l) {
          if (O === "$ref" || O === "allOf") continue;
          if (O in N2.def && JSON.stringify(l[O]) === JSON.stringify(N2.def[O])) delete l[O];
        }
      }
    }
    r2.override({ zodSchema: $2, jsonSchema: l, path: u2.path ?? [] });
  };
  for (let $2 of [...r2.seen.entries()].reverse()) t($2[0]);
  let n = {};
  if (r2.target === "draft-2020-12") n.$schema = "https://json-schema.org/draft/2020-12/schema";
  else if (r2.target === "draft-07") n.$schema = "http://json-schema.org/draft-07/schema#";
  else if (r2.target === "draft-04") n.$schema = "http://json-schema.org/draft-04/schema#";
  else if (r2.target === "openapi-3.0") ;
  if (r2.external?.uri) {
    let $2 = r2.external.registry.get(i)?.id;
    if (!$2) throw Error("Schema is missing an `id` property");
    n.$id = r2.external.uri($2);
  }
  Object.assign(n, o.def ?? o.schema);
  let v = r2.external?.defs ?? {};
  for (let $2 of r2.seen.entries()) {
    let u2 = $2[1];
    if (u2.def && u2.defId) v[u2.defId] = u2.def;
  }
  if (r2.external) ;
  else if (Object.keys(v).length > 0) if (r2.target === "draft-2020-12") n.$defs = v;
  else n.definitions = v;
  try {
    let $2 = JSON.parse(JSON.stringify(n));
    return Object.defineProperty($2, "~standard", { value: { ...i["~standard"], jsonSchema: { input: Zr$1(i, "input", r2.processors), output: Zr$1(i, "output", r2.processors) } }, enumerable: false, writable: false }), $2;
  } catch ($2) {
    throw Error("Error converting schema to JSON.");
  }
}
function T$2(r2, i) {
  let o = i ?? { seen: /* @__PURE__ */ new Set() };
  if (o.seen.has(r2)) return false;
  o.seen.add(r2);
  let t = r2._zod.def;
  if (t.type === "transform") return true;
  if (t.type === "array") return T$2(t.element, o);
  if (t.type === "set") return T$2(t.valueType, o);
  if (t.type === "lazy") return T$2(t.getter(), o);
  if (t.type === "promise" || t.type === "optional" || t.type === "nonoptional" || t.type === "nullable" || t.type === "readonly" || t.type === "default" || t.type === "prefault") return T$2(t.innerType, o);
  if (t.type === "intersection") return T$2(t.left, o) || T$2(t.right, o);
  if (t.type === "record" || t.type === "map") return T$2(t.keyType, o) || T$2(t.valueType, o);
  if (t.type === "pipe") return T$2(t.in, o) || T$2(t.out, o);
  if (t.type === "object") {
    for (let n in t.shape) if (T$2(t.shape[n], o)) return true;
    return false;
  }
  if (t.type === "union") {
    for (let n of t.options) if (T$2(n, o)) return true;
    return false;
  }
  if (t.type === "tuple") {
    for (let n of t.items) if (T$2(n, o)) return true;
    if (t.rest && T$2(t.rest, o)) return true;
    return false;
  }
  return false;
}
var Nu$1 = (r2, i = {}) => (o) => {
  let t = er({ ...o, processors: i });
  return L$1(r2, t), lr(t, r2), Ir$1(t, r2);
}, Zr$1 = (r2, i, o = {}) => (t) => {
  let { libraryOptions: n, target: v } = t ?? {}, $2 = er({ ...n ?? {}, target: v, io: i, processors: o });
  return L$1(r2, $2), lr($2, r2), Ir$1($2, r2);
};
var Wc$1 = { guid: "uuid", url: "uri", datetime: "date-time", json_string: "json-string", regex: "" }, Ou$1 = (r2, i, o, t) => {
  let n = o;
  n.type = "string";
  let { minimum: v, maximum: $2, format: u2, patterns: l, contentEncoding: e } = r2._zod.bag;
  if (typeof v === "number") n.minLength = v;
  if (typeof $2 === "number") n.maxLength = $2;
  if (u2) {
    if (n.format = Wc$1[u2] ?? u2, n.format === "") delete n.format;
    if (u2 === "time") delete n.format;
  }
  if (e) n.contentEncoding = e;
  if (l && l.size > 0) {
    let c = [...l];
    if (c.length === 1) n.pattern = c[0].source;
    else if (c.length > 1) n.allOf = [...c.map((b) => ({ ...i.target === "draft-07" || i.target === "draft-04" || i.target === "openapi-3.0" ? { type: "string" } : {}, pattern: b.source }))];
  }
}, Su$1 = (r2, i, o, t) => {
  let n = o, { minimum: v, maximum: $2, format: u2, multipleOf: l, exclusiveMaximum: e, exclusiveMinimum: c } = r2._zod.bag;
  if (typeof u2 === "string" && u2.includes("int")) n.type = "integer";
  else n.type = "number";
  if (typeof c === "number") if (i.target === "draft-04" || i.target === "openapi-3.0") n.minimum = c, n.exclusiveMinimum = true;
  else n.exclusiveMinimum = c;
  if (typeof v === "number") {
    if (n.minimum = v, typeof c === "number" && i.target !== "draft-04") if (c >= v) delete n.minimum;
    else delete n.exclusiveMinimum;
  }
  if (typeof e === "number") if (i.target === "draft-04" || i.target === "openapi-3.0") n.maximum = e, n.exclusiveMaximum = true;
  else n.exclusiveMaximum = e;
  if (typeof $2 === "number") {
    if (n.maximum = $2, typeof e === "number" && i.target !== "draft-04") if (e <= $2) delete n.maximum;
    else delete n.exclusiveMaximum;
  }
  if (typeof l === "number") n.multipleOf = l;
}, zu$1 = (r2, i, o, t) => {
  o.type = "boolean";
}, Pu$1 = (r2, i, o, t) => {
  if (i.unrepresentable === "throw") throw Error("BigInt cannot be represented in JSON Schema");
}, ju$1 = (r2, i, o, t) => {
  if (i.unrepresentable === "throw") throw Error("Symbols cannot be represented in JSON Schema");
}, Ju$1 = (r2, i, o, t) => {
  if (i.target === "openapi-3.0") o.type = "string", o.nullable = true, o.enum = [null];
  else o.type = "null";
}, Lu$1 = (r2, i, o, t) => {
  if (i.unrepresentable === "throw") throw Error("Undefined cannot be represented in JSON Schema");
}, Eu$1 = (r2, i, o, t) => {
  if (i.unrepresentable === "throw") throw Error("Void cannot be represented in JSON Schema");
}, Gu$1 = (r2, i, o, t) => {
  o.not = {};
}, Wu$1 = (r2, i, o, t) => {
}, Xu$1 = (r2, i, o, t) => {
}, Au$1 = (r2, i, o, t) => {
  if (i.unrepresentable === "throw") throw Error("Date cannot be represented in JSON Schema");
}, Vu$1 = (r2, i, o, t) => {
  let n = r2._zod.def, v = vn$1(n.entries);
  if (v.every(($2) => typeof $2 === "number")) o.type = "number";
  if (v.every(($2) => typeof $2 === "string")) o.type = "string";
  o.enum = v;
}, Ku$1 = (r2, i, o, t) => {
  let n = r2._zod.def, v = [];
  for (let $2 of n.values) if ($2 === void 0) {
    if (i.unrepresentable === "throw") throw Error("Literal `undefined` cannot be represented in JSON Schema");
  } else if (typeof $2 === "bigint") if (i.unrepresentable === "throw") throw Error("BigInt literals cannot be represented in JSON Schema");
  else v.push(Number($2));
  else v.push($2);
  if (v.length === 0) ;
  else if (v.length === 1) {
    let $2 = v[0];
    if (o.type = $2 === null ? "null" : typeof $2, i.target === "draft-04" || i.target === "openapi-3.0") o.enum = [$2];
    else o.const = $2;
  } else {
    if (v.every(($2) => typeof $2 === "number")) o.type = "number";
    if (v.every(($2) => typeof $2 === "string")) o.type = "string";
    if (v.every(($2) => typeof $2 === "boolean")) o.type = "boolean";
    if (v.every(($2) => $2 === null)) o.type = "null";
    o.enum = v;
  }
}, Yu$1 = (r2, i, o, t) => {
  if (i.unrepresentable === "throw") throw Error("NaN cannot be represented in JSON Schema");
}, Qu$1 = (r2, i, o, t) => {
  let n = o, v = r2._zod.pattern;
  if (!v) throw Error("Pattern not found in template literal");
  n.type = "string", n.pattern = v.source;
}, Tu$1 = (r2, i, o, t) => {
  let n = o, v = { type: "string", format: "binary", contentEncoding: "binary" }, { minimum: $2, maximum: u2, mime: l } = r2._zod.bag;
  if ($2 !== void 0) v.minLength = $2;
  if (u2 !== void 0) v.maxLength = u2;
  if (l) if (l.length === 1) v.contentMediaType = l[0], Object.assign(n, v);
  else Object.assign(n, v), n.anyOf = l.map((e) => ({ contentMediaType: e }));
  else Object.assign(n, v);
}, Fu$1 = (r2, i, o, t) => {
  o.type = "boolean";
}, qu$1 = (r2, i, o, t) => {
  if (i.unrepresentable === "throw") throw Error("Custom types cannot be represented in JSON Schema");
}, Bu$1 = (r2, i, o, t) => {
  if (i.unrepresentable === "throw") throw Error("Function types cannot be represented in JSON Schema");
}, Hu$1 = (r2, i, o, t) => {
  if (i.unrepresentable === "throw") throw Error("Transforms cannot be represented in JSON Schema");
}, Mu$1 = (r2, i, o, t) => {
  if (i.unrepresentable === "throw") throw Error("Map cannot be represented in JSON Schema");
}, mu$1 = (r2, i, o, t) => {
  if (i.unrepresentable === "throw") throw Error("Set cannot be represented in JSON Schema");
}, Ru$1 = (r2, i, o, t) => {
  let n = o, v = r2._zod.def, { minimum: $2, maximum: u2 } = r2._zod.bag;
  if (typeof $2 === "number") n.minItems = $2;
  if (typeof u2 === "number") n.maxItems = u2;
  n.type = "array", n.items = L$1(v.element, i, { ...t, path: [...t.path, "items"] });
}, xu$1 = (r2, i, o, t) => {
  let n = o, v = r2._zod.def;
  n.type = "object", n.properties = {};
  let $2 = v.shape;
  for (let e in $2) n.properties[e] = L$1($2[e], i, { ...t, path: [...t.path, "properties", e] });
  let u2 = new Set(Object.keys($2)), l = new Set([...u2].filter((e) => {
    let c = v.shape[e]._zod;
    if (i.io === "input") return c.optin === void 0;
    else return c.optout === void 0;
  }));
  if (l.size > 0) n.required = Array.from(l);
  if (v.catchall?._zod.def.type === "never") n.additionalProperties = false;
  else if (!v.catchall) {
    if (i.io === "output") n.additionalProperties = false;
  } else if (v.catchall) n.additionalProperties = L$1(v.catchall, i, { ...t, path: [...t.path, "additionalProperties"] });
}, Qi$1 = (r2, i, o, t) => {
  let n = r2._zod.def, v = n.inclusive === false, $2 = n.options.map((u2, l) => L$1(u2, i, { ...t, path: [...t.path, v ? "oneOf" : "anyOf", l] }));
  if (v) o.oneOf = $2;
  else o.anyOf = $2;
}, Zu$1 = (r2, i, o, t) => {
  let n = r2._zod.def, v = L$1(n.left, i, { ...t, path: [...t.path, "allOf", 0] }), $2 = L$1(n.right, i, { ...t, path: [...t.path, "allOf", 1] }), u2 = (e) => "allOf" in e && Object.keys(e).length === 1, l = [...u2(v) ? v.allOf : [v], ...u2($2) ? $2.allOf : [$2]];
  o.allOf = l;
}, du$1 = (r2, i, o, t) => {
  let n = o, v = r2._zod.def;
  n.type = "array";
  let $2 = i.target === "draft-2020-12" ? "prefixItems" : "items", u2 = i.target === "draft-2020-12" ? "items" : i.target === "openapi-3.0" ? "items" : "additionalItems", l = v.items.map((N2, O) => L$1(N2, i, { ...t, path: [...t.path, $2, O] })), e = v.rest ? L$1(v.rest, i, { ...t, path: [...t.path, u2, ...i.target === "openapi-3.0" ? [v.items.length] : []] }) : null;
  if (i.target === "draft-2020-12") {
    if (n.prefixItems = l, e) n.items = e;
  } else if (i.target === "openapi-3.0") {
    if (n.items = { anyOf: l }, e) n.items.anyOf.push(e);
    if (n.minItems = l.length, !e) n.maxItems = l.length;
  } else if (n.items = l, e) n.additionalItems = e;
  let { minimum: c, maximum: b } = r2._zod.bag;
  if (typeof c === "number") n.minItems = c;
  if (typeof b === "number") n.maxItems = b;
}, Cu$1 = (r2, i, o, t) => {
  let n = o, v = r2._zod.def;
  n.type = "object";
  let $2 = v.keyType, l = $2._zod.bag?.patterns;
  if (v.mode === "loose" && l && l.size > 0) {
    let c = L$1(v.valueType, i, { ...t, path: [...t.path, "patternProperties", "*"] });
    n.patternProperties = {};
    for (let b of l) n.patternProperties[b.source] = c;
  } else {
    if (i.target === "draft-07" || i.target === "draft-2020-12") n.propertyNames = L$1(v.keyType, i, { ...t, path: [...t.path, "propertyNames"] });
    n.additionalProperties = L$1(v.valueType, i, { ...t, path: [...t.path, "additionalProperties"] });
  }
  let e = $2._zod.values;
  if (e) {
    let c = [...e].filter((b) => typeof b === "string" || typeof b === "number");
    if (c.length > 0) n.required = c;
  }
}, fu$1 = (r2, i, o, t) => {
  let n = r2._zod.def, v = L$1(n.innerType, i, t), $2 = i.seen.get(r2);
  if (i.target === "openapi-3.0") $2.ref = n.innerType, o.nullable = true;
  else o.anyOf = [v, { type: "null" }];
}, yu$1 = (r2, i, o, t) => {
  let n = r2._zod.def;
  L$1(n.innerType, i, t);
  let v = i.seen.get(r2);
  v.ref = n.innerType;
}, hu$1 = (r2, i, o, t) => {
  let n = r2._zod.def;
  L$1(n.innerType, i, t);
  let v = i.seen.get(r2);
  v.ref = n.innerType, o.default = JSON.parse(JSON.stringify(n.defaultValue));
}, au$1 = (r2, i, o, t) => {
  let n = r2._zod.def;
  L$1(n.innerType, i, t);
  let v = i.seen.get(r2);
  if (v.ref = n.innerType, i.io === "input") o._prefault = JSON.parse(JSON.stringify(n.defaultValue));
}, pu$1 = (r2, i, o, t) => {
  let n = r2._zod.def;
  L$1(n.innerType, i, t);
  let v = i.seen.get(r2);
  v.ref = n.innerType;
  let $2;
  try {
    $2 = n.catchValue(void 0);
  } catch {
    throw Error("Dynamic catch values are not supported in JSON Schema");
  }
  o.default = $2;
}, su$1 = (r2, i, o, t) => {
  let n = r2._zod.def, v = i.io === "input" ? n.in._zod.def.type === "transform" ? n.out : n.in : n.out;
  L$1(v, i, t);
  let $2 = i.seen.get(r2);
  $2.ref = v;
}, rg$1 = (r2, i, o, t) => {
  let n = r2._zod.def;
  L$1(n.innerType, i, t);
  let v = i.seen.get(r2);
  v.ref = n.innerType, o.readOnly = true;
}, ng$1 = (r2, i, o, t) => {
  let n = r2._zod.def;
  L$1(n.innerType, i, t);
  let v = i.seen.get(r2);
  v.ref = n.innerType;
}, Ti$1 = (r2, i, o, t) => {
  let n = r2._zod.def;
  L$1(n.innerType, i, t);
  let v = i.seen.get(r2);
  v.ref = n.innerType;
}, ig$1 = (r2, i, o, t) => {
  let n = r2._zod.innerType;
  L$1(n, i, t);
  let v = i.seen.get(r2);
  v.ref = n;
}, Yi$1 = { string: Ou$1, number: Su$1, boolean: zu$1, bigint: Pu$1, symbol: ju$1, null: Ju$1, undefined: Lu$1, void: Eu$1, never: Gu$1, any: Wu$1, unknown: Xu$1, date: Au$1, enum: Vu$1, literal: Ku$1, nan: Yu$1, template_literal: Qu$1, file: Tu$1, success: Fu$1, custom: qu$1, function: Bu$1, transform: Hu$1, map: Mu$1, set: mu$1, array: Ru$1, object: xu$1, union: Qi$1, intersection: Zu$1, tuple: du$1, record: Cu$1, nullable: fu$1, nonoptional: yu$1, default: hu$1, prefault: au$1, catch: pu$1, pipe: su$1, readonly: rg$1, promise: ng$1, optional: Ti$1, lazy: ig$1 };
function Fi$1(r2, i) {
  if ("_idmap" in r2) {
    let t = r2, n = er({ ...i, processors: Yi$1 }), v = {};
    for (let l of t._idmap.entries()) {
      let [e, c] = l;
      L$1(c, n);
    }
    let $2 = {}, u2 = { registry: t, uri: i?.uri, defs: v };
    n.external = u2;
    for (let l of t._idmap.entries()) {
      let [e, c] = l;
      lr(n, c), $2[e] = Ir$1(n, c);
    }
    if (Object.keys(v).length > 0) {
      let l = n.target === "draft-2020-12" ? "$defs" : "definitions";
      $2.__shared = { [l]: v };
    }
    return { schemas: $2 };
  }
  let o = er({ ...i, processors: Yi$1 });
  return L$1(r2, o), lr(o, r2), Ir$1(o, r2);
}
let vg$1 = class vg {
  get metadataRegistry() {
    return this.ctx.metadataRegistry;
  }
  get target() {
    return this.ctx.target;
  }
  get unrepresentable() {
    return this.ctx.unrepresentable;
  }
  get override() {
    return this.ctx.override;
  }
  get io() {
    return this.ctx.io;
  }
  get counter() {
    return this.ctx.counter;
  }
  set counter(r2) {
    this.ctx.counter = r2;
  }
  get seen() {
    return this.ctx.seen;
  }
  constructor(r2) {
    let i = r2?.target ?? "draft-2020-12";
    if (i === "draft-4") i = "draft-04";
    if (i === "draft-7") i = "draft-07";
    this.ctx = er({ processors: Yi$1, target: i, ...r2?.metadata && { metadata: r2.metadata }, ...r2?.unrepresentable && { unrepresentable: r2.unrepresentable }, ...r2?.override && { override: r2.override }, ...r2?.io && { io: r2.io } });
  }
  process(r2, i = { path: [], schemaPath: [] }) {
    return L$1(r2, this.ctx, i);
  }
  emit(r2, i) {
    if (i) {
      if (i.cycles) this.ctx.cycles = i.cycles;
      if (i.reused) this.ctx.reused = i.reused;
      if (i.external) this.ctx.external = i.external;
    }
    lr(this.ctx, r2);
    let o = Ir$1(this.ctx, r2), { "~standard": t, ...n } = o;
    return n;
  }
};
var bl$1 = {};
var jn$1 = {};
s(jn$1, { xor: () => $I, xid: () => Wl$1, void: () => rI, uuidv7: () => Sl$1, uuidv6: () => Ol$1, uuidv4: () => Nl$1, uuid: () => wl$1, url: () => zl$1, unknown: () => Nr$1, union: () => lv$1, undefined: () => pl$1, ulid: () => Gl$1, uint64: () => hl$1, uint32: () => Cl$1, tuple: () => Fg$1, transform: () => cv$1, templateLiteral: () => NI, symbol: () => al$1, superRefine: () => le$2, success: () => DI, stringbool: () => EI, stringFormat: () => Hl$1, string: () => Ri$1, strictObject: () => oI, set: () => II, refine: () => ee$2, record: () => qg$1, readonly: () => ve$1, promise: () => OI, preprocess: () => WI, prefault: () => hg$1, pipe: () => Gn$1, partialRecord: () => gI, optional: () => Ln$1, object: () => vI, number: () => Sg$1, nullish: () => UI, nullable: () => En$1, null: () => Lg$1, nonoptional: () => ag$1, never: () => ev$1, nativeEnum: () => cI, nanoid: () => Jl$1, nan: () => kI, meta: () => JI, map: () => lI, mac: () => Vl$1, looseRecord: () => eI, looseObject: () => tI, literal: () => _I, lazy: () => $e$1, ksuid: () => Xl$1, keyof: () => iI, jwt: () => Bl$1, json: () => GI, ipv6: () => Kl$1, ipv4: () => Al$1, intersection: () => Qg$1, int64: () => yl$1, int32: () => dl$1, int: () => xi$1, instanceof: () => LI, httpUrl: () => Pl$1, hostname: () => Ml$1, hex: () => ml$1, hash: () => Rl$1, guid: () => kl$1, function: () => SI, float64: () => Zl$1, float32: () => xl$1, file: () => bI, exactOptional: () => Zg$1, enum: () => Iv$1, emoji: () => jl$1, email: () => Dl$1, e164: () => ql$1, discriminatedUnion: () => uI, describe: () => jI, date: () => nI, custom: () => PI, cuid2: () => El$1, cuid: () => Ll$1, codec: () => wI, cidrv6: () => Ql$1, cidrv4: () => Yl$1, check: () => zI, catch: () => re$1, boolean: () => zg$1, bigint: () => fl$1, base64url: () => Fl$1, base64: () => Tl$1, array: () => An$1, any: () => sl$1, _function: () => SI, _default: () => fg$1, _ZodString: () => Zi$1, ZodXor: () => Vg$1, ZodXID: () => pi$1, ZodVoid: () => Xg$1, ZodUnknown: () => Gg$1, ZodUnion: () => Kn$1, ZodUndefined: () => jg$1, ZodUUID: () => p$2, ZodURL: () => Wn$1, ZodULID: () => ai$1, ZodType: () => P$1, ZodTuple: () => Tg$1, ZodTransform: () => Rg$1, ZodTemplateLiteral: () => oe, ZodSymbol: () => Pg$1, ZodSuccess: () => pg$1, ZodStringFormat: () => G$1, ZodString: () => fr$1, ZodSet: () => Hg$1, ZodRecord: () => Yn$1, ZodReadonly: () => ie$1, ZodPromise: () => ue$2, ZodPrefault: () => yg$1, ZodPipe: () => Uv$1, ZodOptional: () => _v$1, ZodObject: () => Vn$1, ZodNumberFormat: () => Or$1, ZodNumber: () => hr$1, ZodNullable: () => dg$1, ZodNull: () => Jg$1, ZodNonOptional: () => bv$1, ZodNever: () => Wg$1, ZodNanoID: () => fi$1, ZodNaN: () => ne, ZodMap: () => Bg$1, ZodMAC: () => Og$1, ZodLiteral: () => Mg$1, ZodLazy: () => te, ZodKSUID: () => si, ZodJWT: () => uv$1, ZodIntersection: () => Yg$1, ZodIPv6: () => nv$1, ZodIPv4: () => rv$1, ZodGUID: () => Jn$1, ZodFunction: () => ge, ZodFile: () => mg$1, ZodExactOptional: () => xg$1, ZodEnum: () => Cr$1, ZodEmoji: () => Ci$1, ZodEmail: () => di$1, ZodE164: () => $v$1, ZodDiscriminatedUnion: () => Kg$1, ZodDefault: () => Cg$1, ZodDate: () => Xn$1, ZodCustomStringFormat: () => yr, ZodCustom: () => Qn$1, ZodCodec: () => Dv$1, ZodCatch: () => sg$1, ZodCUID2: () => hi$1, ZodCUID: () => yi$1, ZodCIDRv6: () => vv$1, ZodCIDRv4: () => iv$1, ZodBoolean: () => ar, ZodBigIntFormat: () => gv$1, ZodBigInt: () => pr$1, ZodBase64URL: () => tv$1, ZodBase64: () => ov$1, ZodArray: () => Ag$1, ZodAny: () => Eg$1 });
var qi$1 = {};
s(qi$1, { uppercase: () => Yr$1, trim: () => Hr$1, toUpperCase: () => mr$1, toLowerCase: () => Mr$1, startsWith: () => Tr$1, slugify: () => Rr$1, size: () => Dr$1, regex: () => Vr$1, property: () => Ki$1, positive: () => Wi$1, overwrite: () => d, normalize: () => Br$1, nonpositive: () => Ai$1, nonnegative: () => Vi$1, negative: () => Xi$1, multipleOf: () => ur, minSize: () => a, minLength: () => nr, mime: () => qr$1, maxSize: () => gr$1, maxLength: () => kr$1, lte: () => m$2, lt: () => y$1, lowercase: () => Kr$1, length: () => wr$1, includes: () => Qr$1, gte: () => Q, gt: () => h$1, endsWith: () => Fr$1 });
var dr = {};
s(dr, { time: () => $g$1, duration: () => ug$1, datetime: () => og$1, date: () => tg$1, ZodISOTime: () => Mi$1, ZodISODuration: () => mi$1, ZodISODateTime: () => Bi$1, ZodISODate: () => Hi$1 });
var Bi$1 = I("ZodISODateTime", (r2, i) => {
  Ho$1.init(r2, i), G$1.init(r2, i);
});
function og$1(r2) {
  return q$(Bi$1, r2);
}
var Hi$1 = I("ZodISODate", (r2, i) => {
  Mo$1.init(r2, i), G$1.init(r2, i);
});
function tg$1(r2) {
  return B$(Hi$1, r2);
}
var Mi$1 = I("ZodISOTime", (r2, i) => {
  mo.init(r2, i), G$1.init(r2, i);
});
function $g$1(r2) {
  return H$(Mi$1, r2);
}
var mi$1 = I("ZodISODuration", (r2, i) => {
  Ro$1.init(r2, i), G$1.init(r2, i);
});
function ug$1(r2) {
  return M$(mi$1, r2);
}
var Ul$1 = (r2, i) => {
  gn$1.init(r2, i), r2.name = "ZodError", Object.defineProperties(r2, { format: { value: (o) => ln$1(r2, o) }, flatten: { value: (o) => en$1(r2, o) }, addIssue: { value: (o) => {
    r2.issues.push(o), r2.message = JSON.stringify(r2.issues, Pr$1, 2);
  } }, addIssues: { value: (o) => {
    r2.issues.push(...o), r2.message = JSON.stringify(r2.issues, Pr$1, 2);
  } }, isEmpty: { get() {
    return r2.issues.length === 0;
  } } });
}, Ac$1 = I("ZodError", Ul$1), H$2 = I("ZodError", Ul$1, { Parent: Error });
var gg$1 = Lr$1(H$2), eg$1 = Er$1(H$2), lg$1 = Gr$1(H$2), Ig$1 = Wr$1(H$2), cg$1 = Mn$1(H$2), _g$1 = mn$1(H$2), bg$1 = Rn$1(H$2), Ug$1 = xn$1(H$2), Dg$1 = Zn$1(H$2), kg$1 = dn$1(H$2), wg$1 = Cn$1(H$2), Ng$1 = fn$1(H$2);
var P$1 = I("ZodType", (r2, i) => {
  return z$1.init(r2, i), Object.assign(r2["~standard"], { jsonSchema: { input: Zr$1(r2, "input"), output: Zr$1(r2, "output") } }), r2.toJSONSchema = Nu$1(r2, {}), r2.def = i, r2.type = i.type, Object.defineProperty(r2, "_def", { value: i }), r2.check = (...o) => {
    return r2.clone(k$3.mergeDefs(i, { checks: [...i.checks ?? [], ...o.map((t) => typeof t === "function" ? { _zod: { check: t, def: { check: "custom" }, onattach: [] } } : t)] }), { parent: true });
  }, r2.with = r2.check, r2.clone = (o, t) => Y$2(r2, o, t), r2.brand = () => r2, r2.register = (o, t) => {
    return o.add(r2, t), r2;
  }, r2.parse = (o, t) => gg$1(r2, o, t, { callee: r2.parse }), r2.safeParse = (o, t) => lg$1(r2, o, t), r2.parseAsync = async (o, t) => eg$1(r2, o, t, { callee: r2.parseAsync }), r2.safeParseAsync = async (o, t) => Ig$1(r2, o, t), r2.spa = r2.safeParseAsync, r2.encode = (o, t) => cg$1(r2, o, t), r2.decode = (o, t) => _g$1(r2, o, t), r2.encodeAsync = async (o, t) => bg$1(r2, o, t), r2.decodeAsync = async (o, t) => Ug$1(r2, o, t), r2.safeEncode = (o, t) => Dg$1(r2, o, t), r2.safeDecode = (o, t) => kg$1(r2, o, t), r2.safeEncodeAsync = async (o, t) => wg$1(r2, o, t), r2.safeDecodeAsync = async (o, t) => Ng$1(r2, o, t), r2.refine = (o, t) => r2.check(ee$2(o, t)), r2.superRefine = (o) => r2.check(le$2(o)), r2.overwrite = (o) => r2.check(d(o)), r2.optional = () => Ln$1(r2), r2.exactOptional = () => Zg$1(r2), r2.nullable = () => En$1(r2), r2.nullish = () => Ln$1(En$1(r2)), r2.nonoptional = (o) => ag$1(r2, o), r2.array = () => An$1(r2), r2.or = (o) => lv$1([r2, o]), r2.and = (o) => Qg$1(r2, o), r2.transform = (o) => Gn$1(r2, cv$1(o)), r2.default = (o) => fg$1(r2, o), r2.prefault = (o) => hg$1(r2, o), r2.catch = (o) => re$1(r2, o), r2.pipe = (o) => Gn$1(r2, o), r2.readonly = () => ve$1(r2), r2.describe = (o) => {
    let t = r2.clone();
    return V.add(t, { description: o }), t;
  }, Object.defineProperty(r2, "description", { get() {
    return V.get(r2)?.description;
  }, configurable: true }), r2.meta = (...o) => {
    if (o.length === 0) return V.get(r2);
    let t = r2.clone();
    return V.add(t, o[0]), t;
  }, r2.isOptional = () => r2.safeParse(void 0).success, r2.isNullable = () => r2.safeParse(null).success, r2.apply = (o) => o(r2), r2;
}), Zi$1 = I("_ZodString", (r2, i) => {
  Ur$1.init(r2, i), P$1.init(r2, i), r2._zod.processJSONSchema = (t, n, v) => Ou$1(r2, t, n);
  let o = r2._zod.bag;
  r2.format = o.format ?? null, r2.minLength = o.minimum ?? null, r2.maxLength = o.maximum ?? null, r2.regex = (...t) => r2.check(Vr$1(...t)), r2.includes = (...t) => r2.check(Qr$1(...t)), r2.startsWith = (...t) => r2.check(Tr$1(...t)), r2.endsWith = (...t) => r2.check(Fr$1(...t)), r2.min = (...t) => r2.check(nr(...t)), r2.max = (...t) => r2.check(kr$1(...t)), r2.length = (...t) => r2.check(wr$1(...t)), r2.nonempty = (...t) => r2.check(nr(1, ...t)), r2.lowercase = (t) => r2.check(Kr$1(t)), r2.uppercase = (t) => r2.check(Yr$1(t)), r2.trim = () => r2.check(Hr$1()), r2.normalize = (...t) => r2.check(Br$1(...t)), r2.toLowerCase = () => r2.check(Mr$1()), r2.toUpperCase = () => r2.check(mr$1()), r2.slugify = () => r2.check(Rr$1());
}), fr$1 = I("ZodString", (r2, i) => {
  Ur$1.init(r2, i), Zi$1.init(r2, i), r2.email = (o) => r2.check(ei$1(di$1, o)), r2.url = (o) => r2.check(Pn$1(Wn$1, o)), r2.jwt = (o) => r2.check(Gi$1(uv$1, o)), r2.emoji = (o) => r2.check(bi$1(Ci$1, o)), r2.guid = (o) => r2.check(zn$1(Jn$1, o)), r2.uuid = (o) => r2.check(li$1(p$2, o)), r2.uuidv4 = (o) => r2.check(Ii$1(p$2, o)), r2.uuidv6 = (o) => r2.check(ci$1(p$2, o)), r2.uuidv7 = (o) => r2.check(_i$1(p$2, o)), r2.nanoid = (o) => r2.check(Ui$1(fi$1, o)), r2.guid = (o) => r2.check(zn$1(Jn$1, o)), r2.cuid = (o) => r2.check(Di$1(yi$1, o)), r2.cuid2 = (o) => r2.check(ki$1(hi$1, o)), r2.ulid = (o) => r2.check(wi$1(ai$1, o)), r2.base64 = (o) => r2.check(Ji$1(ov$1, o)), r2.base64url = (o) => r2.check(Li$1(tv$1, o)), r2.xid = (o) => r2.check(Ni$1(pi$1, o)), r2.ksuid = (o) => r2.check(Oi$1(si, o)), r2.ipv4 = (o) => r2.check(Si$1(rv$1, o)), r2.ipv6 = (o) => r2.check(zi$1(nv$1, o)), r2.cidrv4 = (o) => r2.check(Pi$1(iv$1, o)), r2.cidrv6 = (o) => r2.check(ji$1(vv$1, o)), r2.e164 = (o) => r2.check(Ei$1($v$1, o)), r2.datetime = (o) => r2.check(og$1(o)), r2.date = (o) => r2.check(tg$1(o)), r2.time = (o) => r2.check($g$1(o)), r2.duration = (o) => r2.check(ug$1(o));
});
function Ri$1(r2) {
  return Y$(fr$1, r2);
}
var G$1 = I("ZodStringFormat", (r2, i) => {
  E.init(r2, i), Zi$1.init(r2, i);
}), di$1 = I("ZodEmail", (r2, i) => {
  Ao$1.init(r2, i), G$1.init(r2, i);
});
function Dl$1(r2) {
  return ei$1(di$1, r2);
}
var Jn$1 = I("ZodGUID", (r2, i) => {
  Wo$1.init(r2, i), G$1.init(r2, i);
});
function kl$1(r2) {
  return zn$1(Jn$1, r2);
}
var p$2 = I("ZodUUID", (r2, i) => {
  Xo$1.init(r2, i), G$1.init(r2, i);
});
function wl$1(r2) {
  return li$1(p$2, r2);
}
function Nl$1(r2) {
  return Ii$1(p$2, r2);
}
function Ol$1(r2) {
  return ci$1(p$2, r2);
}
function Sl$1(r2) {
  return _i$1(p$2, r2);
}
var Wn$1 = I("ZodURL", (r2, i) => {
  Vo$1.init(r2, i), G$1.init(r2, i);
});
function zl$1(r2) {
  return Pn$1(Wn$1, r2);
}
function Pl$1(r2) {
  return Pn$1(Wn$1, { protocol: /^https?$/, hostname: x$1.domain, ...k$3.normalizeParams(r2) });
}
var Ci$1 = I("ZodEmoji", (r2, i) => {
  Ko$1.init(r2, i), G$1.init(r2, i);
});
function jl$1(r2) {
  return bi$1(Ci$1, r2);
}
var fi$1 = I("ZodNanoID", (r2, i) => {
  Yo$1.init(r2, i), G$1.init(r2, i);
});
function Jl$1(r2) {
  return Ui$1(fi$1, r2);
}
var yi$1 = I("ZodCUID", (r2, i) => {
  Qo$1.init(r2, i), G$1.init(r2, i);
});
function Ll$1(r2) {
  return Di$1(yi$1, r2);
}
var hi$1 = I("ZodCUID2", (r2, i) => {
  To$1.init(r2, i), G$1.init(r2, i);
});
function El$1(r2) {
  return ki$1(hi$1, r2);
}
var ai$1 = I("ZodULID", (r2, i) => {
  Fo$1.init(r2, i), G$1.init(r2, i);
});
function Gl$1(r2) {
  return wi$1(ai$1, r2);
}
var pi$1 = I("ZodXID", (r2, i) => {
  qo$1.init(r2, i), G$1.init(r2, i);
});
function Wl$1(r2) {
  return Ni$1(pi$1, r2);
}
var si = I("ZodKSUID", (r2, i) => {
  Bo$1.init(r2, i), G$1.init(r2, i);
});
function Xl$1(r2) {
  return Oi$1(si, r2);
}
var rv$1 = I("ZodIPv4", (r2, i) => {
  xo$1.init(r2, i), G$1.init(r2, i);
});
function Al$1(r2) {
  return Si$1(rv$1, r2);
}
var Og$1 = I("ZodMAC", (r2, i) => {
  Co$1.init(r2, i), G$1.init(r2, i);
});
function Vl$1(r2) {
  return T$(Og$1, r2);
}
var nv$1 = I("ZodIPv6", (r2, i) => {
  Zo$1.init(r2, i), G$1.init(r2, i);
});
function Kl$1(r2) {
  return zi$1(nv$1, r2);
}
var iv$1 = I("ZodCIDRv4", (r2, i) => {
  fo.init(r2, i), G$1.init(r2, i);
});
function Yl$1(r2) {
  return Pi$1(iv$1, r2);
}
var vv$1 = I("ZodCIDRv6", (r2, i) => {
  yo$1.init(r2, i), G$1.init(r2, i);
});
function Ql$1(r2) {
  return ji$1(vv$1, r2);
}
var ov$1 = I("ZodBase64", (r2, i) => {
  ao.init(r2, i), G$1.init(r2, i);
});
function Tl$1(r2) {
  return Ji$1(ov$1, r2);
}
var tv$1 = I("ZodBase64URL", (r2, i) => {
  po.init(r2, i), G$1.init(r2, i);
});
function Fl$1(r2) {
  return Li$1(tv$1, r2);
}
var $v$1 = I("ZodE164", (r2, i) => {
  so.init(r2, i), G$1.init(r2, i);
});
function ql$1(r2) {
  return Ei$1($v$1, r2);
}
var uv$1 = I("ZodJWT", (r2, i) => {
  rt$1.init(r2, i), G$1.init(r2, i);
});
function Bl$1(r2) {
  return Gi$1(uv$1, r2);
}
var yr = I("ZodCustomStringFormat", (r2, i) => {
  nt$1.init(r2, i), G$1.init(r2, i);
});
function Hl$1(r2, i, o = {}) {
  return xr$1(yr, r2, i, o);
}
function Ml$1(r2) {
  return xr$1(yr, "hostname", x$1.hostname, r2);
}
function ml$1(r2) {
  return xr$1(yr, "hex", x$1.hex, r2);
}
function Rl$1(r2, i) {
  let o = i?.enc ?? "hex", t = `${r2}_${o}`, n = x$1[t];
  if (!n) throw Error(`Unrecognized hash format: ${t}`);
  return xr$1(yr, t, n, i);
}
var hr$1 = I("ZodNumber", (r2, i) => {
  oi.init(r2, i), P$1.init(r2, i), r2._zod.processJSONSchema = (t, n, v) => Su$1(r2, t, n), r2.gt = (t, n) => r2.check(h$1(t, n)), r2.gte = (t, n) => r2.check(Q(t, n)), r2.min = (t, n) => r2.check(Q(t, n)), r2.lt = (t, n) => r2.check(y$1(t, n)), r2.lte = (t, n) => r2.check(m$2(t, n)), r2.max = (t, n) => r2.check(m$2(t, n)), r2.int = (t) => r2.check(xi$1(t)), r2.safe = (t) => r2.check(xi$1(t)), r2.positive = (t) => r2.check(h$1(0, t)), r2.nonnegative = (t) => r2.check(Q(0, t)), r2.negative = (t) => r2.check(y$1(0, t)), r2.nonpositive = (t) => r2.check(m$2(0, t)), r2.multipleOf = (t, n) => r2.check(ur(t, n)), r2.step = (t, n) => r2.check(ur(t, n)), r2.finite = () => r2;
  let o = r2._zod.bag;
  r2.minValue = Math.max(o.minimum ?? Number.NEGATIVE_INFINITY, o.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null, r2.maxValue = Math.min(o.maximum ?? Number.POSITIVE_INFINITY, o.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null, r2.isInt = (o.format ?? "").includes("int") || Number.isSafeInteger(o.multipleOf ?? 0.5), r2.isFinite = true, r2.format = o.format ?? null;
});
function Sg$1(r2) {
  return m$(hr$1, r2);
}
var Or$1 = I("ZodNumberFormat", (r2, i) => {
  it$1.init(r2, i), hr$1.init(r2, i);
});
function xi$1(r2) {
  return x$(Or$1, r2);
}
function xl$1(r2) {
  return Z$(Or$1, r2);
}
function Zl$1(r2) {
  return d$(Or$1, r2);
}
function dl$1(r2) {
  return C$(Or$1, r2);
}
function Cl$1(r2) {
  return f$(Or$1, r2);
}
var ar = I("ZodBoolean", (r2, i) => {
  bn$1.init(r2, i), P$1.init(r2, i), r2._zod.processJSONSchema = (o, t, n) => zu$1(r2, o, t);
});
function zg$1(r2) {
  return y$(ar, r2);
}
var pr$1 = I("ZodBigInt", (r2, i) => {
  ti$1.init(r2, i), P$1.init(r2, i), r2._zod.processJSONSchema = (t, n, v) => Pu$1(r2, t), r2.gte = (t, n) => r2.check(Q(t, n)), r2.min = (t, n) => r2.check(Q(t, n)), r2.gt = (t, n) => r2.check(h$1(t, n)), r2.gte = (t, n) => r2.check(Q(t, n)), r2.min = (t, n) => r2.check(Q(t, n)), r2.lt = (t, n) => r2.check(y$1(t, n)), r2.lte = (t, n) => r2.check(m$2(t, n)), r2.max = (t, n) => r2.check(m$2(t, n)), r2.positive = (t) => r2.check(h$1(BigInt(0), t)), r2.negative = (t) => r2.check(y$1(BigInt(0), t)), r2.nonpositive = (t) => r2.check(m$2(BigInt(0), t)), r2.nonnegative = (t) => r2.check(Q(BigInt(0), t)), r2.multipleOf = (t, n) => r2.check(ur(t, n));
  let o = r2._zod.bag;
  r2.minValue = o.minimum ?? null, r2.maxValue = o.maximum ?? null, r2.format = o.format ?? null;
});
function fl$1(r2) {
  return a$(pr$1, r2);
}
var gv$1 = I("ZodBigIntFormat", (r2, i) => {
  vt$1.init(r2, i), pr$1.init(r2, i);
});
function yl$1(r2) {
  return s$(gv$1, r2);
}
function hl$1(r2) {
  return ru$1(gv$1, r2);
}
var Pg$1 = I("ZodSymbol", (r2, i) => {
  ot$1.init(r2, i), P$1.init(r2, i), r2._zod.processJSONSchema = (o, t, n) => ju$1(r2, o);
});
function al$1(r2) {
  return nu$1(Pg$1, r2);
}
var jg$1 = I("ZodUndefined", (r2, i) => {
  tt$1.init(r2, i), P$1.init(r2, i), r2._zod.processJSONSchema = (o, t, n) => Lu$1(r2, o);
});
function pl$1(r2) {
  return iu$1(jg$1, r2);
}
var Jg$1 = I("ZodNull", (r2, i) => {
  $t$1.init(r2, i), P$1.init(r2, i), r2._zod.processJSONSchema = (o, t, n) => Ju$1(r2, o, t);
});
function Lg$1(r2) {
  return vu$1(Jg$1, r2);
}
var Eg$1 = I("ZodAny", (r2, i) => {
  ut.init(r2, i), P$1.init(r2, i), r2._zod.processJSONSchema = (o, t, n) => Wu$1();
});
function sl$1() {
  return ou$1(Eg$1);
}
var Gg$1 = I("ZodUnknown", (r2, i) => {
  gt$1.init(r2, i), P$1.init(r2, i), r2._zod.processJSONSchema = (o, t, n) => Xu$1();
});
function Nr$1() {
  return tu$1(Gg$1);
}
var Wg$1 = I("ZodNever", (r2, i) => {
  et$1.init(r2, i), P$1.init(r2, i), r2._zod.processJSONSchema = (o, t, n) => Gu$1(r2, o, t);
});
function ev$1(r2) {
  return $u$1(Wg$1, r2);
}
var Xg$1 = I("ZodVoid", (r2, i) => {
  lt$1.init(r2, i), P$1.init(r2, i), r2._zod.processJSONSchema = (o, t, n) => Eu$1(r2, o);
});
function rI(r2) {
  return uu$1(Xg$1, r2);
}
var Xn$1 = I("ZodDate", (r2, i) => {
  It$1.init(r2, i), P$1.init(r2, i), r2._zod.processJSONSchema = (t, n, v) => Au$1(r2, t), r2.min = (t, n) => r2.check(Q(t, n)), r2.max = (t, n) => r2.check(m$2(t, n));
  let o = r2._zod.bag;
  r2.minDate = o.minimum ? new Date(o.minimum) : null, r2.maxDate = o.maximum ? new Date(o.maximum) : null;
});
function nI(r2) {
  return gu$1(Xn$1, r2);
}
var Ag$1 = I("ZodArray", (r2, i) => {
  ct.init(r2, i), P$1.init(r2, i), r2._zod.processJSONSchema = (o, t, n) => Ru$1(r2, o, t, n), r2.element = i.element, r2.min = (o, t) => r2.check(nr(o, t)), r2.nonempty = (o) => r2.check(nr(1, o)), r2.max = (o, t) => r2.check(kr$1(o, t)), r2.length = (o, t) => r2.check(wr$1(o, t)), r2.unwrap = () => r2.element;
});
function An$1(r2, i) {
  return Iu$1(Ag$1, r2, i);
}
function iI(r2) {
  let i = r2._zod.def.shape;
  return Iv$1(Object.keys(i));
}
var Vn$1 = I("ZodObject", (r2, i) => {
  _t.init(r2, i), P$1.init(r2, i), r2._zod.processJSONSchema = (o, t, n) => xu$1(r2, o, t, n), k$3.defineLazy(r2, "shape", () => {
    return i.shape;
  }), r2.keyof = () => Iv$1(Object.keys(r2._zod.def.shape)), r2.catchall = (o) => r2.clone({ ...r2._zod.def, catchall: o }), r2.passthrough = () => r2.clone({ ...r2._zod.def, catchall: Nr$1() }), r2.loose = () => r2.clone({ ...r2._zod.def, catchall: Nr$1() }), r2.strict = () => r2.clone({ ...r2._zod.def, catchall: ev$1() }), r2.strip = () => r2.clone({ ...r2._zod.def, catchall: void 0 }), r2.extend = (o) => {
    return k$3.extend(r2, o);
  }, r2.safeExtend = (o) => {
    return k$3.safeExtend(r2, o);
  }, r2.merge = (o) => k$3.merge(r2, o), r2.pick = (o) => k$3.pick(r2, o), r2.omit = (o) => k$3.omit(r2, o), r2.partial = (...o) => k$3.partial(_v$1, r2, o[0]), r2.required = (...o) => k$3.required(bv$1, r2, o[0]);
});
function vI(r2, i) {
  let o = { type: "object", shape: r2 ?? {}, ...k$3.normalizeParams(i) };
  return new Vn$1(o);
}
function oI(r2, i) {
  return new Vn$1({ type: "object", shape: r2, catchall: ev$1(), ...k$3.normalizeParams(i) });
}
function tI(r2, i) {
  return new Vn$1({ type: "object", shape: r2, catchall: Nr$1(), ...k$3.normalizeParams(i) });
}
var Kn$1 = I("ZodUnion", (r2, i) => {
  Un$1.init(r2, i), P$1.init(r2, i), r2._zod.processJSONSchema = (o, t, n) => Qi$1(r2, o, t, n), r2.options = i.options;
});
function lv$1(r2, i) {
  return new Kn$1({ type: "union", options: r2, ...k$3.normalizeParams(i) });
}
var Vg$1 = I("ZodXor", (r2, i) => {
  Kn$1.init(r2, i), bt.init(r2, i), r2._zod.processJSONSchema = (o, t, n) => Qi$1(r2, o, t, n), r2.options = i.options;
});
function $I(r2, i) {
  return new Vg$1({ type: "union", options: r2, inclusive: false, ...k$3.normalizeParams(i) });
}
var Kg$1 = I("ZodDiscriminatedUnion", (r2, i) => {
  Kn$1.init(r2, i), Ut$1.init(r2, i);
});
function uI(r2, i, o) {
  return new Kg$1({ type: "union", options: i, discriminator: r2, ...k$3.normalizeParams(o) });
}
var Yg$1 = I("ZodIntersection", (r2, i) => {
  Dt$1.init(r2, i), P$1.init(r2, i), r2._zod.processJSONSchema = (o, t, n) => Zu$1(r2, o, t, n);
});
function Qg$1(r2, i) {
  return new Yg$1({ type: "intersection", left: r2, right: i });
}
var Tg$1 = I("ZodTuple", (r2, i) => {
  $i$1.init(r2, i), P$1.init(r2, i), r2._zod.processJSONSchema = (o, t, n) => du$1(r2, o, t, n), r2.rest = (o) => r2.clone({ ...r2._zod.def, rest: o });
});
function Fg$1(r2, i, o) {
  let t = i instanceof z$1, n = t ? o : i;
  return new Tg$1({ type: "tuple", items: r2, rest: t ? i : null, ...k$3.normalizeParams(n) });
}
var Yn$1 = I("ZodRecord", (r2, i) => {
  kt$1.init(r2, i), P$1.init(r2, i), r2._zod.processJSONSchema = (o, t, n) => Cu$1(r2, o, t, n), r2.keyType = i.keyType, r2.valueType = i.valueType;
});
function qg$1(r2, i, o) {
  return new Yn$1({ type: "record", keyType: r2, valueType: i, ...k$3.normalizeParams(o) });
}
function gI(r2, i, o) {
  let t = Y$2(r2);
  return t._zod.values = void 0, new Yn$1({ type: "record", keyType: t, valueType: i, ...k$3.normalizeParams(o) });
}
function eI(r2, i, o) {
  return new Yn$1({ type: "record", keyType: r2, valueType: i, mode: "loose", ...k$3.normalizeParams(o) });
}
var Bg$1 = I("ZodMap", (r2, i) => {
  wt$1.init(r2, i), P$1.init(r2, i), r2._zod.processJSONSchema = (o, t, n) => Mu$1(r2, o), r2.keyType = i.keyType, r2.valueType = i.valueType, r2.min = (...o) => r2.check(a(...o)), r2.nonempty = (o) => r2.check(a(1, o)), r2.max = (...o) => r2.check(gr$1(...o)), r2.size = (...o) => r2.check(Dr$1(...o));
});
function lI(r2, i, o) {
  return new Bg$1({ type: "map", keyType: r2, valueType: i, ...k$3.normalizeParams(o) });
}
var Hg$1 = I("ZodSet", (r2, i) => {
  Nt$1.init(r2, i), P$1.init(r2, i), r2._zod.processJSONSchema = (o, t, n) => mu$1(r2, o), r2.min = (...o) => r2.check(a(...o)), r2.nonempty = (o) => r2.check(a(1, o)), r2.max = (...o) => r2.check(gr$1(...o)), r2.size = (...o) => r2.check(Dr$1(...o));
});
function II(r2, i) {
  return new Hg$1({ type: "set", valueType: r2, ...k$3.normalizeParams(i) });
}
var Cr$1 = I("ZodEnum", (r2, i) => {
  Ot$1.init(r2, i), P$1.init(r2, i), r2._zod.processJSONSchema = (t, n, v) => Vu$1(r2, t, n), r2.enum = i.entries, r2.options = Object.values(i.entries);
  let o = new Set(Object.keys(i.entries));
  r2.extract = (t, n) => {
    let v = {};
    for (let $2 of t) if (o.has($2)) v[$2] = i.entries[$2];
    else throw Error(`Key ${$2} not found in enum`);
    return new Cr$1({ ...i, checks: [], ...k$3.normalizeParams(n), entries: v });
  }, r2.exclude = (t, n) => {
    let v = { ...i.entries };
    for (let $2 of t) if (o.has($2)) delete v[$2];
    else throw Error(`Key ${$2} not found in enum`);
    return new Cr$1({ ...i, checks: [], ...k$3.normalizeParams(n), entries: v });
  };
});
function Iv$1(r2, i) {
  let o = Array.isArray(r2) ? Object.fromEntries(r2.map((t) => [t, t])) : r2;
  return new Cr$1({ type: "enum", entries: o, ...k$3.normalizeParams(i) });
}
function cI(r2, i) {
  return new Cr$1({ type: "enum", entries: r2, ...k$3.normalizeParams(i) });
}
var Mg$1 = I("ZodLiteral", (r2, i) => {
  St$1.init(r2, i), P$1.init(r2, i), r2._zod.processJSONSchema = (o, t, n) => Ku$1(r2, o, t), r2.values = new Set(i.values), Object.defineProperty(r2, "value", { get() {
    if (i.values.length > 1) throw Error("This schema contains multiple valid literal values. Use `.values` instead.");
    return i.values[0];
  } });
});
function _I(r2, i) {
  return new Mg$1({ type: "literal", values: Array.isArray(r2) ? r2 : [r2], ...k$3.normalizeParams(i) });
}
var mg$1 = I("ZodFile", (r2, i) => {
  zt$1.init(r2, i), P$1.init(r2, i), r2._zod.processJSONSchema = (o, t, n) => Tu$1(r2, o, t), r2.min = (o, t) => r2.check(a(o, t)), r2.max = (o, t) => r2.check(gr$1(o, t)), r2.mime = (o, t) => r2.check(qr$1(Array.isArray(o) ? o : [o], t));
});
function bI(r2) {
  return cu$1(mg$1, r2);
}
var Rg$1 = I("ZodTransform", (r2, i) => {
  Pt$1.init(r2, i), P$1.init(r2, i), r2._zod.processJSONSchema = (o, t, n) => Hu$1(r2, o), r2._zod.parse = (o, t) => {
    if (t.direction === "backward") throw new cr(r2.constructor.name);
    o.addIssue = (v) => {
      if (typeof v === "string") o.issues.push(k$3.issue(v, o.value, i));
      else {
        let $2 = v;
        if ($2.fatal) $2.continue = false;
        $2.code ?? ($2.code = "custom"), $2.input ?? ($2.input = o.value), $2.inst ?? ($2.inst = r2), o.issues.push(k$3.issue($2));
      }
    };
    let n = i.transform(o.value, o);
    if (n instanceof Promise) return n.then((v) => {
      return o.value = v, o;
    });
    return o.value = n, o;
  };
});
function cv$1(r2) {
  return new Rg$1({ type: "transform", transform: r2 });
}
var _v$1 = I("ZodOptional", (r2, i) => {
  ui.init(r2, i), P$1.init(r2, i), r2._zod.processJSONSchema = (o, t, n) => Ti$1(r2, o, t, n), r2.unwrap = () => r2._zod.def.innerType;
});
function Ln$1(r2) {
  return new _v$1({ type: "optional", innerType: r2 });
}
var xg$1 = I("ZodExactOptional", (r2, i) => {
  jt$1.init(r2, i), P$1.init(r2, i), r2._zod.processJSONSchema = (o, t, n) => Ti$1(r2, o, t, n), r2.unwrap = () => r2._zod.def.innerType;
});
function Zg$1(r2) {
  return new xg$1({ type: "optional", innerType: r2 });
}
var dg$1 = I("ZodNullable", (r2, i) => {
  Jt.init(r2, i), P$1.init(r2, i), r2._zod.processJSONSchema = (o, t, n) => fu$1(r2, o, t, n), r2.unwrap = () => r2._zod.def.innerType;
});
function En$1(r2) {
  return new dg$1({ type: "nullable", innerType: r2 });
}
function UI(r2) {
  return Ln$1(En$1(r2));
}
var Cg$1 = I("ZodDefault", (r2, i) => {
  Lt$1.init(r2, i), P$1.init(r2, i), r2._zod.processJSONSchema = (o, t, n) => hu$1(r2, o, t, n), r2.unwrap = () => r2._zod.def.innerType, r2.removeDefault = r2.unwrap;
});
function fg$1(r2, i) {
  return new Cg$1({ type: "default", innerType: r2, get defaultValue() {
    return typeof i === "function" ? i() : k$3.shallowClone(i);
  } });
}
var yg$1 = I("ZodPrefault", (r2, i) => {
  Et$1.init(r2, i), P$1.init(r2, i), r2._zod.processJSONSchema = (o, t, n) => au$1(r2, o, t, n), r2.unwrap = () => r2._zod.def.innerType;
});
function hg$1(r2, i) {
  return new yg$1({ type: "prefault", innerType: r2, get defaultValue() {
    return typeof i === "function" ? i() : k$3.shallowClone(i);
  } });
}
var bv$1 = I("ZodNonOptional", (r2, i) => {
  Gt.init(r2, i), P$1.init(r2, i), r2._zod.processJSONSchema = (o, t, n) => yu$1(r2, o, t, n), r2.unwrap = () => r2._zod.def.innerType;
});
function ag$1(r2, i) {
  return new bv$1({ type: "nonoptional", innerType: r2, ...k$3.normalizeParams(i) });
}
var pg$1 = I("ZodSuccess", (r2, i) => {
  Wt$1.init(r2, i), P$1.init(r2, i), r2._zod.processJSONSchema = (o, t, n) => Fu$1(r2, o, t), r2.unwrap = () => r2._zod.def.innerType;
});
function DI(r2) {
  return new pg$1({ type: "success", innerType: r2 });
}
var sg$1 = I("ZodCatch", (r2, i) => {
  Xt$1.init(r2, i), P$1.init(r2, i), r2._zod.processJSONSchema = (o, t, n) => pu$1(r2, o, t, n), r2.unwrap = () => r2._zod.def.innerType, r2.removeCatch = r2.unwrap;
});
function re$1(r2, i) {
  return new sg$1({ type: "catch", innerType: r2, catchValue: typeof i === "function" ? i : () => i });
}
var ne = I("ZodNaN", (r2, i) => {
  At$1.init(r2, i), P$1.init(r2, i), r2._zod.processJSONSchema = (o, t, n) => Yu$1(r2, o);
});
function kI(r2) {
  return lu$1(ne, r2);
}
var Uv$1 = I("ZodPipe", (r2, i) => {
  Vt.init(r2, i), P$1.init(r2, i), r2._zod.processJSONSchema = (o, t, n) => su$1(r2, o, t, n), r2.in = i.in, r2.out = i.out;
});
function Gn$1(r2, i) {
  return new Uv$1({ type: "pipe", in: r2, out: i });
}
var Dv$1 = I("ZodCodec", (r2, i) => {
  Uv$1.init(r2, i), Dn$1.init(r2, i);
});
function wI(r2, i, o) {
  return new Dv$1({ type: "pipe", in: r2, out: i, transform: o.decode, reverseTransform: o.encode });
}
var ie$1 = I("ZodReadonly", (r2, i) => {
  Kt$1.init(r2, i), P$1.init(r2, i), r2._zod.processJSONSchema = (o, t, n) => rg$1(r2, o, t, n), r2.unwrap = () => r2._zod.def.innerType;
});
function ve$1(r2) {
  return new ie$1({ type: "readonly", innerType: r2 });
}
var oe = I("ZodTemplateLiteral", (r2, i) => {
  Yt$1.init(r2, i), P$1.init(r2, i), r2._zod.processJSONSchema = (o, t, n) => Qu$1(r2, o, t);
});
function NI(r2, i) {
  return new oe({ type: "template_literal", parts: r2, ...k$3.normalizeParams(i) });
}
var te = I("ZodLazy", (r2, i) => {
  Ft$1.init(r2, i), P$1.init(r2, i), r2._zod.processJSONSchema = (o, t, n) => ig$1(r2, o, t, n), r2.unwrap = () => r2._zod.def.getter();
});
function $e$1(r2) {
  return new te({ type: "lazy", getter: r2 });
}
var ue$2 = I("ZodPromise", (r2, i) => {
  Tt$1.init(r2, i), P$1.init(r2, i), r2._zod.processJSONSchema = (o, t, n) => ng$1(r2, o, t, n), r2.unwrap = () => r2._zod.def.innerType;
});
function OI(r2) {
  return new ue$2({ type: "promise", innerType: r2 });
}
var ge = I("ZodFunction", (r2, i) => {
  Qt$1.init(r2, i), P$1.init(r2, i), r2._zod.processJSONSchema = (o, t, n) => Bu$1(r2, o);
});
function SI(r2) {
  return new ge({ type: "function", input: Array.isArray(r2?.input) ? Fg$1(r2?.input) : r2?.input ?? An$1(Nr$1()), output: r2?.output ?? Nr$1() });
}
var Qn$1 = I("ZodCustom", (r2, i) => {
  qt$1.init(r2, i), P$1.init(r2, i), r2._zod.processJSONSchema = (o, t, n) => qu$1(r2, o);
});
function zI(r2) {
  let i = new W$1({ check: "custom" });
  return i._zod.check = r2, i;
}
function PI(r2, i) {
  return _u$1(Qn$1, r2 ?? (() => true), i);
}
function ee$2(r2, i = {}) {
  return bu$1(Qn$1, r2, i);
}
function le$2(r2) {
  return Uu$1(r2);
}
var jI = Du$1, JI = ku$1;
function LI(r2, i = {}) {
  let o = new Qn$1({ type: "custom", check: "custom", fn: (t) => t instanceof r2, abort: true, ...k$3.normalizeParams(i) });
  return o._zod.bag.Class = r2, o._zod.check = (t) => {
    if (!(t.value instanceof r2)) t.issues.push({ code: "invalid_type", expected: r2.name, input: t.value, inst: o, path: [...o._zod.def.path ?? []] });
  }, o;
}
var EI = (...r2) => wu$1({ Codec: Dv$1, Boolean: ar, String: fr$1 }, ...r2);
function GI(r2) {
  let i = $e$1(() => {
    return lv$1([Ri$1(r2), Sg$1(), zg$1(), Lg$1(), An$1(i), qg$1(Ri$1(), i)]);
  });
  return i;
}
function WI(r2, i) {
  return Gn$1(cv$1(r2), i);
}
var Kc$1 = { invalid_type: "invalid_type", too_big: "too_big", too_small: "too_small", invalid_format: "invalid_format", not_multiple_of: "not_multiple_of", unrecognized_keys: "unrecognized_keys", invalid_union: "invalid_union", invalid_key: "invalid_key", invalid_element: "invalid_element", invalid_value: "invalid_value", custom: "custom" };
function Yc$1(r2) {
  A$1({ customError: r2 });
}
function Qc$1() {
  return A$1().customError;
}
var Ie$2;
/* @__PURE__ */ (function(r2) {
})(Ie$2 || (Ie$2 = {}));
var S$1 = { ...jn$1, ...qi$1, iso: dr }, Tc$1 = /* @__PURE__ */ new Set(["$schema", "$ref", "$defs", "definitions", "$id", "id", "$comment", "$anchor", "$vocabulary", "$dynamicRef", "$dynamicAnchor", "type", "enum", "const", "anyOf", "oneOf", "allOf", "not", "properties", "required", "additionalProperties", "patternProperties", "propertyNames", "minProperties", "maxProperties", "items", "prefixItems", "additionalItems", "minItems", "maxItems", "uniqueItems", "contains", "minContains", "maxContains", "minLength", "maxLength", "pattern", "format", "minimum", "maximum", "exclusiveMinimum", "exclusiveMaximum", "multipleOf", "description", "default", "contentEncoding", "contentMediaType", "contentSchema", "unevaluatedItems", "unevaluatedProperties", "if", "then", "else", "dependentSchemas", "dependentRequired", "nullable", "readOnly"]);
function Fc$1(r2, i) {
  let o = r2.$schema;
  if (o === "https://json-schema.org/draft/2020-12/schema") return "draft-2020-12";
  if (o === "http://json-schema.org/draft-07/schema#") return "draft-7";
  if (o === "http://json-schema.org/draft-04/schema#") return "draft-4";
  return i ?? "draft-2020-12";
}
function qc$1(r2, i) {
  if (!r2.startsWith("#")) throw Error("External $ref is not supported, only local refs (#/...) are allowed");
  let o = r2.slice(1).split("/").filter(Boolean);
  if (o.length === 0) return i.rootSchema;
  let t = i.version === "draft-2020-12" ? "$defs" : "definitions";
  if (o[0] === t) {
    let n = o[1];
    if (!n || !i.defs[n]) throw Error(`Reference not found: ${r2}`);
    return i.defs[n];
  }
  throw Error(`Reference not found: ${r2}`);
}
function XI(r2, i) {
  if (r2.not !== void 0) {
    if (typeof r2.not === "object" && Object.keys(r2.not).length === 0) return S$1.never();
    throw Error("not is not supported in Zod (except { not: {} } for never)");
  }
  if (r2.unevaluatedItems !== void 0) throw Error("unevaluatedItems is not supported");
  if (r2.unevaluatedProperties !== void 0) throw Error("unevaluatedProperties is not supported");
  if (r2.if !== void 0 || r2.then !== void 0 || r2.else !== void 0) throw Error("Conditional schemas (if/then/else) are not supported");
  if (r2.dependentSchemas !== void 0 || r2.dependentRequired !== void 0) throw Error("dependentSchemas and dependentRequired are not supported");
  if (r2.$ref) {
    let n = r2.$ref;
    if (i.refs.has(n)) return i.refs.get(n);
    if (i.processing.has(n)) return S$1.lazy(() => {
      if (!i.refs.has(n)) throw Error(`Circular reference not resolved: ${n}`);
      return i.refs.get(n);
    });
    i.processing.add(n);
    let v = qc$1(n, i), $2 = K$2(v, i);
    return i.refs.set(n, $2), i.processing.delete(n), $2;
  }
  if (r2.enum !== void 0) {
    let n = r2.enum;
    if (i.version === "openapi-3.0" && r2.nullable === true && n.length === 1 && n[0] === null) return S$1.null();
    if (n.length === 0) return S$1.never();
    if (n.length === 1) return S$1.literal(n[0]);
    if (n.every(($2) => typeof $2 === "string")) return S$1.enum(n);
    let v = n.map(($2) => S$1.literal($2));
    if (v.length < 2) return v[0];
    return S$1.union([v[0], v[1], ...v.slice(2)]);
  }
  if (r2.const !== void 0) return S$1.literal(r2.const);
  let o = r2.type;
  if (Array.isArray(o)) {
    let n = o.map((v) => {
      let $2 = { ...r2, type: v };
      return XI($2, i);
    });
    if (n.length === 0) return S$1.never();
    if (n.length === 1) return n[0];
    return S$1.union(n);
  }
  if (!o) return S$1.any();
  let t;
  switch (o) {
    case "string": {
      let n = S$1.string();
      if (r2.format) {
        let v = r2.format;
        if (v === "email") n = n.check(S$1.email());
        else if (v === "uri" || v === "uri-reference") n = n.check(S$1.url());
        else if (v === "uuid" || v === "guid") n = n.check(S$1.uuid());
        else if (v === "date-time") n = n.check(S$1.iso.datetime());
        else if (v === "date") n = n.check(S$1.iso.date());
        else if (v === "time") n = n.check(S$1.iso.time());
        else if (v === "duration") n = n.check(S$1.iso.duration());
        else if (v === "ipv4") n = n.check(S$1.ipv4());
        else if (v === "ipv6") n = n.check(S$1.ipv6());
        else if (v === "mac") n = n.check(S$1.mac());
        else if (v === "cidr") n = n.check(S$1.cidrv4());
        else if (v === "cidr-v6") n = n.check(S$1.cidrv6());
        else if (v === "base64") n = n.check(S$1.base64());
        else if (v === "base64url") n = n.check(S$1.base64url());
        else if (v === "e164") n = n.check(S$1.e164());
        else if (v === "jwt") n = n.check(S$1.jwt());
        else if (v === "emoji") n = n.check(S$1.emoji());
        else if (v === "nanoid") n = n.check(S$1.nanoid());
        else if (v === "cuid") n = n.check(S$1.cuid());
        else if (v === "cuid2") n = n.check(S$1.cuid2());
        else if (v === "ulid") n = n.check(S$1.ulid());
        else if (v === "xid") n = n.check(S$1.xid());
        else if (v === "ksuid") n = n.check(S$1.ksuid());
      }
      if (typeof r2.minLength === "number") n = n.min(r2.minLength);
      if (typeof r2.maxLength === "number") n = n.max(r2.maxLength);
      if (r2.pattern) n = n.regex(new RegExp(r2.pattern));
      t = n;
      break;
    }
    case "number":
    case "integer": {
      let n = o === "integer" ? S$1.number().int() : S$1.number();
      if (typeof r2.minimum === "number") n = n.min(r2.minimum);
      if (typeof r2.maximum === "number") n = n.max(r2.maximum);
      if (typeof r2.exclusiveMinimum === "number") n = n.gt(r2.exclusiveMinimum);
      else if (r2.exclusiveMinimum === true && typeof r2.minimum === "number") n = n.gt(r2.minimum);
      if (typeof r2.exclusiveMaximum === "number") n = n.lt(r2.exclusiveMaximum);
      else if (r2.exclusiveMaximum === true && typeof r2.maximum === "number") n = n.lt(r2.maximum);
      if (typeof r2.multipleOf === "number") n = n.multipleOf(r2.multipleOf);
      t = n;
      break;
    }
    case "boolean": {
      t = S$1.boolean();
      break;
    }
    case "null": {
      t = S$1.null();
      break;
    }
    case "object": {
      let n = {}, v = r2.properties || {}, $2 = new Set(r2.required || []);
      for (let [l, e] of Object.entries(v)) {
        let c = K$2(e, i);
        n[l] = $2.has(l) ? c : c.optional();
      }
      if (r2.propertyNames) {
        let l = K$2(r2.propertyNames, i), e = r2.additionalProperties && typeof r2.additionalProperties === "object" ? K$2(r2.additionalProperties, i) : S$1.any();
        if (Object.keys(n).length === 0) {
          t = S$1.record(l, e);
          break;
        }
        let c = S$1.object(n).passthrough(), b = S$1.looseRecord(l, e);
        t = S$1.intersection(c, b);
        break;
      }
      if (r2.patternProperties) {
        let l = r2.patternProperties, e = Object.keys(l), c = [];
        for (let N2 of e) {
          let O = K$2(l[N2], i), J2 = S$1.string().regex(new RegExp(N2));
          c.push(S$1.looseRecord(J2, O));
        }
        let b = [];
        if (Object.keys(n).length > 0) b.push(S$1.object(n).passthrough());
        if (b.push(...c), b.length === 0) t = S$1.object({}).passthrough();
        else if (b.length === 1) t = b[0];
        else {
          let N2 = S$1.intersection(b[0], b[1]);
          for (let O = 2; O < b.length; O++) N2 = S$1.intersection(N2, b[O]);
          t = N2;
        }
        break;
      }
      let u2 = S$1.object(n);
      if (r2.additionalProperties === false) t = u2.strict();
      else if (typeof r2.additionalProperties === "object") t = u2.catchall(K$2(r2.additionalProperties, i));
      else t = u2.passthrough();
      break;
    }
    case "array": {
      let { prefixItems: n, items: v } = r2;
      if (n && Array.isArray(n)) {
        let $2 = n.map((l) => K$2(l, i)), u2 = v && typeof v === "object" && !Array.isArray(v) ? K$2(v, i) : void 0;
        if (u2) t = S$1.tuple($2).rest(u2);
        else t = S$1.tuple($2);
        if (typeof r2.minItems === "number") t = t.check(S$1.minLength(r2.minItems));
        if (typeof r2.maxItems === "number") t = t.check(S$1.maxLength(r2.maxItems));
      } else if (Array.isArray(v)) {
        let $2 = v.map((l) => K$2(l, i)), u2 = r2.additionalItems && typeof r2.additionalItems === "object" ? K$2(r2.additionalItems, i) : void 0;
        if (u2) t = S$1.tuple($2).rest(u2);
        else t = S$1.tuple($2);
        if (typeof r2.minItems === "number") t = t.check(S$1.minLength(r2.minItems));
        if (typeof r2.maxItems === "number") t = t.check(S$1.maxLength(r2.maxItems));
      } else if (v !== void 0) {
        let $2 = K$2(v, i), u2 = S$1.array($2);
        if (typeof r2.minItems === "number") u2 = u2.min(r2.minItems);
        if (typeof r2.maxItems === "number") u2 = u2.max(r2.maxItems);
        t = u2;
      } else t = S$1.array(S$1.any());
      break;
    }
    default:
      throw Error(`Unsupported type: ${o}`);
  }
  if (r2.description) t = t.describe(r2.description);
  if (r2.default !== void 0) t = t.default(r2.default);
  return t;
}
function K$2(r2, i) {
  if (typeof r2 === "boolean") return r2 ? S$1.any() : S$1.never();
  let o = XI(r2, i), t = r2.type || r2.enum !== void 0 || r2.const !== void 0;
  if (r2.anyOf && Array.isArray(r2.anyOf)) {
    let u2 = r2.anyOf.map((e) => K$2(e, i)), l = S$1.union(u2);
    o = t ? S$1.intersection(o, l) : l;
  }
  if (r2.oneOf && Array.isArray(r2.oneOf)) {
    let u2 = r2.oneOf.map((e) => K$2(e, i)), l = S$1.xor(u2);
    o = t ? S$1.intersection(o, l) : l;
  }
  if (r2.allOf && Array.isArray(r2.allOf)) if (r2.allOf.length === 0) o = t ? o : S$1.any();
  else {
    let u2 = t ? o : K$2(r2.allOf[0], i), l = t ? 0 : 1;
    for (let e = l; e < r2.allOf.length; e++) u2 = S$1.intersection(u2, K$2(r2.allOf[e], i));
    o = u2;
  }
  if (r2.nullable === true && i.version === "openapi-3.0") o = S$1.nullable(o);
  if (r2.readOnly === true) o = S$1.readonly(o);
  let n = {}, v = ["$id", "id", "$comment", "$anchor", "$vocabulary", "$dynamicRef", "$dynamicAnchor"];
  for (let u2 of v) if (u2 in r2) n[u2] = r2[u2];
  let $2 = ["contentEncoding", "contentMediaType", "contentSchema"];
  for (let u2 of $2) if (u2 in r2) n[u2] = r2[u2];
  for (let u2 of Object.keys(r2)) if (!Tc$1.has(u2)) n[u2] = r2[u2];
  if (Object.keys(n).length > 0) i.registry.add(o, n);
  return o;
}
function AI(r2, i) {
  if (typeof r2 === "boolean") return r2 ? S$1.any() : S$1.never();
  let o = Fc$1(r2, i?.defaultTarget), t = r2.$defs || r2.definitions || {}, n = { version: o, defs: t, refs: /* @__PURE__ */ new Map(), processing: /* @__PURE__ */ new Set(), rootSchema: r2, registry: i?.registry ?? V };
  return K$2(r2, n);
}
var ce$1 = {};
s(ce$1, { string: () => Bc$1, number: () => Hc$1, date: () => Rc$1, boolean: () => Mc$1, bigint: () => mc$1 });
function Bc$1(r2) {
  return Q$(fr$1, r2);
}
function Hc$1(r2) {
  return R$(hr$1, r2);
}
function Mc$1(r2) {
  return h$(ar, r2);
}
function mc$1(r2) {
  return p$(pr$1, r2);
}
function Rc$1(r2) {
  return eu$1(Xn$1, r2);
}
A$1(kn$1());
var YI = g.union([g.literal("light"), g.literal("dark")]).describe("Color theme preference for the host environment."), sr = g.union([g.literal("inline"), g.literal("fullscreen"), g.literal("pip")]).describe("Display mode for UI presentation."), Cc$1 = g.union([g.literal("--color-background-primary"), g.literal("--color-background-secondary"), g.literal("--color-background-tertiary"), g.literal("--color-background-inverse"), g.literal("--color-background-ghost"), g.literal("--color-background-info"), g.literal("--color-background-danger"), g.literal("--color-background-success"), g.literal("--color-background-warning"), g.literal("--color-background-disabled"), g.literal("--color-text-primary"), g.literal("--color-text-secondary"), g.literal("--color-text-tertiary"), g.literal("--color-text-inverse"), g.literal("--color-text-ghost"), g.literal("--color-text-info"), g.literal("--color-text-danger"), g.literal("--color-text-success"), g.literal("--color-text-warning"), g.literal("--color-text-disabled"), g.literal("--color-text-ghost"), g.literal("--color-border-primary"), g.literal("--color-border-secondary"), g.literal("--color-border-tertiary"), g.literal("--color-border-inverse"), g.literal("--color-border-ghost"), g.literal("--color-border-info"), g.literal("--color-border-danger"), g.literal("--color-border-success"), g.literal("--color-border-warning"), g.literal("--color-border-disabled"), g.literal("--color-ring-primary"), g.literal("--color-ring-secondary"), g.literal("--color-ring-inverse"), g.literal("--color-ring-info"), g.literal("--color-ring-danger"), g.literal("--color-ring-success"), g.literal("--color-ring-warning"), g.literal("--font-sans"), g.literal("--font-mono"), g.literal("--font-weight-normal"), g.literal("--font-weight-medium"), g.literal("--font-weight-semibold"), g.literal("--font-weight-bold"), g.literal("--font-text-xs-size"), g.literal("--font-text-sm-size"), g.literal("--font-text-md-size"), g.literal("--font-text-lg-size"), g.literal("--font-heading-xs-size"), g.literal("--font-heading-sm-size"), g.literal("--font-heading-md-size"), g.literal("--font-heading-lg-size"), g.literal("--font-heading-xl-size"), g.literal("--font-heading-2xl-size"), g.literal("--font-heading-3xl-size"), g.literal("--font-text-xs-line-height"), g.literal("--font-text-sm-line-height"), g.literal("--font-text-md-line-height"), g.literal("--font-text-lg-line-height"), g.literal("--font-heading-xs-line-height"), g.literal("--font-heading-sm-line-height"), g.literal("--font-heading-md-line-height"), g.literal("--font-heading-lg-line-height"), g.literal("--font-heading-xl-line-height"), g.literal("--font-heading-2xl-line-height"), g.literal("--font-heading-3xl-line-height"), g.literal("--border-radius-xs"), g.literal("--border-radius-sm"), g.literal("--border-radius-md"), g.literal("--border-radius-lg"), g.literal("--border-radius-xl"), g.literal("--border-radius-full"), g.literal("--border-width-regular"), g.literal("--shadow-hairline"), g.literal("--shadow-sm"), g.literal("--shadow-md"), g.literal("--shadow-lg")]).describe("CSS variable keys available to MCP apps for theming."), fc$1 = g.record(Cc$1.describe(`Style variables for theming MCP apps.

Individual style keys are optional - hosts may provide any subset of these values.
Values are strings containing CSS values (colors, sizes, font stacks, etc.).

Note: This type uses \`Record<K, string | undefined>\` rather than \`Partial<Record<K, string>>\`
for compatibility with Zod schema generation. Both are functionally equivalent for validation.`), g.union([g.string(), g.undefined()]).describe(`Style variables for theming MCP apps.

Individual style keys are optional - hosts may provide any subset of these values.
Values are strings containing CSS values (colors, sizes, font stacks, etc.).

Note: This type uses \`Record<K, string | undefined>\` rather than \`Partial<Record<K, string>>\`
for compatibility with Zod schema generation. Both are functionally equivalent for validation.`)).describe(`Style variables for theming MCP apps.

Individual style keys are optional - hosts may provide any subset of these values.
Values are strings containing CSS values (colors, sizes, font stacks, etc.).

Note: This type uses \`Record<K, string | undefined>\` rather than \`Partial<Record<K, string>>\`
for compatibility with Zod schema generation. Both are functionally equivalent for validation.`);
g.object({ method: g.literal("ui/open-link"), params: g.object({ url: g.string().describe("URL to open in the host's browser") }) });
g.object({ isError: g.boolean().optional().describe("True if the host failed to open the URL (e.g., due to security policy).") }).passthrough();
g.object({ isError: g.boolean().optional().describe("True if the host rejected or failed to deliver the message.") }).passthrough();
g.object({ method: g.literal("ui/notifications/sandbox-proxy-ready"), params: g.object({}) });
var kv$1 = g.object({ connectDomains: g.array(g.string()).optional().describe(`Origins for network requests (fetch/XHR/WebSocket).

- Maps to CSP \`connect-src\` directive
- Empty or omitted  no network connections (secure default)`), resourceDomains: g.array(g.string()).optional().describe("Origins for static resources (images, scripts, stylesheets, fonts, media).\n\n- Maps to CSP `img-src`, `script-src`, `style-src`, `font-src`, `media-src` directives\n- Wildcard subdomains supported: `https://*.example.com`\n- Empty or omitted  no network resources (secure default)"), frameDomains: g.array(g.string()).optional().describe("Origins for nested iframes.\n\n- Maps to CSP `frame-src` directive\n- Empty or omitted  no nested iframes allowed (`frame-src 'none'`)"), baseUriDomains: g.array(g.string()).optional().describe("Allowed base URIs for the document.\n\n- Maps to CSP `base-uri` directive\n- Empty or omitted  only same origin allowed (`base-uri 'self'`)") }), wv$1 = g.object({ camera: g.object({}).optional().describe("Request camera access.\n\nMaps to Permission Policy `camera` feature."), microphone: g.object({}).optional().describe("Request microphone access.\n\nMaps to Permission Policy `microphone` feature."), geolocation: g.object({}).optional().describe("Request geolocation access.\n\nMaps to Permission Policy `geolocation` feature."), clipboardWrite: g.object({}).optional().describe("Request clipboard write access.\n\nMaps to Permission Policy `clipboard-write` feature.") });
g.object({ method: g.literal("ui/notifications/size-changed"), params: g.object({ width: g.number().optional().describe("New width in pixels."), height: g.number().optional().describe("New height in pixels.") }) });
g.object({ method: g.literal("ui/notifications/tool-input"), params: g.object({ arguments: g.record(g.string(), g.unknown().describe("Complete tool call arguments as key-value pairs.")).optional().describe("Complete tool call arguments as key-value pairs.") }) });
g.object({ method: g.literal("ui/notifications/tool-input-partial"), params: g.object({ arguments: g.record(g.string(), g.unknown().describe("Partial tool call arguments (incomplete, may change).")).optional().describe("Partial tool call arguments (incomplete, may change).") }) });
g.object({ method: g.literal("ui/notifications/tool-cancelled"), params: g.object({ reason: g.string().optional().describe('Optional reason for the cancellation (e.g., "user action", "timeout").') }) });
var QI = g.object({ fonts: g.string().optional() }), TI = g.object({ variables: fc$1.optional().describe("CSS variables for theming the app."), css: QI.optional().describe("CSS blocks that apps can inject.") });
g.object({ method: g.literal("ui/resource-teardown"), params: g.object({}) });
g.record(g.string(), g.unknown());
var _e$1 = g.object({ text: g.object({}).optional().describe("Host supports text content blocks."), image: g.object({}).optional().describe("Host supports image content blocks."), audio: g.object({}).optional().describe("Host supports audio content blocks."), resource: g.object({}).optional().describe("Host supports resource content blocks."), resourceLink: g.object({}).optional().describe("Host supports resource link content blocks."), structuredContent: g.object({}).optional().describe("Host supports structured content.") }), FI = g.object({ experimental: g.object({}).optional().describe("Experimental features (structure TBD)."), openLinks: g.object({}).optional().describe("Host supports opening external URLs."), serverTools: g.object({ listChanged: g.boolean().optional().describe("Host supports tools/list_changed notifications.") }).optional().describe("Host can proxy tool calls to the MCP server."), serverResources: g.object({ listChanged: g.boolean().optional().describe("Host supports resources/list_changed notifications.") }).optional().describe("Host can proxy resource reads to the MCP server."), logging: g.object({}).optional().describe("Host accepts log messages."), sandbox: g.object({ permissions: wv$1.optional().describe("Permissions granted by the host (camera, microphone, geolocation)."), csp: kv$1.optional().describe("CSP domains approved by the host.") }).optional().describe("Sandbox configuration applied by the host."), updateModelContext: _e$1.optional().describe("Host accepts context updates (ui/update-model-context) to be included in the model's context for future turns."), message: _e$1.optional().describe("Host supports receiving content messages (ui/message) from the view.") }), qI = g.object({ experimental: g.object({}).optional().describe("Experimental features (structure TBD)."), tools: g.object({ listChanged: g.boolean().optional().describe("App supports tools/list_changed notifications.") }).optional().describe("App exposes MCP-style tools that the host can call."), availableDisplayModes: g.array(sr).optional().describe("Display modes the app supports.") });
g.object({ method: g.literal("ui/notifications/initialized"), params: g.object({}).optional() });
g.object({ csp: kv$1.optional().describe("Content Security Policy configuration for UI resources."), permissions: wv$1.optional().describe("Sandbox permissions requested by the UI resource."), domain: g.string().optional().describe(`Dedicated origin for view sandbox.

Useful when views need stable, dedicated origins for OAuth callbacks, CORS policies, or API key allowlists.

**Host-dependent:** The format and validation rules for this field are determined by each host. Servers MUST consult host-specific documentation for the expected domain format. Common patterns include:
- Hash-based subdomains (e.g., \`{hash}.claudemcpcontent.com\`)
- URL-derived subdomains (e.g., \`www-example-com.oaiusercontent.com\`)

If omitted, host uses default sandbox origin (typically per-conversation).`), prefersBorder: g.boolean().optional().describe(`Visual boundary preference - true if view prefers a visible border.

Boolean requesting whether a visible border and background is provided by the host. Specifying an explicit value for this is recommended because hosts' defaults may vary.

- \`true\`: request visible border + background
- \`false\`: request no visible border + background
- omitted: host decides border`) });
g.object({ method: g.literal("ui/request-display-mode"), params: g.object({ mode: sr.describe("The display mode being requested.") }) });
g.object({ mode: sr.describe("The display mode that was actually set. May differ from requested if not supported.") }).passthrough();
var BI = g.union([g.literal("model"), g.literal("app")]).describe("Tool visibility scope - who can access the tool.");
g.object({ resourceUri: g.string().optional(), visibility: g.array(BI).optional().describe(`Who can access this tool. Default: ["model", "app"]
- "model": Tool visible to and callable by the agent
- "app": Tool callable by the app from this server only`) });
g.object({ mimeTypes: g.array(g.string()).optional().describe('Array of supported MIME types for UI resources.\nMust include `"text/html;profile=mcp-app"` for MCP Apps support.') });
g.object({ method: g.literal("ui/message"), params: g.object({ role: g.literal("user").describe('Message role, currently only "user" is supported.'), content: g.array(ContentBlockSchema).describe("Message content blocks (text, image, etc.).") }) });
g.object({ method: g.literal("ui/notifications/sandbox-resource-ready"), params: g.object({ html: g.string().describe("HTML content to load into the inner iframe."), sandbox: g.string().optional().describe("Optional override for the inner iframe's sandbox attribute."), csp: kv$1.optional().describe("CSP configuration from resource metadata."), permissions: wv$1.optional().describe("Sandbox permissions from resource metadata.") }) });
g.object({ method: g.literal("ui/notifications/tool-result"), params: CallToolResultSchema.describe("Standard MCP tool execution result.") });
var Ge$1 = g.object({ toolInfo: g.object({ id: RequestIdSchema.optional().describe("JSON-RPC id of the tools/call request."), tool: ToolSchema.describe("Tool definition including name, inputSchema, etc.") }).optional().describe("Metadata of the tool call that instantiated this App."), theme: YI.optional().describe("Current color theme preference."), styles: TI.optional().describe("Style configuration for theming the app."), displayMode: sr.optional().describe("How the UI is currently displayed."), availableDisplayModes: g.array(sr).optional().describe("Display modes the host supports."), containerDimensions: g.union([g.object({ height: g.number().describe("Fixed container height in pixels.") }), g.object({ maxHeight: g.union([g.number(), g.undefined()]).optional().describe("Maximum container height in pixels.") })]).and(g.union([g.object({ width: g.number().describe("Fixed container width in pixels.") }), g.object({ maxWidth: g.union([g.number(), g.undefined()]).optional().describe("Maximum container width in pixels.") })])).optional().describe(`Container dimensions. Represents the dimensions of the iframe or other
container holding the app. Specify either width or maxWidth, and either height or maxHeight.`), locale: g.string().optional().describe("User's language and region preference in BCP 47 format."), timeZone: g.string().optional().describe("User's timezone in IANA format."), userAgent: g.string().optional().describe("Host application identifier."), platform: g.union([g.literal("web"), g.literal("desktop"), g.literal("mobile")]).optional().describe("Platform type for responsive design decisions."), deviceCapabilities: g.object({ touch: g.boolean().optional().describe("Whether the device supports touch input."), hover: g.boolean().optional().describe("Whether the device supports hover interactions.") }).optional().describe("Device input capabilities."), safeAreaInsets: g.object({ top: g.number().describe("Top safe area inset in pixels."), right: g.number().describe("Right safe area inset in pixels."), bottom: g.number().describe("Bottom safe area inset in pixels."), left: g.number().describe("Left safe area inset in pixels.") }).optional().describe("Mobile safe area boundaries in pixels.") }).passthrough();
g.object({ method: g.literal("ui/notifications/host-context-changed"), params: Ge$1.describe("Partial context update containing only changed fields.") });
g.object({ method: g.literal("ui/update-model-context"), params: g.object({ content: g.array(ContentBlockSchema).optional().describe("Context content blocks (text, image, etc.)."), structuredContent: g.record(g.string(), g.unknown().describe("Structured content for machine-readable context data.")).optional().describe("Structured content for machine-readable context data.") }) });
g.object({ method: g.literal("ui/initialize"), params: g.object({ appInfo: ImplementationSchema.describe("App identification (name and version)."), appCapabilities: qI.describe("Features and capabilities this app provides."), protocolVersion: g.string().describe("Protocol version this app supports.") }) });
g.object({ protocolVersion: g.string().describe('Negotiated protocol version string (e.g., "2025-11-21").'), hostInfo: ImplementationSchema.describe("Host application identification and version."), hostCapabilities: FI.describe("Features and capabilities provided by the host."), hostContext: Ge$1.describe("Rich context about the host environment.") }).passthrough();
var Ke = "ui/resourceUri";
function pk(r2) {
  let o = r2._meta?.ui?.resourceUri;
  if (o === void 0) o = r2._meta?.[Ke];
  if (typeof o === "string" && o.startsWith("ui://")) return o;
  else if (o !== void 0) throw Error(`Invalid UI resource URI: ${JSON.stringify(o)}`);
  return;
}
const EMPTY_DEBUGGER_STATE = {
  isInitiatingAuth: false,
  oauthTokens: null,
  oauthStep: "metadata_discovery",
  oauthMetadata: null,
  resourceMetadata: null,
  resourceMetadataError: null,
  resource: null,
  authServerUrl: null,
  oauthClientInfo: null,
  authorizationUrl: null,
  authorizationCode: "",
  latestError: null,
  statusMessage: null,
  validationError: null
};
let crypto$1;
crypto$1 = globalThis.crypto;
async function getRandomValues(size2) {
  return (await crypto$1).getRandomValues(new Uint8Array(size2));
}
async function random(size2) {
  const mask = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~";
  const evenDistCutoff = Math.pow(2, 8) - Math.pow(2, 8) % mask.length;
  let result = "";
  while (result.length < size2) {
    const randomBytes = await getRandomValues(size2 - result.length);
    for (const randomByte of randomBytes) {
      if (randomByte < evenDistCutoff) {
        result += mask[randomByte % mask.length];
      }
    }
  }
  return result;
}
async function generateVerifier(length) {
  return await random(length);
}
async function generateChallenge(code_verifier) {
  const buffer = await (await crypto$1).subtle.digest("SHA-256", new TextEncoder().encode(code_verifier));
  return btoa(String.fromCharCode(...new Uint8Array(buffer))).replace(/\//g, "_").replace(/\+/g, "-").replace(/=/g, "");
}
async function pkceChallenge(length) {
  if (!length)
    length = 43;
  if (length < 43 || length > 128) {
    throw `Expected a length between 43 and 128. Received ${length}.`;
  }
  const verifier = await generateVerifier(length);
  const challenge = await generateChallenge(verifier);
  return {
    code_verifier: verifier,
    code_challenge: challenge
  };
}
function resourceUrlFromServerUrl(url2) {
  const resourceURL = typeof url2 === "string" ? new URL(url2) : new URL(url2.href);
  resourceURL.hash = "";
  return resourceURL;
}
function checkResourceAllowed({ requestedResource, configuredResource }) {
  const requested = typeof requestedResource === "string" ? new URL(requestedResource) : new URL(requestedResource.href);
  const configured = typeof configuredResource === "string" ? new URL(configuredResource) : new URL(configuredResource.href);
  if (requested.origin !== configured.origin) {
    return false;
  }
  if (requested.pathname.length < configured.pathname.length) {
    return false;
  }
  const requestedPath = requested.pathname.endsWith("/") ? requested.pathname : requested.pathname + "/";
  const configuredPath = configured.pathname.endsWith("/") ? configured.pathname : configured.pathname + "/";
  return requestedPath.startsWith(configuredPath);
}
class OAuthError extends Error {
  constructor(message, errorUri) {
    super(message);
    this.errorUri = errorUri;
    this.name = this.constructor.name;
  }
  /**
   * Converts the error to a standard OAuth error response object
   */
  toResponseObject() {
    const response = {
      error: this.errorCode,
      error_description: this.message
    };
    if (this.errorUri) {
      response.error_uri = this.errorUri;
    }
    return response;
  }
  get errorCode() {
    return this.constructor.errorCode;
  }
}
class InvalidRequestError extends OAuthError {
}
InvalidRequestError.errorCode = "invalid_request";
class InvalidClientError extends OAuthError {
}
InvalidClientError.errorCode = "invalid_client";
class InvalidGrantError extends OAuthError {
}
InvalidGrantError.errorCode = "invalid_grant";
class UnauthorizedClientError extends OAuthError {
}
UnauthorizedClientError.errorCode = "unauthorized_client";
class UnsupportedGrantTypeError extends OAuthError {
}
UnsupportedGrantTypeError.errorCode = "unsupported_grant_type";
class InvalidScopeError extends OAuthError {
}
InvalidScopeError.errorCode = "invalid_scope";
class AccessDeniedError extends OAuthError {
}
AccessDeniedError.errorCode = "access_denied";
class ServerError extends OAuthError {
}
ServerError.errorCode = "server_error";
class TemporarilyUnavailableError extends OAuthError {
}
TemporarilyUnavailableError.errorCode = "temporarily_unavailable";
class UnsupportedResponseTypeError extends OAuthError {
}
UnsupportedResponseTypeError.errorCode = "unsupported_response_type";
class UnsupportedTokenTypeError extends OAuthError {
}
UnsupportedTokenTypeError.errorCode = "unsupported_token_type";
class InvalidTokenError extends OAuthError {
}
InvalidTokenError.errorCode = "invalid_token";
class MethodNotAllowedError extends OAuthError {
}
MethodNotAllowedError.errorCode = "method_not_allowed";
class TooManyRequestsError extends OAuthError {
}
TooManyRequestsError.errorCode = "too_many_requests";
class InvalidClientMetadataError extends OAuthError {
}
InvalidClientMetadataError.errorCode = "invalid_client_metadata";
class InsufficientScopeError extends OAuthError {
}
InsufficientScopeError.errorCode = "insufficient_scope";
class InvalidTargetError extends OAuthError {
}
InvalidTargetError.errorCode = "invalid_target";
const OAUTH_ERRORS = {
  [InvalidRequestError.errorCode]: InvalidRequestError,
  [InvalidClientError.errorCode]: InvalidClientError,
  [InvalidGrantError.errorCode]: InvalidGrantError,
  [UnauthorizedClientError.errorCode]: UnauthorizedClientError,
  [UnsupportedGrantTypeError.errorCode]: UnsupportedGrantTypeError,
  [InvalidScopeError.errorCode]: InvalidScopeError,
  [AccessDeniedError.errorCode]: AccessDeniedError,
  [ServerError.errorCode]: ServerError,
  [TemporarilyUnavailableError.errorCode]: TemporarilyUnavailableError,
  [UnsupportedResponseTypeError.errorCode]: UnsupportedResponseTypeError,
  [UnsupportedTokenTypeError.errorCode]: UnsupportedTokenTypeError,
  [InvalidTokenError.errorCode]: InvalidTokenError,
  [MethodNotAllowedError.errorCode]: MethodNotAllowedError,
  [TooManyRequestsError.errorCode]: TooManyRequestsError,
  [InvalidClientMetadataError.errorCode]: InvalidClientMetadataError,
  [InsufficientScopeError.errorCode]: InsufficientScopeError,
  [InvalidTargetError.errorCode]: InvalidTargetError
};
class UnauthorizedError extends Error {
  constructor(message) {
    super(message ?? "Unauthorized");
  }
}
function isClientAuthMethod(method) {
  return ["client_secret_basic", "client_secret_post", "none"].includes(method);
}
const AUTHORIZATION_CODE_RESPONSE_TYPE = "code";
const AUTHORIZATION_CODE_CHALLENGE_METHOD = "S256";
function selectClientAuthMethod(clientInformation, supportedMethods) {
  const hasClientSecret = clientInformation.client_secret !== void 0;
  if (supportedMethods.length === 0) {
    return hasClientSecret ? "client_secret_post" : "none";
  }
  if ("token_endpoint_auth_method" in clientInformation && clientInformation.token_endpoint_auth_method && isClientAuthMethod(clientInformation.token_endpoint_auth_method) && supportedMethods.includes(clientInformation.token_endpoint_auth_method)) {
    return clientInformation.token_endpoint_auth_method;
  }
  if (hasClientSecret && supportedMethods.includes("client_secret_basic")) {
    return "client_secret_basic";
  }
  if (hasClientSecret && supportedMethods.includes("client_secret_post")) {
    return "client_secret_post";
  }
  if (supportedMethods.includes("none")) {
    return "none";
  }
  return hasClientSecret ? "client_secret_post" : "none";
}
function applyClientAuthentication(method, clientInformation, headers, params) {
  const { client_id, client_secret } = clientInformation;
  switch (method) {
    case "client_secret_basic":
      applyBasicAuth(client_id, client_secret, headers);
      return;
    case "client_secret_post":
      applyPostAuth(client_id, client_secret, params);
      return;
    case "none":
      applyPublicAuth(client_id, params);
      return;
    default:
      throw new Error(`Unsupported client authentication method: ${method}`);
  }
}
function applyBasicAuth(clientId, clientSecret, headers) {
  if (!clientSecret) {
    throw new Error("client_secret_basic authentication requires a client_secret");
  }
  const credentials = btoa(`${clientId}:${clientSecret}`);
  headers.set("Authorization", `Basic ${credentials}`);
}
function applyPostAuth(clientId, clientSecret, params) {
  params.set("client_id", clientId);
  if (clientSecret) {
    params.set("client_secret", clientSecret);
  }
}
function applyPublicAuth(clientId, params) {
  params.set("client_id", clientId);
}
async function parseErrorResponse(input) {
  const statusCode = input instanceof Response ? input.status : void 0;
  const body = input instanceof Response ? await input.text() : input;
  try {
    const result = OAuthErrorResponseSchema.parse(JSON.parse(body));
    const { error, error_description, error_uri } = result;
    const errorClass = OAUTH_ERRORS[error] || ServerError;
    return new errorClass(error_description || "", error_uri);
  } catch (error) {
    const errorMessage = `${statusCode ? `HTTP ${statusCode}: ` : ""}Invalid OAuth error response: ${error}. Raw body: ${body}`;
    return new ServerError(errorMessage);
  }
}
async function auth(provider, options) {
  try {
    return await authInternal(provider, options);
  } catch (error) {
    if (error instanceof InvalidClientError || error instanceof UnauthorizedClientError) {
      await provider.invalidateCredentials?.("all");
      return await authInternal(provider, options);
    } else if (error instanceof InvalidGrantError) {
      await provider.invalidateCredentials?.("tokens");
      return await authInternal(provider, options);
    }
    throw error;
  }
}
async function authInternal(provider, { serverUrl, authorizationCode, scope: scope2, resourceMetadataUrl, fetchFn }) {
  const cachedState = await provider.discoveryState?.();
  let resourceMetadata;
  let authorizationServerUrl;
  let metadata2;
  let effectiveResourceMetadataUrl = resourceMetadataUrl;
  if (!effectiveResourceMetadataUrl && cachedState?.resourceMetadataUrl) {
    effectiveResourceMetadataUrl = new URL(cachedState.resourceMetadataUrl);
  }
  if (cachedState?.authorizationServerUrl) {
    authorizationServerUrl = cachedState.authorizationServerUrl;
    resourceMetadata = cachedState.resourceMetadata;
    metadata2 = cachedState.authorizationServerMetadata ?? await discoverAuthorizationServerMetadata(authorizationServerUrl, { fetchFn });
    if (!resourceMetadata) {
      try {
        resourceMetadata = await discoverOAuthProtectedResourceMetadata(serverUrl, { resourceMetadataUrl: effectiveResourceMetadataUrl }, fetchFn);
      } catch {
      }
    }
    if (metadata2 !== cachedState.authorizationServerMetadata || resourceMetadata !== cachedState.resourceMetadata) {
      await provider.saveDiscoveryState?.({
        authorizationServerUrl: String(authorizationServerUrl),
        resourceMetadataUrl: effectiveResourceMetadataUrl?.toString(),
        resourceMetadata,
        authorizationServerMetadata: metadata2
      });
    }
  } else {
    const serverInfo = await discoverOAuthServerInfo(serverUrl, { resourceMetadataUrl: effectiveResourceMetadataUrl, fetchFn });
    authorizationServerUrl = serverInfo.authorizationServerUrl;
    metadata2 = serverInfo.authorizationServerMetadata;
    resourceMetadata = serverInfo.resourceMetadata;
    await provider.saveDiscoveryState?.({
      authorizationServerUrl: String(authorizationServerUrl),
      resourceMetadataUrl: effectiveResourceMetadataUrl?.toString(),
      resourceMetadata,
      authorizationServerMetadata: metadata2
    });
  }
  const resource = await selectResourceURL(serverUrl, provider, resourceMetadata);
  let clientInformation = await Promise.resolve(provider.clientInformation());
  if (!clientInformation) {
    if (authorizationCode !== void 0) {
      throw new Error("Existing OAuth client information is required when exchanging an authorization code");
    }
    const supportsUrlBasedClientId = metadata2?.client_id_metadata_document_supported === true;
    const clientMetadataUrl = provider.clientMetadataUrl;
    if (clientMetadataUrl && !isHttpsUrl(clientMetadataUrl)) {
      throw new InvalidClientMetadataError(`clientMetadataUrl must be a valid HTTPS URL with a non-root pathname, got: ${clientMetadataUrl}`);
    }
    const shouldUseUrlBasedClientId = supportsUrlBasedClientId && clientMetadataUrl;
    if (shouldUseUrlBasedClientId) {
      clientInformation = {
        client_id: clientMetadataUrl
      };
      await provider.saveClientInformation?.(clientInformation);
    } else {
      if (!provider.saveClientInformation) {
        throw new Error("OAuth client information must be saveable for dynamic registration");
      }
      const fullInformation = await registerClient(authorizationServerUrl, {
        metadata: metadata2,
        clientMetadata: provider.clientMetadata,
        fetchFn
      });
      await provider.saveClientInformation(fullInformation);
      clientInformation = fullInformation;
    }
  }
  const nonInteractiveFlow = !provider.redirectUrl;
  if (authorizationCode !== void 0 || nonInteractiveFlow) {
    const tokens2 = await fetchToken(provider, authorizationServerUrl, {
      metadata: metadata2,
      resource,
      authorizationCode,
      fetchFn
    });
    await provider.saveTokens(tokens2);
    return "AUTHORIZED";
  }
  const tokens = await provider.tokens();
  if (tokens?.refresh_token) {
    try {
      const newTokens = await refreshAuthorization(authorizationServerUrl, {
        metadata: metadata2,
        clientInformation,
        refreshToken: tokens.refresh_token,
        resource,
        addClientAuthentication: provider.addClientAuthentication,
        fetchFn
      });
      await provider.saveTokens(newTokens);
      return "AUTHORIZED";
    } catch (error) {
      if (!(error instanceof OAuthError) || error instanceof ServerError) ;
      else {
        throw error;
      }
    }
  }
  const state = provider.state ? await provider.state() : void 0;
  const { authorizationUrl, codeVerifier } = await startAuthorization(authorizationServerUrl, {
    metadata: metadata2,
    clientInformation,
    state,
    redirectUrl: provider.redirectUrl,
    scope: scope2 || resourceMetadata?.scopes_supported?.join(" ") || provider.clientMetadata.scope,
    resource
  });
  await provider.saveCodeVerifier(codeVerifier);
  await provider.redirectToAuthorization(authorizationUrl);
  return "REDIRECT";
}
function isHttpsUrl(value) {
  if (!value)
    return false;
  try {
    const url2 = new URL(value);
    return url2.protocol === "https:" && url2.pathname !== "/";
  } catch {
    return false;
  }
}
async function selectResourceURL(serverUrl, provider, resourceMetadata) {
  const defaultResource = resourceUrlFromServerUrl(serverUrl);
  if (provider.validateResourceURL) {
    return await provider.validateResourceURL(defaultResource, resourceMetadata?.resource);
  }
  if (!resourceMetadata) {
    return void 0;
  }
  if (!checkResourceAllowed({ requestedResource: defaultResource, configuredResource: resourceMetadata.resource })) {
    throw new Error(`Protected resource ${resourceMetadata.resource} does not match expected ${defaultResource} (or origin)`);
  }
  return new URL(resourceMetadata.resource);
}
function extractWWWAuthenticateParams(res) {
  const authenticateHeader = res.headers.get("WWW-Authenticate");
  if (!authenticateHeader) {
    return {};
  }
  const [type2, scheme] = authenticateHeader.split(" ");
  if (type2.toLowerCase() !== "bearer" || !scheme) {
    return {};
  }
  const resourceMetadataMatch = extractFieldFromWwwAuth(res, "resource_metadata") || void 0;
  let resourceMetadataUrl;
  if (resourceMetadataMatch) {
    try {
      resourceMetadataUrl = new URL(resourceMetadataMatch);
    } catch {
    }
  }
  const scope2 = extractFieldFromWwwAuth(res, "scope") || void 0;
  const error = extractFieldFromWwwAuth(res, "error") || void 0;
  return {
    resourceMetadataUrl,
    scope: scope2,
    error
  };
}
function extractFieldFromWwwAuth(response, fieldName) {
  const wwwAuthHeader = response.headers.get("WWW-Authenticate");
  if (!wwwAuthHeader) {
    return null;
  }
  const pattern2 = new RegExp(`${fieldName}=(?:"([^"]+)"|([^\\s,]+))`);
  const match = wwwAuthHeader.match(pattern2);
  if (match) {
    return match[1] || match[2];
  }
  return null;
}
async function discoverOAuthProtectedResourceMetadata(serverUrl, opts, fetchFn = fetch) {
  const response = await discoverMetadataWithFallback(serverUrl, "oauth-protected-resource", fetchFn, {
    protocolVersion: opts?.protocolVersion,
    metadataUrl: opts?.resourceMetadataUrl
  });
  if (!response || response.status === 404) {
    await response?.body?.cancel();
    throw new Error(`Resource server does not implement OAuth 2.0 Protected Resource Metadata.`);
  }
  if (!response.ok) {
    await response.body?.cancel();
    throw new Error(`HTTP ${response.status} trying to load well-known OAuth protected resource metadata.`);
  }
  return OAuthProtectedResourceMetadataSchema.parse(await response.json());
}
async function fetchWithCorsRetry(url2, headers, fetchFn = fetch) {
  try {
    return await fetchFn(url2, { headers });
  } catch (error) {
    if (error instanceof TypeError) {
      if (headers) {
        return fetchWithCorsRetry(url2, void 0, fetchFn);
      } else {
        return void 0;
      }
    }
    throw error;
  }
}
function buildWellKnownPath(wellKnownPrefix, pathname = "", options = {}) {
  if (pathname.endsWith("/")) {
    pathname = pathname.slice(0, -1);
  }
  return options.prependPathname ? `${pathname}/.well-known/${wellKnownPrefix}` : `/.well-known/${wellKnownPrefix}${pathname}`;
}
async function tryMetadataDiscovery(url2, protocolVersion, fetchFn = fetch) {
  const headers = {
    "MCP-Protocol-Version": protocolVersion
  };
  return await fetchWithCorsRetry(url2, headers, fetchFn);
}
function shouldAttemptFallback(response, pathname) {
  return !response || response.status >= 400 && response.status < 500 && pathname !== "/";
}
async function discoverMetadataWithFallback(serverUrl, wellKnownType, fetchFn, opts) {
  const issuer = new URL(serverUrl);
  const protocolVersion = opts?.protocolVersion ?? LATEST_PROTOCOL_VERSION;
  let url2;
  if (opts?.metadataUrl) {
    url2 = new URL(opts.metadataUrl);
  } else {
    const wellKnownPath = buildWellKnownPath(wellKnownType, issuer.pathname);
    url2 = new URL(wellKnownPath, opts?.metadataServerUrl ?? issuer);
    url2.search = issuer.search;
  }
  let response = await tryMetadataDiscovery(url2, protocolVersion, fetchFn);
  if (!opts?.metadataUrl && shouldAttemptFallback(response, issuer.pathname)) {
    const rootUrl = new URL(`/.well-known/${wellKnownType}`, issuer);
    response = await tryMetadataDiscovery(rootUrl, protocolVersion, fetchFn);
  }
  return response;
}
function buildDiscoveryUrls(authorizationServerUrl) {
  const url2 = typeof authorizationServerUrl === "string" ? new URL(authorizationServerUrl) : authorizationServerUrl;
  const hasPath = url2.pathname !== "/";
  const urlsToTry = [];
  if (!hasPath) {
    urlsToTry.push({
      url: new URL("/.well-known/oauth-authorization-server", url2.origin),
      type: "oauth"
    });
    urlsToTry.push({
      url: new URL(`/.well-known/openid-configuration`, url2.origin),
      type: "oidc"
    });
    return urlsToTry;
  }
  let pathname = url2.pathname;
  if (pathname.endsWith("/")) {
    pathname = pathname.slice(0, -1);
  }
  urlsToTry.push({
    url: new URL(`/.well-known/oauth-authorization-server${pathname}`, url2.origin),
    type: "oauth"
  });
  urlsToTry.push({
    url: new URL(`/.well-known/openid-configuration${pathname}`, url2.origin),
    type: "oidc"
  });
  urlsToTry.push({
    url: new URL(`${pathname}/.well-known/openid-configuration`, url2.origin),
    type: "oidc"
  });
  return urlsToTry;
}
async function discoverAuthorizationServerMetadata(authorizationServerUrl, { fetchFn = fetch, protocolVersion = LATEST_PROTOCOL_VERSION } = {}) {
  const headers = {
    "MCP-Protocol-Version": protocolVersion,
    Accept: "application/json"
  };
  const urlsToTry = buildDiscoveryUrls(authorizationServerUrl);
  for (const { url: endpointUrl, type: type2 } of urlsToTry) {
    const response = await fetchWithCorsRetry(endpointUrl, headers, fetchFn);
    if (!response) {
      continue;
    }
    if (!response.ok) {
      await response.body?.cancel();
      if (response.status >= 400 && response.status < 500) {
        continue;
      }
      throw new Error(`HTTP ${response.status} trying to load ${type2 === "oauth" ? "OAuth" : "OpenID provider"} metadata from ${endpointUrl}`);
    }
    if (type2 === "oauth") {
      return OAuthMetadataSchema.parse(await response.json());
    } else {
      return OpenIdProviderDiscoveryMetadataSchema.parse(await response.json());
    }
  }
  return void 0;
}
async function discoverOAuthServerInfo(serverUrl, opts) {
  let resourceMetadata;
  let authorizationServerUrl;
  try {
    resourceMetadata = await discoverOAuthProtectedResourceMetadata(serverUrl, { resourceMetadataUrl: opts?.resourceMetadataUrl }, opts?.fetchFn);
    if (resourceMetadata.authorization_servers && resourceMetadata.authorization_servers.length > 0) {
      authorizationServerUrl = resourceMetadata.authorization_servers[0];
    }
  } catch {
  }
  if (!authorizationServerUrl) {
    authorizationServerUrl = String(new URL("/", serverUrl));
  }
  const authorizationServerMetadata = await discoverAuthorizationServerMetadata(authorizationServerUrl, { fetchFn: opts?.fetchFn });
  return {
    authorizationServerUrl,
    authorizationServerMetadata,
    resourceMetadata
  };
}
async function startAuthorization(authorizationServerUrl, { metadata: metadata2, clientInformation, redirectUrl, scope: scope2, state, resource }) {
  let authorizationUrl;
  if (metadata2) {
    authorizationUrl = new URL(metadata2.authorization_endpoint);
    if (!metadata2.response_types_supported.includes(AUTHORIZATION_CODE_RESPONSE_TYPE)) {
      throw new Error(`Incompatible auth server: does not support response type ${AUTHORIZATION_CODE_RESPONSE_TYPE}`);
    }
    if (metadata2.code_challenge_methods_supported && !metadata2.code_challenge_methods_supported.includes(AUTHORIZATION_CODE_CHALLENGE_METHOD)) {
      throw new Error(`Incompatible auth server: does not support code challenge method ${AUTHORIZATION_CODE_CHALLENGE_METHOD}`);
    }
  } else {
    authorizationUrl = new URL("/authorize", authorizationServerUrl);
  }
  const challenge = await pkceChallenge();
  const codeVerifier = challenge.code_verifier;
  const codeChallenge = challenge.code_challenge;
  authorizationUrl.searchParams.set("response_type", AUTHORIZATION_CODE_RESPONSE_TYPE);
  authorizationUrl.searchParams.set("client_id", clientInformation.client_id);
  authorizationUrl.searchParams.set("code_challenge", codeChallenge);
  authorizationUrl.searchParams.set("code_challenge_method", AUTHORIZATION_CODE_CHALLENGE_METHOD);
  authorizationUrl.searchParams.set("redirect_uri", String(redirectUrl));
  if (state) {
    authorizationUrl.searchParams.set("state", state);
  }
  if (scope2) {
    authorizationUrl.searchParams.set("scope", scope2);
  }
  if (scope2?.includes("offline_access")) {
    authorizationUrl.searchParams.append("prompt", "consent");
  }
  if (resource) {
    authorizationUrl.searchParams.set("resource", resource.href);
  }
  return { authorizationUrl, codeVerifier };
}
function prepareAuthorizationCodeRequest(authorizationCode, codeVerifier, redirectUri) {
  return new URLSearchParams({
    grant_type: "authorization_code",
    code: authorizationCode,
    code_verifier: codeVerifier,
    redirect_uri: String(redirectUri)
  });
}
async function executeTokenRequest(authorizationServerUrl, { metadata: metadata2, tokenRequestParams, clientInformation, addClientAuthentication, resource, fetchFn }) {
  const tokenUrl = metadata2?.token_endpoint ? new URL(metadata2.token_endpoint) : new URL("/token", authorizationServerUrl);
  const headers = new Headers({
    "Content-Type": "application/x-www-form-urlencoded",
    Accept: "application/json"
  });
  if (resource) {
    tokenRequestParams.set("resource", resource.href);
  }
  if (addClientAuthentication) {
    await addClientAuthentication(headers, tokenRequestParams, tokenUrl, metadata2);
  } else if (clientInformation) {
    const supportedMethods = metadata2?.token_endpoint_auth_methods_supported ?? [];
    const authMethod = selectClientAuthMethod(clientInformation, supportedMethods);
    applyClientAuthentication(authMethod, clientInformation, headers, tokenRequestParams);
  }
  const response = await (fetchFn ?? fetch)(tokenUrl, {
    method: "POST",
    headers,
    body: tokenRequestParams
  });
  if (!response.ok) {
    throw await parseErrorResponse(response);
  }
  return OAuthTokensSchema.parse(await response.json());
}
async function exchangeAuthorization(authorizationServerUrl, { metadata: metadata2, clientInformation, authorizationCode, codeVerifier, redirectUri, resource, addClientAuthentication, fetchFn }) {
  const tokenRequestParams = prepareAuthorizationCodeRequest(authorizationCode, codeVerifier, redirectUri);
  return executeTokenRequest(authorizationServerUrl, {
    metadata: metadata2,
    tokenRequestParams,
    clientInformation,
    addClientAuthentication,
    resource,
    fetchFn
  });
}
async function refreshAuthorization(authorizationServerUrl, { metadata: metadata2, clientInformation, refreshToken, resource, addClientAuthentication, fetchFn }) {
  const tokenRequestParams = new URLSearchParams({
    grant_type: "refresh_token",
    refresh_token: refreshToken
  });
  const tokens = await executeTokenRequest(authorizationServerUrl, {
    metadata: metadata2,
    tokenRequestParams,
    clientInformation,
    addClientAuthentication,
    resource,
    fetchFn
  });
  return { refresh_token: refreshToken, ...tokens };
}
async function fetchToken(provider, authorizationServerUrl, { metadata: metadata2, resource, authorizationCode, fetchFn } = {}) {
  const scope2 = provider.clientMetadata.scope;
  let tokenRequestParams;
  if (provider.prepareTokenRequest) {
    tokenRequestParams = await provider.prepareTokenRequest(scope2);
  }
  if (!tokenRequestParams) {
    if (!authorizationCode) {
      throw new Error("Either provider.prepareTokenRequest() or authorizationCode is required");
    }
    if (!provider.redirectUrl) {
      throw new Error("redirectUrl is required for authorization_code flow");
    }
    const codeVerifier = await provider.codeVerifier();
    tokenRequestParams = prepareAuthorizationCodeRequest(authorizationCode, codeVerifier, provider.redirectUrl);
  }
  const clientInformation = await provider.clientInformation();
  return executeTokenRequest(authorizationServerUrl, {
    metadata: metadata2,
    tokenRequestParams,
    clientInformation: clientInformation ?? void 0,
    addClientAuthentication: provider.addClientAuthentication,
    resource,
    fetchFn
  });
}
async function registerClient(authorizationServerUrl, { metadata: metadata2, clientMetadata, fetchFn }) {
  let registrationUrl;
  if (metadata2) {
    if (!metadata2.registration_endpoint) {
      throw new Error("Incompatible auth server: does not support dynamic client registration");
    }
    registrationUrl = new URL(metadata2.registration_endpoint);
  } else {
    registrationUrl = new URL("/register", authorizationServerUrl);
  }
  const response = await (fetchFn ?? fetch)(registrationUrl, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify(clientMetadata)
  });
  if (!response.ok) {
    throw await parseErrorResponse(response);
  }
  return OAuthClientInformationFullSchema.parse(await response.json());
}
const parseOAuthCallbackParams = (location) => {
  const params = new URLSearchParams(location);
  const code2 = params.get("code");
  if (code2) {
    return { successful: true, code: code2 };
  }
  const error = params.get("error");
  const error_description = params.get("error_description");
  const error_uri = params.get("error_uri");
  if (error) {
    return { successful: false, error, error_description, error_uri };
  }
  return {
    successful: false,
    error: "invalid_request",
    error_description: "Missing code or error in response",
    error_uri: null
  };
};
const generateOAuthState = () => {
  const array2 = new Uint8Array(32);
  crypto.getRandomValues(array2);
  return Array.from(array2, (byte) => byte.toString(16).padStart(2, "0")).join(
    ""
  );
};
const generateOAuthErrorDescription = (params) => {
  const error = params.error;
  const errorDescription = params.error_description;
  const errorUri = params.error_uri;
  return [
    `Error: ${error}.`,
    errorDescription ? `Details: ${errorDescription}.` : "",
    errorUri ? `More info: ${errorUri}.` : ""
  ].filter(Boolean).join("\n");
};
const getAuthorizationServerMetadataDiscoveryUrl = (authorizationServerUrl) => {
  const url2 = typeof authorizationServerUrl === "string" ? new URL(authorizationServerUrl) : authorizationServerUrl;
  const hasPath = url2.pathname !== "/";
  if (!hasPath) {
    return new URL("/.well-known/oauth-authorization-server", url2.origin).href;
  }
  const pathname = url2.pathname.endsWith("/") ? url2.pathname.slice(0, -1) : url2.pathname;
  return new URL(
    `/.well-known/oauth-authorization-server${pathname}`,
    url2.origin
  ).href;
};
function validateRedirectUrl(url2) {
  try {
    const parsedUrl = new URL(url2);
    if (parsedUrl.protocol !== "http:" && parsedUrl.protocol !== "https:") {
      throw new Error("Authorization URL must be HTTP or HTTPS");
    }
  } catch (error) {
    if (error instanceof Error && error.message === "Authorization URL must be HTTP or HTTPS") {
      throw error;
    }
    throw new Error(`Invalid URL: ${url2}`);
  }
}
const discoverScopes = async (serverUrl, resourceMetadata) => {
  try {
    const metadata2 = await discoverAuthorizationServerMetadata(
      new URL("/", serverUrl)
    );
    const resourceScopes = resourceMetadata?.scopes_supported;
    const oauthScopes = metadata2?.scopes_supported;
    const scopesSupported = resourceScopes && resourceScopes.length > 0 ? resourceScopes : oauthScopes;
    return scopesSupported && scopesSupported.length > 0 ? scopesSupported.join(" ") : void 0;
  } catch (error) {
    console.debug("OAuth scope discovery failed:", error);
    return void 0;
  }
};
const getClientInformationFromSessionStorage = async ({
  serverUrl,
  isPreregistered
}) => {
  const key = getServerSpecificKey(
    isPreregistered ? SESSION_KEYS.PREREGISTERED_CLIENT_INFORMATION : SESSION_KEYS.CLIENT_INFORMATION,
    serverUrl
  );
  const value = sessionStorage.getItem(key);
  if (!value) {
    return void 0;
  }
  return await OAuthClientInformationSchema.parseAsync(JSON.parse(value));
};
const saveClientInformationToSessionStorage = ({
  serverUrl,
  clientInformation,
  isPreregistered
}) => {
  const key = getServerSpecificKey(
    isPreregistered ? SESSION_KEYS.PREREGISTERED_CLIENT_INFORMATION : SESSION_KEYS.CLIENT_INFORMATION,
    serverUrl
  );
  sessionStorage.setItem(key, JSON.stringify(clientInformation));
};
const clearClientInformationFromSessionStorage = ({
  serverUrl,
  isPreregistered
}) => {
  const key = getServerSpecificKey(
    isPreregistered ? SESSION_KEYS.PREREGISTERED_CLIENT_INFORMATION : SESSION_KEYS.CLIENT_INFORMATION,
    serverUrl
  );
  sessionStorage.removeItem(key);
};
const getScopeFromSessionStorage = (serverUrl) => {
  const key = getServerSpecificKey(SESSION_KEYS.SCOPE, serverUrl);
  const value = sessionStorage.getItem(key);
  return value || void 0;
};
const saveScopeToSessionStorage = (serverUrl, scope2) => {
  const key = getServerSpecificKey(SESSION_KEYS.SCOPE, serverUrl);
  if (scope2) {
    sessionStorage.setItem(key, scope2);
  } else {
    sessionStorage.removeItem(key);
  }
};
const clearScopeFromSessionStorage = (serverUrl) => {
  const key = getServerSpecificKey(SESSION_KEYS.SCOPE, serverUrl);
  sessionStorage.removeItem(key);
};
class InspectorOAuthClientProvider {
  constructor(serverUrl) {
    this.serverUrl = serverUrl;
    sessionStorage.setItem(SESSION_KEYS.SERVER_URL, serverUrl);
  }
  get scope() {
    return getScopeFromSessionStorage(this.serverUrl);
  }
  get redirectUrl() {
    return window.location.origin + "/oauth/callback";
  }
  get debugRedirectUrl() {
    return window.location.origin + "/oauth/callback/debug";
  }
  get redirect_uris() {
    return [.../* @__PURE__ */ new Set([this.redirectUrl, this.debugRedirectUrl])];
  }
  get clientMetadata() {
    const metadata2 = {
      redirect_uris: this.redirect_uris,
      token_endpoint_auth_method: "none",
      grant_types: ["authorization_code", "refresh_token"],
      response_types: ["code"],
      client_name: "MCP Inspector",
      client_uri: "https://github.com/modelcontextprotocol/inspector"
    };
    if (this.scope) {
      metadata2.scope = this.scope;
    }
    return metadata2;
  }
  state() {
    return generateOAuthState();
  }
  async clientInformation() {
    const preregisteredClientInformation = await getClientInformationFromSessionStorage({
      serverUrl: this.serverUrl,
      isPreregistered: true
    });
    return preregisteredClientInformation ?? await getClientInformationFromSessionStorage({
      serverUrl: this.serverUrl,
      isPreregistered: false
    });
  }
  saveClientInformation(clientInformation) {
    saveClientInformationToSessionStorage({
      serverUrl: this.serverUrl,
      clientInformation,
      isPreregistered: false
    });
  }
  async tokens() {
    const key = getServerSpecificKey(SESSION_KEYS.TOKENS, this.serverUrl);
    const tokens = sessionStorage.getItem(key);
    if (!tokens) {
      return void 0;
    }
    return await OAuthTokensSchema.parseAsync(JSON.parse(tokens));
  }
  saveTokens(tokens) {
    const key = getServerSpecificKey(SESSION_KEYS.TOKENS, this.serverUrl);
    sessionStorage.setItem(key, JSON.stringify(tokens));
  }
  redirectToAuthorization(authorizationUrl) {
    validateRedirectUrl(authorizationUrl.href);
    window.location.href = authorizationUrl.href;
  }
  saveCodeVerifier(codeVerifier) {
    const key = getServerSpecificKey(
      SESSION_KEYS.CODE_VERIFIER,
      this.serverUrl
    );
    sessionStorage.setItem(key, codeVerifier);
  }
  codeVerifier() {
    const key = getServerSpecificKey(
      SESSION_KEYS.CODE_VERIFIER,
      this.serverUrl
    );
    const verifier = sessionStorage.getItem(key);
    if (!verifier) {
      throw new Error("No code verifier saved for session");
    }
    return verifier;
  }
  clear() {
    clearClientInformationFromSessionStorage({
      serverUrl: this.serverUrl,
      isPreregistered: false
    });
    sessionStorage.removeItem(
      getServerSpecificKey(SESSION_KEYS.TOKENS, this.serverUrl)
    );
    sessionStorage.removeItem(
      getServerSpecificKey(SESSION_KEYS.CODE_VERIFIER, this.serverUrl)
    );
  }
}
class DebugInspectorOAuthClientProvider extends InspectorOAuthClientProvider {
  get redirectUrl() {
    return this.debugRedirectUrl;
  }
  saveServerMetadata(metadata2) {
    const key = getServerSpecificKey(
      SESSION_KEYS.SERVER_METADATA,
      this.serverUrl
    );
    sessionStorage.setItem(key, JSON.stringify(metadata2));
  }
  getServerMetadata() {
    const key = getServerSpecificKey(
      SESSION_KEYS.SERVER_METADATA,
      this.serverUrl
    );
    const metadata2 = sessionStorage.getItem(key);
    if (!metadata2) {
      return null;
    }
    return JSON.parse(metadata2);
  }
  clear() {
    super.clear();
    sessionStorage.removeItem(
      getServerSpecificKey(SESSION_KEYS.SERVER_METADATA, this.serverUrl)
    );
  }
}
const oauthTransitions = {
  metadata_discovery: {
    canTransition: async () => true,
    execute: async (context) => {
      let authServerUrl = new URL("/", context.serverUrl);
      let resourceMetadata = null;
      let resourceMetadataError = null;
      try {
        resourceMetadata = await discoverOAuthProtectedResourceMetadata(
          context.serverUrl
        );
        if (resourceMetadata?.authorization_servers?.length) {
          authServerUrl = new URL(resourceMetadata.authorization_servers[0]);
        }
      } catch (e) {
        if (e instanceof Error) {
          resourceMetadataError = e;
        } else {
          resourceMetadataError = new Error(String(e));
        }
      }
      const resource = await selectResourceURL(
        context.serverUrl,
        context.provider,
        // we default to null, so swap it for undefined if not set
        resourceMetadata ?? void 0
      );
      const metadata2 = await discoverAuthorizationServerMetadata(authServerUrl);
      if (!metadata2) {
        throw new Error("Failed to discover OAuth metadata");
      }
      const parsedMetadata = await OAuthMetadataSchema.parseAsync(metadata2);
      context.provider.saveServerMetadata(parsedMetadata);
      context.updateState({
        resourceMetadata,
        resource,
        resourceMetadataError,
        authServerUrl,
        oauthMetadata: parsedMetadata,
        oauthStep: "client_registration"
      });
    }
  },
  client_registration: {
    canTransition: async (context) => !!context.state.oauthMetadata,
    execute: async (context) => {
      const metadata2 = context.state.oauthMetadata;
      const clientMetadata = context.provider.clientMetadata;
      if (!context.provider.scope || context.provider.scope.trim() === "") {
        const scopesSupported = context.state.resourceMetadata?.scopes_supported || metadata2.scopes_supported;
        if (scopesSupported) {
          clientMetadata.scope = scopesSupported.join(" ");
        }
      }
      let fullInformation = await context.provider.clientInformation();
      if (!fullInformation) {
        fullInformation = await registerClient(context.serverUrl, {
          metadata: metadata2,
          clientMetadata
        });
        context.provider.saveClientInformation(fullInformation);
      }
      context.updateState({
        oauthClientInfo: fullInformation,
        oauthStep: "authorization_redirect"
      });
    }
  },
  authorization_redirect: {
    canTransition: async (context) => !!context.state.oauthMetadata && !!context.state.oauthClientInfo,
    execute: async (context) => {
      const metadata2 = context.state.oauthMetadata;
      const clientInformation = context.state.oauthClientInfo;
      let scope2 = context.provider.scope;
      if (!scope2 || scope2.trim() === "") {
        scope2 = await discoverScopes(
          context.serverUrl,
          context.state.resourceMetadata ?? void 0
        );
      }
      const { authorizationUrl, codeVerifier } = await startAuthorization(
        context.serverUrl,
        {
          metadata: metadata2,
          clientInformation,
          redirectUrl: context.provider.redirectUrl,
          scope: scope2,
          state: generateOAuthState(),
          resource: context.state.resource ?? void 0
        }
      );
      context.provider.saveCodeVerifier(codeVerifier);
      context.updateState({
        authorizationUrl,
        oauthStep: "authorization_code"
      });
    }
  },
  authorization_code: {
    canTransition: async () => true,
    execute: async (context) => {
      if (!context.state.authorizationCode || context.state.authorizationCode.trim() === "") {
        context.updateState({
          validationError: "You need to provide an authorization code"
        });
        throw new Error("Authorization code required");
      }
      context.updateState({
        validationError: null,
        oauthStep: "token_request"
      });
    }
  },
  token_request: {
    canTransition: async (context) => {
      return !!context.state.authorizationCode && !!context.provider.getServerMetadata() && !!await context.provider.clientInformation();
    },
    execute: async (context) => {
      const codeVerifier = context.provider.codeVerifier();
      const metadata2 = context.provider.getServerMetadata();
      const clientInformation = await context.provider.clientInformation();
      const tokens = await exchangeAuthorization(context.serverUrl, {
        metadata: metadata2,
        clientInformation,
        authorizationCode: context.state.authorizationCode,
        codeVerifier,
        redirectUri: context.provider.redirectUrl,
        resource: context.state.resource ? context.state.resource instanceof URL ? context.state.resource : new URL(context.state.resource) : void 0
      });
      context.provider.saveTokens(tokens);
      context.updateState({
        oauthTokens: tokens,
        oauthStep: "complete"
      });
    }
  },
  complete: {
    canTransition: async () => false,
    execute: async () => {
    }
  }
};
class OAuthStateMachine {
  constructor(serverUrl, updateState) {
    this.serverUrl = serverUrl;
    this.updateState = updateState;
  }
  async executeStep(state) {
    const provider = new DebugInspectorOAuthClientProvider(this.serverUrl);
    const context = {
      state,
      serverUrl: this.serverUrl,
      provider,
      updateState: this.updateState
    };
    const transition = oauthTransitions[state.oauthStep];
    if (!await transition.canTransition(context)) {
      throw new Error(`Cannot transition from ${state.oauthStep}`);
    }
    await transition.execute(context);
  }
}
var uri_all$1 = { exports: {} };
var uri_all = uri_all$1.exports;
var hasRequiredUri_all;
function requireUri_all() {
  if (hasRequiredUri_all) return uri_all$1.exports;
  hasRequiredUri_all = 1;
  (function(module, exports$1) {
    (function(global2, factory) {
      factory(exports$1);
    })(uri_all, (function(exports$12) {
      function merge2() {
        for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
          sets[_key] = arguments[_key];
        }
        if (sets.length > 1) {
          sets[0] = sets[0].slice(0, -1);
          var xl2 = sets.length - 1;
          for (var x2 = 1; x2 < xl2; ++x2) {
            sets[x2] = sets[x2].slice(1, -1);
          }
          sets[xl2] = sets[xl2].slice(1);
          return sets.join("");
        } else {
          return sets[0];
        }
      }
      function subexp(str) {
        return "(?:" + str + ")";
      }
      function typeOf(o) {
        return o === void 0 ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
      }
      function toUpperCase(str) {
        return str.toUpperCase();
      }
      function toArray(obj) {
        return obj !== void 0 && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
      }
      function assign(target, source) {
        var obj = target;
        if (source) {
          for (var key in source) {
            obj[key] = source[key];
          }
        }
        return obj;
      }
      function buildExps(isIRI) {
        var ALPHA$$ = "[A-Za-z]", DIGIT$$ = "[0-9]", HEXDIG$$2 = merge2(DIGIT$$, "[A-Fa-f]"), PCT_ENCODED$2 = subexp(subexp("%[EFef]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%" + HEXDIG$$2 + HEXDIG$$2)), GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge2(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]", UNRESERVED$$2 = merge2(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$);
        subexp(ALPHA$$ + merge2(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*");
        subexp(subexp(PCT_ENCODED$2 + "|" + merge2(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]")) + "*");
        var DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$), IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$2 + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$2 + "|" + PCT_ENCODED$2) + "+");
        subexp("[vV]" + HEXDIG$$2 + "+\\." + merge2(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]") + "+");
        subexp(subexp(PCT_ENCODED$2 + "|" + merge2(UNRESERVED$$2, SUB_DELIMS$$)) + "*");
        var PCHAR$ = subexp(PCT_ENCODED$2 + "|" + merge2(UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@]"));
        subexp(subexp(PCT_ENCODED$2 + "|" + merge2(UNRESERVED$$2, SUB_DELIMS$$, "[\\@]")) + "+");
        subexp(subexp(PCHAR$ + "|" + merge2("[\\/\\?]", IPRIVATE$$)) + "*");
        return {
          NOT_SCHEME: new RegExp(merge2("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
          NOT_USERINFO: new RegExp(merge2("[^\\%\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_HOST: new RegExp(merge2("[^\\%\\[\\]\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_PATH: new RegExp(merge2("[^\\%\\/\\:\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_PATH_NOSCHEME: new RegExp(merge2("[^\\%\\/\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_QUERY: new RegExp(merge2("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
          NOT_FRAGMENT: new RegExp(merge2("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
          ESCAPE: new RegExp(merge2("[^]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          UNRESERVED: new RegExp(UNRESERVED$$2, "g"),
          OTHER_CHARS: new RegExp(merge2("[^\\%]", UNRESERVED$$2, RESERVED$$), "g"),
          PCT_ENCODED: new RegExp(PCT_ENCODED$2, "g"),
          IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
          IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$")
          //RFC 6874, with relaxed parsing rules
        };
      }
      var URI_PROTOCOL = buildExps(false);
      var IRI_PROTOCOL = buildExps(true);
      var slicedToArray = /* @__PURE__ */ (function() {
        function sliceIterator(arr, i) {
          var _arr = [];
          var _n2 = true;
          var _d2 = false;
          var _e2 = void 0;
          try {
            for (var _i2 = arr[Symbol.iterator](), _s2; !(_n2 = (_s2 = _i2.next()).done); _n2 = true) {
              _arr.push(_s2.value);
              if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d2 = true;
            _e2 = err;
          } finally {
            try {
              if (!_n2 && _i2["return"]) _i2["return"]();
            } finally {
              if (_d2) throw _e2;
            }
          }
          return _arr;
        }
        return function(arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      })();
      var toConsumableArray = function(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
          return arr2;
        } else {
          return Array.from(arr);
        }
      };
      var maxInt = 2147483647;
      var base = 36;
      var tMin = 1;
      var tMax = 26;
      var skew = 38;
      var damp = 700;
      var initialBias = 72;
      var initialN = 128;
      var delimiter = "-";
      var regexPunycode = /^xn--/;
      var regexNonASCII = /[^\0-\x7E]/;
      var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
      var errors2 = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      };
      var baseMinusTMin = base - tMin;
      var floor2 = Math.floor;
      var stringFromCharCode = String.fromCharCode;
      function error$1(type2) {
        throw new RangeError(errors2[type2]);
      }
      function map(array2, fn2) {
        var result = [];
        var length = array2.length;
        while (length--) {
          result[length] = fn2(array2[length]);
        }
        return result;
      }
      function mapDomain(string2, fn2) {
        var parts = string2.split("@");
        var result = "";
        if (parts.length > 1) {
          result = parts[0] + "@";
          string2 = parts[1];
        }
        string2 = string2.replace(regexSeparators, ".");
        var labels = string2.split(".");
        var encoded = map(labels, fn2).join(".");
        return result + encoded;
      }
      function ucs2decode(string2) {
        var output = [];
        var counter = 0;
        var length = string2.length;
        while (counter < length) {
          var value = string2.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            var extra = string2.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      var ucs2encode = function ucs2encode2(array2) {
        return String.fromCodePoint.apply(String, toConsumableArray(array2));
      };
      var basicToDigit = function basicToDigit2(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      };
      var digitToBasic = function digitToBasic2(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      };
      var adapt = function adapt2(delta, numPoints, firstTime) {
        var k2 = 0;
        delta = firstTime ? floor2(delta / damp) : delta >> 1;
        delta += floor2(delta / numPoints);
        for (
          ;
          /* no initialization */
          delta > baseMinusTMin * tMax >> 1;
          k2 += base
        ) {
          delta = floor2(delta / baseMinusTMin);
        }
        return floor2(k2 + (baseMinusTMin + 1) * delta / (delta + skew));
      };
      var decode = function decode2(input) {
        var output = [];
        var inputLength = input.length;
        var i = 0;
        var n = initialN;
        var bias = initialBias;
        var basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (var j2 = 0; j2 < basic; ++j2) {
          if (input.charCodeAt(j2) >= 128) {
            error$1("not-basic");
          }
          output.push(input.charCodeAt(j2));
        }
        for (var index2 = basic > 0 ? basic + 1 : 0; index2 < inputLength; ) {
          var oldi = i;
          for (
            var w2 = 1, k2 = base;
            ;
            /* no condition */
            k2 += base
          ) {
            if (index2 >= inputLength) {
              error$1("invalid-input");
            }
            var digit = basicToDigit(input.charCodeAt(index2++));
            if (digit >= base || digit > floor2((maxInt - i) / w2)) {
              error$1("overflow");
            }
            i += digit * w2;
            var t = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
            if (digit < t) {
              break;
            }
            var baseMinusT = base - t;
            if (w2 > floor2(maxInt / baseMinusT)) {
              error$1("overflow");
            }
            w2 *= baseMinusT;
          }
          var out = output.length + 1;
          bias = adapt(i - oldi, out, oldi == 0);
          if (floor2(i / out) > maxInt - n) {
            error$1("overflow");
          }
          n += floor2(i / out);
          i %= out;
          output.splice(i++, 0, n);
        }
        return String.fromCodePoint.apply(String, output);
      };
      var encode = function encode2(input) {
        var output = [];
        input = ucs2decode(input);
        var inputLength = input.length;
        var n = initialN;
        var delta = 0;
        var bias = initialBias;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = void 0;
        try {
          for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _currentValue2 = _step.value;
            if (_currentValue2 < 128) {
              output.push(stringFromCharCode(_currentValue2));
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        var basicLength = output.length;
        var handledCPCount = basicLength;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          var m2 = maxInt;
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = void 0;
          try {
            for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var currentValue = _step2.value;
              if (currentValue >= n && currentValue < m2) {
                m2 = currentValue;
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
          var handledCPCountPlusOne = handledCPCount + 1;
          if (m2 - n > floor2((maxInt - delta) / handledCPCountPlusOne)) {
            error$1("overflow");
          }
          delta += (m2 - n) * handledCPCountPlusOne;
          n = m2;
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = void 0;
          try {
            for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var _currentValue = _step3.value;
              if (_currentValue < n && ++delta > maxInt) {
                error$1("overflow");
              }
              if (_currentValue == n) {
                var q2 = delta;
                for (
                  var k2 = base;
                  ;
                  /* no condition */
                  k2 += base
                ) {
                  var t = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
                  if (q2 < t) {
                    break;
                  }
                  var qMinusT = q2 - t;
                  var baseMinusT = base - t;
                  output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                  q2 = floor2(qMinusT / baseMinusT);
                }
                output.push(stringFromCharCode(digitToBasic(q2, 0)));
                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                delta = 0;
                ++handledCPCount;
              }
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
          ++delta;
          ++n;
        }
        return output.join("");
      };
      var toUnicode = function toUnicode2(input) {
        return mapDomain(input, function(string2) {
          return regexPunycode.test(string2) ? decode(string2.slice(4).toLowerCase()) : string2;
        });
      };
      var toASCII = function toASCII2(input) {
        return mapDomain(input, function(string2) {
          return regexNonASCII.test(string2) ? "xn--" + encode(string2) : string2;
        });
      };
      var punycode = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        "version": "2.1.0",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode,
        "encode": encode,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      var SCHEMES = {};
      function pctEncChar(chr) {
        var c = chr.charCodeAt(0);
        var e = void 0;
        if (c < 16) e = "%0" + c.toString(16).toUpperCase();
        else if (c < 128) e = "%" + c.toString(16).toUpperCase();
        else if (c < 2048) e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
        else e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
        return e;
      }
      function pctDecChars(str) {
        var newStr = "";
        var i = 0;
        var il2 = str.length;
        while (i < il2) {
          var c = parseInt(str.substr(i + 1, 2), 16);
          if (c < 128) {
            newStr += String.fromCharCode(c);
            i += 3;
          } else if (c >= 194 && c < 224) {
            if (il2 - i >= 6) {
              var c2 = parseInt(str.substr(i + 4, 2), 16);
              newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
            } else {
              newStr += str.substr(i, 6);
            }
            i += 6;
          } else if (c >= 224) {
            if (il2 - i >= 9) {
              var _c2 = parseInt(str.substr(i + 4, 2), 16);
              var c3 = parseInt(str.substr(i + 7, 2), 16);
              newStr += String.fromCharCode((c & 15) << 12 | (_c2 & 63) << 6 | c3 & 63);
            } else {
              newStr += str.substr(i, 9);
            }
            i += 9;
          } else {
            newStr += str.substr(i, 3);
            i += 3;
          }
        }
        return newStr;
      }
      function _normalizeComponentEncoding(components, protocol) {
        function decodeUnreserved2(str) {
          var decStr = pctDecChars(str);
          return !decStr.match(protocol.UNRESERVED) ? str : decStr;
        }
        if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_SCHEME, "");
        if (components.userinfo !== void 0) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.host !== void 0) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.path !== void 0) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.query !== void 0) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.fragment !== void 0) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        return components;
      }
      function _stripLeadingZeros(str) {
        return str.replace(/^0*(.*)/, "$1") || "0";
      }
      function _normalizeIPv4(host, protocol) {
        var matches = host.match(protocol.IPV4ADDRESS) || [];
        var _matches = slicedToArray(matches, 2), address = _matches[1];
        if (address) {
          return address.split(".").map(_stripLeadingZeros).join(".");
        } else {
          return host;
        }
      }
      function _normalizeIPv6(host, protocol) {
        var matches = host.match(protocol.IPV6ADDRESS) || [];
        var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];
        if (address) {
          var _address$toLowerCase$ = address.toLowerCase().split("::").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];
          var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
          var lastFields = last.split(":").map(_stripLeadingZeros);
          var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
          var fieldCount = isLastFieldIPv4Address ? 7 : 8;
          var lastFieldsStart = lastFields.length - fieldCount;
          var fields = Array(fieldCount);
          for (var x2 = 0; x2 < fieldCount; ++x2) {
            fields[x2] = firstFields[x2] || lastFields[lastFieldsStart + x2] || "";
          }
          if (isLastFieldIPv4Address) {
            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
          }
          var allZeroFields = fields.reduce(function(acc, field, index2) {
            if (!field || field === "0") {
              var lastLongest = acc[acc.length - 1];
              if (lastLongest && lastLongest.index + lastLongest.length === index2) {
                lastLongest.length++;
              } else {
                acc.push({ index: index2, length: 1 });
              }
            }
            return acc;
          }, []);
          var longestZeroFields = allZeroFields.sort(function(a2, b) {
            return b.length - a2.length;
          })[0];
          var newHost = void 0;
          if (longestZeroFields && longestZeroFields.length > 1) {
            var newFirst = fields.slice(0, longestZeroFields.index);
            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
            newHost = newFirst.join(":") + "::" + newLast.join(":");
          } else {
            newHost = fields.join(":");
          }
          if (zone) {
            newHost += "%" + zone;
          }
          return newHost;
        } else {
          return host;
        }
      }
      var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
      var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === void 0;
      function parse2(uriString) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var components = {};
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        if (options.reference === "suffix") uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
        var matches = uriString.match(URI_PARSE);
        if (matches) {
          if (NO_MATCH_IS_UNDEFINED) {
            components.scheme = matches[1];
            components.userinfo = matches[3];
            components.host = matches[4];
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = matches[7];
            components.fragment = matches[8];
            if (isNaN(components.port)) {
              components.port = matches[5];
            }
          } else {
            components.scheme = matches[1] || void 0;
            components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : void 0;
            components.host = uriString.indexOf("//") !== -1 ? matches[4] : void 0;
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = uriString.indexOf("?") !== -1 ? matches[7] : void 0;
            components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : void 0;
            if (isNaN(components.port)) {
              components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : void 0;
            }
          }
          if (components.host) {
            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
          }
          if (components.scheme === void 0 && components.userinfo === void 0 && components.host === void 0 && components.port === void 0 && !components.path && components.query === void 0) {
            components.reference = "same-document";
          } else if (components.scheme === void 0) {
            components.reference = "relative";
          } else if (components.fragment === void 0) {
            components.reference = "absolute";
          } else {
            components.reference = "uri";
          }
          if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
            components.error = components.error || "URI is not a " + options.reference + " reference.";
          }
          var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
          if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
              try {
                components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
              } catch (e) {
                components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
              }
            }
            _normalizeComponentEncoding(components, URI_PROTOCOL);
          } else {
            _normalizeComponentEncoding(components, protocol);
          }
          if (schemeHandler && schemeHandler.parse) {
            schemeHandler.parse(components, options);
          }
        } else {
          components.error = components.error || "URI can not be parsed.";
        }
        return components;
      }
      function _recomposeAuthority(components, options) {
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        if (components.userinfo !== void 0) {
          uriTokens.push(components.userinfo);
          uriTokens.push("@");
        }
        if (components.host !== void 0) {
          uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_2, $1, $2) {
            return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
          }));
        }
        if (typeof components.port === "number" || typeof components.port === "string") {
          uriTokens.push(":");
          uriTokens.push(String(components.port));
        }
        return uriTokens.length ? uriTokens.join("") : void 0;
      }
      var RDS1 = /^\.\.?\//;
      var RDS2 = /^\/\.(\/|$)/;
      var RDS3 = /^\/\.\.(\/|$)/;
      var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
      function removeDotSegments(input) {
        var output = [];
        while (input.length) {
          if (input.match(RDS1)) {
            input = input.replace(RDS1, "");
          } else if (input.match(RDS2)) {
            input = input.replace(RDS2, "/");
          } else if (input.match(RDS3)) {
            input = input.replace(RDS3, "/");
            output.pop();
          } else if (input === "." || input === "..") {
            input = "";
          } else {
            var im2 = input.match(RDS5);
            if (im2) {
              var s2 = im2[0];
              input = input.slice(s2.length);
              output.push(s2);
            } else {
              throw new Error("Unexpected dot segment condition");
            }
          }
        }
        return output.join("");
      }
      function serialize(components) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
        if (components.host) {
          if (protocol.IPV6ADDRESS.test(components.host)) ;
          else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
            try {
              components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
            } catch (e) {
              components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
            }
          }
        }
        _normalizeComponentEncoding(components, protocol);
        if (options.reference !== "suffix" && components.scheme) {
          uriTokens.push(components.scheme);
          uriTokens.push(":");
        }
        var authority = _recomposeAuthority(components, options);
        if (authority !== void 0) {
          if (options.reference !== "suffix") {
            uriTokens.push("//");
          }
          uriTokens.push(authority);
          if (components.path && components.path.charAt(0) !== "/") {
            uriTokens.push("/");
          }
        }
        if (components.path !== void 0) {
          var s2 = components.path;
          if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
            s2 = removeDotSegments(s2);
          }
          if (authority === void 0) {
            s2 = s2.replace(/^\/\//, "/%2F");
          }
          uriTokens.push(s2);
        }
        if (components.query !== void 0) {
          uriTokens.push("?");
          uriTokens.push(components.query);
        }
        if (components.fragment !== void 0) {
          uriTokens.push("#");
          uriTokens.push(components.fragment);
        }
        return uriTokens.join("");
      }
      function resolveComponents(base2, relative) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var skipNormalization = arguments[3];
        var target = {};
        if (!skipNormalization) {
          base2 = parse2(serialize(base2, options), options);
          relative = parse2(serialize(relative, options), options);
        }
        options = options || {};
        if (!options.tolerant && relative.scheme) {
          target.scheme = relative.scheme;
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || "");
            target.query = relative.query;
          } else {
            if (!relative.path) {
              target.path = base2.path;
              if (relative.query !== void 0) {
                target.query = relative.query;
              } else {
                target.query = base2.query;
              }
            } else {
              if (relative.path.charAt(0) === "/") {
                target.path = removeDotSegments(relative.path);
              } else {
                if ((base2.userinfo !== void 0 || base2.host !== void 0 || base2.port !== void 0) && !base2.path) {
                  target.path = "/" + relative.path;
                } else if (!base2.path) {
                  target.path = relative.path;
                } else {
                  target.path = base2.path.slice(0, base2.path.lastIndexOf("/") + 1) + relative.path;
                }
                target.path = removeDotSegments(target.path);
              }
              target.query = relative.query;
            }
            target.userinfo = base2.userinfo;
            target.host = base2.host;
            target.port = base2.port;
          }
          target.scheme = base2.scheme;
        }
        target.fragment = relative.fragment;
        return target;
      }
      function resolve2(baseURI, relativeURI, options) {
        var schemelessOptions = assign({ scheme: "null" }, options);
        return serialize(resolveComponents(parse2(baseURI, schemelessOptions), parse2(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
      }
      function normalize(uri2, options) {
        if (typeof uri2 === "string") {
          uri2 = serialize(parse2(uri2, options), options);
        } else if (typeOf(uri2) === "object") {
          uri2 = parse2(serialize(uri2, options), options);
        }
        return uri2;
      }
      function equal2(uriA, uriB, options) {
        if (typeof uriA === "string") {
          uriA = serialize(parse2(uriA, options), options);
        } else if (typeOf(uriA) === "object") {
          uriA = serialize(uriA, options);
        }
        if (typeof uriB === "string") {
          uriB = serialize(parse2(uriB, options), options);
        } else if (typeOf(uriB) === "object") {
          uriB = serialize(uriB, options);
        }
        return uriA === uriB;
      }
      function escapeComponent(str, options) {
        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
      }
      function unescapeComponent(str, options) {
        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
      }
      var handler = {
        scheme: "http",
        domainHost: true,
        parse: function parse3(components, options) {
          if (!components.host) {
            components.error = components.error || "HTTP URIs must have a host.";
          }
          return components;
        },
        serialize: function serialize2(components, options) {
          var secure = String(components.scheme).toLowerCase() === "https";
          if (components.port === (secure ? 443 : 80) || components.port === "") {
            components.port = void 0;
          }
          if (!components.path) {
            components.path = "/";
          }
          return components;
        }
      };
      var handler$1 = {
        scheme: "https",
        domainHost: handler.domainHost,
        parse: handler.parse,
        serialize: handler.serialize
      };
      function isSecure(wsComponents) {
        return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
      }
      var handler$2 = {
        scheme: "ws",
        domainHost: true,
        parse: function parse3(components, options) {
          var wsComponents = components;
          wsComponents.secure = isSecure(wsComponents);
          wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
          wsComponents.path = void 0;
          wsComponents.query = void 0;
          return wsComponents;
        },
        serialize: function serialize2(wsComponents, options) {
          if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
            wsComponents.port = void 0;
          }
          if (typeof wsComponents.secure === "boolean") {
            wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
            wsComponents.secure = void 0;
          }
          if (wsComponents.resourceName) {
            var _wsComponents$resourc = wsComponents.resourceName.split("?"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];
            wsComponents.path = path && path !== "/" ? path : void 0;
            wsComponents.query = query;
            wsComponents.resourceName = void 0;
          }
          wsComponents.fragment = void 0;
          return wsComponents;
        }
      };
      var handler$3 = {
        scheme: "wss",
        domainHost: handler$2.domainHost,
        parse: handler$2.parse,
        serialize: handler$2.serialize
      };
      var O = {};
      var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]";
      var HEXDIG$$ = "[0-9A-Fa-f]";
      var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$));
      var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
      var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
      var VCHAR$$ = merge2(QTEXT$$, '[\\"\\\\]');
      var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
      var UNRESERVED = new RegExp(UNRESERVED$$, "g");
      var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
      var NOT_LOCAL_PART = new RegExp(merge2("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
      var NOT_HFNAME = new RegExp(merge2("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
      var NOT_HFVALUE = NOT_HFNAME;
      function decodeUnreserved(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(UNRESERVED) ? str : decStr;
      }
      var handler$4 = {
        scheme: "mailto",
        parse: function parse$$1(components, options) {
          var mailtoComponents = components;
          var to2 = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
          mailtoComponents.path = void 0;
          if (mailtoComponents.query) {
            var unknownHeaders = false;
            var headers = {};
            var hfields = mailtoComponents.query.split("&");
            for (var x2 = 0, xl2 = hfields.length; x2 < xl2; ++x2) {
              var hfield = hfields[x2].split("=");
              switch (hfield[0]) {
                case "to":
                  var toAddrs = hfield[1].split(",");
                  for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                    to2.push(toAddrs[_x]);
                  }
                  break;
                case "subject":
                  mailtoComponents.subject = unescapeComponent(hfield[1], options);
                  break;
                case "body":
                  mailtoComponents.body = unescapeComponent(hfield[1], options);
                  break;
                default:
                  unknownHeaders = true;
                  headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                  break;
              }
            }
            if (unknownHeaders) mailtoComponents.headers = headers;
          }
          mailtoComponents.query = void 0;
          for (var _x2 = 0, _xl2 = to2.length; _x2 < _xl2; ++_x2) {
            var addr = to2[_x2].split("@");
            addr[0] = unescapeComponent(addr[0]);
            if (!options.unicodeSupport) {
              try {
                addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
              } catch (e) {
                mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
              }
            } else {
              addr[1] = unescapeComponent(addr[1], options).toLowerCase();
            }
            to2[_x2] = addr.join("@");
          }
          return mailtoComponents;
        },
        serialize: function serialize$$1(mailtoComponents, options) {
          var components = mailtoComponents;
          var to2 = toArray(mailtoComponents.to);
          if (to2) {
            for (var x2 = 0, xl2 = to2.length; x2 < xl2; ++x2) {
              var toAddr = String(to2[x2]);
              var atIdx = toAddr.lastIndexOf("@");
              var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
              var domain = toAddr.slice(atIdx + 1);
              try {
                domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
              } catch (e) {
                components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
              }
              to2[x2] = localPart + "@" + domain;
            }
            components.path = to2.join(",");
          }
          var headers = mailtoComponents.headers = mailtoComponents.headers || {};
          if (mailtoComponents.subject) headers["subject"] = mailtoComponents.subject;
          if (mailtoComponents.body) headers["body"] = mailtoComponents.body;
          var fields = [];
          for (var name2 in headers) {
            if (headers[name2] !== O[name2]) {
              fields.push(name2.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name2].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
            }
          }
          if (fields.length) {
            components.query = fields.join("&");
          }
          return components;
        }
      };
      var URN_PARSE = /^([^\:]+)\:(.*)/;
      var handler$5 = {
        scheme: "urn",
        parse: function parse$$1(components, options) {
          var matches = components.path && components.path.match(URN_PARSE);
          var urnComponents = components;
          if (matches) {
            var scheme = options.scheme || urnComponents.scheme || "urn";
            var nid = matches[1].toLowerCase();
            var nss = matches[2];
            var urnScheme = scheme + ":" + (options.nid || nid);
            var schemeHandler = SCHEMES[urnScheme];
            urnComponents.nid = nid;
            urnComponents.nss = nss;
            urnComponents.path = void 0;
            if (schemeHandler) {
              urnComponents = schemeHandler.parse(urnComponents, options);
            }
          } else {
            urnComponents.error = urnComponents.error || "URN can not be parsed.";
          }
          return urnComponents;
        },
        serialize: function serialize$$1(urnComponents, options) {
          var scheme = options.scheme || urnComponents.scheme || "urn";
          var nid = urnComponents.nid;
          var urnScheme = scheme + ":" + (options.nid || nid);
          var schemeHandler = SCHEMES[urnScheme];
          if (schemeHandler) {
            urnComponents = schemeHandler.serialize(urnComponents, options);
          }
          var uriComponents = urnComponents;
          var nss = urnComponents.nss;
          uriComponents.path = (nid || options.nid) + ":" + nss;
          return uriComponents;
        }
      };
      var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
      var handler$6 = {
        scheme: "urn:uuid",
        parse: function parse3(urnComponents, options) {
          var uuidComponents = urnComponents;
          uuidComponents.uuid = uuidComponents.nss;
          uuidComponents.nss = void 0;
          if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
            uuidComponents.error = uuidComponents.error || "UUID is not valid.";
          }
          return uuidComponents;
        },
        serialize: function serialize2(uuidComponents, options) {
          var urnComponents = uuidComponents;
          urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
          return urnComponents;
        }
      };
      SCHEMES[handler.scheme] = handler;
      SCHEMES[handler$1.scheme] = handler$1;
      SCHEMES[handler$2.scheme] = handler$2;
      SCHEMES[handler$3.scheme] = handler$3;
      SCHEMES[handler$4.scheme] = handler$4;
      SCHEMES[handler$5.scheme] = handler$5;
      SCHEMES[handler$6.scheme] = handler$6;
      exports$12.SCHEMES = SCHEMES;
      exports$12.pctEncChar = pctEncChar;
      exports$12.pctDecChars = pctDecChars;
      exports$12.parse = parse2;
      exports$12.removeDotSegments = removeDotSegments;
      exports$12.serialize = serialize;
      exports$12.resolveComponents = resolveComponents;
      exports$12.resolve = resolve2;
      exports$12.normalize = normalize;
      exports$12.equal = equal2;
      exports$12.escapeComponent = escapeComponent;
      exports$12.unescapeComponent = unescapeComponent;
      Object.defineProperty(exports$12, "__esModule", { value: true });
    }));
  })(uri_all$1, uri_all$1.exports);
  return uri_all$1.exports;
}
var fastDeepEqual;
var hasRequiredFastDeepEqual;
function requireFastDeepEqual() {
  if (hasRequiredFastDeepEqual) return fastDeepEqual;
  hasRequiredFastDeepEqual = 1;
  fastDeepEqual = function equal2(a2, b) {
    if (a2 === b) return true;
    if (a2 && b && typeof a2 == "object" && typeof b == "object") {
      if (a2.constructor !== b.constructor) return false;
      var length, i, keys;
      if (Array.isArray(a2)) {
        length = a2.length;
        if (length != b.length) return false;
        for (i = length; i-- !== 0; )
          if (!equal2(a2[i], b[i])) return false;
        return true;
      }
      if (a2.constructor === RegExp) return a2.source === b.source && a2.flags === b.flags;
      if (a2.valueOf !== Object.prototype.valueOf) return a2.valueOf() === b.valueOf();
      if (a2.toString !== Object.prototype.toString) return a2.toString() === b.toString();
      keys = Object.keys(a2);
      length = keys.length;
      if (length !== Object.keys(b).length) return false;
      for (i = length; i-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
      for (i = length; i-- !== 0; ) {
        var key = keys[i];
        if (!equal2(a2[key], b[key])) return false;
      }
      return true;
    }
    return a2 !== a2 && b !== b;
  };
  return fastDeepEqual;
}
var ucs2length$2;
var hasRequiredUcs2length$2;
function requireUcs2length$2() {
  if (hasRequiredUcs2length$2) return ucs2length$2;
  hasRequiredUcs2length$2 = 1;
  ucs2length$2 = function ucs2length2(str) {
    var length = 0, len = str.length, pos = 0, value;
    while (pos < len) {
      length++;
      value = str.charCodeAt(pos++);
      if (value >= 55296 && value <= 56319 && pos < len) {
        value = str.charCodeAt(pos);
        if ((value & 64512) == 56320) pos++;
      }
    }
    return length;
  };
  return ucs2length$2;
}
var util$2;
var hasRequiredUtil$2;
function requireUtil$2() {
  if (hasRequiredUtil$2) return util$2;
  hasRequiredUtil$2 = 1;
  util$2 = {
    copy,
    checkDataType,
    checkDataTypes,
    coerceToTypes,
    toHash,
    getProperty,
    escapeQuotes,
    equal: requireFastDeepEqual(),
    ucs2length: requireUcs2length$2(),
    varOccurences,
    varReplace,
    schemaHasRules,
    schemaHasRulesExcept,
    schemaUnknownRules,
    toQuotedString,
    getPathExpr,
    getPath,
    getData,
    unescapeFragment,
    unescapeJsonPointer,
    escapeFragment,
    escapeJsonPointer
  };
  function copy(o, to2) {
    to2 = to2 || {};
    for (var key in o) to2[key] = o[key];
    return to2;
  }
  function checkDataType(dataType2, data2, strictNumbers, negate) {
    var EQUAL = negate ? " !== " : " === ", AND = negate ? " || " : " && ", OK2 = negate ? "!" : "", NOT = negate ? "" : "!";
    switch (dataType2) {
      case "null":
        return data2 + EQUAL + "null";
      case "array":
        return OK2 + "Array.isArray(" + data2 + ")";
      case "object":
        return "(" + OK2 + data2 + AND + "typeof " + data2 + EQUAL + '"object"' + AND + NOT + "Array.isArray(" + data2 + "))";
      case "integer":
        return "(typeof " + data2 + EQUAL + '"number"' + AND + NOT + "(" + data2 + " % 1)" + AND + data2 + EQUAL + data2 + (strictNumbers ? AND + OK2 + "isFinite(" + data2 + ")" : "") + ")";
      case "number":
        return "(typeof " + data2 + EQUAL + '"' + dataType2 + '"' + (strictNumbers ? AND + OK2 + "isFinite(" + data2 + ")" : "") + ")";
      default:
        return "typeof " + data2 + EQUAL + '"' + dataType2 + '"';
    }
  }
  function checkDataTypes(dataTypes, data2, strictNumbers) {
    switch (dataTypes.length) {
      case 1:
        return checkDataType(dataTypes[0], data2, strictNumbers, true);
      default:
        var code2 = "";
        var types2 = toHash(dataTypes);
        if (types2.array && types2.object) {
          code2 = types2.null ? "(" : "(!" + data2 + " || ";
          code2 += "typeof " + data2 + ' !== "object")';
          delete types2.null;
          delete types2.array;
          delete types2.object;
        }
        if (types2.number) delete types2.integer;
        for (var t in types2)
          code2 += (code2 ? " && " : "") + checkDataType(t, data2, strictNumbers, true);
        return code2;
    }
  }
  var COERCE_TO_TYPES = toHash(["string", "number", "integer", "boolean", "null"]);
  function coerceToTypes(optionCoerceTypes, dataTypes) {
    if (Array.isArray(dataTypes)) {
      var types2 = [];
      for (var i = 0; i < dataTypes.length; i++) {
        var t = dataTypes[i];
        if (COERCE_TO_TYPES[t]) types2[types2.length] = t;
        else if (optionCoerceTypes === "array" && t === "array") types2[types2.length] = t;
      }
      if (types2.length) return types2;
    } else if (COERCE_TO_TYPES[dataTypes]) {
      return [dataTypes];
    } else if (optionCoerceTypes === "array" && dataTypes === "array") {
      return ["array"];
    }
  }
  function toHash(arr) {
    var hash = {};
    for (var i = 0; i < arr.length; i++) hash[arr[i]] = true;
    return hash;
  }
  var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
  var SINGLE_QUOTE = /'|\\/g;
  function getProperty(key) {
    return typeof key == "number" ? "[" + key + "]" : IDENTIFIER.test(key) ? "." + key : "['" + escapeQuotes(key) + "']";
  }
  function escapeQuotes(str) {
    return str.replace(SINGLE_QUOTE, "\\$&").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\f/g, "\\f").replace(/\t/g, "\\t");
  }
  function varOccurences(str, dataVar) {
    dataVar += "[^0-9]";
    var matches = str.match(new RegExp(dataVar, "g"));
    return matches ? matches.length : 0;
  }
  function varReplace(str, dataVar, expr) {
    dataVar += "([^0-9])";
    expr = expr.replace(/\$/g, "$$$$");
    return str.replace(new RegExp(dataVar, "g"), expr + "$1");
  }
  function schemaHasRules(schema, rules2) {
    if (typeof schema == "boolean") return !schema;
    for (var key in schema) if (rules2[key]) return true;
  }
  function schemaHasRulesExcept(schema, rules2, exceptKeyword) {
    if (typeof schema == "boolean") return !schema && exceptKeyword != "not";
    for (var key in schema) if (key != exceptKeyword && rules2[key]) return true;
  }
  function schemaUnknownRules(schema, rules2) {
    if (typeof schema == "boolean") return;
    for (var key in schema) if (!rules2[key]) return key;
  }
  function toQuotedString(str) {
    return "'" + escapeQuotes(str) + "'";
  }
  function getPathExpr(currentPath, expr, jsonPointers, isNumber2) {
    var path = jsonPointers ? "'/' + " + expr + (isNumber2 ? "" : ".replace(/~/g, '~0').replace(/\\//g, '~1')") : isNumber2 ? "'[' + " + expr + " + ']'" : "'[\\'' + " + expr + " + '\\']'";
    return joinPaths(currentPath, path);
  }
  function getPath(currentPath, prop, jsonPointers) {
    var path = jsonPointers ? toQuotedString("/" + escapeJsonPointer(prop)) : toQuotedString(getProperty(prop));
    return joinPaths(currentPath, path);
  }
  var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
  var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
  function getData($data, lvl, paths) {
    var up2, jsonPointer, data2, matches;
    if ($data === "") return "rootData";
    if ($data[0] == "/") {
      if (!JSON_POINTER.test($data)) throw new Error("Invalid JSON-pointer: " + $data);
      jsonPointer = $data;
      data2 = "rootData";
    } else {
      matches = $data.match(RELATIVE_JSON_POINTER);
      if (!matches) throw new Error("Invalid JSON-pointer: " + $data);
      up2 = +matches[1];
      jsonPointer = matches[2];
      if (jsonPointer == "#") {
        if (up2 >= lvl) throw new Error("Cannot access property/index " + up2 + " levels up, current level is " + lvl);
        return paths[lvl - up2];
      }
      if (up2 > lvl) throw new Error("Cannot access data " + up2 + " levels up, current level is " + lvl);
      data2 = "data" + (lvl - up2 || "");
      if (!jsonPointer) return data2;
    }
    var expr = data2;
    var segments = jsonPointer.split("/");
    for (var i = 0; i < segments.length; i++) {
      var segment = segments[i];
      if (segment) {
        data2 += getProperty(unescapeJsonPointer(segment));
        expr += " && " + data2;
      }
    }
    return expr;
  }
  function joinPaths(a2, b) {
    if (a2 == '""') return b;
    return (a2 + " + " + b).replace(/([^\\])' \+ '/g, "$1");
  }
  function unescapeFragment(str) {
    return unescapeJsonPointer(decodeURIComponent(str));
  }
  function escapeFragment(str) {
    return encodeURIComponent(escapeJsonPointer(str));
  }
  function escapeJsonPointer(str) {
    return str.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  function unescapeJsonPointer(str) {
    return str.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  return util$2;
}
var schema_obj;
var hasRequiredSchema_obj;
function requireSchema_obj() {
  if (hasRequiredSchema_obj) return schema_obj;
  hasRequiredSchema_obj = 1;
  var util2 = requireUtil$2();
  schema_obj = SchemaObject;
  function SchemaObject(obj) {
    util2.copy(obj, this);
  }
  return schema_obj;
}
var jsonSchemaTraverse$2 = { exports: {} };
var hasRequiredJsonSchemaTraverse$2;
function requireJsonSchemaTraverse$2() {
  if (hasRequiredJsonSchemaTraverse$2) return jsonSchemaTraverse$2.exports;
  hasRequiredJsonSchemaTraverse$2 = 1;
  var traverse = jsonSchemaTraverse$2.exports = function(schema, opts, cb) {
    if (typeof opts == "function") {
      cb = opts;
      opts = {};
    }
    cb = opts.cb || cb;
    var pre = typeof cb == "function" ? cb : cb.pre || function() {
    };
    var post = cb.post || function() {
    };
    _traverse(opts, pre, post, schema, "", schema);
  };
  traverse.keywords = {
    additionalItems: true,
    items: true,
    contains: true,
    additionalProperties: true,
    propertyNames: true,
    not: true
  };
  traverse.arrayKeywords = {
    items: true,
    allOf: true,
    anyOf: true,
    oneOf: true
  };
  traverse.propsKeywords = {
    definitions: true,
    properties: true,
    patternProperties: true,
    dependencies: true
  };
  traverse.skipKeywords = {
    default: true,
    enum: true,
    const: true,
    required: true,
    maximum: true,
    minimum: true,
    exclusiveMaximum: true,
    exclusiveMinimum: true,
    multipleOf: true,
    maxLength: true,
    minLength: true,
    pattern: true,
    format: true,
    maxItems: true,
    minItems: true,
    uniqueItems: true,
    maxProperties: true,
    minProperties: true
  };
  function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
    if (schema && typeof schema == "object" && !Array.isArray(schema)) {
      pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      for (var key in schema) {
        var sch = schema[key];
        if (Array.isArray(sch)) {
          if (key in traverse.arrayKeywords) {
            for (var i = 0; i < sch.length; i++)
              _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
          }
        } else if (key in traverse.propsKeywords) {
          if (sch && typeof sch == "object") {
            for (var prop in sch)
              _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
          }
        } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
          _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
        }
      }
      post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    }
  }
  function escapeJsonPtr(str) {
    return str.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  return jsonSchemaTraverse$2.exports;
}
var resolve_1;
var hasRequiredResolve$2;
function requireResolve$2() {
  if (hasRequiredResolve$2) return resolve_1;
  hasRequiredResolve$2 = 1;
  var URI = requireUri_all(), equal2 = requireFastDeepEqual(), util2 = requireUtil$2(), SchemaObject = requireSchema_obj(), traverse = requireJsonSchemaTraverse$2();
  resolve_1 = resolve2;
  resolve2.normalizeId = normalizeId;
  resolve2.fullPath = getFullPath;
  resolve2.url = resolveUrl;
  resolve2.ids = resolveIds;
  resolve2.inlineRef = inlineRef;
  resolve2.schema = resolveSchema;
  function resolve2(compile2, root, ref2) {
    var refVal = this._refs[ref2];
    if (typeof refVal == "string") {
      if (this._refs[refVal]) refVal = this._refs[refVal];
      else return resolve2.call(this, compile2, root, refVal);
    }
    refVal = refVal || this._schemas[ref2];
    if (refVal instanceof SchemaObject) {
      return inlineRef(refVal.schema, this._opts.inlineRefs) ? refVal.schema : refVal.validate || this._compile(refVal);
    }
    var res = resolveSchema.call(this, root, ref2);
    var schema, v, baseId;
    if (res) {
      schema = res.schema;
      root = res.root;
      baseId = res.baseId;
    }
    if (schema instanceof SchemaObject) {
      v = schema.validate || compile2.call(this, schema.schema, root, void 0, baseId);
    } else if (schema !== void 0) {
      v = inlineRef(schema, this._opts.inlineRefs) ? schema : compile2.call(this, schema, root, void 0, baseId);
    }
    return v;
  }
  function resolveSchema(root, ref2) {
    var p2 = URI.parse(ref2), refPath = _getFullPath(p2), baseId = getFullPath(this._getId(root.schema));
    if (Object.keys(root.schema).length === 0 || refPath !== baseId) {
      var id2 = normalizeId(refPath);
      var refVal = this._refs[id2];
      if (typeof refVal == "string") {
        return resolveRecursive.call(this, root, refVal, p2);
      } else if (refVal instanceof SchemaObject) {
        if (!refVal.validate) this._compile(refVal);
        root = refVal;
      } else {
        refVal = this._schemas[id2];
        if (refVal instanceof SchemaObject) {
          if (!refVal.validate) this._compile(refVal);
          if (id2 == normalizeId(ref2))
            return { schema: refVal, root, baseId };
          root = refVal;
        } else {
          return;
        }
      }
      if (!root.schema) return;
      baseId = getFullPath(this._getId(root.schema));
    }
    return getJsonPointer.call(this, p2, baseId, root.schema, root);
  }
  function resolveRecursive(root, ref2, parsedRef) {
    var res = resolveSchema.call(this, root, ref2);
    if (res) {
      var schema = res.schema;
      var baseId = res.baseId;
      root = res.root;
      var id2 = this._getId(schema);
      if (id2) baseId = resolveUrl(baseId, id2);
      return getJsonPointer.call(this, parsedRef, baseId, schema, root);
    }
  }
  var PREVENT_SCOPE_CHANGE = util2.toHash(["properties", "patternProperties", "enum", "dependencies", "definitions"]);
  function getJsonPointer(parsedRef, baseId, schema, root) {
    parsedRef.fragment = parsedRef.fragment || "";
    if (parsedRef.fragment.slice(0, 1) != "/") return;
    var parts = parsedRef.fragment.split("/");
    for (var i = 1; i < parts.length; i++) {
      var part = parts[i];
      if (part) {
        part = util2.unescapeFragment(part);
        schema = schema[part];
        if (schema === void 0) break;
        var id2;
        if (!PREVENT_SCOPE_CHANGE[part]) {
          id2 = this._getId(schema);
          if (id2) baseId = resolveUrl(baseId, id2);
          if (schema.$ref) {
            var $ref = resolveUrl(baseId, schema.$ref);
            var res = resolveSchema.call(this, root, $ref);
            if (res) {
              schema = res.schema;
              root = res.root;
              baseId = res.baseId;
            }
          }
        }
      }
    }
    if (schema !== void 0 && schema !== root.schema)
      return { schema, root, baseId };
  }
  var SIMPLE_INLINED = util2.toHash([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum"
  ]);
  function inlineRef(schema, limit2) {
    if (limit2 === false) return false;
    if (limit2 === void 0 || limit2 === true) return checkNoRef(schema);
    else if (limit2) return countKeys(schema) <= limit2;
  }
  function checkNoRef(schema) {
    var item;
    if (Array.isArray(schema)) {
      for (var i = 0; i < schema.length; i++) {
        item = schema[i];
        if (typeof item == "object" && !checkNoRef(item)) return false;
      }
    } else {
      for (var key in schema) {
        if (key == "$ref") return false;
        item = schema[key];
        if (typeof item == "object" && !checkNoRef(item)) return false;
      }
    }
    return true;
  }
  function countKeys(schema) {
    var count2 = 0, item;
    if (Array.isArray(schema)) {
      for (var i = 0; i < schema.length; i++) {
        item = schema[i];
        if (typeof item == "object") count2 += countKeys(item);
        if (count2 == Infinity) return Infinity;
      }
    } else {
      for (var key in schema) {
        if (key == "$ref") return Infinity;
        if (SIMPLE_INLINED[key]) {
          count2++;
        } else {
          item = schema[key];
          if (typeof item == "object") count2 += countKeys(item) + 1;
          if (count2 == Infinity) return Infinity;
        }
      }
    }
    return count2;
  }
  function getFullPath(id2, normalize) {
    if (normalize !== false) id2 = normalizeId(id2);
    var p2 = URI.parse(id2);
    return _getFullPath(p2);
  }
  function _getFullPath(p2) {
    return URI.serialize(p2).split("#")[0] + "#";
  }
  var TRAILING_SLASH_HASH = /#\/?$/;
  function normalizeId(id2) {
    return id2 ? id2.replace(TRAILING_SLASH_HASH, "") : "";
  }
  function resolveUrl(baseId, id2) {
    id2 = normalizeId(id2);
    return URI.resolve(baseId, id2);
  }
  function resolveIds(schema) {
    var schemaId = normalizeId(this._getId(schema));
    var baseIds = { "": schemaId };
    var fullPaths = { "": getFullPath(schemaId, false) };
    var localRefs = {};
    var self2 = this;
    traverse(schema, { allKeys: true }, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (jsonPtr === "") return;
      var id2 = self2._getId(sch);
      var baseId = baseIds[parentJsonPtr];
      var fullPath = fullPaths[parentJsonPtr] + "/" + parentKeyword;
      if (keyIndex !== void 0)
        fullPath += "/" + (typeof keyIndex == "number" ? keyIndex : util2.escapeFragment(keyIndex));
      if (typeof id2 == "string") {
        id2 = baseId = normalizeId(baseId ? URI.resolve(baseId, id2) : id2);
        var refVal = self2._refs[id2];
        if (typeof refVal == "string") refVal = self2._refs[refVal];
        if (refVal && refVal.schema) {
          if (!equal2(sch, refVal.schema))
            throw new Error('id "' + id2 + '" resolves to more than one schema');
        } else if (id2 != normalizeId(fullPath)) {
          if (id2[0] == "#") {
            if (localRefs[id2] && !equal2(sch, localRefs[id2]))
              throw new Error('id "' + id2 + '" resolves to more than one schema');
            localRefs[id2] = sch;
          } else {
            self2._refs[id2] = fullPath;
          }
        }
      }
      baseIds[jsonPtr] = baseId;
      fullPaths[jsonPtr] = fullPath;
    });
    return localRefs;
  }
  return resolve_1;
}
var error_classes;
var hasRequiredError_classes;
function requireError_classes() {
  if (hasRequiredError_classes) return error_classes;
  hasRequiredError_classes = 1;
  var resolve2 = requireResolve$2();
  error_classes = {
    Validation: errorSubclass(ValidationError),
    MissingRef: errorSubclass(MissingRefError)
  };
  function ValidationError(errors2) {
    this.message = "validation failed";
    this.errors = errors2;
    this.ajv = this.validation = true;
  }
  MissingRefError.message = function(baseId, ref2) {
    return "can't resolve reference " + ref2 + " from id " + baseId;
  };
  function MissingRefError(baseId, ref2, message) {
    this.message = message || MissingRefError.message(baseId, ref2);
    this.missingRef = resolve2.url(baseId, ref2);
    this.missingSchema = resolve2.normalizeId(resolve2.fullPath(this.missingRef));
  }
  function errorSubclass(Subclass) {
    Subclass.prototype = Object.create(Error.prototype);
    Subclass.prototype.constructor = Subclass;
    return Subclass;
  }
  return error_classes;
}
var fastJsonStableStringify;
var hasRequiredFastJsonStableStringify;
function requireFastJsonStableStringify() {
  if (hasRequiredFastJsonStableStringify) return fastJsonStableStringify;
  hasRequiredFastJsonStableStringify = 1;
  fastJsonStableStringify = function(data2, opts) {
    if (!opts) opts = {};
    if (typeof opts === "function") opts = { cmp: opts };
    var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
    var cmp = opts.cmp && /* @__PURE__ */ (function(f2) {
      return function(node) {
        return function(a2, b) {
          var aobj = { key: a2, value: node[a2] };
          var bobj = { key: b, value: node[b] };
          return f2(aobj, bobj);
        };
      };
    })(opts.cmp);
    var seen2 = [];
    return (function stringify(node) {
      if (node && node.toJSON && typeof node.toJSON === "function") {
        node = node.toJSON();
      }
      if (node === void 0) return;
      if (typeof node == "number") return isFinite(node) ? "" + node : "null";
      if (typeof node !== "object") return JSON.stringify(node);
      var i, out;
      if (Array.isArray(node)) {
        out = "[";
        for (i = 0; i < node.length; i++) {
          if (i) out += ",";
          out += stringify(node[i]) || "null";
        }
        return out + "]";
      }
      if (node === null) return "null";
      if (seen2.indexOf(node) !== -1) {
        if (cycles) return JSON.stringify("__cycle__");
        throw new TypeError("Converting circular structure to JSON");
      }
      var seenIndex = seen2.push(node) - 1;
      var keys = Object.keys(node).sort(cmp && cmp(node));
      out = "";
      for (i = 0; i < keys.length; i++) {
        var key = keys[i];
        var value = stringify(node[key]);
        if (!value) continue;
        if (out) out += ",";
        out += JSON.stringify(key) + ":" + value;
      }
      seen2.splice(seenIndex, 1);
      return "{" + out + "}";
    })(data2);
  };
  return fastJsonStableStringify;
}
var validate$2;
var hasRequiredValidate$2;
function requireValidate$2() {
  if (hasRequiredValidate$2) return validate$2;
  hasRequiredValidate$2 = 1;
  validate$2 = function generate_validate(it2, $keyword, $ruleType) {
    var out = "";
    var $async = it2.schema.$async === true, $refKeywords = it2.util.schemaHasRulesExcept(it2.schema, it2.RULES.all, "$ref"), $id2 = it2.self._getId(it2.schema);
    if (it2.opts.strictKeywords) {
      var $unknownKwd = it2.util.schemaUnknownRules(it2.schema, it2.RULES.keywords);
      if ($unknownKwd) {
        var $keywordsMsg = "unknown keyword: " + $unknownKwd;
        if (it2.opts.strictKeywords === "log") it2.logger.warn($keywordsMsg);
        else throw new Error($keywordsMsg);
      }
    }
    if (it2.isTop) {
      out += " var validate = ";
      if ($async) {
        it2.async = true;
        out += "async ";
      }
      out += "function(data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; ";
      if ($id2 && (it2.opts.sourceCode || it2.opts.processCode)) {
        out += " " + ("/*# sourceURL=" + $id2 + " */") + " ";
      }
    }
    if (typeof it2.schema == "boolean" || !($refKeywords || it2.schema.$ref)) {
      var $keyword = "false schema";
      var $lvl = it2.level;
      var $dataLvl = it2.dataLevel;
      var $schema2 = it2.schema[$keyword];
      var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
      var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it2.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      if (it2.schema === false) {
        if (it2.isTop) {
          $breakOnError = true;
        } else {
          out += " var " + $valid + " = false; ";
        }
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it2.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "false schema") + "' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it2.opts.messages !== false) {
            out += " , message: 'boolean schema is false' ";
          }
          if (it2.opts.verbose) {
            out += " , schema: false , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it2.compositeRule && $breakOnError) {
          if (it2.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
      } else {
        if (it2.isTop) {
          if ($async) {
            out += " return data; ";
          } else {
            out += " validate.errors = null; return true; ";
          }
        } else {
          out += " var " + $valid + " = true; ";
        }
      }
      if (it2.isTop) {
        out += " }; return validate; ";
      }
      return out;
    }
    if (it2.isTop) {
      var $top = it2.isTop, $lvl = it2.level = 0, $dataLvl = it2.dataLevel = 0, $data = "data";
      it2.rootId = it2.resolve.fullPath(it2.self._getId(it2.root.schema));
      it2.baseId = it2.baseId || it2.rootId;
      delete it2.isTop;
      it2.dataPathArr = [""];
      if (it2.schema.default !== void 0 && it2.opts.useDefaults && it2.opts.strictDefaults) {
        var $defaultMsg = "default is ignored in the schema root";
        if (it2.opts.strictDefaults === "log") it2.logger.warn($defaultMsg);
        else throw new Error($defaultMsg);
      }
      out += " var vErrors = null; ";
      out += " var errors = 0;     ";
      out += " if (rootData === undefined) rootData = data; ";
    } else {
      var $lvl = it2.level, $dataLvl = it2.dataLevel, $data = "data" + ($dataLvl || "");
      if ($id2) it2.baseId = it2.resolve.url(it2.baseId, $id2);
      if ($async && !it2.async) throw new Error("async schema in sync schema");
      out += " var errs_" + $lvl + " = errors;";
    }
    var $valid = "valid" + $lvl, $breakOnError = !it2.opts.allErrors, $closingBraces1 = "", $closingBraces2 = "";
    var $errorKeyword;
    var $typeSchema = it2.schema.type, $typeIsArray = Array.isArray($typeSchema);
    if ($typeSchema && it2.opts.nullable && it2.schema.nullable === true) {
      if ($typeIsArray) {
        if ($typeSchema.indexOf("null") == -1) $typeSchema = $typeSchema.concat("null");
      } else if ($typeSchema != "null") {
        $typeSchema = [$typeSchema, "null"];
        $typeIsArray = true;
      }
    }
    if ($typeIsArray && $typeSchema.length == 1) {
      $typeSchema = $typeSchema[0];
      $typeIsArray = false;
    }
    if (it2.schema.$ref && $refKeywords) {
      if (it2.opts.extendRefs == "fail") {
        throw new Error('$ref: validation keywords used in schema at path "' + it2.errSchemaPath + '" (see option extendRefs)');
      } else if (it2.opts.extendRefs !== true) {
        $refKeywords = false;
        it2.logger.warn('$ref: keywords ignored in schema at path "' + it2.errSchemaPath + '"');
      }
    }
    if (it2.schema.$comment && it2.opts.$comment) {
      out += " " + it2.RULES.all.$comment.code(it2, "$comment");
    }
    if ($typeSchema) {
      if (it2.opts.coerceTypes) {
        var $coerceToTypes = it2.util.coerceToTypes(it2.opts.coerceTypes, $typeSchema);
      }
      var $rulesGroup = it2.RULES.types[$typeSchema];
      if ($coerceToTypes || $typeIsArray || $rulesGroup === true || $rulesGroup && !$shouldUseGroup($rulesGroup)) {
        var $schemaPath = it2.schemaPath + ".type", $errSchemaPath = it2.errSchemaPath + "/type";
        var $schemaPath = it2.schemaPath + ".type", $errSchemaPath = it2.errSchemaPath + "/type", $method = $typeIsArray ? "checkDataTypes" : "checkDataType";
        out += " if (" + it2.util[$method]($typeSchema, $data, it2.opts.strictNumbers, true) + ") { ";
        if ($coerceToTypes) {
          var $dataType = "dataType" + $lvl, $coerced = "coerced" + $lvl;
          out += " var " + $dataType + " = typeof " + $data + "; var " + $coerced + " = undefined; ";
          if (it2.opts.coerceTypes == "array") {
            out += " if (" + $dataType + " == 'object' && Array.isArray(" + $data + ") && " + $data + ".length == 1) { " + $data + " = " + $data + "[0]; " + $dataType + " = typeof " + $data + "; if (" + it2.util.checkDataType(it2.schema.type, $data, it2.opts.strictNumbers) + ") " + $coerced + " = " + $data + "; } ";
          }
          out += " if (" + $coerced + " !== undefined) ; ";
          var arr1 = $coerceToTypes;
          if (arr1) {
            var $type, $i2 = -1, l1 = arr1.length - 1;
            while ($i2 < l1) {
              $type = arr1[$i2 += 1];
              if ($type == "string") {
                out += " else if (" + $dataType + " == 'number' || " + $dataType + " == 'boolean') " + $coerced + " = '' + " + $data + "; else if (" + $data + " === null) " + $coerced + " = ''; ";
              } else if ($type == "number" || $type == "integer") {
                out += " else if (" + $dataType + " == 'boolean' || " + $data + " === null || (" + $dataType + " == 'string' && " + $data + " && " + $data + " == +" + $data + " ";
                if ($type == "integer") {
                  out += " && !(" + $data + " % 1)";
                }
                out += ")) " + $coerced + " = +" + $data + "; ";
              } else if ($type == "boolean") {
                out += " else if (" + $data + " === 'false' || " + $data + " === 0 || " + $data + " === null) " + $coerced + " = false; else if (" + $data + " === 'true' || " + $data + " === 1) " + $coerced + " = true; ";
              } else if ($type == "null") {
                out += " else if (" + $data + " === '' || " + $data + " === 0 || " + $data + " === false) " + $coerced + " = null; ";
              } else if (it2.opts.coerceTypes == "array" && $type == "array") {
                out += " else if (" + $dataType + " == 'string' || " + $dataType + " == 'number' || " + $dataType + " == 'boolean' || " + $data + " == null) " + $coerced + " = [" + $data + "]; ";
              }
            }
          }
          out += " else {   ";
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it2.createErrors !== false) {
            out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { type: '";
            if ($typeIsArray) {
              out += "" + $typeSchema.join(",");
            } else {
              out += "" + $typeSchema;
            }
            out += "' } ";
            if (it2.opts.messages !== false) {
              out += " , message: 'should be ";
              if ($typeIsArray) {
                out += "" + $typeSchema.join(",");
              } else {
                out += "" + $typeSchema;
              }
              out += "' ";
            }
            if (it2.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it2.compositeRule && $breakOnError) {
            if (it2.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          out += " } if (" + $coerced + " !== undefined) {  ";
          var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it2.dataPathArr[$dataLvl] : "parentDataProperty";
          out += " " + $data + " = " + $coerced + "; ";
          if (!$dataLvl) {
            out += "if (" + $parentData + " !== undefined)";
          }
          out += " " + $parentData + "[" + $parentDataProperty + "] = " + $coerced + "; } ";
        } else {
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it2.createErrors !== false) {
            out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { type: '";
            if ($typeIsArray) {
              out += "" + $typeSchema.join(",");
            } else {
              out += "" + $typeSchema;
            }
            out += "' } ";
            if (it2.opts.messages !== false) {
              out += " , message: 'should be ";
              if ($typeIsArray) {
                out += "" + $typeSchema.join(",");
              } else {
                out += "" + $typeSchema;
              }
              out += "' ";
            }
            if (it2.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it2.compositeRule && $breakOnError) {
            if (it2.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
        }
        out += " } ";
      }
    }
    if (it2.schema.$ref && !$refKeywords) {
      out += " " + it2.RULES.all.$ref.code(it2, "$ref") + " ";
      if ($breakOnError) {
        out += " } if (errors === ";
        if ($top) {
          out += "0";
        } else {
          out += "errs_" + $lvl;
        }
        out += ") { ";
        $closingBraces2 += "}";
      }
    } else {
      var arr2 = it2.RULES;
      if (arr2) {
        var $rulesGroup, i2 = -1, l2 = arr2.length - 1;
        while (i2 < l2) {
          $rulesGroup = arr2[i2 += 1];
          if ($shouldUseGroup($rulesGroup)) {
            if ($rulesGroup.type) {
              out += " if (" + it2.util.checkDataType($rulesGroup.type, $data, it2.opts.strictNumbers) + ") { ";
            }
            if (it2.opts.useDefaults) {
              if ($rulesGroup.type == "object" && it2.schema.properties) {
                var $schema2 = it2.schema.properties, $schemaKeys = Object.keys($schema2);
                var arr3 = $schemaKeys;
                if (arr3) {
                  var $propertyKey, i3 = -1, l3 = arr3.length - 1;
                  while (i3 < l3) {
                    $propertyKey = arr3[i3 += 1];
                    var $sch = $schema2[$propertyKey];
                    if ($sch.default !== void 0) {
                      var $passData = $data + it2.util.getProperty($propertyKey);
                      if (it2.compositeRule) {
                        if (it2.opts.strictDefaults) {
                          var $defaultMsg = "default is ignored for: " + $passData;
                          if (it2.opts.strictDefaults === "log") it2.logger.warn($defaultMsg);
                          else throw new Error($defaultMsg);
                        }
                      } else {
                        out += " if (" + $passData + " === undefined ";
                        if (it2.opts.useDefaults == "empty") {
                          out += " || " + $passData + " === null || " + $passData + " === '' ";
                        }
                        out += " ) " + $passData + " = ";
                        if (it2.opts.useDefaults == "shared") {
                          out += " " + it2.useDefault($sch.default) + " ";
                        } else {
                          out += " " + JSON.stringify($sch.default) + " ";
                        }
                        out += "; ";
                      }
                    }
                  }
                }
              } else if ($rulesGroup.type == "array" && Array.isArray(it2.schema.items)) {
                var arr4 = it2.schema.items;
                if (arr4) {
                  var $sch, $i2 = -1, l42 = arr4.length - 1;
                  while ($i2 < l42) {
                    $sch = arr4[$i2 += 1];
                    if ($sch.default !== void 0) {
                      var $passData = $data + "[" + $i2 + "]";
                      if (it2.compositeRule) {
                        if (it2.opts.strictDefaults) {
                          var $defaultMsg = "default is ignored for: " + $passData;
                          if (it2.opts.strictDefaults === "log") it2.logger.warn($defaultMsg);
                          else throw new Error($defaultMsg);
                        }
                      } else {
                        out += " if (" + $passData + " === undefined ";
                        if (it2.opts.useDefaults == "empty") {
                          out += " || " + $passData + " === null || " + $passData + " === '' ";
                        }
                        out += " ) " + $passData + " = ";
                        if (it2.opts.useDefaults == "shared") {
                          out += " " + it2.useDefault($sch.default) + " ";
                        } else {
                          out += " " + JSON.stringify($sch.default) + " ";
                        }
                        out += "; ";
                      }
                    }
                  }
                }
              }
            }
            var arr5 = $rulesGroup.rules;
            if (arr5) {
              var $rule, i5 = -1, l5 = arr5.length - 1;
              while (i5 < l5) {
                $rule = arr5[i5 += 1];
                if ($shouldUseRule($rule)) {
                  var $code = $rule.code(it2, $rule.keyword, $rulesGroup.type);
                  if ($code) {
                    out += " " + $code + " ";
                    if ($breakOnError) {
                      $closingBraces1 += "}";
                    }
                  }
                }
              }
            }
            if ($breakOnError) {
              out += " " + $closingBraces1 + " ";
              $closingBraces1 = "";
            }
            if ($rulesGroup.type) {
              out += " } ";
              if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {
                out += " else { ";
                var $schemaPath = it2.schemaPath + ".type", $errSchemaPath = it2.errSchemaPath + "/type";
                var $$outStack = $$outStack || [];
                $$outStack.push(out);
                out = "";
                if (it2.createErrors !== false) {
                  out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { type: '";
                  if ($typeIsArray) {
                    out += "" + $typeSchema.join(",");
                  } else {
                    out += "" + $typeSchema;
                  }
                  out += "' } ";
                  if (it2.opts.messages !== false) {
                    out += " , message: 'should be ";
                    if ($typeIsArray) {
                      out += "" + $typeSchema.join(",");
                    } else {
                      out += "" + $typeSchema;
                    }
                    out += "' ";
                  }
                  if (it2.opts.verbose) {
                    out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
                  }
                  out += " } ";
                } else {
                  out += " {} ";
                }
                var __err = out;
                out = $$outStack.pop();
                if (!it2.compositeRule && $breakOnError) {
                  if (it2.async) {
                    out += " throw new ValidationError([" + __err + "]); ";
                  } else {
                    out += " validate.errors = [" + __err + "]; return false; ";
                  }
                } else {
                  out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                }
                out += " } ";
              }
            }
            if ($breakOnError) {
              out += " if (errors === ";
              if ($top) {
                out += "0";
              } else {
                out += "errs_" + $lvl;
              }
              out += ") { ";
              $closingBraces2 += "}";
            }
          }
        }
      }
    }
    if ($breakOnError) {
      out += " " + $closingBraces2 + " ";
    }
    if ($top) {
      if ($async) {
        out += " if (errors === 0) return data;           ";
        out += " else throw new ValidationError(vErrors); ";
      } else {
        out += " validate.errors = vErrors; ";
        out += " return errors === 0;       ";
      }
      out += " }; return validate;";
    } else {
      out += " var " + $valid + " = errors === errs_" + $lvl + ";";
    }
    function $shouldUseGroup($rulesGroup2) {
      var rules2 = $rulesGroup2.rules;
      for (var i = 0; i < rules2.length; i++)
        if ($shouldUseRule(rules2[i])) return true;
    }
    function $shouldUseRule($rule2) {
      return it2.schema[$rule2.keyword] !== void 0 || $rule2.implements && $ruleImplementsSomeKeyword($rule2);
    }
    function $ruleImplementsSomeKeyword($rule2) {
      var impl = $rule2.implements;
      for (var i = 0; i < impl.length; i++)
        if (it2.schema[impl[i]] !== void 0) return true;
    }
    return out;
  };
  return validate$2;
}
var compile_1;
var hasRequiredCompile$2;
function requireCompile$2() {
  if (hasRequiredCompile$2) return compile_1;
  hasRequiredCompile$2 = 1;
  var resolve2 = requireResolve$2(), util2 = requireUtil$2(), errorClasses = requireError_classes(), stableStringify = requireFastJsonStableStringify();
  var validateGenerator = requireValidate$2();
  var ucs2length2 = util2.ucs2length;
  var equal2 = requireFastDeepEqual();
  var ValidationError = errorClasses.Validation;
  compile_1 = compile2;
  function compile2(schema, root, localRefs, baseId) {
    var self2 = this, opts = this._opts, refVal = [void 0], refs = {}, patterns = [], patternsHash = {}, defaults2 = [], defaultsHash = {}, customRules = [];
    function patternCode(i, patterns2) {
      var regExpCode = opts.regExp ? "regExp" : "new RegExp";
      return "var pattern" + i + " = " + regExpCode + "(" + util2.toQuotedString(patterns2[i]) + ");";
    }
    root = root || { schema, refVal, refs };
    var c = checkCompiling.call(this, schema, root, baseId);
    var compilation = this._compilations[c.index];
    if (c.compiling) return compilation.callValidate = callValidate;
    var formats2 = this._formats;
    var RULES = this.RULES;
    try {
      var v = localCompile(schema, root, localRefs, baseId);
      compilation.validate = v;
      var cv2 = compilation.callValidate;
      if (cv2) {
        cv2.schema = v.schema;
        cv2.errors = null;
        cv2.refs = v.refs;
        cv2.refVal = v.refVal;
        cv2.root = v.root;
        cv2.$async = v.$async;
        if (opts.sourceCode) cv2.source = v.source;
      }
      return v;
    } finally {
      endCompiling.call(this, schema, root, baseId);
    }
    function callValidate() {
      var validate2 = compilation.validate;
      var result = validate2.apply(this, arguments);
      callValidate.errors = validate2.errors;
      return result;
    }
    function localCompile(_schema, _root, localRefs2, baseId2) {
      var isRoot = !_root || _root && _root.schema == _schema;
      if (_root.schema != root.schema)
        return compile2.call(self2, _schema, _root, localRefs2, baseId2);
      var $async = _schema.$async === true;
      var sourceCode = validateGenerator({
        isTop: true,
        schema: _schema,
        isRoot,
        baseId: baseId2,
        root: _root,
        schemaPath: "",
        errSchemaPath: "#",
        errorPath: '""',
        MissingRefError: errorClasses.MissingRef,
        RULES,
        validate: validateGenerator,
        util: util2,
        resolve: resolve2,
        resolveRef: resolveRef2,
        usePattern,
        useDefault,
        useCustomRule,
        opts,
        formats: formats2,
        logger: self2.logger,
        self: self2
      });
      sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode) + vars(defaults2, defaultCode) + vars(customRules, customRuleCode) + sourceCode;
      if (opts.processCode) sourceCode = opts.processCode(sourceCode, _schema);
      var validate2;
      try {
        var makeValidate = new Function(
          "self",
          "RULES",
          "formats",
          "root",
          "refVal",
          "defaults",
          "customRules",
          "equal",
          "ucs2length",
          "ValidationError",
          "regExp",
          sourceCode
        );
        validate2 = makeValidate(
          self2,
          RULES,
          formats2,
          root,
          refVal,
          defaults2,
          customRules,
          equal2,
          ucs2length2,
          ValidationError,
          opts.regExp
        );
        refVal[0] = validate2;
      } catch (e) {
        self2.logger.error("Error compiling schema, function code:", sourceCode);
        throw e;
      }
      validate2.schema = _schema;
      validate2.errors = null;
      validate2.refs = refs;
      validate2.refVal = refVal;
      validate2.root = isRoot ? validate2 : _root;
      if ($async) validate2.$async = true;
      if (opts.sourceCode === true) {
        validate2.source = {
          code: sourceCode,
          patterns,
          defaults: defaults2
        };
      }
      return validate2;
    }
    function resolveRef2(baseId2, ref2, isRoot) {
      ref2 = resolve2.url(baseId2, ref2);
      var refIndex = refs[ref2];
      var _refVal, refCode;
      if (refIndex !== void 0) {
        _refVal = refVal[refIndex];
        refCode = "refVal[" + refIndex + "]";
        return resolvedRef(_refVal, refCode);
      }
      if (!isRoot && root.refs) {
        var rootRefId = root.refs[ref2];
        if (rootRefId !== void 0) {
          _refVal = root.refVal[rootRefId];
          refCode = addLocalRef(ref2, _refVal);
          return resolvedRef(_refVal, refCode);
        }
      }
      refCode = addLocalRef(ref2);
      var v2 = resolve2.call(self2, localCompile, root, ref2);
      if (v2 === void 0) {
        var localSchema = localRefs && localRefs[ref2];
        if (localSchema) {
          v2 = resolve2.inlineRef(localSchema, opts.inlineRefs) ? localSchema : compile2.call(self2, localSchema, root, localRefs, baseId2);
        }
      }
      if (v2 === void 0) {
        removeLocalRef(ref2);
      } else {
        replaceLocalRef(ref2, v2);
        return resolvedRef(v2, refCode);
      }
    }
    function addLocalRef(ref2, v2) {
      var refId = refVal.length;
      refVal[refId] = v2;
      refs[ref2] = refId;
      return "refVal" + refId;
    }
    function removeLocalRef(ref2) {
      delete refs[ref2];
    }
    function replaceLocalRef(ref2, v2) {
      var refId = refs[ref2];
      refVal[refId] = v2;
    }
    function resolvedRef(refVal2, code2) {
      return typeof refVal2 == "object" || typeof refVal2 == "boolean" ? { code: code2, schema: refVal2, inline: true } : { code: code2, $async: refVal2 && !!refVal2.$async };
    }
    function usePattern(regexStr) {
      var index2 = patternsHash[regexStr];
      if (index2 === void 0) {
        index2 = patternsHash[regexStr] = patterns.length;
        patterns[index2] = regexStr;
      }
      return "pattern" + index2;
    }
    function useDefault(value) {
      switch (typeof value) {
        case "boolean":
        case "number":
          return "" + value;
        case "string":
          return util2.toQuotedString(value);
        case "object":
          if (value === null) return "null";
          var valueStr = stableStringify(value);
          var index2 = defaultsHash[valueStr];
          if (index2 === void 0) {
            index2 = defaultsHash[valueStr] = defaults2.length;
            defaults2[index2] = value;
          }
          return "default" + index2;
      }
    }
    function useCustomRule(rule, schema2, parentSchema, it2) {
      if (self2._opts.validateSchema !== false) {
        var deps = rule.definition.dependencies;
        if (deps && !deps.every(function(keyword2) {
          return Object.prototype.hasOwnProperty.call(parentSchema, keyword2);
        }))
          throw new Error("parent schema must have all required keywords: " + deps.join(","));
        var validateSchema = rule.definition.validateSchema;
        if (validateSchema) {
          var valid = validateSchema(schema2);
          if (!valid) {
            var message = "keyword schema is invalid: " + self2.errorsText(validateSchema.errors);
            if (self2._opts.validateSchema == "log") self2.logger.error(message);
            else throw new Error(message);
          }
        }
      }
      var compile3 = rule.definition.compile, inline = rule.definition.inline, macro = rule.definition.macro;
      var validate2;
      if (compile3) {
        validate2 = compile3.call(self2, schema2, parentSchema, it2);
      } else if (macro) {
        validate2 = macro.call(self2, schema2, parentSchema, it2);
        if (opts.validateSchema !== false) self2.validateSchema(validate2, true);
      } else if (inline) {
        validate2 = inline.call(self2, it2, rule.keyword, schema2, parentSchema);
      } else {
        validate2 = rule.definition.validate;
        if (!validate2) return;
      }
      if (validate2 === void 0)
        throw new Error('custom keyword "' + rule.keyword + '"failed to compile');
      var index2 = customRules.length;
      customRules[index2] = validate2;
      return {
        code: "customRule" + index2,
        validate: validate2
      };
    }
  }
  function checkCompiling(schema, root, baseId) {
    var index2 = compIndex.call(this, schema, root, baseId);
    if (index2 >= 0) return { index: index2, compiling: true };
    index2 = this._compilations.length;
    this._compilations[index2] = {
      schema,
      root,
      baseId
    };
    return { index: index2, compiling: false };
  }
  function endCompiling(schema, root, baseId) {
    var i = compIndex.call(this, schema, root, baseId);
    if (i >= 0) this._compilations.splice(i, 1);
  }
  function compIndex(schema, root, baseId) {
    for (var i = 0; i < this._compilations.length; i++) {
      var c = this._compilations[i];
      if (c.schema == schema && c.root == root && c.baseId == baseId) return i;
    }
    return -1;
  }
  function defaultCode(i) {
    return "var default" + i + " = defaults[" + i + "];";
  }
  function refValCode(i, refVal) {
    return refVal[i] === void 0 ? "" : "var refVal" + i + " = refVal[" + i + "];";
  }
  function customRuleCode(i) {
    return "var customRule" + i + " = customRules[" + i + "];";
  }
  function vars(arr, statement) {
    if (!arr.length) return "";
    var code2 = "";
    for (var i = 0; i < arr.length; i++)
      code2 += statement(i, arr);
    return code2;
  }
  return compile_1;
}
var cache = { exports: {} };
var hasRequiredCache;
function requireCache() {
  if (hasRequiredCache) return cache.exports;
  hasRequiredCache = 1;
  var Cache = cache.exports = function Cache2() {
    this._cache = {};
  };
  Cache.prototype.put = function Cache_put(key, value) {
    this._cache[key] = value;
  };
  Cache.prototype.get = function Cache_get(key) {
    return this._cache[key];
  };
  Cache.prototype.del = function Cache_del(key) {
    delete this._cache[key];
  };
  Cache.prototype.clear = function Cache_clear() {
    this._cache = {};
  };
  return cache.exports;
}
var formats_1;
var hasRequiredFormats$1;
function requireFormats$1() {
  if (hasRequiredFormats$1) return formats_1;
  hasRequiredFormats$1 = 1;
  var util2 = requireUtil$2();
  var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
  var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
  var HOSTNAME = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i;
  var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  var URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
  var URL2 = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i;
  var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
  var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
  var JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
  var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
  formats_1 = formats2;
  function formats2(mode) {
    mode = mode == "full" ? "full" : "fast";
    return util2.copy(formats2[mode]);
  }
  formats2.fast = {
    // date: http://tools.ietf.org/html/rfc3339#section-5.6
    date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
    // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
    time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
    "date-time": /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
    // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
    uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
    "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
    "uri-template": URITEMPLATE,
    url: URL2,
    // email (sources from jsen validator):
    // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
    // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')
    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
    hostname: HOSTNAME,
    // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
    ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
    regex,
    // uuid: http://tools.ietf.org/html/rfc4122
    uuid: UUID,
    // JSON-pointer: https://tools.ietf.org/html/rfc6901
    // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
    "json-pointer": JSON_POINTER,
    "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
    // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
    "relative-json-pointer": RELATIVE_JSON_POINTER
  };
  formats2.full = {
    date: date2,
    time: time2,
    "date-time": date_time,
    uri: uri2,
    "uri-reference": URIREF,
    "uri-template": URITEMPLATE,
    url: URL2,
    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
    hostname: HOSTNAME,
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
    regex,
    uuid: UUID,
    "json-pointer": JSON_POINTER,
    "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
    "relative-json-pointer": RELATIVE_JSON_POINTER
  };
  function isLeapYear(year) {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  }
  function date2(str) {
    var matches = str.match(DATE);
    if (!matches) return false;
    var year = +matches[1];
    var month = +matches[2];
    var day = +matches[3];
    return month >= 1 && month <= 12 && day >= 1 && day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);
  }
  function time2(str, full) {
    var matches = str.match(TIME);
    if (!matches) return false;
    var hour = matches[1];
    var minute = matches[2];
    var second = matches[3];
    var timeZone = matches[5];
    return (hour <= 23 && minute <= 59 && second <= 59 || hour == 23 && minute == 59 && second == 60) && (!full || timeZone);
  }
  var DATE_TIME_SEPARATOR = /t|\s/i;
  function date_time(str) {
    var dateTime = str.split(DATE_TIME_SEPARATOR);
    return dateTime.length == 2 && date2(dateTime[0]) && time2(dateTime[1], true);
  }
  var NOT_URI_FRAGMENT = /\/|:/;
  function uri2(str) {
    return NOT_URI_FRAGMENT.test(str) && URI.test(str);
  }
  var Z_ANCHOR = /[^\\]\\Z/;
  function regex(str) {
    if (Z_ANCHOR.test(str)) return false;
    try {
      new RegExp(str);
      return true;
    } catch (e) {
      return false;
    }
  }
  return formats_1;
}
var ref$2;
var hasRequiredRef$2;
function requireRef$2() {
  if (hasRequiredRef$2) return ref$2;
  hasRequiredRef$2 = 1;
  ref$2 = function generate_ref(it2, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it2.level;
    var $dataLvl = it2.dataLevel;
    var $schema2 = it2.schema[$keyword];
    var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it2.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $async, $refCode;
    if ($schema2 == "#" || $schema2 == "#/") {
      if (it2.isRoot) {
        $async = it2.async;
        $refCode = "validate";
      } else {
        $async = it2.root.schema.$async === true;
        $refCode = "root.refVal[0]";
      }
    } else {
      var $refVal = it2.resolveRef(it2.baseId, $schema2, it2.isRoot);
      if ($refVal === void 0) {
        var $message = it2.MissingRefError.message(it2.baseId, $schema2);
        if (it2.opts.missingRefs == "fail") {
          it2.logger.error($message);
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it2.createErrors !== false) {
            out += " { keyword: '$ref' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { ref: '" + it2.util.escapeQuotes($schema2) + "' } ";
            if (it2.opts.messages !== false) {
              out += " , message: 'can\\'t resolve reference " + it2.util.escapeQuotes($schema2) + "' ";
            }
            if (it2.opts.verbose) {
              out += " , schema: " + it2.util.toQuotedString($schema2) + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it2.compositeRule && $breakOnError) {
            if (it2.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          if ($breakOnError) {
            out += " if (false) { ";
          }
        } else if (it2.opts.missingRefs == "ignore") {
          it2.logger.warn($message);
          if ($breakOnError) {
            out += " if (true) { ";
          }
        } else {
          throw new it2.MissingRefError(it2.baseId, $schema2, $message);
        }
      } else if ($refVal.inline) {
        var $it = it2.util.copy(it2);
        $it.level++;
        var $nextValid = "valid" + $it.level;
        $it.schema = $refVal.schema;
        $it.schemaPath = "";
        $it.errSchemaPath = $schema2;
        var $code = it2.validate($it).replace(/validate\.schema/g, $refVal.code);
        out += " " + $code + " ";
        if ($breakOnError) {
          out += " if (" + $nextValid + ") { ";
        }
      } else {
        $async = $refVal.$async === true || it2.async && $refVal.$async !== false;
        $refCode = $refVal.code;
      }
    }
    if ($refCode) {
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it2.opts.passContext) {
        out += " " + $refCode + ".call(this, ";
      } else {
        out += " " + $refCode + "( ";
      }
      out += " " + $data + ", (dataPath || '')";
      if (it2.errorPath != '""') {
        out += " + " + it2.errorPath;
      }
      var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it2.dataPathArr[$dataLvl] : "parentDataProperty";
      out += " , " + $parentData + " , " + $parentDataProperty + ", rootData)  ";
      var __callValidate = out;
      out = $$outStack.pop();
      if ($async) {
        if (!it2.async) throw new Error("async schema referenced by sync schema");
        if ($breakOnError) {
          out += " var " + $valid + "; ";
        }
        out += " try { await " + __callValidate + "; ";
        if ($breakOnError) {
          out += " " + $valid + " = true; ";
        }
        out += " } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ";
        if ($breakOnError) {
          out += " " + $valid + " = false; ";
        }
        out += " } ";
        if ($breakOnError) {
          out += " if (" + $valid + ") { ";
        }
      } else {
        out += " if (!" + __callValidate + ") { if (vErrors === null) vErrors = " + $refCode + ".errors; else vErrors = vErrors.concat(" + $refCode + ".errors); errors = vErrors.length; } ";
        if ($breakOnError) {
          out += " else { ";
        }
      }
    }
    return out;
  };
  return ref$2;
}
var allOf$2;
var hasRequiredAllOf$2;
function requireAllOf$2() {
  if (hasRequiredAllOf$2) return allOf$2;
  hasRequiredAllOf$2 = 1;
  allOf$2 = function generate_allOf(it2, $keyword, $ruleType) {
    var out = " ";
    var $schema2 = it2.schema[$keyword];
    var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
    var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it2.opts.allErrors;
    var $it = it2.util.copy(it2);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $currentBaseId = $it.baseId, $allSchemasEmpty = true;
    var arr1 = $schema2;
    if (arr1) {
      var $sch, $i2 = -1, l1 = arr1.length - 1;
      while ($i2 < l1) {
        $sch = arr1[$i2 += 1];
        if (it2.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it2.util.schemaHasRules($sch, it2.RULES.all)) {
          $allSchemasEmpty = false;
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + "[" + $i2 + "]";
          $it.errSchemaPath = $errSchemaPath + "/" + $i2;
          out += "  " + it2.validate($it) + " ";
          $it.baseId = $currentBaseId;
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
            $closingBraces += "}";
          }
        }
      }
    }
    if ($breakOnError) {
      if ($allSchemasEmpty) {
        out += " if (true) { ";
      } else {
        out += " " + $closingBraces.slice(0, -1) + " ";
      }
    }
    return out;
  };
  return allOf$2;
}
var anyOf$2;
var hasRequiredAnyOf$2;
function requireAnyOf$2() {
  if (hasRequiredAnyOf$2) return anyOf$2;
  hasRequiredAnyOf$2 = 1;
  anyOf$2 = function generate_anyOf(it2, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it2.level;
    var $dataLvl = it2.dataLevel;
    var $schema2 = it2.schema[$keyword];
    var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
    var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it2.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $errs = "errs__" + $lvl;
    var $it = it2.util.copy(it2);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $noEmptySchema = $schema2.every(function($sch2) {
      return it2.opts.strictKeywords ? typeof $sch2 == "object" && Object.keys($sch2).length > 0 || $sch2 === false : it2.util.schemaHasRules($sch2, it2.RULES.all);
    });
    if ($noEmptySchema) {
      var $currentBaseId = $it.baseId;
      out += " var " + $errs + " = errors; var " + $valid + " = false;  ";
      var $wasComposite = it2.compositeRule;
      it2.compositeRule = $it.compositeRule = true;
      var arr1 = $schema2;
      if (arr1) {
        var $sch, $i2 = -1, l1 = arr1.length - 1;
        while ($i2 < l1) {
          $sch = arr1[$i2 += 1];
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + "[" + $i2 + "]";
          $it.errSchemaPath = $errSchemaPath + "/" + $i2;
          out += "  " + it2.validate($it) + " ";
          $it.baseId = $currentBaseId;
          out += " " + $valid + " = " + $valid + " || " + $nextValid + "; if (!" + $valid + ") { ";
          $closingBraces += "}";
        }
      }
      it2.compositeRule = $it.compositeRule = $wasComposite;
      out += " " + $closingBraces + " if (!" + $valid + ") {   var err =   ";
      if (it2.createErrors !== false) {
        out += " { keyword: 'anyOf' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: {} ";
        if (it2.opts.messages !== false) {
          out += " , message: 'should match some schema in anyOf' ";
        }
        if (it2.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      if (!it2.compositeRule && $breakOnError) {
        if (it2.async) {
          out += " throw new ValidationError(vErrors); ";
        } else {
          out += " validate.errors = vErrors; return false; ";
        }
      }
      out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
      if (it2.opts.allErrors) {
        out += " } ";
      }
    } else {
      if ($breakOnError) {
        out += " if (true) { ";
      }
    }
    return out;
  };
  return anyOf$2;
}
var comment;
var hasRequiredComment;
function requireComment() {
  if (hasRequiredComment) return comment;
  hasRequiredComment = 1;
  comment = function generate_comment(it2, $keyword, $ruleType) {
    var out = " ";
    var $schema2 = it2.schema[$keyword];
    var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
    !it2.opts.allErrors;
    var $comment = it2.util.toQuotedString($schema2);
    if (it2.opts.$comment === true) {
      out += " console.log(" + $comment + ");";
    } else if (typeof it2.opts.$comment == "function") {
      out += " self._opts.$comment(" + $comment + ", " + it2.util.toQuotedString($errSchemaPath) + ", validate.root.schema);";
    }
    return out;
  };
  return comment;
}
var _const$2;
var hasRequired_const$2;
function require_const$2() {
  if (hasRequired_const$2) return _const$2;
  hasRequired_const$2 = 1;
  _const$2 = function generate_const(it2, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it2.level;
    var $dataLvl = it2.dataLevel;
    var $schema2 = it2.schema[$keyword];
    var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
    var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it2.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $isData = it2.opts.$data && $schema2 && $schema2.$data;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it2.util.getData($schema2.$data, $dataLvl, it2.dataPathArr) + "; ";
    }
    if (!$isData) {
      out += " var schema" + $lvl + " = validate.schema" + $schemaPath + ";";
    }
    out += "var " + $valid + " = equal(" + $data + ", schema" + $lvl + "); if (!" + $valid + ") {   ";
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it2.createErrors !== false) {
      out += " { keyword: 'const' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { allowedValue: schema" + $lvl + " } ";
      if (it2.opts.messages !== false) {
        out += " , message: 'should be equal to constant' ";
      }
      if (it2.opts.verbose) {
        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it2.compositeRule && $breakOnError) {
      if (it2.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += " }";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
  return _const$2;
}
var contains$2;
var hasRequiredContains$2;
function requireContains$2() {
  if (hasRequiredContains$2) return contains$2;
  hasRequiredContains$2 = 1;
  contains$2 = function generate_contains(it2, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it2.level;
    var $dataLvl = it2.dataLevel;
    var $schema2 = it2.schema[$keyword];
    var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
    var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it2.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $errs = "errs__" + $lvl;
    var $it = it2.util.copy(it2);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it2.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it2.baseId, $nonEmptySchema = it2.opts.strictKeywords ? typeof $schema2 == "object" && Object.keys($schema2).length > 0 || $schema2 === false : it2.util.schemaHasRules($schema2, it2.RULES.all);
    out += "var " + $errs + " = errors;var " + $valid + ";";
    if ($nonEmptySchema) {
      var $wasComposite = it2.compositeRule;
      it2.compositeRule = $it.compositeRule = true;
      $it.schema = $schema2;
      $it.schemaPath = $schemaPath;
      $it.errSchemaPath = $errSchemaPath;
      out += " var " + $nextValid + " = false; for (var " + $idx + " = 0; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
      $it.errorPath = it2.util.getPathExpr(it2.errorPath, $idx, it2.opts.jsonPointers, true);
      var $passData = $data + "[" + $idx + "]";
      $it.dataPathArr[$dataNxt] = $idx;
      var $code = it2.validate($it);
      $it.baseId = $currentBaseId;
      if (it2.util.varOccurences($code, $nextData) < 2) {
        out += " " + it2.util.varReplace($code, $nextData, $passData) + " ";
      } else {
        out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
      }
      out += " if (" + $nextValid + ") break; }  ";
      it2.compositeRule = $it.compositeRule = $wasComposite;
      out += " " + $closingBraces + " if (!" + $nextValid + ") {";
    } else {
      out += " if (" + $data + ".length == 0) {";
    }
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it2.createErrors !== false) {
      out += " { keyword: 'contains' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: {} ";
      if (it2.opts.messages !== false) {
        out += " , message: 'should contain a valid item' ";
      }
      if (it2.opts.verbose) {
        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it2.compositeRule && $breakOnError) {
      if (it2.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += " } else { ";
    if ($nonEmptySchema) {
      out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
    }
    if (it2.opts.allErrors) {
      out += " } ";
    }
    return out;
  };
  return contains$2;
}
var dependencies$2;
var hasRequiredDependencies$2;
function requireDependencies$2() {
  if (hasRequiredDependencies$2) return dependencies$2;
  hasRequiredDependencies$2 = 1;
  dependencies$2 = function generate_dependencies(it2, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it2.level;
    var $dataLvl = it2.dataLevel;
    var $schema2 = it2.schema[$keyword];
    var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
    var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it2.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $errs = "errs__" + $lvl;
    var $it = it2.util.copy(it2);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $schemaDeps = {}, $propertyDeps = {}, $ownProperties = it2.opts.ownProperties;
    for ($property in $schema2) {
      if ($property == "__proto__") continue;
      var $sch = $schema2[$property];
      var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
      $deps[$property] = $sch;
    }
    out += "var " + $errs + " = errors;";
    var $currentErrorPath = it2.errorPath;
    out += "var missing" + $lvl + ";";
    for (var $property in $propertyDeps) {
      $deps = $propertyDeps[$property];
      if ($deps.length) {
        out += " if ( " + $data + it2.util.getProperty($property) + " !== undefined ";
        if ($ownProperties) {
          out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it2.util.escapeQuotes($property) + "') ";
        }
        if ($breakOnError) {
          out += " && ( ";
          var arr1 = $deps;
          if (arr1) {
            var $propertyKey, $i2 = -1, l1 = arr1.length - 1;
            while ($i2 < l1) {
              $propertyKey = arr1[$i2 += 1];
              if ($i2) {
                out += " || ";
              }
              var $prop = it2.util.getProperty($propertyKey), $useData = $data + $prop;
              out += " ( ( " + $useData + " === undefined ";
              if ($ownProperties) {
                out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it2.util.escapeQuotes($propertyKey) + "') ";
              }
              out += ") && (missing" + $lvl + " = " + it2.util.toQuotedString(it2.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
            }
          }
          out += ")) {  ";
          var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
          if (it2.opts._errorDataPathProperty) {
            it2.errorPath = it2.opts.jsonPointers ? it2.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
          }
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it2.createErrors !== false) {
            out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it2.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it2.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
            if (it2.opts.messages !== false) {
              out += " , message: 'should have ";
              if ($deps.length == 1) {
                out += "property " + it2.util.escapeQuotes($deps[0]);
              } else {
                out += "properties " + it2.util.escapeQuotes($deps.join(", "));
              }
              out += " when property " + it2.util.escapeQuotes($property) + " is present' ";
            }
            if (it2.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it2.compositeRule && $breakOnError) {
            if (it2.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
        } else {
          out += " ) { ";
          var arr2 = $deps;
          if (arr2) {
            var $propertyKey, i2 = -1, l2 = arr2.length - 1;
            while (i2 < l2) {
              $propertyKey = arr2[i2 += 1];
              var $prop = it2.util.getProperty($propertyKey), $missingProperty = it2.util.escapeQuotes($propertyKey), $useData = $data + $prop;
              if (it2.opts._errorDataPathProperty) {
                it2.errorPath = it2.util.getPath($currentErrorPath, $propertyKey, it2.opts.jsonPointers);
              }
              out += " if ( " + $useData + " === undefined ";
              if ($ownProperties) {
                out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it2.util.escapeQuotes($propertyKey) + "') ";
              }
              out += ") {  var err =   ";
              if (it2.createErrors !== false) {
                out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it2.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it2.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
                if (it2.opts.messages !== false) {
                  out += " , message: 'should have ";
                  if ($deps.length == 1) {
                    out += "property " + it2.util.escapeQuotes($deps[0]);
                  } else {
                    out += "properties " + it2.util.escapeQuotes($deps.join(", "));
                  }
                  out += " when property " + it2.util.escapeQuotes($property) + " is present' ";
                }
                if (it2.opts.verbose) {
                  out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
            }
          }
        }
        out += " }   ";
        if ($breakOnError) {
          $closingBraces += "}";
          out += " else { ";
        }
      }
    }
    it2.errorPath = $currentErrorPath;
    var $currentBaseId = $it.baseId;
    for (var $property in $schemaDeps) {
      var $sch = $schemaDeps[$property];
      if (it2.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it2.util.schemaHasRules($sch, it2.RULES.all)) {
        out += " " + $nextValid + " = true; if ( " + $data + it2.util.getProperty($property) + " !== undefined ";
        if ($ownProperties) {
          out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it2.util.escapeQuotes($property) + "') ";
        }
        out += ") { ";
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + it2.util.getProperty($property);
        $it.errSchemaPath = $errSchemaPath + "/" + it2.util.escapeFragment($property);
        out += "  " + it2.validate($it) + " ";
        $it.baseId = $currentBaseId;
        out += " }  ";
        if ($breakOnError) {
          out += " if (" + $nextValid + ") { ";
          $closingBraces += "}";
        }
      }
    }
    if ($breakOnError) {
      out += "   " + $closingBraces + " if (" + $errs + " == errors) {";
    }
    return out;
  };
  return dependencies$2;
}
var _enum$2;
var hasRequired_enum$2;
function require_enum$2() {
  if (hasRequired_enum$2) return _enum$2;
  hasRequired_enum$2 = 1;
  _enum$2 = function generate_enum(it2, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it2.level;
    var $dataLvl = it2.dataLevel;
    var $schema2 = it2.schema[$keyword];
    var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
    var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it2.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $isData = it2.opts.$data && $schema2 && $schema2.$data;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it2.util.getData($schema2.$data, $dataLvl, it2.dataPathArr) + "; ";
    }
    var $i2 = "i" + $lvl, $vSchema = "schema" + $lvl;
    if (!$isData) {
      out += " var " + $vSchema + " = validate.schema" + $schemaPath + ";";
    }
    out += "var " + $valid + ";";
    if ($isData) {
      out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
    }
    out += "" + $valid + " = false;for (var " + $i2 + "=0; " + $i2 + "<" + $vSchema + ".length; " + $i2 + "++) if (equal(" + $data + ", " + $vSchema + "[" + $i2 + "])) { " + $valid + " = true; break; }";
    if ($isData) {
      out += "  }  ";
    }
    out += " if (!" + $valid + ") {   ";
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it2.createErrors !== false) {
      out += " { keyword: 'enum' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { allowedValues: schema" + $lvl + " } ";
      if (it2.opts.messages !== false) {
        out += " , message: 'should be equal to one of the allowed values' ";
      }
      if (it2.opts.verbose) {
        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it2.compositeRule && $breakOnError) {
      if (it2.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += " }";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
  return _enum$2;
}
var format$4;
var hasRequiredFormat$4;
function requireFormat$4() {
  if (hasRequiredFormat$4) return format$4;
  hasRequiredFormat$4 = 1;
  format$4 = function generate_format(it2, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it2.level;
    var $dataLvl = it2.dataLevel;
    var $schema2 = it2.schema[$keyword];
    var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
    var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it2.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    if (it2.opts.format === false) {
      if ($breakOnError) {
        out += " if (true) { ";
      }
      return out;
    }
    var $isData = it2.opts.$data && $schema2 && $schema2.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it2.util.getData($schema2.$data, $dataLvl, it2.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema2;
    }
    var $unknownFormats = it2.opts.unknownFormats, $allowUnknown = Array.isArray($unknownFormats);
    if ($isData) {
      var $format = "format" + $lvl, $isObject = "isObject" + $lvl, $formatType = "formatType" + $lvl;
      out += " var " + $format + " = formats[" + $schemaValue + "]; var " + $isObject + " = typeof " + $format + " == 'object' && !(" + $format + " instanceof RegExp) && " + $format + ".validate; var " + $formatType + " = " + $isObject + " && " + $format + ".type || 'string'; if (" + $isObject + ") { ";
      if (it2.async) {
        out += " var async" + $lvl + " = " + $format + ".async; ";
      }
      out += " " + $format + " = " + $format + ".validate; } if (  ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
      }
      out += " (";
      if ($unknownFormats != "ignore") {
        out += " (" + $schemaValue + " && !" + $format + " ";
        if ($allowUnknown) {
          out += " && self._opts.unknownFormats.indexOf(" + $schemaValue + ") == -1 ";
        }
        out += ") || ";
      }
      out += " (" + $format + " && " + $formatType + " == '" + $ruleType + "' && !(typeof " + $format + " == 'function' ? ";
      if (it2.async) {
        out += " (async" + $lvl + " ? await " + $format + "(" + $data + ") : " + $format + "(" + $data + ")) ";
      } else {
        out += " " + $format + "(" + $data + ") ";
      }
      out += " : " + $format + ".test(" + $data + "))))) {";
    } else {
      var $format = it2.formats[$schema2];
      if (!$format) {
        if ($unknownFormats == "ignore") {
          it2.logger.warn('unknown format "' + $schema2 + '" ignored in schema at path "' + it2.errSchemaPath + '"');
          if ($breakOnError) {
            out += " if (true) { ";
          }
          return out;
        } else if ($allowUnknown && $unknownFormats.indexOf($schema2) >= 0) {
          if ($breakOnError) {
            out += " if (true) { ";
          }
          return out;
        } else {
          throw new Error('unknown format "' + $schema2 + '" is used in schema at path "' + it2.errSchemaPath + '"');
        }
      }
      var $isObject = typeof $format == "object" && !($format instanceof RegExp) && $format.validate;
      var $formatType = $isObject && $format.type || "string";
      if ($isObject) {
        var $async = $format.async === true;
        $format = $format.validate;
      }
      if ($formatType != $ruleType) {
        if ($breakOnError) {
          out += " if (true) { ";
        }
        return out;
      }
      if ($async) {
        if (!it2.async) throw new Error("async format in sync schema");
        var $formatRef = "formats" + it2.util.getProperty($schema2) + ".validate";
        out += " if (!(await " + $formatRef + "(" + $data + "))) { ";
      } else {
        out += " if (! ";
        var $formatRef = "formats" + it2.util.getProperty($schema2);
        if ($isObject) $formatRef += ".validate";
        if (typeof $format == "function") {
          out += " " + $formatRef + "(" + $data + ") ";
        } else {
          out += " " + $formatRef + ".test(" + $data + ") ";
        }
        out += ") { ";
      }
    }
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it2.createErrors !== false) {
      out += " { keyword: 'format' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { format:  ";
      if ($isData) {
        out += "" + $schemaValue;
      } else {
        out += "" + it2.util.toQuotedString($schema2);
      }
      out += "  } ";
      if (it2.opts.messages !== false) {
        out += ` , message: 'should match format "`;
        if ($isData) {
          out += "' + " + $schemaValue + " + '";
        } else {
          out += "" + it2.util.escapeQuotes($schema2);
        }
        out += `"' `;
      }
      if (it2.opts.verbose) {
        out += " , schema:  ";
        if ($isData) {
          out += "validate.schema" + $schemaPath;
        } else {
          out += "" + it2.util.toQuotedString($schema2);
        }
        out += "         , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it2.compositeRule && $breakOnError) {
      if (it2.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += " } ";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
  return format$4;
}
var _if$2;
var hasRequired_if$2;
function require_if$2() {
  if (hasRequired_if$2) return _if$2;
  hasRequired_if$2 = 1;
  _if$2 = function generate_if(it2, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it2.level;
    var $dataLvl = it2.dataLevel;
    var $schema2 = it2.schema[$keyword];
    var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
    var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it2.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $errs = "errs__" + $lvl;
    var $it = it2.util.copy(it2);
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $thenSch = it2.schema["then"], $elseSch = it2.schema["else"], $thenPresent = $thenSch !== void 0 && (it2.opts.strictKeywords ? typeof $thenSch == "object" && Object.keys($thenSch).length > 0 || $thenSch === false : it2.util.schemaHasRules($thenSch, it2.RULES.all)), $elsePresent = $elseSch !== void 0 && (it2.opts.strictKeywords ? typeof $elseSch == "object" && Object.keys($elseSch).length > 0 || $elseSch === false : it2.util.schemaHasRules($elseSch, it2.RULES.all)), $currentBaseId = $it.baseId;
    if ($thenPresent || $elsePresent) {
      var $ifClause;
      $it.createErrors = false;
      $it.schema = $schema2;
      $it.schemaPath = $schemaPath;
      $it.errSchemaPath = $errSchemaPath;
      out += " var " + $errs + " = errors; var " + $valid + " = true;  ";
      var $wasComposite = it2.compositeRule;
      it2.compositeRule = $it.compositeRule = true;
      out += "  " + it2.validate($it) + " ";
      $it.baseId = $currentBaseId;
      $it.createErrors = true;
      out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }  ";
      it2.compositeRule = $it.compositeRule = $wasComposite;
      if ($thenPresent) {
        out += " if (" + $nextValid + ") {  ";
        $it.schema = it2.schema["then"];
        $it.schemaPath = it2.schemaPath + ".then";
        $it.errSchemaPath = it2.errSchemaPath + "/then";
        out += "  " + it2.validate($it) + " ";
        $it.baseId = $currentBaseId;
        out += " " + $valid + " = " + $nextValid + "; ";
        if ($thenPresent && $elsePresent) {
          $ifClause = "ifClause" + $lvl;
          out += " var " + $ifClause + " = 'then'; ";
        } else {
          $ifClause = "'then'";
        }
        out += " } ";
        if ($elsePresent) {
          out += " else { ";
        }
      } else {
        out += " if (!" + $nextValid + ") { ";
      }
      if ($elsePresent) {
        $it.schema = it2.schema["else"];
        $it.schemaPath = it2.schemaPath + ".else";
        $it.errSchemaPath = it2.errSchemaPath + "/else";
        out += "  " + it2.validate($it) + " ";
        $it.baseId = $currentBaseId;
        out += " " + $valid + " = " + $nextValid + "; ";
        if ($thenPresent && $elsePresent) {
          $ifClause = "ifClause" + $lvl;
          out += " var " + $ifClause + " = 'else'; ";
        } else {
          $ifClause = "'else'";
        }
        out += " } ";
      }
      out += " if (!" + $valid + ") {   var err =   ";
      if (it2.createErrors !== false) {
        out += " { keyword: 'if' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { failingKeyword: " + $ifClause + " } ";
        if (it2.opts.messages !== false) {
          out += ` , message: 'should match "' + ` + $ifClause + ` + '" schema' `;
        }
        if (it2.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      if (!it2.compositeRule && $breakOnError) {
        if (it2.async) {
          out += " throw new ValidationError(vErrors); ";
        } else {
          out += " validate.errors = vErrors; return false; ";
        }
      }
      out += " }   ";
      if ($breakOnError) {
        out += " else { ";
      }
    } else {
      if ($breakOnError) {
        out += " if (true) { ";
      }
    }
    return out;
  };
  return _if$2;
}
var items$2;
var hasRequiredItems$2;
function requireItems$2() {
  if (hasRequiredItems$2) return items$2;
  hasRequiredItems$2 = 1;
  items$2 = function generate_items(it2, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it2.level;
    var $dataLvl = it2.dataLevel;
    var $schema2 = it2.schema[$keyword];
    var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
    var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it2.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $errs = "errs__" + $lvl;
    var $it = it2.util.copy(it2);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it2.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it2.baseId;
    out += "var " + $errs + " = errors;var " + $valid + ";";
    if (Array.isArray($schema2)) {
      var $additionalItems = it2.schema.additionalItems;
      if ($additionalItems === false) {
        out += " " + $valid + " = " + $data + ".length <= " + $schema2.length + "; ";
        var $currErrSchemaPath = $errSchemaPath;
        $errSchemaPath = it2.errSchemaPath + "/additionalItems";
        out += "  if (!" + $valid + ") {   ";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it2.createErrors !== false) {
          out += " { keyword: 'additionalItems' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schema2.length + " } ";
          if (it2.opts.messages !== false) {
            out += " , message: 'should NOT have more than " + $schema2.length + " items' ";
          }
          if (it2.opts.verbose) {
            out += " , schema: false , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it2.compositeRule && $breakOnError) {
          if (it2.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } ";
        $errSchemaPath = $currErrSchemaPath;
        if ($breakOnError) {
          $closingBraces += "}";
          out += " else { ";
        }
      }
      var arr1 = $schema2;
      if (arr1) {
        var $sch, $i2 = -1, l1 = arr1.length - 1;
        while ($i2 < l1) {
          $sch = arr1[$i2 += 1];
          if (it2.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it2.util.schemaHasRules($sch, it2.RULES.all)) {
            out += " " + $nextValid + " = true; if (" + $data + ".length > " + $i2 + ") { ";
            var $passData = $data + "[" + $i2 + "]";
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + "[" + $i2 + "]";
            $it.errSchemaPath = $errSchemaPath + "/" + $i2;
            $it.errorPath = it2.util.getPathExpr(it2.errorPath, $i2, it2.opts.jsonPointers, true);
            $it.dataPathArr[$dataNxt] = $i2;
            var $code = it2.validate($it);
            $it.baseId = $currentBaseId;
            if (it2.util.varOccurences($code, $nextData) < 2) {
              out += " " + it2.util.varReplace($code, $nextData, $passData) + " ";
            } else {
              out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
            }
            out += " }  ";
            if ($breakOnError) {
              out += " if (" + $nextValid + ") { ";
              $closingBraces += "}";
            }
          }
        }
      }
      if (typeof $additionalItems == "object" && (it2.opts.strictKeywords ? typeof $additionalItems == "object" && Object.keys($additionalItems).length > 0 || $additionalItems === false : it2.util.schemaHasRules($additionalItems, it2.RULES.all))) {
        $it.schema = $additionalItems;
        $it.schemaPath = it2.schemaPath + ".additionalItems";
        $it.errSchemaPath = it2.errSchemaPath + "/additionalItems";
        out += " " + $nextValid + " = true; if (" + $data + ".length > " + $schema2.length + ") {  for (var " + $idx + " = " + $schema2.length + "; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
        $it.errorPath = it2.util.getPathExpr(it2.errorPath, $idx, it2.opts.jsonPointers, true);
        var $passData = $data + "[" + $idx + "]";
        $it.dataPathArr[$dataNxt] = $idx;
        var $code = it2.validate($it);
        $it.baseId = $currentBaseId;
        if (it2.util.varOccurences($code, $nextData) < 2) {
          out += " " + it2.util.varReplace($code, $nextData, $passData) + " ";
        } else {
          out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
        }
        if ($breakOnError) {
          out += " if (!" + $nextValid + ") break; ";
        }
        out += " } }  ";
        if ($breakOnError) {
          out += " if (" + $nextValid + ") { ";
          $closingBraces += "}";
        }
      }
    } else if (it2.opts.strictKeywords ? typeof $schema2 == "object" && Object.keys($schema2).length > 0 || $schema2 === false : it2.util.schemaHasRules($schema2, it2.RULES.all)) {
      $it.schema = $schema2;
      $it.schemaPath = $schemaPath;
      $it.errSchemaPath = $errSchemaPath;
      out += "  for (var " + $idx + " = 0; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
      $it.errorPath = it2.util.getPathExpr(it2.errorPath, $idx, it2.opts.jsonPointers, true);
      var $passData = $data + "[" + $idx + "]";
      $it.dataPathArr[$dataNxt] = $idx;
      var $code = it2.validate($it);
      $it.baseId = $currentBaseId;
      if (it2.util.varOccurences($code, $nextData) < 2) {
        out += " " + it2.util.varReplace($code, $nextData, $passData) + " ";
      } else {
        out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
      }
      if ($breakOnError) {
        out += " if (!" + $nextValid + ") break; ";
      }
      out += " }";
    }
    if ($breakOnError) {
      out += " " + $closingBraces + " if (" + $errs + " == errors) {";
    }
    return out;
  };
  return items$2;
}
var _limit;
var hasRequired_limit;
function require_limit() {
  if (hasRequired_limit) return _limit;
  hasRequired_limit = 1;
  _limit = function generate__limit(it2, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it2.level;
    var $dataLvl = it2.dataLevel;
    var $schema2 = it2.schema[$keyword];
    var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
    var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it2.opts.allErrors;
    var $errorKeyword;
    var $data = "data" + ($dataLvl || "");
    var $isData = it2.opts.$data && $schema2 && $schema2.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it2.util.getData($schema2.$data, $dataLvl, it2.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema2;
    }
    var $isMax = $keyword == "maximum", $exclusiveKeyword = $isMax ? "exclusiveMaximum" : "exclusiveMinimum", $schemaExcl = it2.schema[$exclusiveKeyword], $isDataExcl = it2.opts.$data && $schemaExcl && $schemaExcl.$data, $op = $isMax ? "<" : ">", $notOp = $isMax ? ">" : "<", $errorKeyword = void 0;
    if (!($isData || typeof $schema2 == "number" || $schema2 === void 0)) {
      throw new Error($keyword + " must be number");
    }
    if (!($isDataExcl || $schemaExcl === void 0 || typeof $schemaExcl == "number" || typeof $schemaExcl == "boolean")) {
      throw new Error($exclusiveKeyword + " must be number or boolean");
    }
    if ($isDataExcl) {
      var $schemaValueExcl = it2.util.getData($schemaExcl.$data, $dataLvl, it2.dataPathArr), $exclusive = "exclusive" + $lvl, $exclType = "exclType" + $lvl, $exclIsNumber = "exclIsNumber" + $lvl, $opExpr = "op" + $lvl, $opStr = "' + " + $opExpr + " + '";
      out += " var schemaExcl" + $lvl + " = " + $schemaValueExcl + "; ";
      $schemaValueExcl = "schemaExcl" + $lvl;
      out += " var " + $exclusive + "; var " + $exclType + " = typeof " + $schemaValueExcl + "; if (" + $exclType + " != 'boolean' && " + $exclType + " != 'undefined' && " + $exclType + " != 'number') { ";
      var $errorKeyword = $exclusiveKeyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it2.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_exclusiveLimit") + "' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: {} ";
        if (it2.opts.messages !== false) {
          out += " , message: '" + $exclusiveKeyword + " should be boolean' ";
        }
        if (it2.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it2.compositeRule && $breakOnError) {
        if (it2.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } else if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
      }
      out += " " + $exclType + " == 'number' ? ( (" + $exclusive + " = " + $schemaValue + " === undefined || " + $schemaValueExcl + " " + $op + "= " + $schemaValue + ") ? " + $data + " " + $notOp + "= " + $schemaValueExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) : ( (" + $exclusive + " = " + $schemaValueExcl + " === true) ? " + $data + " " + $notOp + "= " + $schemaValue + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { var op" + $lvl + " = " + $exclusive + " ? '" + $op + "' : '" + $op + "='; ";
      if ($schema2 === void 0) {
        $errorKeyword = $exclusiveKeyword;
        $errSchemaPath = it2.errSchemaPath + "/" + $exclusiveKeyword;
        $schemaValue = $schemaValueExcl;
        $isData = $isDataExcl;
      }
    } else {
      var $exclIsNumber = typeof $schemaExcl == "number", $opStr = $op;
      if ($exclIsNumber && $isData) {
        var $opExpr = "'" + $opStr + "'";
        out += " if ( ";
        if ($isData) {
          out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
        }
        out += " ( " + $schemaValue + " === undefined || " + $schemaExcl + " " + $op + "= " + $schemaValue + " ? " + $data + " " + $notOp + "= " + $schemaExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { ";
      } else {
        if ($exclIsNumber && $schema2 === void 0) {
          $exclusive = true;
          $errorKeyword = $exclusiveKeyword;
          $errSchemaPath = it2.errSchemaPath + "/" + $exclusiveKeyword;
          $schemaValue = $schemaExcl;
          $notOp += "=";
        } else {
          if ($exclIsNumber) $schemaValue = Math[$isMax ? "min" : "max"]($schemaExcl, $schema2);
          if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
            $exclusive = true;
            $errorKeyword = $exclusiveKeyword;
            $errSchemaPath = it2.errSchemaPath + "/" + $exclusiveKeyword;
            $notOp += "=";
          } else {
            $exclusive = false;
            $opStr += "=";
          }
        }
        var $opExpr = "'" + $opStr + "'";
        out += " if ( ";
        if ($isData) {
          out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
        }
        out += " " + $data + " " + $notOp + " " + $schemaValue + " || " + $data + " !== " + $data + ") { ";
      }
    }
    $errorKeyword = $errorKeyword || $keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it2.createErrors !== false) {
      out += " { keyword: '" + ($errorKeyword || "_limit") + "' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { comparison: " + $opExpr + ", limit: " + $schemaValue + ", exclusive: " + $exclusive + " } ";
      if (it2.opts.messages !== false) {
        out += " , message: 'should be " + $opStr + " ";
        if ($isData) {
          out += "' + " + $schemaValue;
        } else {
          out += "" + $schemaValue + "'";
        }
      }
      if (it2.opts.verbose) {
        out += " , schema:  ";
        if ($isData) {
          out += "validate.schema" + $schemaPath;
        } else {
          out += "" + $schema2;
        }
        out += "         , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it2.compositeRule && $breakOnError) {
      if (it2.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += " } ";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
  return _limit;
}
var _limitItems;
var hasRequired_limitItems;
function require_limitItems() {
  if (hasRequired_limitItems) return _limitItems;
  hasRequired_limitItems = 1;
  _limitItems = function generate__limitItems(it2, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it2.level;
    var $dataLvl = it2.dataLevel;
    var $schema2 = it2.schema[$keyword];
    var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
    var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it2.opts.allErrors;
    var $errorKeyword;
    var $data = "data" + ($dataLvl || "");
    var $isData = it2.opts.$data && $schema2 && $schema2.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it2.util.getData($schema2.$data, $dataLvl, it2.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema2;
    }
    if (!($isData || typeof $schema2 == "number")) {
      throw new Error($keyword + " must be number");
    }
    var $op = $keyword == "maxItems" ? ">" : "<";
    out += "if ( ";
    if ($isData) {
      out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
    }
    out += " " + $data + ".length " + $op + " " + $schemaValue + ") { ";
    var $errorKeyword = $keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it2.createErrors !== false) {
      out += " { keyword: '" + ($errorKeyword || "_limitItems") + "' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
      if (it2.opts.messages !== false) {
        out += " , message: 'should NOT have ";
        if ($keyword == "maxItems") {
          out += "more";
        } else {
          out += "fewer";
        }
        out += " than ";
        if ($isData) {
          out += "' + " + $schemaValue + " + '";
        } else {
          out += "" + $schema2;
        }
        out += " items' ";
      }
      if (it2.opts.verbose) {
        out += " , schema:  ";
        if ($isData) {
          out += "validate.schema" + $schemaPath;
        } else {
          out += "" + $schema2;
        }
        out += "         , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it2.compositeRule && $breakOnError) {
      if (it2.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += "} ";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
  return _limitItems;
}
var _limitLength;
var hasRequired_limitLength;
function require_limitLength() {
  if (hasRequired_limitLength) return _limitLength;
  hasRequired_limitLength = 1;
  _limitLength = function generate__limitLength(it2, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it2.level;
    var $dataLvl = it2.dataLevel;
    var $schema2 = it2.schema[$keyword];
    var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
    var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it2.opts.allErrors;
    var $errorKeyword;
    var $data = "data" + ($dataLvl || "");
    var $isData = it2.opts.$data && $schema2 && $schema2.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it2.util.getData($schema2.$data, $dataLvl, it2.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema2;
    }
    if (!($isData || typeof $schema2 == "number")) {
      throw new Error($keyword + " must be number");
    }
    var $op = $keyword == "maxLength" ? ">" : "<";
    out += "if ( ";
    if ($isData) {
      out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
    }
    if (it2.opts.unicode === false) {
      out += " " + $data + ".length ";
    } else {
      out += " ucs2length(" + $data + ") ";
    }
    out += " " + $op + " " + $schemaValue + ") { ";
    var $errorKeyword = $keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it2.createErrors !== false) {
      out += " { keyword: '" + ($errorKeyword || "_limitLength") + "' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
      if (it2.opts.messages !== false) {
        out += " , message: 'should NOT be ";
        if ($keyword == "maxLength") {
          out += "longer";
        } else {
          out += "shorter";
        }
        out += " than ";
        if ($isData) {
          out += "' + " + $schemaValue + " + '";
        } else {
          out += "" + $schema2;
        }
        out += " characters' ";
      }
      if (it2.opts.verbose) {
        out += " , schema:  ";
        if ($isData) {
          out += "validate.schema" + $schemaPath;
        } else {
          out += "" + $schema2;
        }
        out += "         , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it2.compositeRule && $breakOnError) {
      if (it2.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += "} ";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
  return _limitLength;
}
var _limitProperties;
var hasRequired_limitProperties;
function require_limitProperties() {
  if (hasRequired_limitProperties) return _limitProperties;
  hasRequired_limitProperties = 1;
  _limitProperties = function generate__limitProperties(it2, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it2.level;
    var $dataLvl = it2.dataLevel;
    var $schema2 = it2.schema[$keyword];
    var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
    var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it2.opts.allErrors;
    var $errorKeyword;
    var $data = "data" + ($dataLvl || "");
    var $isData = it2.opts.$data && $schema2 && $schema2.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it2.util.getData($schema2.$data, $dataLvl, it2.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema2;
    }
    if (!($isData || typeof $schema2 == "number")) {
      throw new Error($keyword + " must be number");
    }
    var $op = $keyword == "maxProperties" ? ">" : "<";
    out += "if ( ";
    if ($isData) {
      out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
    }
    out += " Object.keys(" + $data + ").length " + $op + " " + $schemaValue + ") { ";
    var $errorKeyword = $keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it2.createErrors !== false) {
      out += " { keyword: '" + ($errorKeyword || "_limitProperties") + "' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
      if (it2.opts.messages !== false) {
        out += " , message: 'should NOT have ";
        if ($keyword == "maxProperties") {
          out += "more";
        } else {
          out += "fewer";
        }
        out += " than ";
        if ($isData) {
          out += "' + " + $schemaValue + " + '";
        } else {
          out += "" + $schema2;
        }
        out += " properties' ";
      }
      if (it2.opts.verbose) {
        out += " , schema:  ";
        if ($isData) {
          out += "validate.schema" + $schemaPath;
        } else {
          out += "" + $schema2;
        }
        out += "         , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it2.compositeRule && $breakOnError) {
      if (it2.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += "} ";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
  return _limitProperties;
}
var multipleOf$2;
var hasRequiredMultipleOf$2;
function requireMultipleOf$2() {
  if (hasRequiredMultipleOf$2) return multipleOf$2;
  hasRequiredMultipleOf$2 = 1;
  multipleOf$2 = function generate_multipleOf(it2, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it2.level;
    var $dataLvl = it2.dataLevel;
    var $schema2 = it2.schema[$keyword];
    var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
    var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it2.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $isData = it2.opts.$data && $schema2 && $schema2.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it2.util.getData($schema2.$data, $dataLvl, it2.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema2;
    }
    if (!($isData || typeof $schema2 == "number")) {
      throw new Error($keyword + " must be number");
    }
    out += "var division" + $lvl + ";if (";
    if ($isData) {
      out += " " + $schemaValue + " !== undefined && ( typeof " + $schemaValue + " != 'number' || ";
    }
    out += " (division" + $lvl + " = " + $data + " / " + $schemaValue + ", ";
    if (it2.opts.multipleOfPrecision) {
      out += " Math.abs(Math.round(division" + $lvl + ") - division" + $lvl + ") > 1e-" + it2.opts.multipleOfPrecision + " ";
    } else {
      out += " division" + $lvl + " !== parseInt(division" + $lvl + ") ";
    }
    out += " ) ";
    if ($isData) {
      out += "  )  ";
    }
    out += " ) {   ";
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it2.createErrors !== false) {
      out += " { keyword: 'multipleOf' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { multipleOf: " + $schemaValue + " } ";
      if (it2.opts.messages !== false) {
        out += " , message: 'should be multiple of ";
        if ($isData) {
          out += "' + " + $schemaValue;
        } else {
          out += "" + $schemaValue + "'";
        }
      }
      if (it2.opts.verbose) {
        out += " , schema:  ";
        if ($isData) {
          out += "validate.schema" + $schemaPath;
        } else {
          out += "" + $schema2;
        }
        out += "         , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it2.compositeRule && $breakOnError) {
      if (it2.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += "} ";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
  return multipleOf$2;
}
var not$2;
var hasRequiredNot$2;
function requireNot$2() {
  if (hasRequiredNot$2) return not$2;
  hasRequiredNot$2 = 1;
  not$2 = function generate_not(it2, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it2.level;
    var $dataLvl = it2.dataLevel;
    var $schema2 = it2.schema[$keyword];
    var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
    var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it2.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $errs = "errs__" + $lvl;
    var $it = it2.util.copy(it2);
    $it.level++;
    var $nextValid = "valid" + $it.level;
    if (it2.opts.strictKeywords ? typeof $schema2 == "object" && Object.keys($schema2).length > 0 || $schema2 === false : it2.util.schemaHasRules($schema2, it2.RULES.all)) {
      $it.schema = $schema2;
      $it.schemaPath = $schemaPath;
      $it.errSchemaPath = $errSchemaPath;
      out += " var " + $errs + " = errors;  ";
      var $wasComposite = it2.compositeRule;
      it2.compositeRule = $it.compositeRule = true;
      $it.createErrors = false;
      var $allErrorsOption;
      if ($it.opts.allErrors) {
        $allErrorsOption = $it.opts.allErrors;
        $it.opts.allErrors = false;
      }
      out += " " + it2.validate($it) + " ";
      $it.createErrors = true;
      if ($allErrorsOption) $it.opts.allErrors = $allErrorsOption;
      it2.compositeRule = $it.compositeRule = $wasComposite;
      out += " if (" + $nextValid + ") {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it2.createErrors !== false) {
        out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: {} ";
        if (it2.opts.messages !== false) {
          out += " , message: 'should NOT be valid' ";
        }
        if (it2.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it2.compositeRule && $breakOnError) {
        if (it2.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
      if (it2.opts.allErrors) {
        out += " } ";
      }
    } else {
      out += "  var err =   ";
      if (it2.createErrors !== false) {
        out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: {} ";
        if (it2.opts.messages !== false) {
          out += " , message: 'should NOT be valid' ";
        }
        if (it2.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      if ($breakOnError) {
        out += " if (false) { ";
      }
    }
    return out;
  };
  return not$2;
}
var oneOf$2;
var hasRequiredOneOf$2;
function requireOneOf$2() {
  if (hasRequiredOneOf$2) return oneOf$2;
  hasRequiredOneOf$2 = 1;
  oneOf$2 = function generate_oneOf(it2, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it2.level;
    var $dataLvl = it2.dataLevel;
    var $schema2 = it2.schema[$keyword];
    var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
    var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it2.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $errs = "errs__" + $lvl;
    var $it = it2.util.copy(it2);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $currentBaseId = $it.baseId, $prevValid = "prevValid" + $lvl, $passingSchemas = "passingSchemas" + $lvl;
    out += "var " + $errs + " = errors , " + $prevValid + " = false , " + $valid + " = false , " + $passingSchemas + " = null; ";
    var $wasComposite = it2.compositeRule;
    it2.compositeRule = $it.compositeRule = true;
    var arr1 = $schema2;
    if (arr1) {
      var $sch, $i2 = -1, l1 = arr1.length - 1;
      while ($i2 < l1) {
        $sch = arr1[$i2 += 1];
        if (it2.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it2.util.schemaHasRules($sch, it2.RULES.all)) {
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + "[" + $i2 + "]";
          $it.errSchemaPath = $errSchemaPath + "/" + $i2;
          out += "  " + it2.validate($it) + " ";
          $it.baseId = $currentBaseId;
        } else {
          out += " var " + $nextValid + " = true; ";
        }
        if ($i2) {
          out += " if (" + $nextValid + " && " + $prevValid + ") { " + $valid + " = false; " + $passingSchemas + " = [" + $passingSchemas + ", " + $i2 + "]; } else { ";
          $closingBraces += "}";
        }
        out += " if (" + $nextValid + ") { " + $valid + " = " + $prevValid + " = true; " + $passingSchemas + " = " + $i2 + "; }";
      }
    }
    it2.compositeRule = $it.compositeRule = $wasComposite;
    out += "" + $closingBraces + "if (!" + $valid + ") {   var err =   ";
    if (it2.createErrors !== false) {
      out += " { keyword: 'oneOf' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { passingSchemas: " + $passingSchemas + " } ";
      if (it2.opts.messages !== false) {
        out += " , message: 'should match exactly one schema in oneOf' ";
      }
      if (it2.opts.verbose) {
        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    if (!it2.compositeRule && $breakOnError) {
      if (it2.async) {
        out += " throw new ValidationError(vErrors); ";
      } else {
        out += " validate.errors = vErrors; return false; ";
      }
    }
    out += "} else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }";
    if (it2.opts.allErrors) {
      out += " } ";
    }
    return out;
  };
  return oneOf$2;
}
var pattern$2;
var hasRequiredPattern$2;
function requirePattern$2() {
  if (hasRequiredPattern$2) return pattern$2;
  hasRequiredPattern$2 = 1;
  pattern$2 = function generate_pattern(it2, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it2.level;
    var $dataLvl = it2.dataLevel;
    var $schema2 = it2.schema[$keyword];
    var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
    var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it2.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $isData = it2.opts.$data && $schema2 && $schema2.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it2.util.getData($schema2.$data, $dataLvl, it2.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema2;
    }
    var $regExpCode = it2.opts.regExp ? "regExp" : "new RegExp";
    if ($isData) {
      out += " var " + $valid + " = true; try { " + $valid + " = " + $regExpCode + "(" + $schemaValue + ").test(" + $data + "); } catch(e) { " + $valid + " = false; } if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
      }
      out += " !" + $valid + ") {";
    } else {
      var $regexp = it2.usePattern($schema2);
      out += " if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
      }
      out += " !" + $regexp + ".test(" + $data + ") ) {";
    }
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it2.createErrors !== false) {
      out += " { keyword: 'pattern' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { pattern:  ";
      if ($isData) {
        out += "" + $schemaValue;
      } else {
        out += "" + it2.util.toQuotedString($schema2);
      }
      out += "  } ";
      if (it2.opts.messages !== false) {
        out += ` , message: 'should match pattern "`;
        if ($isData) {
          out += "' + " + $schemaValue + " + '";
        } else {
          out += "" + it2.util.escapeQuotes($schema2);
        }
        out += `"' `;
      }
      if (it2.opts.verbose) {
        out += " , schema:  ";
        if ($isData) {
          out += "validate.schema" + $schemaPath;
        } else {
          out += "" + it2.util.toQuotedString($schema2);
        }
        out += "         , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it2.compositeRule && $breakOnError) {
      if (it2.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += "} ";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
  return pattern$2;
}
var properties$8;
var hasRequiredProperties$2;
function requireProperties$2() {
  if (hasRequiredProperties$2) return properties$8;
  hasRequiredProperties$2 = 1;
  properties$8 = function generate_properties(it2, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it2.level;
    var $dataLvl = it2.dataLevel;
    var $schema2 = it2.schema[$keyword];
    var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
    var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it2.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $errs = "errs__" + $lvl;
    var $it = it2.util.copy(it2);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $key = "key" + $lvl, $idx = "idx" + $lvl, $dataNxt = $it.dataLevel = it2.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl;
    var $schemaKeys = Object.keys($schema2 || {}).filter(notProto), $pProperties = it2.schema.patternProperties || {}, $pPropertyKeys = Object.keys($pProperties).filter(notProto), $aProperties = it2.schema.additionalProperties, $someProperties = $schemaKeys.length || $pPropertyKeys.length, $noAdditional = $aProperties === false, $additionalIsSchema = typeof $aProperties == "object" && Object.keys($aProperties).length, $removeAdditional = it2.opts.removeAdditional, $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional, $ownProperties = it2.opts.ownProperties, $currentBaseId = it2.baseId;
    var $required = it2.schema.required;
    if ($required && !(it2.opts.$data && $required.$data) && $required.length < it2.opts.loopRequired) {
      var $requiredHash = it2.util.toHash($required);
    }
    function notProto(p2) {
      return p2 !== "__proto__";
    }
    out += "var " + $errs + " = errors;var " + $nextValid + " = true;";
    if ($ownProperties) {
      out += " var " + $dataProperties + " = undefined;";
    }
    if ($checkAdditional) {
      if ($ownProperties) {
        out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
      } else {
        out += " for (var " + $key + " in " + $data + ") { ";
      }
      if ($someProperties) {
        out += " var isAdditional" + $lvl + " = !(false ";
        if ($schemaKeys.length) {
          if ($schemaKeys.length > 8) {
            out += " || validate.schema" + $schemaPath + ".hasOwnProperty(" + $key + ") ";
          } else {
            var arr1 = $schemaKeys;
            if (arr1) {
              var $propertyKey, i1 = -1, l1 = arr1.length - 1;
              while (i1 < l1) {
                $propertyKey = arr1[i1 += 1];
                out += " || " + $key + " == " + it2.util.toQuotedString($propertyKey) + " ";
              }
            }
          }
        }
        if ($pPropertyKeys.length) {
          var arr2 = $pPropertyKeys;
          if (arr2) {
            var $pProperty, $i2 = -1, l2 = arr2.length - 1;
            while ($i2 < l2) {
              $pProperty = arr2[$i2 += 1];
              out += " || " + it2.usePattern($pProperty) + ".test(" + $key + ") ";
            }
          }
        }
        out += " ); if (isAdditional" + $lvl + ") { ";
      }
      if ($removeAdditional == "all") {
        out += " delete " + $data + "[" + $key + "]; ";
      } else {
        var $currentErrorPath = it2.errorPath;
        var $additionalProperty = "' + " + $key + " + '";
        if (it2.opts._errorDataPathProperty) {
          it2.errorPath = it2.util.getPathExpr(it2.errorPath, $key, it2.opts.jsonPointers);
        }
        if ($noAdditional) {
          if ($removeAdditional) {
            out += " delete " + $data + "[" + $key + "]; ";
          } else {
            out += " " + $nextValid + " = false; ";
            var $currErrSchemaPath = $errSchemaPath;
            $errSchemaPath = it2.errSchemaPath + "/additionalProperties";
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it2.createErrors !== false) {
              out += " { keyword: 'additionalProperties' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { additionalProperty: '" + $additionalProperty + "' } ";
              if (it2.opts.messages !== false) {
                out += " , message: '";
                if (it2.opts._errorDataPathProperty) {
                  out += "is an invalid additional property";
                } else {
                  out += "should NOT have additional properties";
                }
                out += "' ";
              }
              if (it2.opts.verbose) {
                out += " , schema: false , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it2.compositeRule && $breakOnError) {
              if (it2.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            $errSchemaPath = $currErrSchemaPath;
            if ($breakOnError) {
              out += " break; ";
            }
          }
        } else if ($additionalIsSchema) {
          if ($removeAdditional == "failing") {
            out += " var " + $errs + " = errors;  ";
            var $wasComposite = it2.compositeRule;
            it2.compositeRule = $it.compositeRule = true;
            $it.schema = $aProperties;
            $it.schemaPath = it2.schemaPath + ".additionalProperties";
            $it.errSchemaPath = it2.errSchemaPath + "/additionalProperties";
            $it.errorPath = it2.opts._errorDataPathProperty ? it2.errorPath : it2.util.getPathExpr(it2.errorPath, $key, it2.opts.jsonPointers);
            var $passData = $data + "[" + $key + "]";
            $it.dataPathArr[$dataNxt] = $key;
            var $code = it2.validate($it);
            $it.baseId = $currentBaseId;
            if (it2.util.varOccurences($code, $nextData) < 2) {
              out += " " + it2.util.varReplace($code, $nextData, $passData) + " ";
            } else {
              out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
            }
            out += " if (!" + $nextValid + ") { errors = " + $errs + "; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete " + $data + "[" + $key + "]; }  ";
            it2.compositeRule = $it.compositeRule = $wasComposite;
          } else {
            $it.schema = $aProperties;
            $it.schemaPath = it2.schemaPath + ".additionalProperties";
            $it.errSchemaPath = it2.errSchemaPath + "/additionalProperties";
            $it.errorPath = it2.opts._errorDataPathProperty ? it2.errorPath : it2.util.getPathExpr(it2.errorPath, $key, it2.opts.jsonPointers);
            var $passData = $data + "[" + $key + "]";
            $it.dataPathArr[$dataNxt] = $key;
            var $code = it2.validate($it);
            $it.baseId = $currentBaseId;
            if (it2.util.varOccurences($code, $nextData) < 2) {
              out += " " + it2.util.varReplace($code, $nextData, $passData) + " ";
            } else {
              out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
            }
            if ($breakOnError) {
              out += " if (!" + $nextValid + ") break; ";
            }
          }
        }
        it2.errorPath = $currentErrorPath;
      }
      if ($someProperties) {
        out += " } ";
      }
      out += " }  ";
      if ($breakOnError) {
        out += " if (" + $nextValid + ") { ";
        $closingBraces += "}";
      }
    }
    var $useDefaults = it2.opts.useDefaults && !it2.compositeRule;
    if ($schemaKeys.length) {
      var arr3 = $schemaKeys;
      if (arr3) {
        var $propertyKey, i3 = -1, l3 = arr3.length - 1;
        while (i3 < l3) {
          $propertyKey = arr3[i3 += 1];
          var $sch = $schema2[$propertyKey];
          if (it2.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it2.util.schemaHasRules($sch, it2.RULES.all)) {
            var $prop = it2.util.getProperty($propertyKey), $passData = $data + $prop, $hasDefault = $useDefaults && $sch.default !== void 0;
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + $prop;
            $it.errSchemaPath = $errSchemaPath + "/" + it2.util.escapeFragment($propertyKey);
            $it.errorPath = it2.util.getPath(it2.errorPath, $propertyKey, it2.opts.jsonPointers);
            $it.dataPathArr[$dataNxt] = it2.util.toQuotedString($propertyKey);
            var $code = it2.validate($it);
            $it.baseId = $currentBaseId;
            if (it2.util.varOccurences($code, $nextData) < 2) {
              $code = it2.util.varReplace($code, $nextData, $passData);
              var $useData = $passData;
            } else {
              var $useData = $nextData;
              out += " var " + $nextData + " = " + $passData + "; ";
            }
            if ($hasDefault) {
              out += " " + $code + " ";
            } else {
              if ($requiredHash && $requiredHash[$propertyKey]) {
                out += " if ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it2.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") { " + $nextValid + " = false; ";
                var $currentErrorPath = it2.errorPath, $currErrSchemaPath = $errSchemaPath, $missingProperty = it2.util.escapeQuotes($propertyKey);
                if (it2.opts._errorDataPathProperty) {
                  it2.errorPath = it2.util.getPath($currentErrorPath, $propertyKey, it2.opts.jsonPointers);
                }
                $errSchemaPath = it2.errSchemaPath + "/required";
                var $$outStack = $$outStack || [];
                $$outStack.push(out);
                out = "";
                if (it2.createErrors !== false) {
                  out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                  if (it2.opts.messages !== false) {
                    out += " , message: '";
                    if (it2.opts._errorDataPathProperty) {
                      out += "is a required property";
                    } else {
                      out += "should have required property \\'" + $missingProperty + "\\'";
                    }
                    out += "' ";
                  }
                  if (it2.opts.verbose) {
                    out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
                  }
                  out += " } ";
                } else {
                  out += " {} ";
                }
                var __err = out;
                out = $$outStack.pop();
                if (!it2.compositeRule && $breakOnError) {
                  if (it2.async) {
                    out += " throw new ValidationError([" + __err + "]); ";
                  } else {
                    out += " validate.errors = [" + __err + "]; return false; ";
                  }
                } else {
                  out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                }
                $errSchemaPath = $currErrSchemaPath;
                it2.errorPath = $currentErrorPath;
                out += " } else { ";
              } else {
                if ($breakOnError) {
                  out += " if ( " + $useData + " === undefined ";
                  if ($ownProperties) {
                    out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it2.util.escapeQuotes($propertyKey) + "') ";
                  }
                  out += ") { " + $nextValid + " = true; } else { ";
                } else {
                  out += " if (" + $useData + " !== undefined ";
                  if ($ownProperties) {
                    out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", '" + it2.util.escapeQuotes($propertyKey) + "') ";
                  }
                  out += " ) { ";
                }
              }
              out += " " + $code + " } ";
            }
          }
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
            $closingBraces += "}";
          }
        }
      }
    }
    if ($pPropertyKeys.length) {
      var arr4 = $pPropertyKeys;
      if (arr4) {
        var $pProperty, i4 = -1, l42 = arr4.length - 1;
        while (i4 < l42) {
          $pProperty = arr4[i4 += 1];
          var $sch = $pProperties[$pProperty];
          if (it2.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it2.util.schemaHasRules($sch, it2.RULES.all)) {
            $it.schema = $sch;
            $it.schemaPath = it2.schemaPath + ".patternProperties" + it2.util.getProperty($pProperty);
            $it.errSchemaPath = it2.errSchemaPath + "/patternProperties/" + it2.util.escapeFragment($pProperty);
            if ($ownProperties) {
              out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
            } else {
              out += " for (var " + $key + " in " + $data + ") { ";
            }
            out += " if (" + it2.usePattern($pProperty) + ".test(" + $key + ")) { ";
            $it.errorPath = it2.util.getPathExpr(it2.errorPath, $key, it2.opts.jsonPointers);
            var $passData = $data + "[" + $key + "]";
            $it.dataPathArr[$dataNxt] = $key;
            var $code = it2.validate($it);
            $it.baseId = $currentBaseId;
            if (it2.util.varOccurences($code, $nextData) < 2) {
              out += " " + it2.util.varReplace($code, $nextData, $passData) + " ";
            } else {
              out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
            }
            if ($breakOnError) {
              out += " if (!" + $nextValid + ") break; ";
            }
            out += " } ";
            if ($breakOnError) {
              out += " else " + $nextValid + " = true; ";
            }
            out += " }  ";
            if ($breakOnError) {
              out += " if (" + $nextValid + ") { ";
              $closingBraces += "}";
            }
          }
        }
      }
    }
    if ($breakOnError) {
      out += " " + $closingBraces + " if (" + $errs + " == errors) {";
    }
    return out;
  };
  return properties$8;
}
var propertyNames$2;
var hasRequiredPropertyNames$2;
function requirePropertyNames$2() {
  if (hasRequiredPropertyNames$2) return propertyNames$2;
  hasRequiredPropertyNames$2 = 1;
  propertyNames$2 = function generate_propertyNames(it2, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it2.level;
    var $dataLvl = it2.dataLevel;
    var $schema2 = it2.schema[$keyword];
    var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
    var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it2.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $errs = "errs__" + $lvl;
    var $it = it2.util.copy(it2);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    out += "var " + $errs + " = errors;";
    if (it2.opts.strictKeywords ? typeof $schema2 == "object" && Object.keys($schema2).length > 0 || $schema2 === false : it2.util.schemaHasRules($schema2, it2.RULES.all)) {
      $it.schema = $schema2;
      $it.schemaPath = $schemaPath;
      $it.errSchemaPath = $errSchemaPath;
      var $key = "key" + $lvl, $idx = "idx" + $lvl, $i2 = "i" + $lvl, $invalidName = "' + " + $key + " + '", $dataNxt = $it.dataLevel = it2.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl, $ownProperties = it2.opts.ownProperties, $currentBaseId = it2.baseId;
      if ($ownProperties) {
        out += " var " + $dataProperties + " = undefined; ";
      }
      if ($ownProperties) {
        out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
      } else {
        out += " for (var " + $key + " in " + $data + ") { ";
      }
      out += " var startErrs" + $lvl + " = errors; ";
      var $passData = $key;
      var $wasComposite = it2.compositeRule;
      it2.compositeRule = $it.compositeRule = true;
      var $code = it2.validate($it);
      $it.baseId = $currentBaseId;
      if (it2.util.varOccurences($code, $nextData) < 2) {
        out += " " + it2.util.varReplace($code, $nextData, $passData) + " ";
      } else {
        out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
      }
      it2.compositeRule = $it.compositeRule = $wasComposite;
      out += " if (!" + $nextValid + ") { for (var " + $i2 + "=startErrs" + $lvl + "; " + $i2 + "<errors; " + $i2 + "++) { vErrors[" + $i2 + "].propertyName = " + $key + "; }   var err =   ";
      if (it2.createErrors !== false) {
        out += " { keyword: 'propertyNames' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { propertyName: '" + $invalidName + "' } ";
        if (it2.opts.messages !== false) {
          out += " , message: 'property name \\'" + $invalidName + "\\' is invalid' ";
        }
        if (it2.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      if (!it2.compositeRule && $breakOnError) {
        if (it2.async) {
          out += " throw new ValidationError(vErrors); ";
        } else {
          out += " validate.errors = vErrors; return false; ";
        }
      }
      if ($breakOnError) {
        out += " break; ";
      }
      out += " } }";
    }
    if ($breakOnError) {
      out += " " + $closingBraces + " if (" + $errs + " == errors) {";
    }
    return out;
  };
  return propertyNames$2;
}
var required$5;
var hasRequiredRequired$2;
function requireRequired$2() {
  if (hasRequiredRequired$2) return required$5;
  hasRequiredRequired$2 = 1;
  required$5 = function generate_required(it2, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it2.level;
    var $dataLvl = it2.dataLevel;
    var $schema2 = it2.schema[$keyword];
    var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
    var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it2.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $isData = it2.opts.$data && $schema2 && $schema2.$data;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it2.util.getData($schema2.$data, $dataLvl, it2.dataPathArr) + "; ";
    }
    var $vSchema = "schema" + $lvl;
    if (!$isData) {
      if ($schema2.length < it2.opts.loopRequired && it2.schema.properties && Object.keys(it2.schema.properties).length) {
        var $required = [];
        var arr1 = $schema2;
        if (arr1) {
          var $property, i1 = -1, l1 = arr1.length - 1;
          while (i1 < l1) {
            $property = arr1[i1 += 1];
            var $propertySch = it2.schema.properties[$property];
            if (!($propertySch && (it2.opts.strictKeywords ? typeof $propertySch == "object" && Object.keys($propertySch).length > 0 || $propertySch === false : it2.util.schemaHasRules($propertySch, it2.RULES.all)))) {
              $required[$required.length] = $property;
            }
          }
        }
      } else {
        var $required = $schema2;
      }
    }
    if ($isData || $required.length) {
      var $currentErrorPath = it2.errorPath, $loopRequired = $isData || $required.length >= it2.opts.loopRequired, $ownProperties = it2.opts.ownProperties;
      if ($breakOnError) {
        out += " var missing" + $lvl + "; ";
        if ($loopRequired) {
          if (!$isData) {
            out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
          }
          var $i2 = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i2 + "]", $missingProperty = "' + " + $propertyPath + " + '";
          if (it2.opts._errorDataPathProperty) {
            it2.errorPath = it2.util.getPathExpr($currentErrorPath, $propertyPath, it2.opts.jsonPointers);
          }
          out += " var " + $valid + " = true; ";
          if ($isData) {
            out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
          }
          out += " for (var " + $i2 + " = 0; " + $i2 + " < " + $vSchema + ".length; " + $i2 + "++) { " + $valid + " = " + $data + "[" + $vSchema + "[" + $i2 + "]] !== undefined ";
          if ($ownProperties) {
            out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i2 + "]) ";
          }
          out += "; if (!" + $valid + ") break; } ";
          if ($isData) {
            out += "  }  ";
          }
          out += "  if (!" + $valid + ") {   ";
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it2.createErrors !== false) {
            out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
            if (it2.opts.messages !== false) {
              out += " , message: '";
              if (it2.opts._errorDataPathProperty) {
                out += "is a required property";
              } else {
                out += "should have required property \\'" + $missingProperty + "\\'";
              }
              out += "' ";
            }
            if (it2.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it2.compositeRule && $breakOnError) {
            if (it2.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          out += " } else { ";
        } else {
          out += " if ( ";
          var arr2 = $required;
          if (arr2) {
            var $propertyKey, $i2 = -1, l2 = arr2.length - 1;
            while ($i2 < l2) {
              $propertyKey = arr2[$i2 += 1];
              if ($i2) {
                out += " || ";
              }
              var $prop = it2.util.getProperty($propertyKey), $useData = $data + $prop;
              out += " ( ( " + $useData + " === undefined ";
              if ($ownProperties) {
                out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it2.util.escapeQuotes($propertyKey) + "') ";
              }
              out += ") && (missing" + $lvl + " = " + it2.util.toQuotedString(it2.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
            }
          }
          out += ") {  ";
          var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
          if (it2.opts._errorDataPathProperty) {
            it2.errorPath = it2.opts.jsonPointers ? it2.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
          }
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it2.createErrors !== false) {
            out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
            if (it2.opts.messages !== false) {
              out += " , message: '";
              if (it2.opts._errorDataPathProperty) {
                out += "is a required property";
              } else {
                out += "should have required property \\'" + $missingProperty + "\\'";
              }
              out += "' ";
            }
            if (it2.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it2.compositeRule && $breakOnError) {
            if (it2.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          out += " } else { ";
        }
      } else {
        if ($loopRequired) {
          if (!$isData) {
            out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
          }
          var $i2 = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i2 + "]", $missingProperty = "' + " + $propertyPath + " + '";
          if (it2.opts._errorDataPathProperty) {
            it2.errorPath = it2.util.getPathExpr($currentErrorPath, $propertyPath, it2.opts.jsonPointers);
          }
          if ($isData) {
            out += " if (" + $vSchema + " && !Array.isArray(" + $vSchema + ")) {  var err =   ";
            if (it2.createErrors !== false) {
              out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
              if (it2.opts.messages !== false) {
                out += " , message: '";
                if (it2.opts._errorDataPathProperty) {
                  out += "is a required property";
                } else {
                  out += "should have required property \\'" + $missingProperty + "\\'";
                }
                out += "' ";
              }
              if (it2.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (" + $vSchema + " !== undefined) { ";
          }
          out += " for (var " + $i2 + " = 0; " + $i2 + " < " + $vSchema + ".length; " + $i2 + "++) { if (" + $data + "[" + $vSchema + "[" + $i2 + "]] === undefined ";
          if ($ownProperties) {
            out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i2 + "]) ";
          }
          out += ") {  var err =   ";
          if (it2.createErrors !== false) {
            out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
            if (it2.opts.messages !== false) {
              out += " , message: '";
              if (it2.opts._errorDataPathProperty) {
                out += "is a required property";
              } else {
                out += "should have required property \\'" + $missingProperty + "\\'";
              }
              out += "' ";
            }
            if (it2.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ";
          if ($isData) {
            out += "  }  ";
          }
        } else {
          var arr3 = $required;
          if (arr3) {
            var $propertyKey, i3 = -1, l3 = arr3.length - 1;
            while (i3 < l3) {
              $propertyKey = arr3[i3 += 1];
              var $prop = it2.util.getProperty($propertyKey), $missingProperty = it2.util.escapeQuotes($propertyKey), $useData = $data + $prop;
              if (it2.opts._errorDataPathProperty) {
                it2.errorPath = it2.util.getPath($currentErrorPath, $propertyKey, it2.opts.jsonPointers);
              }
              out += " if ( " + $useData + " === undefined ";
              if ($ownProperties) {
                out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it2.util.escapeQuotes($propertyKey) + "') ";
              }
              out += ") {  var err =   ";
              if (it2.createErrors !== false) {
                out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                if (it2.opts.messages !== false) {
                  out += " , message: '";
                  if (it2.opts._errorDataPathProperty) {
                    out += "is a required property";
                  } else {
                    out += "should have required property \\'" + $missingProperty + "\\'";
                  }
                  out += "' ";
                }
                if (it2.opts.verbose) {
                  out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
            }
          }
        }
      }
      it2.errorPath = $currentErrorPath;
    } else if ($breakOnError) {
      out += " if (true) {";
    }
    return out;
  };
  return required$5;
}
var uniqueItems$2;
var hasRequiredUniqueItems$2;
function requireUniqueItems$2() {
  if (hasRequiredUniqueItems$2) return uniqueItems$2;
  hasRequiredUniqueItems$2 = 1;
  uniqueItems$2 = function generate_uniqueItems(it2, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it2.level;
    var $dataLvl = it2.dataLevel;
    var $schema2 = it2.schema[$keyword];
    var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
    var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it2.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $isData = it2.opts.$data && $schema2 && $schema2.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it2.util.getData($schema2.$data, $dataLvl, it2.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema2;
    }
    if (($schema2 || $isData) && it2.opts.uniqueItems !== false) {
      if ($isData) {
        out += " var " + $valid + "; if (" + $schemaValue + " === false || " + $schemaValue + " === undefined) " + $valid + " = true; else if (typeof " + $schemaValue + " != 'boolean') " + $valid + " = false; else { ";
      }
      out += " var i = " + $data + ".length , " + $valid + " = true , j; if (i > 1) { ";
      var $itemType = it2.schema.items && it2.schema.items.type, $typeIsArray = Array.isArray($itemType);
      if (!$itemType || $itemType == "object" || $itemType == "array" || $typeIsArray && ($itemType.indexOf("object") >= 0 || $itemType.indexOf("array") >= 0)) {
        out += " outer: for (;i--;) { for (j = i; j--;) { if (equal(" + $data + "[i], " + $data + "[j])) { " + $valid + " = false; break outer; } } } ";
      } else {
        out += " var itemIndices = {}, item; for (;i--;) { var item = " + $data + "[i]; ";
        var $method = "checkDataType" + ($typeIsArray ? "s" : "");
        out += " if (" + it2.util[$method]($itemType, "item", it2.opts.strictNumbers, true) + ") continue; ";
        if ($typeIsArray) {
          out += ` if (typeof item == 'string') item = '"' + item; `;
        }
        out += " if (typeof itemIndices[item] == 'number') { " + $valid + " = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ";
      }
      out += " } ";
      if ($isData) {
        out += "  }  ";
      }
      out += " if (!" + $valid + ") {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it2.createErrors !== false) {
        out += " { keyword: 'uniqueItems' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { i: i, j: j } ";
        if (it2.opts.messages !== false) {
          out += " , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' ";
        }
        if (it2.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema2;
          }
          out += "         , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it2.compositeRule && $breakOnError) {
        if (it2.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } ";
      if ($breakOnError) {
        out += " else { ";
      }
    } else {
      if ($breakOnError) {
        out += " if (true) { ";
      }
    }
    return out;
  };
  return uniqueItems$2;
}
var dotjs;
var hasRequiredDotjs;
function requireDotjs() {
  if (hasRequiredDotjs) return dotjs;
  hasRequiredDotjs = 1;
  dotjs = {
    "$ref": requireRef$2(),
    allOf: requireAllOf$2(),
    anyOf: requireAnyOf$2(),
    "$comment": requireComment(),
    const: require_const$2(),
    contains: requireContains$2(),
    dependencies: requireDependencies$2(),
    "enum": require_enum$2(),
    format: requireFormat$4(),
    "if": require_if$2(),
    items: requireItems$2(),
    maximum: require_limit(),
    minimum: require_limit(),
    maxItems: require_limitItems(),
    minItems: require_limitItems(),
    maxLength: require_limitLength(),
    minLength: require_limitLength(),
    maxProperties: require_limitProperties(),
    minProperties: require_limitProperties(),
    multipleOf: requireMultipleOf$2(),
    not: requireNot$2(),
    oneOf: requireOneOf$2(),
    pattern: requirePattern$2(),
    properties: requireProperties$2(),
    propertyNames: requirePropertyNames$2(),
    required: requireRequired$2(),
    uniqueItems: requireUniqueItems$2(),
    validate: requireValidate$2()
  };
  return dotjs;
}
var rules$2;
var hasRequiredRules$2;
function requireRules$2() {
  if (hasRequiredRules$2) return rules$2;
  hasRequiredRules$2 = 1;
  var ruleModules = requireDotjs(), toHash = requireUtil$2().toHash;
  rules$2 = function rules2() {
    var RULES = [
      {
        type: "number",
        rules: [
          { "maximum": ["exclusiveMaximum"] },
          { "minimum": ["exclusiveMinimum"] },
          "multipleOf",
          "format"
        ]
      },
      {
        type: "string",
        rules: ["maxLength", "minLength", "pattern", "format"]
      },
      {
        type: "array",
        rules: ["maxItems", "minItems", "items", "contains", "uniqueItems"]
      },
      {
        type: "object",
        rules: [
          "maxProperties",
          "minProperties",
          "required",
          "dependencies",
          "propertyNames",
          { "properties": ["additionalProperties", "patternProperties"] }
        ]
      },
      { rules: ["$ref", "const", "enum", "not", "anyOf", "oneOf", "allOf", "if"] }
    ];
    var ALL = ["type", "$comment"];
    var KEYWORDS = [
      "$schema",
      "$id",
      "id",
      "$data",
      "$async",
      "title",
      "description",
      "default",
      "definitions",
      "examples",
      "readOnly",
      "writeOnly",
      "contentMediaType",
      "contentEncoding",
      "additionalItems",
      "then",
      "else"
    ];
    var TYPES = ["number", "integer", "string", "array", "object", "boolean", "null"];
    RULES.all = toHash(ALL);
    RULES.types = toHash(TYPES);
    RULES.forEach(function(group) {
      group.rules = group.rules.map(function(keyword2) {
        var implKeywords;
        if (typeof keyword2 == "object") {
          var key = Object.keys(keyword2)[0];
          implKeywords = keyword2[key];
          keyword2 = key;
          implKeywords.forEach(function(k2) {
            ALL.push(k2);
            RULES.all[k2] = true;
          });
        }
        ALL.push(keyword2);
        var rule = RULES.all[keyword2] = {
          keyword: keyword2,
          code: ruleModules[keyword2],
          implements: implKeywords
        };
        return rule;
      });
      RULES.all.$comment = {
        keyword: "$comment",
        code: ruleModules.$comment
      };
      if (group.type) RULES.types[group.type] = group;
    });
    RULES.keywords = toHash(ALL.concat(KEYWORDS));
    RULES.custom = {};
    return RULES;
  };
  return rules$2;
}
var data;
var hasRequiredData;
function requireData() {
  if (hasRequiredData) return data;
  hasRequiredData = 1;
  var KEYWORDS = [
    "multipleOf",
    "maximum",
    "exclusiveMaximum",
    "minimum",
    "exclusiveMinimum",
    "maxLength",
    "minLength",
    "pattern",
    "additionalItems",
    "maxItems",
    "minItems",
    "uniqueItems",
    "maxProperties",
    "minProperties",
    "required",
    "additionalProperties",
    "enum",
    "format",
    "const"
  ];
  data = function(metaSchema, keywordsJsonPointers) {
    for (var i = 0; i < keywordsJsonPointers.length; i++) {
      metaSchema = JSON.parse(JSON.stringify(metaSchema));
      var segments = keywordsJsonPointers[i].split("/");
      var keywords = metaSchema;
      var j2;
      for (j2 = 1; j2 < segments.length; j2++)
        keywords = keywords[segments[j2]];
      for (j2 = 0; j2 < KEYWORDS.length; j2++) {
        var key = KEYWORDS[j2];
        var schema = keywords[key];
        if (schema) {
          keywords[key] = {
            anyOf: [
              schema,
              { $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }
            ]
          };
        }
      }
    }
    return metaSchema;
  };
  return data;
}
var async;
var hasRequiredAsync;
function requireAsync() {
  if (hasRequiredAsync) return async;
  hasRequiredAsync = 1;
  var MissingRefError = requireError_classes().MissingRef;
  async = compileAsync;
  function compileAsync(schema, meta, callback) {
    var self2 = this;
    if (typeof this._opts.loadSchema != "function")
      throw new Error("options.loadSchema should be a function");
    if (typeof meta == "function") {
      callback = meta;
      meta = void 0;
    }
    var p2 = loadMetaSchemaOf(schema).then(function() {
      var schemaObj = self2._addSchema(schema, void 0, meta);
      return schemaObj.validate || _compileAsync(schemaObj);
    });
    if (callback) {
      p2.then(
        function(v) {
          callback(null, v);
        },
        callback
      );
    }
    return p2;
    function loadMetaSchemaOf(sch) {
      var $schema2 = sch.$schema;
      return $schema2 && !self2.getSchema($schema2) ? compileAsync.call(self2, { $ref: $schema2 }, true) : Promise.resolve();
    }
    function _compileAsync(schemaObj) {
      try {
        return self2._compile(schemaObj);
      } catch (e) {
        if (e instanceof MissingRefError) return loadMissingSchema(e);
        throw e;
      }
      function loadMissingSchema(e) {
        var ref2 = e.missingSchema;
        if (added(ref2)) throw new Error("Schema " + ref2 + " is loaded but " + e.missingRef + " cannot be resolved");
        var schemaPromise = self2._loadingSchemas[ref2];
        if (!schemaPromise) {
          schemaPromise = self2._loadingSchemas[ref2] = self2._opts.loadSchema(ref2);
          schemaPromise.then(removePromise, removePromise);
        }
        return schemaPromise.then(function(sch) {
          if (!added(ref2)) {
            return loadMetaSchemaOf(sch).then(function() {
              if (!added(ref2)) self2.addSchema(sch, ref2, void 0, meta);
            });
          }
        }).then(function() {
          return _compileAsync(schemaObj);
        });
        function removePromise() {
          delete self2._loadingSchemas[ref2];
        }
        function added(ref3) {
          return self2._refs[ref3] || self2._schemas[ref3];
        }
      }
    }
  }
  return async;
}
var custom;
var hasRequiredCustom;
function requireCustom() {
  if (hasRequiredCustom) return custom;
  hasRequiredCustom = 1;
  custom = function generate_custom(it2, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it2.level;
    var $dataLvl = it2.dataLevel;
    var $schema2 = it2.schema[$keyword];
    var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
    var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it2.opts.allErrors;
    var $errorKeyword;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $errs = "errs__" + $lvl;
    var $isData = it2.opts.$data && $schema2 && $schema2.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it2.util.getData($schema2.$data, $dataLvl, it2.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema2;
    }
    var $rule = this, $definition = "definition" + $lvl, $rDef = $rule.definition, $closingBraces = "";
    var $compile, $inline, $macro, $ruleValidate, $validateCode;
    if ($isData && $rDef.$data) {
      $validateCode = "keywordValidate" + $lvl;
      var $validateSchema = $rDef.validateSchema;
      out += " var " + $definition + " = RULES.custom['" + $keyword + "'].definition; var " + $validateCode + " = " + $definition + ".validate;";
    } else {
      $ruleValidate = it2.useCustomRule($rule, $schema2, it2.schema, it2);
      if (!$ruleValidate) return;
      $schemaValue = "validate.schema" + $schemaPath;
      $validateCode = $ruleValidate.code;
      $compile = $rDef.compile;
      $inline = $rDef.inline;
      $macro = $rDef.macro;
    }
    var $ruleErrs = $validateCode + ".errors", $i2 = "i" + $lvl, $ruleErr = "ruleErr" + $lvl, $asyncKeyword = $rDef.async;
    if ($asyncKeyword && !it2.async) throw new Error("async keyword in sync schema");
    if (!($inline || $macro)) {
      out += "" + $ruleErrs + " = null;";
    }
    out += "var " + $errs + " = errors;var " + $valid + ";";
    if ($isData && $rDef.$data) {
      $closingBraces += "}";
      out += " if (" + $schemaValue + " === undefined) { " + $valid + " = true; } else { ";
      if ($validateSchema) {
        $closingBraces += "}";
        out += " " + $valid + " = " + $definition + ".validateSchema(" + $schemaValue + "); if (" + $valid + ") { ";
      }
    }
    if ($inline) {
      if ($rDef.statements) {
        out += " " + $ruleValidate.validate + " ";
      } else {
        out += " " + $valid + " = " + $ruleValidate.validate + "; ";
      }
    } else if ($macro) {
      var $it = it2.util.copy(it2);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      $it.schema = $ruleValidate.validate;
      $it.schemaPath = "";
      var $wasComposite = it2.compositeRule;
      it2.compositeRule = $it.compositeRule = true;
      var $code = it2.validate($it).replace(/validate\.schema/g, $validateCode);
      it2.compositeRule = $it.compositeRule = $wasComposite;
      out += " " + $code;
    } else {
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      out += "  " + $validateCode + ".call( ";
      if (it2.opts.passContext) {
        out += "this";
      } else {
        out += "self";
      }
      if ($compile || $rDef.schema === false) {
        out += " , " + $data + " ";
      } else {
        out += " , " + $schemaValue + " , " + $data + " , validate.schema" + it2.schemaPath + " ";
      }
      out += " , (dataPath || '')";
      if (it2.errorPath != '""') {
        out += " + " + it2.errorPath;
      }
      var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it2.dataPathArr[$dataLvl] : "parentDataProperty";
      out += " , " + $parentData + " , " + $parentDataProperty + " , rootData )  ";
      var def_callRuleValidate = out;
      out = $$outStack.pop();
      if ($rDef.errors === false) {
        out += " " + $valid + " = ";
        if ($asyncKeyword) {
          out += "await ";
        }
        out += "" + def_callRuleValidate + "; ";
      } else {
        if ($asyncKeyword) {
          $ruleErrs = "customErrors" + $lvl;
          out += " var " + $ruleErrs + " = null; try { " + $valid + " = await " + def_callRuleValidate + "; } catch (e) { " + $valid + " = false; if (e instanceof ValidationError) " + $ruleErrs + " = e.errors; else throw e; } ";
        } else {
          out += " " + $ruleErrs + " = null; " + $valid + " = " + def_callRuleValidate + "; ";
        }
      }
    }
    if ($rDef.modifying) {
      out += " if (" + $parentData + ") " + $data + " = " + $parentData + "[" + $parentDataProperty + "];";
    }
    out += "" + $closingBraces;
    if ($rDef.valid) {
      if ($breakOnError) {
        out += " if (true) { ";
      }
    } else {
      out += " if ( ";
      if ($rDef.valid === void 0) {
        out += " !";
        if ($macro) {
          out += "" + $nextValid;
        } else {
          out += "" + $valid;
        }
      } else {
        out += " " + !$rDef.valid + " ";
      }
      out += ") { ";
      $errorKeyword = $rule.keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it2.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
        if (it2.opts.messages !== false) {
          out += ` , message: 'should pass "` + $rule.keyword + `" keyword validation' `;
        }
        if (it2.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it2.compositeRule && $breakOnError) {
        if (it2.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      var def_customError = out;
      out = $$outStack.pop();
      if ($inline) {
        if ($rDef.errors) {
          if ($rDef.errors != "full") {
            out += "  for (var " + $i2 + "=" + $errs + "; " + $i2 + "<errors; " + $i2 + "++) { var " + $ruleErr + " = vErrors[" + $i2 + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it2.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
            if (it2.opts.verbose) {
              out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
            }
            out += " } ";
          }
        } else {
          if ($rDef.errors === false) {
            out += " " + def_customError + " ";
          } else {
            out += " if (" + $errs + " == errors) { " + def_customError + " } else {  for (var " + $i2 + "=" + $errs + "; " + $i2 + "<errors; " + $i2 + "++) { var " + $ruleErr + " = vErrors[" + $i2 + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it2.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
            if (it2.opts.verbose) {
              out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
            }
            out += " } } ";
          }
        }
      } else if ($macro) {
        out += "   var err =   ";
        if (it2.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
          if (it2.opts.messages !== false) {
            out += ` , message: 'should pass "` + $rule.keyword + `" keyword validation' `;
          }
          if (it2.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if (!it2.compositeRule && $breakOnError) {
          if (it2.async) {
            out += " throw new ValidationError(vErrors); ";
          } else {
            out += " validate.errors = vErrors; return false; ";
          }
        }
      } else {
        if ($rDef.errors === false) {
          out += " " + def_customError + " ";
        } else {
          out += " if (Array.isArray(" + $ruleErrs + ")) { if (vErrors === null) vErrors = " + $ruleErrs + "; else vErrors = vErrors.concat(" + $ruleErrs + "); errors = vErrors.length;  for (var " + $i2 + "=" + $errs + "; " + $i2 + "<errors; " + $i2 + "++) { var " + $ruleErr + " = vErrors[" + $i2 + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it2.errorPath + ";  " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '";  ';
          if (it2.opts.verbose) {
            out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
          }
          out += " } } else { " + def_customError + " } ";
        }
      }
      out += " } ";
      if ($breakOnError) {
        out += " else { ";
      }
    }
    return out;
  };
  return custom;
}
const $schema$3 = "http://json-schema.org/draft-07/schema#";
const $id$5 = "http://json-schema.org/draft-07/schema#";
const title$2 = "Core schema meta-schema";
const definitions$2 = { "schemaArray": { "type": "array", "minItems": 1, "items": { "$ref": "#" } }, "nonNegativeInteger": { "type": "integer", "minimum": 0 }, "nonNegativeIntegerDefault0": { "allOf": [{ "$ref": "#/definitions/nonNegativeInteger" }, { "default": 0 }] }, "simpleTypes": { "enum": ["array", "boolean", "integer", "null", "number", "object", "string"] }, "stringArray": { "type": "array", "items": { "type": "string" }, "uniqueItems": true, "default": [] } };
const type$5 = ["object", "boolean"];
const properties$7 = { "$id": { "type": "string", "format": "uri-reference" }, "$schema": { "type": "string", "format": "uri" }, "$ref": { "type": "string", "format": "uri-reference" }, "$comment": { "type": "string" }, "title": { "type": "string" }, "description": { "type": "string" }, "default": true, "readOnly": { "type": "boolean", "default": false }, "examples": { "type": "array", "items": true }, "multipleOf": { "type": "number", "exclusiveMinimum": 0 }, "maximum": { "type": "number" }, "exclusiveMaximum": { "type": "number" }, "minimum": { "type": "number" }, "exclusiveMinimum": { "type": "number" }, "maxLength": { "$ref": "#/definitions/nonNegativeInteger" }, "minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "pattern": { "type": "string", "format": "regex" }, "additionalItems": { "$ref": "#" }, "items": { "anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/schemaArray" }], "default": true }, "maxItems": { "$ref": "#/definitions/nonNegativeInteger" }, "minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "uniqueItems": { "type": "boolean", "default": false }, "contains": { "$ref": "#" }, "maxProperties": { "$ref": "#/definitions/nonNegativeInteger" }, "minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "required": { "$ref": "#/definitions/stringArray" }, "additionalProperties": { "$ref": "#" }, "definitions": { "type": "object", "additionalProperties": { "$ref": "#" }, "default": {} }, "properties": { "type": "object", "additionalProperties": { "$ref": "#" }, "default": {} }, "patternProperties": { "type": "object", "additionalProperties": { "$ref": "#" }, "propertyNames": { "format": "regex" }, "default": {} }, "dependencies": { "type": "object", "additionalProperties": { "anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/stringArray" }] } }, "propertyNames": { "$ref": "#" }, "const": true, "enum": { "type": "array", "items": true, "minItems": 1, "uniqueItems": true }, "type": { "anyOf": [{ "$ref": "#/definitions/simpleTypes" }, { "type": "array", "items": { "$ref": "#/definitions/simpleTypes" }, "minItems": 1, "uniqueItems": true }] }, "format": { "type": "string" }, "contentMediaType": { "type": "string" }, "contentEncoding": { "type": "string" }, "if": { "$ref": "#" }, "then": { "$ref": "#" }, "else": { "$ref": "#" }, "allOf": { "$ref": "#/definitions/schemaArray" }, "anyOf": { "$ref": "#/definitions/schemaArray" }, "oneOf": { "$ref": "#/definitions/schemaArray" }, "not": { "$ref": "#" } };
const require$$13 = {
  $schema: $schema$3,
  $id: $id$5,
  title: title$2,
  definitions: definitions$2,
  type: type$5,
  properties: properties$7,
  "default": true
};
var definition_schema;
var hasRequiredDefinition_schema;
function requireDefinition_schema() {
  if (hasRequiredDefinition_schema) return definition_schema;
  hasRequiredDefinition_schema = 1;
  var metaSchema = require$$13;
  definition_schema = {
    $id: "https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js",
    definitions: {
      simpleTypes: metaSchema.definitions.simpleTypes
    },
    type: "object",
    dependencies: {
      schema: ["validate"],
      $data: ["validate"],
      statements: ["inline"],
      valid: { not: { required: ["macro"] } }
    },
    properties: {
      type: metaSchema.properties.type,
      schema: { type: "boolean" },
      statements: { type: "boolean" },
      dependencies: {
        type: "array",
        items: { type: "string" }
      },
      metaSchema: { type: "object" },
      modifying: { type: "boolean" },
      valid: { type: "boolean" },
      $data: { type: "boolean" },
      async: { type: "boolean" },
      errors: {
        anyOf: [
          { type: "boolean" },
          { const: "full" }
        ]
      }
    }
  };
  return definition_schema;
}
var keyword$2;
var hasRequiredKeyword$2;
function requireKeyword$2() {
  if (hasRequiredKeyword$2) return keyword$2;
  hasRequiredKeyword$2 = 1;
  var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
  var customRuleCode = requireCustom();
  var definitionSchema = requireDefinition_schema();
  keyword$2 = {
    add: addKeyword,
    get: getKeyword,
    remove: removeKeyword,
    validate: validateKeyword
  };
  function addKeyword(keyword2, definition) {
    var RULES = this.RULES;
    if (RULES.keywords[keyword2])
      throw new Error("Keyword " + keyword2 + " is already defined");
    if (!IDENTIFIER.test(keyword2))
      throw new Error("Keyword " + keyword2 + " is not a valid identifier");
    if (definition) {
      this.validateKeyword(definition, true);
      var dataType2 = definition.type;
      if (Array.isArray(dataType2)) {
        for (var i = 0; i < dataType2.length; i++)
          _addRule(keyword2, dataType2[i], definition);
      } else {
        _addRule(keyword2, dataType2, definition);
      }
      var metaSchema = definition.metaSchema;
      if (metaSchema) {
        if (definition.$data && this._opts.$data) {
          metaSchema = {
            anyOf: [
              metaSchema,
              { "$ref": "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }
            ]
          };
        }
        definition.validateSchema = this.compile(metaSchema, true);
      }
    }
    RULES.keywords[keyword2] = RULES.all[keyword2] = true;
    function _addRule(keyword3, dataType3, definition2) {
      var ruleGroup;
      for (var i2 = 0; i2 < RULES.length; i2++) {
        var rg2 = RULES[i2];
        if (rg2.type == dataType3) {
          ruleGroup = rg2;
          break;
        }
      }
      if (!ruleGroup) {
        ruleGroup = { type: dataType3, rules: [] };
        RULES.push(ruleGroup);
      }
      var rule = {
        keyword: keyword3,
        definition: definition2,
        custom: true,
        code: customRuleCode,
        implements: definition2.implements
      };
      ruleGroup.rules.push(rule);
      RULES.custom[keyword3] = rule;
    }
    return this;
  }
  function getKeyword(keyword2) {
    var rule = this.RULES.custom[keyword2];
    return rule ? rule.definition : this.RULES.keywords[keyword2] || false;
  }
  function removeKeyword(keyword2) {
    var RULES = this.RULES;
    delete RULES.keywords[keyword2];
    delete RULES.all[keyword2];
    delete RULES.custom[keyword2];
    for (var i = 0; i < RULES.length; i++) {
      var rules2 = RULES[i].rules;
      for (var j2 = 0; j2 < rules2.length; j2++) {
        if (rules2[j2].keyword == keyword2) {
          rules2.splice(j2, 1);
          break;
        }
      }
    }
    return this;
  }
  function validateKeyword(definition, throwError) {
    validateKeyword.errors = null;
    var v = this._validateKeyword = this._validateKeyword || this.compile(definitionSchema, true);
    if (v(definition)) return true;
    validateKeyword.errors = v.errors;
    if (throwError)
      throw new Error("custom keyword definition is invalid: " + this.errorsText(v.errors));
    else
      return false;
  }
  return keyword$2;
}
const $schema$2 = "http://json-schema.org/draft-07/schema#";
const $id$4 = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
const description$2 = "Meta-schema for $data reference (JSON Schema extension proposal)";
const type$4 = "object";
const required$4 = ["$data"];
const properties$6 = { "$data": { "type": "string", "anyOf": [{ "format": "relative-json-pointer" }, { "format": "json-pointer" }] } };
const additionalProperties$4 = false;
const require$$12 = {
  $schema: $schema$2,
  $id: $id$4,
  description: description$2,
  type: type$4,
  required: required$4,
  properties: properties$6,
  additionalProperties: additionalProperties$4
};
var ajv$3;
var hasRequiredAjv$2;
function requireAjv$2() {
  if (hasRequiredAjv$2) return ajv$3;
  hasRequiredAjv$2 = 1;
  var compileSchema = requireCompile$2(), resolve2 = requireResolve$2(), Cache = requireCache(), SchemaObject = requireSchema_obj(), stableStringify = requireFastJsonStableStringify(), formats2 = requireFormats$1(), rules2 = requireRules$2(), $dataMetaSchema = requireData(), util2 = requireUtil$2();
  ajv$3 = Ajv2;
  Ajv2.prototype.validate = validate2;
  Ajv2.prototype.compile = compile2;
  Ajv2.prototype.addSchema = addSchema;
  Ajv2.prototype.addMetaSchema = addMetaSchema;
  Ajv2.prototype.validateSchema = validateSchema;
  Ajv2.prototype.getSchema = getSchema;
  Ajv2.prototype.removeSchema = removeSchema;
  Ajv2.prototype.addFormat = addFormat;
  Ajv2.prototype.errorsText = errorsText;
  Ajv2.prototype._addSchema = _addSchema;
  Ajv2.prototype._compile = _compile;
  Ajv2.prototype.compileAsync = requireAsync();
  var customKeyword = requireKeyword$2();
  Ajv2.prototype.addKeyword = customKeyword.add;
  Ajv2.prototype.getKeyword = customKeyword.get;
  Ajv2.prototype.removeKeyword = customKeyword.remove;
  Ajv2.prototype.validateKeyword = customKeyword.validate;
  var errorClasses = requireError_classes();
  Ajv2.ValidationError = errorClasses.Validation;
  Ajv2.MissingRefError = errorClasses.MissingRef;
  Ajv2.$dataMetaSchema = $dataMetaSchema;
  var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
  var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes", "strictDefaults"];
  var META_SUPPORT_DATA = ["/properties"];
  function Ajv2(opts) {
    if (!(this instanceof Ajv2)) return new Ajv2(opts);
    opts = this._opts = util2.copy(opts) || {};
    setLogger(this);
    this._schemas = {};
    this._refs = {};
    this._fragments = {};
    this._formats = formats2(opts.format);
    this._cache = opts.cache || new Cache();
    this._loadingSchemas = {};
    this._compilations = [];
    this.RULES = rules2();
    this._getId = chooseGetId(opts);
    opts.loopRequired = opts.loopRequired || Infinity;
    if (opts.errorDataPath == "property") opts._errorDataPathProperty = true;
    if (opts.serialize === void 0) opts.serialize = stableStringify;
    this._metaOpts = getMetaSchemaOptions(this);
    if (opts.formats) addInitialFormats(this);
    if (opts.keywords) addInitialKeywords(this);
    addDefaultMetaSchema(this);
    if (typeof opts.meta == "object") this.addMetaSchema(opts.meta);
    if (opts.nullable) this.addKeyword("nullable", { metaSchema: { type: "boolean" } });
    addInitialSchemas(this);
  }
  function validate2(schemaKeyRef, data2) {
    var v;
    if (typeof schemaKeyRef == "string") {
      v = this.getSchema(schemaKeyRef);
      if (!v) throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
    } else {
      var schemaObj = this._addSchema(schemaKeyRef);
      v = schemaObj.validate || this._compile(schemaObj);
    }
    var valid = v(data2);
    if (v.$async !== true) this.errors = v.errors;
    return valid;
  }
  function compile2(schema, _meta) {
    var schemaObj = this._addSchema(schema, void 0, _meta);
    return schemaObj.validate || this._compile(schemaObj);
  }
  function addSchema(schema, key, _skipValidation, _meta) {
    if (Array.isArray(schema)) {
      for (var i = 0; i < schema.length; i++) this.addSchema(schema[i], void 0, _skipValidation, _meta);
      return this;
    }
    var id2 = this._getId(schema);
    if (id2 !== void 0 && typeof id2 != "string")
      throw new Error("schema id must be string");
    key = resolve2.normalizeId(key || id2);
    checkUnique(this, key);
    this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);
    return this;
  }
  function addMetaSchema(schema, key, skipValidation) {
    this.addSchema(schema, key, skipValidation, true);
    return this;
  }
  function validateSchema(schema, throwOrLogError) {
    var $schema2 = schema.$schema;
    if ($schema2 !== void 0 && typeof $schema2 != "string")
      throw new Error("$schema must be a string");
    $schema2 = $schema2 || this._opts.defaultMeta || defaultMeta(this);
    if (!$schema2) {
      this.logger.warn("meta-schema not available");
      this.errors = null;
      return true;
    }
    var valid = this.validate($schema2, schema);
    if (!valid && throwOrLogError) {
      var message = "schema is invalid: " + this.errorsText();
      if (this._opts.validateSchema == "log") this.logger.error(message);
      else throw new Error(message);
    }
    return valid;
  }
  function defaultMeta(self2) {
    var meta = self2._opts.meta;
    self2._opts.defaultMeta = typeof meta == "object" ? self2._getId(meta) || meta : self2.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0;
    return self2._opts.defaultMeta;
  }
  function getSchema(keyRef) {
    var schemaObj = _getSchemaObj(this, keyRef);
    switch (typeof schemaObj) {
      case "object":
        return schemaObj.validate || this._compile(schemaObj);
      case "string":
        return this.getSchema(schemaObj);
      case "undefined":
        return _getSchemaFragment(this, keyRef);
    }
  }
  function _getSchemaFragment(self2, ref2) {
    var res = resolve2.schema.call(self2, { schema: {} }, ref2);
    if (res) {
      var schema = res.schema, root = res.root, baseId = res.baseId;
      var v = compileSchema.call(self2, schema, root, void 0, baseId);
      self2._fragments[ref2] = new SchemaObject({
        ref: ref2,
        fragment: true,
        schema,
        root,
        baseId,
        validate: v
      });
      return v;
    }
  }
  function _getSchemaObj(self2, keyRef) {
    keyRef = resolve2.normalizeId(keyRef);
    return self2._schemas[keyRef] || self2._refs[keyRef] || self2._fragments[keyRef];
  }
  function removeSchema(schemaKeyRef) {
    if (schemaKeyRef instanceof RegExp) {
      _removeAllSchemas(this, this._schemas, schemaKeyRef);
      _removeAllSchemas(this, this._refs, schemaKeyRef);
      return this;
    }
    switch (typeof schemaKeyRef) {
      case "undefined":
        _removeAllSchemas(this, this._schemas);
        _removeAllSchemas(this, this._refs);
        this._cache.clear();
        return this;
      case "string":
        var schemaObj = _getSchemaObj(this, schemaKeyRef);
        if (schemaObj) this._cache.del(schemaObj.cacheKey);
        delete this._schemas[schemaKeyRef];
        delete this._refs[schemaKeyRef];
        return this;
      case "object":
        var serialize = this._opts.serialize;
        var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
        this._cache.del(cacheKey);
        var id2 = this._getId(schemaKeyRef);
        if (id2) {
          id2 = resolve2.normalizeId(id2);
          delete this._schemas[id2];
          delete this._refs[id2];
        }
    }
    return this;
  }
  function _removeAllSchemas(self2, schemas, regex) {
    for (var keyRef in schemas) {
      var schemaObj = schemas[keyRef];
      if (!schemaObj.meta && (!regex || regex.test(keyRef))) {
        self2._cache.del(schemaObj.cacheKey);
        delete schemas[keyRef];
      }
    }
  }
  function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
    if (typeof schema != "object" && typeof schema != "boolean")
      throw new Error("schema should be object or boolean");
    var serialize = this._opts.serialize;
    var cacheKey = serialize ? serialize(schema) : schema;
    var cached2 = this._cache.get(cacheKey);
    if (cached2) return cached2;
    shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;
    var id2 = resolve2.normalizeId(this._getId(schema));
    if (id2 && shouldAddSchema) checkUnique(this, id2);
    var willValidate = this._opts.validateSchema !== false && !skipValidation;
    var recursiveMeta;
    if (willValidate && !(recursiveMeta = id2 && id2 == resolve2.normalizeId(schema.$schema)))
      this.validateSchema(schema, true);
    var localRefs = resolve2.ids.call(this, schema);
    var schemaObj = new SchemaObject({
      id: id2,
      schema,
      localRefs,
      cacheKey,
      meta
    });
    if (id2[0] != "#" && shouldAddSchema) this._refs[id2] = schemaObj;
    this._cache.put(cacheKey, schemaObj);
    if (willValidate && recursiveMeta) this.validateSchema(schema, true);
    return schemaObj;
  }
  function _compile(schemaObj, root) {
    if (schemaObj.compiling) {
      schemaObj.validate = callValidate;
      callValidate.schema = schemaObj.schema;
      callValidate.errors = null;
      callValidate.root = root ? root : callValidate;
      if (schemaObj.schema.$async === true)
        callValidate.$async = true;
      return callValidate;
    }
    schemaObj.compiling = true;
    var currentOpts;
    if (schemaObj.meta) {
      currentOpts = this._opts;
      this._opts = this._metaOpts;
    }
    var v;
    try {
      v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs);
    } catch (e) {
      delete schemaObj.validate;
      throw e;
    } finally {
      schemaObj.compiling = false;
      if (schemaObj.meta) this._opts = currentOpts;
    }
    schemaObj.validate = v;
    schemaObj.refs = v.refs;
    schemaObj.refVal = v.refVal;
    schemaObj.root = v.root;
    return v;
    function callValidate() {
      var _validate = schemaObj.validate;
      var result = _validate.apply(this, arguments);
      callValidate.errors = _validate.errors;
      return result;
    }
  }
  function chooseGetId(opts) {
    switch (opts.schemaId) {
      case "auto":
        return _get$IdOrId;
      case "id":
        return _getId;
      default:
        return _get$Id;
    }
  }
  function _getId(schema) {
    if (schema.$id) this.logger.warn("schema $id ignored", schema.$id);
    return schema.id;
  }
  function _get$Id(schema) {
    if (schema.id) this.logger.warn("schema id ignored", schema.id);
    return schema.$id;
  }
  function _get$IdOrId(schema) {
    if (schema.$id && schema.id && schema.$id != schema.id)
      throw new Error("schema $id is different from id");
    return schema.$id || schema.id;
  }
  function errorsText(errors2, options) {
    errors2 = errors2 || this.errors;
    if (!errors2) return "No errors";
    options = options || {};
    var separator = options.separator === void 0 ? ", " : options.separator;
    var dataVar = options.dataVar === void 0 ? "data" : options.dataVar;
    var text = "";
    for (var i = 0; i < errors2.length; i++) {
      var e = errors2[i];
      if (e) text += dataVar + e.dataPath + " " + e.message + separator;
    }
    return text.slice(0, -separator.length);
  }
  function addFormat(name2, format2) {
    if (typeof format2 == "string") format2 = new RegExp(format2);
    this._formats[name2] = format2;
    return this;
  }
  function addDefaultMetaSchema(self2) {
    var $dataSchema;
    if (self2._opts.$data) {
      $dataSchema = require$$12;
      self2.addMetaSchema($dataSchema, $dataSchema.$id, true);
    }
    if (self2._opts.meta === false) return;
    var metaSchema = require$$13;
    if (self2._opts.$data) metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);
    self2.addMetaSchema(metaSchema, META_SCHEMA_ID, true);
    self2._refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
  }
  function addInitialSchemas(self2) {
    var optsSchemas = self2._opts.schemas;
    if (!optsSchemas) return;
    if (Array.isArray(optsSchemas)) self2.addSchema(optsSchemas);
    else for (var key in optsSchemas) self2.addSchema(optsSchemas[key], key);
  }
  function addInitialFormats(self2) {
    for (var name2 in self2._opts.formats) {
      var format2 = self2._opts.formats[name2];
      self2.addFormat(name2, format2);
    }
  }
  function addInitialKeywords(self2) {
    for (var name2 in self2._opts.keywords) {
      var keyword2 = self2._opts.keywords[name2];
      self2.addKeyword(name2, keyword2);
    }
  }
  function checkUnique(self2, id2) {
    if (self2._schemas[id2] || self2._refs[id2])
      throw new Error('schema with key or id "' + id2 + '" already exists');
  }
  function getMetaSchemaOptions(self2) {
    var metaOpts = util2.copy(self2._opts);
    for (var i = 0; i < META_IGNORE_OPTIONS.length; i++)
      delete metaOpts[META_IGNORE_OPTIONS[i]];
    return metaOpts;
  }
  function setLogger(self2) {
    var logger = self2._opts.logger;
    if (logger === false) {
      self2.logger = { log: noop3, warn: noop3, error: noop3 };
    } else {
      if (logger === void 0) logger = console;
      if (!(typeof logger == "object" && logger.log && logger.warn && logger.error))
        throw new Error("logger must implement log, warn and error methods");
      self2.logger = logger;
    }
  }
  function noop3() {
  }
  return ajv$3;
}
var ajvExports$1 = requireAjv$2();
const Ajv$1 = /* @__PURE__ */ getDefaultExportFromCjs(ajvExports$1);
const ajv$2 = new Ajv$1();
const toolOutputValidators = /* @__PURE__ */ new Map();
function cacheToolOutputSchemas(tools) {
  toolOutputValidators.clear();
  for (const tool of tools) {
    if (tool.outputSchema) {
      try {
        const validator = ajv$2.compile(tool.outputSchema);
        toolOutputValidators.set(tool.name, validator);
      } catch (error) {
        console.warn(
          `Failed to compile output schema for tool ${tool.name}:`,
          error
        );
      }
    }
  }
}
function getToolOutputValidator(toolName) {
  return toolOutputValidators.get(toolName);
}
function validateToolOutput(toolName, structuredContent) {
  const validator = getToolOutputValidator(toolName);
  if (!validator) {
    return { isValid: true };
  }
  const isValid2 = validator(structuredContent);
  if (!isValid2) {
    return {
      isValid: false,
      error: ajv$2.errorsText(validator.errors)
    };
  }
  return { isValid: true };
}
function hasOutputSchema(toolName) {
  return toolOutputValidators.has(toolName);
}
function generateDefaultValue(schema, propertyName, parentSchema) {
  if ("default" in schema && schema.default !== void 0) {
    return schema.default;
  }
  const isRequired = propertyName && parentSchema ? isPropertyRequired(propertyName, parentSchema) : false;
  const isRootSchema = propertyName === void 0 && parentSchema === void 0;
  switch (schema.type) {
    case "string":
      return isRequired ? "" : void 0;
    case "number":
    case "integer":
      return isRequired ? 0 : void 0;
    case "boolean":
      return isRequired ? false : void 0;
    case "array":
      return isRequired ? [] : void 0;
    case "object": {
      if (!schema.properties) {
        return isRequired || isRootSchema ? {} : void 0;
      }
      const obj = {};
      Object.entries(schema.properties).forEach(([key, prop]) => {
        const hasExplicitDefault = "default" in prop && prop.default !== void 0;
        if (isPropertyRequired(key, schema) || hasExplicitDefault) {
          const value = generateDefaultValue(prop, key, schema);
          if (value !== void 0) {
            obj[key] = value;
          }
        }
      });
      if (Object.keys(obj).length === 0) {
        return isRequired || isRootSchema ? {} : void 0;
      }
      return obj;
    }
    case "null":
      return null;
    default:
      return void 0;
  }
}
function isPropertyRequired(propertyName, schema) {
  return schema.required?.includes(propertyName) ?? false;
}
function resolveRef(schema, rootSchema, visitedRefs = /* @__PURE__ */ new Set()) {
  if (!schema) return schema;
  if (!("$ref" in schema) || !schema.$ref) {
    if (schema.anyOf && Array.isArray(schema.anyOf)) {
      const resolvedAnyOf = schema.anyOf.map((item) => {
        if (typeof item === "object" && item !== null) {
          return resolveRef(item, rootSchema, visitedRefs);
        }
        return item;
      });
      return {
        ...schema,
        anyOf: resolvedAnyOf
      };
    }
    return schema;
  }
  const ref2 = schema.$ref;
  if (ref2.startsWith("#/")) {
    if (visitedRefs.has(ref2)) {
      console.warn(`Circular reference detected: ${ref2}`);
      return schema;
    }
    visitedRefs.add(ref2);
    const path = ref2.substring(2).split("/");
    let current = rootSchema;
    for (const segment of path) {
      if (current && typeof current === "object" && current !== null && segment in current) {
        current = current[segment];
      } else {
        visitedRefs.delete(ref2);
        console.warn(`Could not resolve $ref: ${ref2}`);
        return schema;
      }
    }
    const resolved = current;
    return resolveRef(resolved, rootSchema, visitedRefs);
  }
  console.warn(`Unsupported $ref format: ${ref2}`);
  return schema;
}
function normalizeUnionType(schema) {
  if (schema.anyOf && schema.anyOf.length === 2 && schema.anyOf.some((t) => t.type === "null")) {
    const nonNullItem = schema.anyOf.find((t) => {
      const item = t;
      return item?.type !== "null";
    });
    if (nonNullItem?.type || nonNullItem?.enum) {
      return {
        ...schema,
        ...nonNullItem,
        type: nonNullItem?.type || (nonNullItem?.enum ? "string" : void 0),
        nullable: true,
        anyOf: void 0
      };
    }
  }
  if (Array.isArray(schema.type) && schema.type.length === 2 && schema.type.includes("string") && schema.type.includes("null")) {
    return { ...schema, type: "string", nullable: true };
  }
  if (Array.isArray(schema.type) && schema.type.length === 2 && schema.type.includes("boolean") && schema.type.includes("null")) {
    return { ...schema, type: "boolean", nullable: true };
  }
  if (Array.isArray(schema.type) && schema.type.length === 2 && schema.type.includes("number") && schema.type.includes("null")) {
    return { ...schema, type: "number", nullable: true };
  }
  if (Array.isArray(schema.type) && schema.type.length === 2 && schema.type.includes("integer") && schema.type.includes("null")) {
    return { ...schema, type: "integer", nullable: true };
  }
  return schema;
}
function resolveRefsInMessage(message) {
  if (!isJSONRPCRequest(message) || !message.params?.requestedSchema) {
    return message;
  }
  const requestedSchema = message.params.requestedSchema;
  if (!requestedSchema?.properties) {
    return message;
  }
  const resolvedMessage = {
    ...message,
    params: {
      ...message.params,
      requestedSchema: {
        ...requestedSchema,
        properties: Object.fromEntries(
          Object.entries(requestedSchema.properties).map(
            ([key, propSchema]) => {
              const resolved = resolveRef(propSchema, requestedSchema);
              const normalized = normalizeUnionType(resolved);
              return [key, normalized];
            }
          )
        )
      }
    }
  };
  return resolvedMessage;
}
function cleanParams(params, schema) {
  const cleaned = {};
  const required2 = schema.required || [];
  const properties2 = schema.properties || {};
  for (const [key, value] of Object.entries(params)) {
    const isFieldRequired = required2.includes(key);
    const fieldSchema = properties2[key];
    const hasDefault = fieldSchema && "default" in fieldSchema;
    const defaultValue = hasDefault ? fieldSchema.default : void 0;
    if (isFieldRequired) {
      cleaned[key] = value;
    } else if (hasDefault && value === defaultValue) {
      cleaned[key] = value;
    } else {
      if (value !== void 0 && value !== "" && value !== null) {
        cleaned[key] = value;
      }
    }
  }
  return cleaned;
}
var ajv$1 = { exports: {} };
var core$3 = {};
var validate$1 = {};
var boolSchema$1 = {};
var errors$1 = {};
var codegen$1 = {};
var code$3 = {};
var hasRequiredCode$3;
function requireCode$3() {
  if (hasRequiredCode$3) return code$3;
  hasRequiredCode$3 = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.regexpCode = exports$1.getEsmExportName = exports$1.getProperty = exports$1.safeStringify = exports$1.stringify = exports$1.strConcat = exports$1.addCodeArg = exports$1.str = exports$1._ = exports$1.nil = exports$1._Code = exports$1.Name = exports$1.IDENTIFIER = exports$1._CodeOrName = void 0;
    class _CodeOrName {
    }
    exports$1._CodeOrName = _CodeOrName;
    exports$1.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    class Name extends _CodeOrName {
      constructor(s2) {
        super();
        if (!exports$1.IDENTIFIER.test(s2))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = s2;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return false;
      }
      get names() {
        return { [this.str]: 1 };
      }
    }
    exports$1.Name = Name;
    class _Code extends _CodeOrName {
      constructor(code2) {
        super();
        this._items = typeof code2 === "string" ? [code2] : code2;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return false;
        const item = this._items[0];
        return item === "" || item === '""';
      }
      get str() {
        var _a2;
        return (_a2 = this._str) !== null && _a2 !== void 0 ? _a2 : this._str = this._items.reduce((s2, c) => `${s2}${c}`, "");
      }
      get names() {
        var _a2;
        return (_a2 = this._names) !== null && _a2 !== void 0 ? _a2 : this._names = this._items.reduce((names2, c) => {
          if (c instanceof Name)
            names2[c.str] = (names2[c.str] || 0) + 1;
          return names2;
        }, {});
      }
    }
    exports$1._Code = _Code;
    exports$1.nil = new _Code("");
    function _2(strs, ...args) {
      const code2 = [strs[0]];
      let i = 0;
      while (i < args.length) {
        addCodeArg(code2, args[i]);
        code2.push(strs[++i]);
      }
      return new _Code(code2);
    }
    exports$1._ = _2;
    const plus = new _Code("+");
    function str(strs, ...args) {
      const expr = [safeStringify(strs[0])];
      let i = 0;
      while (i < args.length) {
        expr.push(plus);
        addCodeArg(expr, args[i]);
        expr.push(plus, safeStringify(strs[++i]));
      }
      optimize(expr);
      return new _Code(expr);
    }
    exports$1.str = str;
    function addCodeArg(code2, arg) {
      if (arg instanceof _Code)
        code2.push(...arg._items);
      else if (arg instanceof Name)
        code2.push(arg);
      else
        code2.push(interpolate(arg));
    }
    exports$1.addCodeArg = addCodeArg;
    function optimize(expr) {
      let i = 1;
      while (i < expr.length - 1) {
        if (expr[i] === plus) {
          const res = mergeExprItems(expr[i - 1], expr[i + 1]);
          if (res !== void 0) {
            expr.splice(i - 1, 3, res);
            continue;
          }
          expr[i++] = "+";
        }
        i++;
      }
    }
    function mergeExprItems(a2, b) {
      if (b === '""')
        return a2;
      if (a2 === '""')
        return b;
      if (typeof a2 == "string") {
        if (b instanceof Name || a2[a2.length - 1] !== '"')
          return;
        if (typeof b != "string")
          return `${a2.slice(0, -1)}${b}"`;
        if (b[0] === '"')
          return a2.slice(0, -1) + b.slice(1);
        return;
      }
      if (typeof b == "string" && b[0] === '"' && !(a2 instanceof Name))
        return `"${a2}${b.slice(1)}`;
      return;
    }
    function strConcat(c1, c2) {
      return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
    }
    exports$1.strConcat = strConcat;
    function interpolate(x2) {
      return typeof x2 == "number" || typeof x2 == "boolean" || x2 === null ? x2 : safeStringify(Array.isArray(x2) ? x2.join(",") : x2);
    }
    function stringify(x2) {
      return new _Code(safeStringify(x2));
    }
    exports$1.stringify = stringify;
    function safeStringify(x2) {
      return JSON.stringify(x2).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    exports$1.safeStringify = safeStringify;
    function getProperty(key) {
      return typeof key == "string" && exports$1.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _2`[${key}]`;
    }
    exports$1.getProperty = getProperty;
    function getEsmExportName(key) {
      if (typeof key == "string" && exports$1.IDENTIFIER.test(key)) {
        return new _Code(`${key}`);
      }
      throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
    }
    exports$1.getEsmExportName = getEsmExportName;
    function regexpCode(rx) {
      return new _Code(rx.toString());
    }
    exports$1.regexpCode = regexpCode;
  })(code$3);
  return code$3;
}
var scope$1 = {};
var hasRequiredScope$1;
function requireScope$1() {
  if (hasRequiredScope$1) return scope$1;
  hasRequiredScope$1 = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.ValueScope = exports$1.ValueScopeName = exports$1.Scope = exports$1.varKinds = exports$1.UsedValueState = void 0;
    const code_1 = /* @__PURE__ */ requireCode$3();
    class ValueError extends Error {
      constructor(name2) {
        super(`CodeGen: "code" for ${name2} not defined`);
        this.value = name2.value;
      }
    }
    var UsedValueState;
    (function(UsedValueState2) {
      UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
      UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
    })(UsedValueState || (exports$1.UsedValueState = UsedValueState = {}));
    exports$1.varKinds = {
      const: new code_1.Name("const"),
      let: new code_1.Name("let"),
      var: new code_1.Name("var")
    };
    class Scope {
      constructor({ prefixes, parent } = {}) {
        this._names = {};
        this._prefixes = prefixes;
        this._parent = parent;
      }
      toName(nameOrPrefix) {
        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
      }
      name(prefix) {
        return new code_1.Name(this._newName(prefix));
      }
      _newName(prefix) {
        const ng2 = this._names[prefix] || this._nameGroup(prefix);
        return `${prefix}${ng2.index++}`;
      }
      _nameGroup(prefix) {
        var _a2, _b;
        if (((_b = (_a2 = this._parent) === null || _a2 === void 0 ? void 0 : _a2._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
          throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
        }
        return this._names[prefix] = { prefix, index: 0 };
      }
    }
    exports$1.Scope = Scope;
    class ValueScopeName extends code_1.Name {
      constructor(prefix, nameStr) {
        super(nameStr);
        this.prefix = prefix;
      }
      setValue(value, { property, itemIndex }) {
        this.value = value;
        this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
      }
    }
    exports$1.ValueScopeName = ValueScopeName;
    const line = (0, code_1._)`\n`;
    class ValueScope extends Scope {
      constructor(opts) {
        super(opts);
        this._values = {};
        this._scope = opts.scope;
        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
      }
      get() {
        return this._scope;
      }
      name(prefix) {
        return new ValueScopeName(prefix, this._newName(prefix));
      }
      value(nameOrPrefix, value) {
        var _a2;
        if (value.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const name2 = this.toName(nameOrPrefix);
        const { prefix } = name2;
        const valueKey = (_a2 = value.key) !== null && _a2 !== void 0 ? _a2 : value.ref;
        let vs2 = this._values[prefix];
        if (vs2) {
          const _name = vs2.get(valueKey);
          if (_name)
            return _name;
        } else {
          vs2 = this._values[prefix] = /* @__PURE__ */ new Map();
        }
        vs2.set(valueKey, name2);
        const s2 = this._scope[prefix] || (this._scope[prefix] = []);
        const itemIndex = s2.length;
        s2[itemIndex] = value.ref;
        name2.setValue(value, { property: prefix, itemIndex });
        return name2;
      }
      getValue(prefix, keyOrRef) {
        const vs2 = this._values[prefix];
        if (!vs2)
          return;
        return vs2.get(keyOrRef);
      }
      scopeRefs(scopeName, values = this._values) {
        return this._reduceValues(values, (name2) => {
          if (name2.scopePath === void 0)
            throw new Error(`CodeGen: name "${name2}" has no value`);
          return (0, code_1._)`${scopeName}${name2.scopePath}`;
        });
      }
      scopeCode(values = this._values, usedValues, getCode) {
        return this._reduceValues(values, (name2) => {
          if (name2.value === void 0)
            throw new Error(`CodeGen: name "${name2}" has no value`);
          return name2.value.code;
        }, usedValues, getCode);
      }
      _reduceValues(values, valueCode, usedValues = {}, getCode) {
        let code2 = code_1.nil;
        for (const prefix in values) {
          const vs2 = values[prefix];
          if (!vs2)
            continue;
          const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
          vs2.forEach((name2) => {
            if (nameSet.has(name2))
              return;
            nameSet.set(name2, UsedValueState.Started);
            let c = valueCode(name2);
            if (c) {
              const def = this.opts.es5 ? exports$1.varKinds.var : exports$1.varKinds.const;
              code2 = (0, code_1._)`${code2}${def} ${name2} = ${c};${this.opts._n}`;
            } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name2)) {
              code2 = (0, code_1._)`${code2}${c}${this.opts._n}`;
            } else {
              throw new ValueError(name2);
            }
            nameSet.set(name2, UsedValueState.Completed);
          });
        }
        return code2;
      }
    }
    exports$1.ValueScope = ValueScope;
  })(scope$1);
  return scope$1;
}
var hasRequiredCodegen$1;
function requireCodegen$1() {
  if (hasRequiredCodegen$1) return codegen$1;
  hasRequiredCodegen$1 = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.or = exports$1.and = exports$1.not = exports$1.CodeGen = exports$1.operators = exports$1.varKinds = exports$1.ValueScopeName = exports$1.ValueScope = exports$1.Scope = exports$1.Name = exports$1.regexpCode = exports$1.stringify = exports$1.getProperty = exports$1.nil = exports$1.strConcat = exports$1.str = exports$1._ = void 0;
    const code_1 = /* @__PURE__ */ requireCode$3();
    const scope_1 = /* @__PURE__ */ requireScope$1();
    var code_2 = /* @__PURE__ */ requireCode$3();
    Object.defineProperty(exports$1, "_", { enumerable: true, get: function() {
      return code_2._;
    } });
    Object.defineProperty(exports$1, "str", { enumerable: true, get: function() {
      return code_2.str;
    } });
    Object.defineProperty(exports$1, "strConcat", { enumerable: true, get: function() {
      return code_2.strConcat;
    } });
    Object.defineProperty(exports$1, "nil", { enumerable: true, get: function() {
      return code_2.nil;
    } });
    Object.defineProperty(exports$1, "getProperty", { enumerable: true, get: function() {
      return code_2.getProperty;
    } });
    Object.defineProperty(exports$1, "stringify", { enumerable: true, get: function() {
      return code_2.stringify;
    } });
    Object.defineProperty(exports$1, "regexpCode", { enumerable: true, get: function() {
      return code_2.regexpCode;
    } });
    Object.defineProperty(exports$1, "Name", { enumerable: true, get: function() {
      return code_2.Name;
    } });
    var scope_2 = /* @__PURE__ */ requireScope$1();
    Object.defineProperty(exports$1, "Scope", { enumerable: true, get: function() {
      return scope_2.Scope;
    } });
    Object.defineProperty(exports$1, "ValueScope", { enumerable: true, get: function() {
      return scope_2.ValueScope;
    } });
    Object.defineProperty(exports$1, "ValueScopeName", { enumerable: true, get: function() {
      return scope_2.ValueScopeName;
    } });
    Object.defineProperty(exports$1, "varKinds", { enumerable: true, get: function() {
      return scope_2.varKinds;
    } });
    exports$1.operators = {
      GT: new code_1._Code(">"),
      GTE: new code_1._Code(">="),
      LT: new code_1._Code("<"),
      LTE: new code_1._Code("<="),
      EQ: new code_1._Code("==="),
      NEQ: new code_1._Code("!=="),
      NOT: new code_1._Code("!"),
      OR: new code_1._Code("||"),
      AND: new code_1._Code("&&"),
      ADD: new code_1._Code("+")
    };
    class Node2 {
      optimizeNodes() {
        return this;
      }
      optimizeNames(_names, _constants) {
        return this;
      }
    }
    class Def extends Node2 {
      constructor(varKind, name2, rhs) {
        super();
        this.varKind = varKind;
        this.name = name2;
        this.rhs = rhs;
      }
      render({ es5, _n: _n2 }) {
        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
        const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${varKind} ${this.name}${rhs};` + _n2;
      }
      optimizeNames(names2, constants) {
        if (!names2[this.name.str])
          return;
        if (this.rhs)
          this.rhs = optimizeExpr(this.rhs, names2, constants);
        return this;
      }
      get names() {
        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
      }
    }
    class Assign extends Node2 {
      constructor(lhs, rhs, sideEffects) {
        super();
        this.lhs = lhs;
        this.rhs = rhs;
        this.sideEffects = sideEffects;
      }
      render({ _n: _n2 }) {
        return `${this.lhs} = ${this.rhs};` + _n2;
      }
      optimizeNames(names2, constants) {
        if (this.lhs instanceof code_1.Name && !names2[this.lhs.str] && !this.sideEffects)
          return;
        this.rhs = optimizeExpr(this.rhs, names2, constants);
        return this;
      }
      get names() {
        const names2 = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
        return addExprNames(names2, this.rhs);
      }
    }
    class AssignOp extends Assign {
      constructor(lhs, op2, rhs, sideEffects) {
        super(lhs, rhs, sideEffects);
        this.op = op2;
      }
      render({ _n: _n2 }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + _n2;
      }
    }
    class Label2 extends Node2 {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n: _n2 }) {
        return `${this.label}:` + _n2;
      }
    }
    class Break extends Node2 {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n: _n2 }) {
        const label = this.label ? ` ${this.label}` : "";
        return `break${label};` + _n2;
      }
    }
    class Throw extends Node2 {
      constructor(error) {
        super();
        this.error = error;
      }
      render({ _n: _n2 }) {
        return `throw ${this.error};` + _n2;
      }
      get names() {
        return this.error.names;
      }
    }
    class AnyCode extends Node2 {
      constructor(code2) {
        super();
        this.code = code2;
      }
      render({ _n: _n2 }) {
        return `${this.code};` + _n2;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(names2, constants) {
        this.code = optimizeExpr(this.code, names2, constants);
        return this;
      }
      get names() {
        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
      }
    }
    class ParentNode extends Node2 {
      constructor(nodes = []) {
        super();
        this.nodes = nodes;
      }
      render(opts) {
        return this.nodes.reduce((code2, n) => code2 + n.render(opts), "");
      }
      optimizeNodes() {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i].optimizeNodes();
          if (Array.isArray(n))
            nodes.splice(i, 1, ...n);
          else if (n)
            nodes[i] = n;
          else
            nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      optimizeNames(names2, constants) {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i];
          if (n.optimizeNames(names2, constants))
            continue;
          subtractNames(names2, n.names);
          nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((names2, n) => addNames(names2, n.names), {});
      }
    }
    class BlockNode extends ParentNode {
      render(opts) {
        return "{" + opts._n + super.render(opts) + "}" + opts._n;
      }
    }
    class Root4 extends ParentNode {
    }
    class Else extends BlockNode {
    }
    Else.kind = "else";
    class If2 extends BlockNode {
      constructor(condition, nodes) {
        super(nodes);
        this.condition = condition;
      }
      render(opts) {
        let code2 = `if(${this.condition})` + super.render(opts);
        if (this.else)
          code2 += "else " + this.else.render(opts);
        return code2;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const cond = this.condition;
        if (cond === true)
          return this.nodes;
        let e = this.else;
        if (e) {
          const ns2 = e.optimizeNodes();
          e = this.else = Array.isArray(ns2) ? new Else(ns2) : ns2;
        }
        if (e) {
          if (cond === false)
            return e instanceof If2 ? e : e.nodes;
          if (this.nodes.length)
            return this;
          return new If2(not2(cond), e instanceof If2 ? [e] : e.nodes);
        }
        if (cond === false || !this.nodes.length)
          return void 0;
        return this;
      }
      optimizeNames(names2, constants) {
        var _a2;
        this.else = (_a2 = this.else) === null || _a2 === void 0 ? void 0 : _a2.optimizeNames(names2, constants);
        if (!(super.optimizeNames(names2, constants) || this.else))
          return;
        this.condition = optimizeExpr(this.condition, names2, constants);
        return this;
      }
      get names() {
        const names2 = super.names;
        addExprNames(names2, this.condition);
        if (this.else)
          addNames(names2, this.else.names);
        return names2;
      }
    }
    If2.kind = "if";
    class For extends BlockNode {
    }
    For.kind = "for";
    class ForLoop extends For {
      constructor(iteration) {
        super();
        this.iteration = iteration;
      }
      render(opts) {
        return `for(${this.iteration})` + super.render(opts);
      }
      optimizeNames(names2, constants) {
        if (!super.optimizeNames(names2, constants))
          return;
        this.iteration = optimizeExpr(this.iteration, names2, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iteration.names);
      }
    }
    class ForRange extends For {
      constructor(varKind, name2, from, to2) {
        super();
        this.varKind = varKind;
        this.name = name2;
        this.from = from;
        this.to = to2;
      }
      render(opts) {
        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
        const { name: name2, from, to: to2 } = this;
        return `for(${varKind} ${name2}=${from}; ${name2}<${to2}; ${name2}++)` + super.render(opts);
      }
      get names() {
        const names2 = addExprNames(super.names, this.from);
        return addExprNames(names2, this.to);
      }
    }
    class ForIter extends For {
      constructor(loop, varKind, name2, iterable) {
        super();
        this.loop = loop;
        this.varKind = varKind;
        this.name = name2;
        this.iterable = iterable;
      }
      render(opts) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
      }
      optimizeNames(names2, constants) {
        if (!super.optimizeNames(names2, constants))
          return;
        this.iterable = optimizeExpr(this.iterable, names2, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iterable.names);
      }
    }
    class Func extends BlockNode {
      constructor(name2, args, async2) {
        super();
        this.name = name2;
        this.args = args;
        this.async = async2;
      }
      render(opts) {
        const _async = this.async ? "async " : "";
        return `${_async}function ${this.name}(${this.args})` + super.render(opts);
      }
    }
    Func.kind = "func";
    class Return extends ParentNode {
      render(opts) {
        return "return " + super.render(opts);
      }
    }
    Return.kind = "return";
    class Try extends BlockNode {
      render(opts) {
        let code2 = "try" + super.render(opts);
        if (this.catch)
          code2 += this.catch.render(opts);
        if (this.finally)
          code2 += this.finally.render(opts);
        return code2;
      }
      optimizeNodes() {
        var _a2, _b;
        super.optimizeNodes();
        (_a2 = this.catch) === null || _a2 === void 0 ? void 0 : _a2.optimizeNodes();
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
        return this;
      }
      optimizeNames(names2, constants) {
        var _a2, _b;
        super.optimizeNames(names2, constants);
        (_a2 = this.catch) === null || _a2 === void 0 ? void 0 : _a2.optimizeNames(names2, constants);
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names2, constants);
        return this;
      }
      get names() {
        const names2 = super.names;
        if (this.catch)
          addNames(names2, this.catch.names);
        if (this.finally)
          addNames(names2, this.finally.names);
        return names2;
      }
    }
    class Catch extends BlockNode {
      constructor(error) {
        super();
        this.error = error;
      }
      render(opts) {
        return `catch(${this.error})` + super.render(opts);
      }
    }
    Catch.kind = "catch";
    class Finally extends BlockNode {
      render(opts) {
        return "finally" + super.render(opts);
      }
    }
    Finally.kind = "finally";
    class CodeGen {
      constructor(extScope, opts = {}) {
        this._values = {};
        this._blockStarts = [];
        this._constants = {};
        this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
        this._extScope = extScope;
        this._scope = new scope_1.Scope({ parent: extScope });
        this._nodes = [new Root4()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(prefix) {
        return this._scope.name(prefix);
      }
      // reserves unique name in the external scope
      scopeName(prefix) {
        return this._extScope.name(prefix);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(prefixOrName, value) {
        const name2 = this._extScope.value(prefixOrName, value);
        const vs2 = this._values[name2.prefix] || (this._values[name2.prefix] = /* @__PURE__ */ new Set());
        vs2.add(name2);
        return name2;
      }
      getScopeValue(prefix, keyOrRef) {
        return this._extScope.getValue(prefix, keyOrRef);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(scopeName) {
        return this._extScope.scopeRefs(scopeName, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(varKind, nameOrPrefix, rhs, constant) {
        const name2 = this._scope.toName(nameOrPrefix);
        if (rhs !== void 0 && constant)
          this._constants[name2.str] = rhs;
        this._leafNode(new Def(varKind, name2, rhs));
        return name2;
      }
      // `const` declaration (`var` in es5 mode)
      const(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
      }
      // `var` declaration with optional assignment
      var(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
      }
      // assignment code
      assign(lhs, rhs, sideEffects) {
        return this._leafNode(new Assign(lhs, rhs, sideEffects));
      }
      // `+=` code
      add(lhs, rhs) {
        return this._leafNode(new AssignOp(lhs, exports$1.operators.ADD, rhs));
      }
      // appends passed SafeExpr to code or executes Block
      code(c) {
        if (typeof c == "function")
          c();
        else if (c !== code_1.nil)
          this._leafNode(new AnyCode(c));
        return this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...keyValues) {
        const code2 = ["{"];
        for (const [key, value] of keyValues) {
          if (code2.length > 1)
            code2.push(",");
          code2.push(key);
          if (key !== value || this.opts.es5) {
            code2.push(":");
            (0, code_1.addCodeArg)(code2, value);
          }
        }
        code2.push("}");
        return new code_1._Code(code2);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(condition, thenBody, elseBody) {
        this._blockNode(new If2(condition));
        if (thenBody && elseBody) {
          this.code(thenBody).else().code(elseBody).endIf();
        } else if (thenBody) {
          this.code(thenBody).endIf();
        } else if (elseBody) {
          throw new Error('CodeGen: "else" body without "then" body');
        }
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(condition) {
        return this._elseNode(new If2(condition));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new Else());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(If2, Else);
      }
      _for(node, forBody) {
        this._blockNode(node);
        if (forBody)
          this.code(forBody).endFor();
        return this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(iteration, forBody) {
        return this._for(new ForLoop(iteration), forBody);
      }
      // `for` statement for a range of values
      forRange(nameOrPrefix, from, to2, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
        const name2 = this._scope.toName(nameOrPrefix);
        return this._for(new ForRange(varKind, name2, from, to2), () => forBody(name2));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
        const name2 = this._scope.toName(nameOrPrefix);
        if (this.opts.es5) {
          const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
          return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
            this.var(name2, (0, code_1._)`${arr}[${i}]`);
            forBody(name2);
          });
        }
        return this._for(new ForIter("of", varKind, name2, iterable), () => forBody(name2));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
        if (this.opts.ownProperties) {
          return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
        }
        const name2 = this._scope.toName(nameOrPrefix);
        return this._for(new ForIter("in", varKind, name2, obj), () => forBody(name2));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(For);
      }
      // `label` statement
      label(label) {
        return this._leafNode(new Label2(label));
      }
      // `break` statement
      break(label) {
        return this._leafNode(new Break(label));
      }
      // `return` statement
      return(value) {
        const node = new Return();
        this._blockNode(node);
        this.code(value);
        if (node.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Return);
      }
      // `try` statement
      try(tryBody, catchCode, finallyCode) {
        if (!catchCode && !finallyCode)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const node = new Try();
        this._blockNode(node);
        this.code(tryBody);
        if (catchCode) {
          const error = this.name("e");
          this._currNode = node.catch = new Catch(error);
          catchCode(error);
        }
        if (finallyCode) {
          this._currNode = node.finally = new Finally();
          this.code(finallyCode);
        }
        return this._endBlockNode(Catch, Finally);
      }
      // `throw` statement
      throw(error) {
        return this._leafNode(new Throw(error));
      }
      // start self-balancing block
      block(body, nodeCount) {
        this._blockStarts.push(this._nodes.length);
        if (body)
          this.code(body).endBlock(nodeCount);
        return this;
      }
      // end the current self-balancing block
      endBlock(nodeCount) {
        const len = this._blockStarts.pop();
        if (len === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const toClose = this._nodes.length - len;
        if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
          throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
        }
        this._nodes.length = len;
        return this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(name2, args = code_1.nil, async2, funcBody) {
        this._blockNode(new Func(name2, args, async2));
        if (funcBody)
          this.code(funcBody).endFunc();
        return this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(Func);
      }
      optimize(n = 1) {
        while (n-- > 0) {
          this._root.optimizeNodes();
          this._root.optimizeNames(this._root.names, this._constants);
        }
      }
      _leafNode(node) {
        this._currNode.nodes.push(node);
        return this;
      }
      _blockNode(node) {
        this._currNode.nodes.push(node);
        this._nodes.push(node);
      }
      _endBlockNode(N1, N2) {
        const n = this._currNode;
        if (n instanceof N1 || N2 && n instanceof N2) {
          this._nodes.pop();
          return this;
        }
        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
      }
      _elseNode(node) {
        const n = this._currNode;
        if (!(n instanceof If2)) {
          throw new Error('CodeGen: "else" without "if"');
        }
        this._currNode = n.else = node;
        return this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const ns2 = this._nodes;
        return ns2[ns2.length - 1];
      }
      set _currNode(node) {
        const ns2 = this._nodes;
        ns2[ns2.length - 1] = node;
      }
    }
    exports$1.CodeGen = CodeGen;
    function addNames(names2, from) {
      for (const n in from)
        names2[n] = (names2[n] || 0) + (from[n] || 0);
      return names2;
    }
    function addExprNames(names2, from) {
      return from instanceof code_1._CodeOrName ? addNames(names2, from.names) : names2;
    }
    function optimizeExpr(expr, names2, constants) {
      if (expr instanceof code_1.Name)
        return replaceName(expr);
      if (!canOptimize(expr))
        return expr;
      return new code_1._Code(expr._items.reduce((items2, c) => {
        if (c instanceof code_1.Name)
          c = replaceName(c);
        if (c instanceof code_1._Code)
          items2.push(...c._items);
        else
          items2.push(c);
        return items2;
      }, []));
      function replaceName(n) {
        const c = constants[n.str];
        if (c === void 0 || names2[n.str] !== 1)
          return n;
        delete names2[n.str];
        return c;
      }
      function canOptimize(e) {
        return e instanceof code_1._Code && e._items.some((c) => c instanceof code_1.Name && names2[c.str] === 1 && constants[c.str] !== void 0);
      }
    }
    function subtractNames(names2, from) {
      for (const n in from)
        names2[n] = (names2[n] || 0) - (from[n] || 0);
    }
    function not2(x2) {
      return typeof x2 == "boolean" || typeof x2 == "number" || x2 === null ? !x2 : (0, code_1._)`!${par(x2)}`;
    }
    exports$1.not = not2;
    const andCode = mappend(exports$1.operators.AND);
    function and(...args) {
      return args.reduce(andCode);
    }
    exports$1.and = and;
    const orCode = mappend(exports$1.operators.OR);
    function or2(...args) {
      return args.reduce(orCode);
    }
    exports$1.or = or2;
    function mappend(op2) {
      return (x2, y2) => x2 === code_1.nil ? y2 : y2 === code_1.nil ? x2 : (0, code_1._)`${par(x2)} ${op2} ${par(y2)}`;
    }
    function par(x2) {
      return x2 instanceof code_1.Name ? x2 : (0, code_1._)`(${x2})`;
    }
  })(codegen$1);
  return codegen$1;
}
var util$1 = {};
var hasRequiredUtil$1;
function requireUtil$1() {
  if (hasRequiredUtil$1) return util$1;
  hasRequiredUtil$1 = 1;
  Object.defineProperty(util$1, "__esModule", { value: true });
  util$1.checkStrictMode = util$1.getErrorPath = util$1.Type = util$1.useFunc = util$1.setEvaluated = util$1.evaluatedPropsToName = util$1.mergeEvaluated = util$1.eachItem = util$1.unescapeJsonPointer = util$1.escapeJsonPointer = util$1.escapeFragment = util$1.unescapeFragment = util$1.schemaRefOrVal = util$1.schemaHasRulesButRef = util$1.schemaHasRules = util$1.checkUnknownRules = util$1.alwaysValidSchema = util$1.toHash = void 0;
  const codegen_1 = /* @__PURE__ */ requireCodegen$1();
  const code_1 = /* @__PURE__ */ requireCode$3();
  function toHash(arr) {
    const hash = {};
    for (const item of arr)
      hash[item] = true;
    return hash;
  }
  util$1.toHash = toHash;
  function alwaysValidSchema(it2, schema) {
    if (typeof schema == "boolean")
      return schema;
    if (Object.keys(schema).length === 0)
      return true;
    checkUnknownRules(it2, schema);
    return !schemaHasRules(schema, it2.self.RULES.all);
  }
  util$1.alwaysValidSchema = alwaysValidSchema;
  function checkUnknownRules(it2, schema = it2.schema) {
    const { opts, self: self2 } = it2;
    if (!opts.strictSchema)
      return;
    if (typeof schema === "boolean")
      return;
    const rules2 = self2.RULES.keywords;
    for (const key in schema) {
      if (!rules2[key])
        checkStrictMode(it2, `unknown keyword: "${key}"`);
    }
  }
  util$1.checkUnknownRules = checkUnknownRules;
  function schemaHasRules(schema, rules2) {
    if (typeof schema == "boolean")
      return !schema;
    for (const key in schema)
      if (rules2[key])
        return true;
    return false;
  }
  util$1.schemaHasRules = schemaHasRules;
  function schemaHasRulesButRef(schema, RULES) {
    if (typeof schema == "boolean")
      return !schema;
    for (const key in schema)
      if (key !== "$ref" && RULES.all[key])
        return true;
    return false;
  }
  util$1.schemaHasRulesButRef = schemaHasRulesButRef;
  function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword2, $data) {
    if (!$data) {
      if (typeof schema == "number" || typeof schema == "boolean")
        return schema;
      if (typeof schema == "string")
        return (0, codegen_1._)`${schema}`;
    }
    return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword2)}`;
  }
  util$1.schemaRefOrVal = schemaRefOrVal;
  function unescapeFragment(str) {
    return unescapeJsonPointer(decodeURIComponent(str));
  }
  util$1.unescapeFragment = unescapeFragment;
  function escapeFragment(str) {
    return encodeURIComponent(escapeJsonPointer(str));
  }
  util$1.escapeFragment = escapeFragment;
  function escapeJsonPointer(str) {
    if (typeof str == "number")
      return `${str}`;
    return str.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  util$1.escapeJsonPointer = escapeJsonPointer;
  function unescapeJsonPointer(str) {
    return str.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  util$1.unescapeJsonPointer = unescapeJsonPointer;
  function eachItem(xs2, f2) {
    if (Array.isArray(xs2)) {
      for (const x2 of xs2)
        f2(x2);
    } else {
      f2(xs2);
    }
  }
  util$1.eachItem = eachItem;
  function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues: mergeValues2, resultToName }) {
    return (gen, from, to2, toName) => {
      const res = to2 === void 0 ? from : to2 instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to2) : mergeToName(gen, from, to2), to2) : from instanceof codegen_1.Name ? (mergeToName(gen, to2, from), from) : mergeValues2(from, to2);
      return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
    };
  }
  util$1.mergeEvaluated = {
    props: makeMergeEvaluated({
      mergeNames: (gen, from, to2) => gen.if((0, codegen_1._)`${to2} !== true && ${from} !== undefined`, () => {
        gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to2, true), () => gen.assign(to2, (0, codegen_1._)`${to2} || {}`).code((0, codegen_1._)`Object.assign(${to2}, ${from})`));
      }),
      mergeToName: (gen, from, to2) => gen.if((0, codegen_1._)`${to2} !== true`, () => {
        if (from === true) {
          gen.assign(to2, true);
        } else {
          gen.assign(to2, (0, codegen_1._)`${to2} || {}`);
          setEvaluated(gen, to2, from);
        }
      }),
      mergeValues: (from, to2) => from === true ? true : { ...from, ...to2 },
      resultToName: evaluatedPropsToName
    }),
    items: makeMergeEvaluated({
      mergeNames: (gen, from, to2) => gen.if((0, codegen_1._)`${to2} !== true && ${from} !== undefined`, () => gen.assign(to2, (0, codegen_1._)`${from} === true ? true : ${to2} > ${from} ? ${to2} : ${from}`)),
      mergeToName: (gen, from, to2) => gen.if((0, codegen_1._)`${to2} !== true`, () => gen.assign(to2, from === true ? true : (0, codegen_1._)`${to2} > ${from} ? ${to2} : ${from}`)),
      mergeValues: (from, to2) => from === true ? true : Math.max(from, to2),
      resultToName: (gen, items2) => gen.var("items", items2)
    })
  };
  function evaluatedPropsToName(gen, ps2) {
    if (ps2 === true)
      return gen.var("props", true);
    const props = gen.var("props", (0, codegen_1._)`{}`);
    if (ps2 !== void 0)
      setEvaluated(gen, props, ps2);
    return props;
  }
  util$1.evaluatedPropsToName = evaluatedPropsToName;
  function setEvaluated(gen, props, ps2) {
    Object.keys(ps2).forEach((p2) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p2)}`, true));
  }
  util$1.setEvaluated = setEvaluated;
  const snippets = {};
  function useFunc(gen, f2) {
    return gen.scopeValue("func", {
      ref: f2,
      code: snippets[f2.code] || (snippets[f2.code] = new code_1._Code(f2.code))
    });
  }
  util$1.useFunc = useFunc;
  var Type;
  (function(Type2) {
    Type2[Type2["Num"] = 0] = "Num";
    Type2[Type2["Str"] = 1] = "Str";
  })(Type || (util$1.Type = Type = {}));
  function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
    if (dataProp instanceof codegen_1.Name) {
      const isNumber2 = dataPropType === Type.Num;
      return jsPropertySyntax ? isNumber2 ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber2 ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
  }
  util$1.getErrorPath = getErrorPath;
  function checkStrictMode(it2, msg, mode = it2.opts.strictSchema) {
    if (!mode)
      return;
    msg = `strict mode: ${msg}`;
    if (mode === true)
      throw new Error(msg);
    it2.self.logger.warn(msg);
  }
  util$1.checkStrictMode = checkStrictMode;
  return util$1;
}
var names$1 = {};
var hasRequiredNames$1;
function requireNames$1() {
  if (hasRequiredNames$1) return names$1;
  hasRequiredNames$1 = 1;
  Object.defineProperty(names$1, "__esModule", { value: true });
  const codegen_1 = /* @__PURE__ */ requireCodegen$1();
  const names2 = {
    // validation function arguments
    data: new codegen_1.Name("data"),
    // data passed to validation function
    // args passed from referencing schema
    valCxt: new codegen_1.Name("valCxt"),
    // validation/data context - should not be used directly, it is destructured to the names below
    instancePath: new codegen_1.Name("instancePath"),
    parentData: new codegen_1.Name("parentData"),
    parentDataProperty: new codegen_1.Name("parentDataProperty"),
    rootData: new codegen_1.Name("rootData"),
    // root data - same as the data passed to the first/top validation function
    dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
    // used to support recursiveRef and dynamicRef
    // function scoped variables
    vErrors: new codegen_1.Name("vErrors"),
    // null or array of validation errors
    errors: new codegen_1.Name("errors"),
    // counter of validation errors
    this: new codegen_1.Name("this"),
    // "globals"
    self: new codegen_1.Name("self"),
    scope: new codegen_1.Name("scope"),
    // JTD serialize/parse name for JSON string and position
    json: new codegen_1.Name("json"),
    jsonPos: new codegen_1.Name("jsonPos"),
    jsonLen: new codegen_1.Name("jsonLen"),
    jsonPart: new codegen_1.Name("jsonPart")
  };
  names$1.default = names2;
  return names$1;
}
var hasRequiredErrors$1;
function requireErrors$1() {
  if (hasRequiredErrors$1) return errors$1;
  hasRequiredErrors$1 = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.extendErrors = exports$1.resetErrorsCount = exports$1.reportExtraError = exports$1.reportError = exports$1.keyword$DataError = exports$1.keywordError = void 0;
    const codegen_1 = /* @__PURE__ */ requireCodegen$1();
    const util_1 = /* @__PURE__ */ requireUtil$1();
    const names_1 = /* @__PURE__ */ requireNames$1();
    exports$1.keywordError = {
      message: ({ keyword: keyword2 }) => (0, codegen_1.str)`must pass "${keyword2}" keyword validation`
    };
    exports$1.keyword$DataError = {
      message: ({ keyword: keyword2, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword2}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword2}" keyword is invalid ($data)`
    };
    function reportError2(cxt, error = exports$1.keywordError, errorPaths, overrideAllErrors) {
      const { it: it2 } = cxt;
      const { gen, compositeRule, allErrors } = it2;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
        addError(gen, errObj);
      } else {
        returnErrors(it2, (0, codegen_1._)`[${errObj}]`);
      }
    }
    exports$1.reportError = reportError2;
    function reportExtraError(cxt, error = exports$1.keywordError, errorPaths) {
      const { it: it2 } = cxt;
      const { gen, compositeRule, allErrors } = it2;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      addError(gen, errObj);
      if (!(compositeRule || allErrors)) {
        returnErrors(it2, names_1.default.vErrors);
      }
    }
    exports$1.reportExtraError = reportExtraError;
    function resetErrorsCount(gen, errsCount) {
      gen.assign(names_1.default.errors, errsCount);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
    }
    exports$1.resetErrorsCount = resetErrorsCount;
    function extendErrors({ gen, keyword: keyword2, schemaValue, data: data2, errsCount, it: it2 }) {
      if (errsCount === void 0)
        throw new Error("ajv implementation error");
      const err = gen.name("err");
      gen.forRange("i", errsCount, names_1.default.errors, (i) => {
        gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
        gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it2.errorPath)));
        gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it2.errSchemaPath}/${keyword2}`);
        if (it2.opts.verbose) {
          gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
          gen.assign((0, codegen_1._)`${err}.data`, data2);
        }
      });
    }
    exports$1.extendErrors = extendErrors;
    function addError(gen, errObj) {
      const err = gen.const("err", errObj);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
      gen.code((0, codegen_1._)`${names_1.default.errors}++`);
    }
    function returnErrors(it2, errs) {
      const { gen, validateName, schemaEnv } = it2;
      if (schemaEnv.$async) {
        gen.throw((0, codegen_1._)`new ${it2.ValidationError}(${errs})`);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, errs);
        gen.return(false);
      }
    }
    const E2 = {
      keyword: new codegen_1.Name("keyword"),
      schemaPath: new codegen_1.Name("schemaPath"),
      // also used in JTD errors
      params: new codegen_1.Name("params"),
      propertyName: new codegen_1.Name("propertyName"),
      message: new codegen_1.Name("message"),
      schema: new codegen_1.Name("schema"),
      parentSchema: new codegen_1.Name("parentSchema")
    };
    function errorObjectCode(cxt, error, errorPaths) {
      const { createErrors } = cxt.it;
      if (createErrors === false)
        return (0, codegen_1._)`{}`;
      return errorObject(cxt, error, errorPaths);
    }
    function errorObject(cxt, error, errorPaths = {}) {
      const { gen, it: it2 } = cxt;
      const keyValues = [
        errorInstancePath(it2, errorPaths),
        errorSchemaPath(cxt, errorPaths)
      ];
      extraErrorProps(cxt, error, keyValues);
      return gen.object(...keyValues);
    }
    function errorInstancePath({ errorPath }, { instancePath }) {
      const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
      return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
    }
    function errorSchemaPath({ keyword: keyword2, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
      let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword2}`;
      if (schemaPath) {
        schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
      }
      return [E2.schemaPath, schPath];
    }
    function extraErrorProps(cxt, { params, message }, keyValues) {
      const { keyword: keyword2, data: data2, schemaValue, it: it2 } = cxt;
      const { opts, propertyName, topSchemaRef, schemaPath } = it2;
      keyValues.push([E2.keyword, keyword2], [E2.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]);
      if (opts.messages) {
        keyValues.push([E2.message, typeof message == "function" ? message(cxt) : message]);
      }
      if (opts.verbose) {
        keyValues.push([E2.schema, schemaValue], [E2.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data2]);
      }
      if (propertyName)
        keyValues.push([E2.propertyName, propertyName]);
    }
  })(errors$1);
  return errors$1;
}
var hasRequiredBoolSchema$1;
function requireBoolSchema$1() {
  if (hasRequiredBoolSchema$1) return boolSchema$1;
  hasRequiredBoolSchema$1 = 1;
  Object.defineProperty(boolSchema$1, "__esModule", { value: true });
  boolSchema$1.boolOrEmptySchema = boolSchema$1.topBoolOrEmptySchema = void 0;
  const errors_1 = /* @__PURE__ */ requireErrors$1();
  const codegen_1 = /* @__PURE__ */ requireCodegen$1();
  const names_1 = /* @__PURE__ */ requireNames$1();
  const boolError = {
    message: "boolean schema is false"
  };
  function topBoolOrEmptySchema(it2) {
    const { gen, schema, validateName } = it2;
    if (schema === false) {
      falseSchemaError(it2, false);
    } else if (typeof schema == "object" && schema.$async === true) {
      gen.return(names_1.default.data);
    } else {
      gen.assign((0, codegen_1._)`${validateName}.errors`, null);
      gen.return(true);
    }
  }
  boolSchema$1.topBoolOrEmptySchema = topBoolOrEmptySchema;
  function boolOrEmptySchema(it2, valid) {
    const { gen, schema } = it2;
    if (schema === false) {
      gen.var(valid, false);
      falseSchemaError(it2);
    } else {
      gen.var(valid, true);
    }
  }
  boolSchema$1.boolOrEmptySchema = boolOrEmptySchema;
  function falseSchemaError(it2, overrideAllErrors) {
    const { gen, data: data2 } = it2;
    const cxt = {
      gen,
      keyword: "false schema",
      data: data2,
      schema: false,
      schemaCode: false,
      schemaValue: false,
      params: {},
      it: it2
    };
    (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
  }
  return boolSchema$1;
}
var dataType$1 = {};
var rules$1 = {};
var hasRequiredRules$1;
function requireRules$1() {
  if (hasRequiredRules$1) return rules$1;
  hasRequiredRules$1 = 1;
  Object.defineProperty(rules$1, "__esModule", { value: true });
  rules$1.getRules = rules$1.isJSONType = void 0;
  const _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
  const jsonTypes = new Set(_jsonTypes);
  function isJSONType(x2) {
    return typeof x2 == "string" && jsonTypes.has(x2);
  }
  rules$1.isJSONType = isJSONType;
  function getRules() {
    const groups = {
      number: { type: "number", rules: [] },
      string: { type: "string", rules: [] },
      array: { type: "array", rules: [] },
      object: { type: "object", rules: [] }
    };
    return {
      types: { ...groups, integer: true, boolean: true, null: true },
      rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
      post: { rules: [] },
      all: {},
      keywords: {}
    };
  }
  rules$1.getRules = getRules;
  return rules$1;
}
var applicability$1 = {};
var hasRequiredApplicability$1;
function requireApplicability$1() {
  if (hasRequiredApplicability$1) return applicability$1;
  hasRequiredApplicability$1 = 1;
  Object.defineProperty(applicability$1, "__esModule", { value: true });
  applicability$1.shouldUseRule = applicability$1.shouldUseGroup = applicability$1.schemaHasRulesForType = void 0;
  function schemaHasRulesForType({ schema, self: self2 }, type2) {
    const group = self2.RULES.types[type2];
    return group && group !== true && shouldUseGroup(schema, group);
  }
  applicability$1.schemaHasRulesForType = schemaHasRulesForType;
  function shouldUseGroup(schema, group) {
    return group.rules.some((rule) => shouldUseRule(schema, rule));
  }
  applicability$1.shouldUseGroup = shouldUseGroup;
  function shouldUseRule(schema, rule) {
    var _a2;
    return schema[rule.keyword] !== void 0 || ((_a2 = rule.definition.implements) === null || _a2 === void 0 ? void 0 : _a2.some((kwd) => schema[kwd] !== void 0));
  }
  applicability$1.shouldUseRule = shouldUseRule;
  return applicability$1;
}
var hasRequiredDataType$1;
function requireDataType$1() {
  if (hasRequiredDataType$1) return dataType$1;
  hasRequiredDataType$1 = 1;
  Object.defineProperty(dataType$1, "__esModule", { value: true });
  dataType$1.reportTypeError = dataType$1.checkDataTypes = dataType$1.checkDataType = dataType$1.coerceAndCheckDataType = dataType$1.getJSONTypes = dataType$1.getSchemaTypes = dataType$1.DataType = void 0;
  const rules_1 = /* @__PURE__ */ requireRules$1();
  const applicability_1 = /* @__PURE__ */ requireApplicability$1();
  const errors_1 = /* @__PURE__ */ requireErrors$1();
  const codegen_1 = /* @__PURE__ */ requireCodegen$1();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  var DataType;
  (function(DataType2) {
    DataType2[DataType2["Correct"] = 0] = "Correct";
    DataType2[DataType2["Wrong"] = 1] = "Wrong";
  })(DataType || (dataType$1.DataType = DataType = {}));
  function getSchemaTypes(schema) {
    const types2 = getJSONTypes(schema.type);
    const hasNull = types2.includes("null");
    if (hasNull) {
      if (schema.nullable === false)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!types2.length && schema.nullable !== void 0) {
        throw new Error('"nullable" cannot be used without "type"');
      }
      if (schema.nullable === true)
        types2.push("null");
    }
    return types2;
  }
  dataType$1.getSchemaTypes = getSchemaTypes;
  function getJSONTypes(ts2) {
    const types2 = Array.isArray(ts2) ? ts2 : ts2 ? [ts2] : [];
    if (types2.every(rules_1.isJSONType))
      return types2;
    throw new Error("type must be JSONType or JSONType[]: " + types2.join(","));
  }
  dataType$1.getJSONTypes = getJSONTypes;
  function coerceAndCheckDataType(it2, types2) {
    const { gen, data: data2, opts } = it2;
    const coerceTo = coerceToTypes(types2, opts.coerceTypes);
    const checkTypes = types2.length > 0 && !(coerceTo.length === 0 && types2.length === 1 && (0, applicability_1.schemaHasRulesForType)(it2, types2[0]));
    if (checkTypes) {
      const wrongType = checkDataTypes(types2, data2, opts.strictNumbers, DataType.Wrong);
      gen.if(wrongType, () => {
        if (coerceTo.length)
          coerceData(it2, types2, coerceTo);
        else
          reportTypeError(it2);
      });
    }
    return checkTypes;
  }
  dataType$1.coerceAndCheckDataType = coerceAndCheckDataType;
  const COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
  function coerceToTypes(types2, coerceTypes) {
    return coerceTypes ? types2.filter((t) => COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
  }
  function coerceData(it2, types2, coerceTo) {
    const { gen, data: data2, opts } = it2;
    const dataType2 = gen.let("dataType", (0, codegen_1._)`typeof ${data2}`);
    const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
    if (opts.coerceTypes === "array") {
      gen.if((0, codegen_1._)`${dataType2} == 'object' && Array.isArray(${data2}) && ${data2}.length == 1`, () => gen.assign(data2, (0, codegen_1._)`${data2}[0]`).assign(dataType2, (0, codegen_1._)`typeof ${data2}`).if(checkDataTypes(types2, data2, opts.strictNumbers), () => gen.assign(coerced, data2)));
    }
    gen.if((0, codegen_1._)`${coerced} !== undefined`);
    for (const t of coerceTo) {
      if (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") {
        coerceSpecificType(t);
      }
    }
    gen.else();
    reportTypeError(it2);
    gen.endIf();
    gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
      gen.assign(data2, coerced);
      assignParentData(it2, coerced);
    });
    function coerceSpecificType(t) {
      switch (t) {
        case "string":
          gen.elseIf((0, codegen_1._)`${dataType2} == "number" || ${dataType2} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data2}`).elseIf((0, codegen_1._)`${data2} === null`).assign(coerced, (0, codegen_1._)`""`);
          return;
        case "number":
          gen.elseIf((0, codegen_1._)`${dataType2} == "boolean" || ${data2} === null
              || (${dataType2} == "string" && ${data2} && ${data2} == +${data2})`).assign(coerced, (0, codegen_1._)`+${data2}`);
          return;
        case "integer":
          gen.elseIf((0, codegen_1._)`${dataType2} === "boolean" || ${data2} === null
              || (${dataType2} === "string" && ${data2} && ${data2} == +${data2} && !(${data2} % 1))`).assign(coerced, (0, codegen_1._)`+${data2}`);
          return;
        case "boolean":
          gen.elseIf((0, codegen_1._)`${data2} === "false" || ${data2} === 0 || ${data2} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data2} === "true" || ${data2} === 1`).assign(coerced, true);
          return;
        case "null":
          gen.elseIf((0, codegen_1._)`${data2} === "" || ${data2} === 0 || ${data2} === false`);
          gen.assign(coerced, null);
          return;
        case "array":
          gen.elseIf((0, codegen_1._)`${dataType2} === "string" || ${dataType2} === "number"
              || ${dataType2} === "boolean" || ${data2} === null`).assign(coerced, (0, codegen_1._)`[${data2}]`);
      }
    }
  }
  function assignParentData({ gen, parentData, parentDataProperty }, expr) {
    gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
  }
  function checkDataType(dataType2, data2, strictNums, correct = DataType.Correct) {
    const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
    let cond;
    switch (dataType2) {
      case "null":
        return (0, codegen_1._)`${data2} ${EQ} null`;
      case "array":
        cond = (0, codegen_1._)`Array.isArray(${data2})`;
        break;
      case "object":
        cond = (0, codegen_1._)`${data2} && typeof ${data2} == "object" && !Array.isArray(${data2})`;
        break;
      case "integer":
        cond = numCond((0, codegen_1._)`!(${data2} % 1) && !isNaN(${data2})`);
        break;
      case "number":
        cond = numCond();
        break;
      default:
        return (0, codegen_1._)`typeof ${data2} ${EQ} ${dataType2}`;
    }
    return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
    function numCond(_cond = codegen_1.nil) {
      return (0, codegen_1.and)((0, codegen_1._)`typeof ${data2} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data2})` : codegen_1.nil);
    }
  }
  dataType$1.checkDataType = checkDataType;
  function checkDataTypes(dataTypes, data2, strictNums, correct) {
    if (dataTypes.length === 1) {
      return checkDataType(dataTypes[0], data2, strictNums, correct);
    }
    let cond;
    const types2 = (0, util_1.toHash)(dataTypes);
    if (types2.array && types2.object) {
      const notObj = (0, codegen_1._)`typeof ${data2} != "object"`;
      cond = types2.null ? notObj : (0, codegen_1._)`!${data2} || ${notObj}`;
      delete types2.null;
      delete types2.array;
      delete types2.object;
    } else {
      cond = codegen_1.nil;
    }
    if (types2.number)
      delete types2.integer;
    for (const t in types2)
      cond = (0, codegen_1.and)(cond, checkDataType(t, data2, strictNums, correct));
    return cond;
  }
  dataType$1.checkDataTypes = checkDataTypes;
  const typeError = {
    message: ({ schema }) => `must be ${schema}`,
    params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
  };
  function reportTypeError(it2) {
    const cxt = getTypeErrorContext(it2);
    (0, errors_1.reportError)(cxt, typeError);
  }
  dataType$1.reportTypeError = reportTypeError;
  function getTypeErrorContext(it2) {
    const { gen, data: data2, schema } = it2;
    const schemaCode = (0, util_1.schemaRefOrVal)(it2, schema, "type");
    return {
      gen,
      keyword: "type",
      data: data2,
      schema: schema.type,
      schemaCode,
      schemaValue: schemaCode,
      parentSchema: schema,
      params: {},
      it: it2
    };
  }
  return dataType$1;
}
var defaults$1 = {};
var hasRequiredDefaults$1;
function requireDefaults$1() {
  if (hasRequiredDefaults$1) return defaults$1;
  hasRequiredDefaults$1 = 1;
  Object.defineProperty(defaults$1, "__esModule", { value: true });
  defaults$1.assignDefaults = void 0;
  const codegen_1 = /* @__PURE__ */ requireCodegen$1();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  function assignDefaults(it2, ty) {
    const { properties: properties2, items: items2 } = it2.schema;
    if (ty === "object" && properties2) {
      for (const key in properties2) {
        assignDefault(it2, key, properties2[key].default);
      }
    } else if (ty === "array" && Array.isArray(items2)) {
      items2.forEach((sch, i) => assignDefault(it2, i, sch.default));
    }
  }
  defaults$1.assignDefaults = assignDefaults;
  function assignDefault(it2, prop, defaultValue) {
    const { gen, compositeRule, data: data2, opts } = it2;
    if (defaultValue === void 0)
      return;
    const childData = (0, codegen_1._)`${data2}${(0, codegen_1.getProperty)(prop)}`;
    if (compositeRule) {
      (0, util_1.checkStrictMode)(it2, `default is ignored for: ${childData}`);
      return;
    }
    let condition = (0, codegen_1._)`${childData} === undefined`;
    if (opts.useDefaults === "empty") {
      condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
    }
    gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
  }
  return defaults$1;
}
var keyword$1 = {};
var code$2 = {};
var hasRequiredCode$2;
function requireCode$2() {
  if (hasRequiredCode$2) return code$2;
  hasRequiredCode$2 = 1;
  Object.defineProperty(code$2, "__esModule", { value: true });
  code$2.validateUnion = code$2.validateArray = code$2.usePattern = code$2.callValidateCode = code$2.schemaProperties = code$2.allSchemaProperties = code$2.noPropertyInData = code$2.propertyInData = code$2.isOwnProperty = code$2.hasPropFunc = code$2.reportMissingProp = code$2.checkMissingProp = code$2.checkReportMissingProp = void 0;
  const codegen_1 = /* @__PURE__ */ requireCodegen$1();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const names_1 = /* @__PURE__ */ requireNames$1();
  const util_2 = /* @__PURE__ */ requireUtil$1();
  function checkReportMissingProp(cxt, prop) {
    const { gen, data: data2, it: it2 } = cxt;
    gen.if(noPropertyInData(gen, data2, prop, it2.opts.ownProperties), () => {
      cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
      cxt.error();
    });
  }
  code$2.checkReportMissingProp = checkReportMissingProp;
  function checkMissingProp({ gen, data: data2, it: { opts } }, properties2, missing) {
    return (0, codegen_1.or)(...properties2.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data2, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
  }
  code$2.checkMissingProp = checkMissingProp;
  function reportMissingProp(cxt, missing) {
    cxt.setParams({ missingProperty: missing }, true);
    cxt.error();
  }
  code$2.reportMissingProp = reportMissingProp;
  function hasPropFunc(gen) {
    return gen.scopeValue("func", {
      // eslint-disable-next-line @typescript-eslint/unbound-method
      ref: Object.prototype.hasOwnProperty,
      code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
    });
  }
  code$2.hasPropFunc = hasPropFunc;
  function isOwnProperty(gen, data2, property) {
    return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data2}, ${property})`;
  }
  code$2.isOwnProperty = isOwnProperty;
  function propertyInData(gen, data2, property, ownProperties) {
    const cond = (0, codegen_1._)`${data2}${(0, codegen_1.getProperty)(property)} !== undefined`;
    return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data2, property)}` : cond;
  }
  code$2.propertyInData = propertyInData;
  function noPropertyInData(gen, data2, property, ownProperties) {
    const cond = (0, codegen_1._)`${data2}${(0, codegen_1.getProperty)(property)} === undefined`;
    return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data2, property))) : cond;
  }
  code$2.noPropertyInData = noPropertyInData;
  function allSchemaProperties(schemaMap) {
    return schemaMap ? Object.keys(schemaMap).filter((p2) => p2 !== "__proto__") : [];
  }
  code$2.allSchemaProperties = allSchemaProperties;
  function schemaProperties(it2, schemaMap) {
    return allSchemaProperties(schemaMap).filter((p2) => !(0, util_1.alwaysValidSchema)(it2, schemaMap[p2]));
  }
  code$2.schemaProperties = schemaProperties;
  function callValidateCode({ schemaCode, data: data2, it: { gen, topSchemaRef, schemaPath, errorPath }, it: it2 }, func, context, passSchema) {
    const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data2}, ${topSchemaRef}${schemaPath}` : data2;
    const valCxt = [
      [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
      [names_1.default.parentData, it2.parentData],
      [names_1.default.parentDataProperty, it2.parentDataProperty],
      [names_1.default.rootData, names_1.default.rootData]
    ];
    if (it2.opts.dynamicRef)
      valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
    const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
    return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
  }
  code$2.callValidateCode = callValidateCode;
  const newRegExp = (0, codegen_1._)`new RegExp`;
  function usePattern({ gen, it: { opts } }, pattern2) {
    const u2 = opts.unicodeRegExp ? "u" : "";
    const { regExp } = opts.code;
    const rx = regExp(pattern2, u2);
    return gen.scopeValue("pattern", {
      key: rx.toString(),
      ref: rx,
      code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern2}, ${u2})`
    });
  }
  code$2.usePattern = usePattern;
  function validateArray(cxt) {
    const { gen, data: data2, keyword: keyword2, it: it2 } = cxt;
    const valid = gen.name("valid");
    if (it2.allErrors) {
      const validArr = gen.let("valid", true);
      validateItems(() => gen.assign(validArr, false));
      return validArr;
    }
    gen.var(valid, true);
    validateItems(() => gen.break());
    return valid;
    function validateItems(notValid) {
      const len = gen.const("len", (0, codegen_1._)`${data2}.length`);
      gen.forRange("i", 0, len, (i) => {
        cxt.subschema({
          keyword: keyword2,
          dataProp: i,
          dataPropType: util_1.Type.Num
        }, valid);
        gen.if((0, codegen_1.not)(valid), notValid);
      });
    }
  }
  code$2.validateArray = validateArray;
  function validateUnion(cxt) {
    const { gen, schema, keyword: keyword2, it: it2 } = cxt;
    if (!Array.isArray(schema))
      throw new Error("ajv implementation error");
    const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it2, sch));
    if (alwaysValid && !it2.opts.unevaluated)
      return;
    const valid = gen.let("valid", false);
    const schValid = gen.name("_valid");
    gen.block(() => schema.forEach((_sch, i) => {
      const schCxt = cxt.subschema({
        keyword: keyword2,
        schemaProp: i,
        compositeRule: true
      }, schValid);
      gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
      const merged = cxt.mergeValidEvaluated(schCxt, schValid);
      if (!merged)
        gen.if((0, codegen_1.not)(valid));
    }));
    cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
  }
  code$2.validateUnion = validateUnion;
  return code$2;
}
var hasRequiredKeyword$1;
function requireKeyword$1() {
  if (hasRequiredKeyword$1) return keyword$1;
  hasRequiredKeyword$1 = 1;
  Object.defineProperty(keyword$1, "__esModule", { value: true });
  keyword$1.validateKeywordUsage = keyword$1.validSchemaType = keyword$1.funcKeywordCode = keyword$1.macroKeywordCode = void 0;
  const codegen_1 = /* @__PURE__ */ requireCodegen$1();
  const names_1 = /* @__PURE__ */ requireNames$1();
  const code_1 = /* @__PURE__ */ requireCode$2();
  const errors_1 = /* @__PURE__ */ requireErrors$1();
  function macroKeywordCode(cxt, def) {
    const { gen, keyword: keyword2, schema, parentSchema, it: it2 } = cxt;
    const macroSchema = def.macro.call(it2.self, schema, parentSchema, it2);
    const schemaRef = useKeyword(gen, keyword2, macroSchema);
    if (it2.opts.validateSchema !== false)
      it2.self.validateSchema(macroSchema, true);
    const valid = gen.name("valid");
    cxt.subschema({
      schema: macroSchema,
      schemaPath: codegen_1.nil,
      errSchemaPath: `${it2.errSchemaPath}/${keyword2}`,
      topSchemaRef: schemaRef,
      compositeRule: true
    }, valid);
    cxt.pass(valid, () => cxt.error(true));
  }
  keyword$1.macroKeywordCode = macroKeywordCode;
  function funcKeywordCode(cxt, def) {
    var _a2;
    const { gen, keyword: keyword2, schema, parentSchema, $data, it: it2 } = cxt;
    checkAsyncKeyword(it2, def);
    const validate2 = !$data && def.compile ? def.compile.call(it2.self, schema, parentSchema, it2) : def.validate;
    const validateRef = useKeyword(gen, keyword2, validate2);
    const valid = gen.let("valid");
    cxt.block$data(valid, validateKeyword);
    cxt.ok((_a2 = def.valid) !== null && _a2 !== void 0 ? _a2 : valid);
    function validateKeyword() {
      if (def.errors === false) {
        assignValid();
        if (def.modifying)
          modifyData(cxt);
        reportErrs(() => cxt.error());
      } else {
        const ruleErrs = def.async ? validateAsync() : validateSync();
        if (def.modifying)
          modifyData(cxt);
        reportErrs(() => addErrs(cxt, ruleErrs));
      }
    }
    function validateAsync() {
      const ruleErrs = gen.let("ruleErrs", null);
      gen.try(() => assignValid((0, codegen_1._)`await `), (e) => gen.assign(valid, false).if((0, codegen_1._)`${e} instanceof ${it2.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e)));
      return ruleErrs;
    }
    function validateSync() {
      const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
      gen.assign(validateErrs, null);
      assignValid(codegen_1.nil);
      return validateErrs;
    }
    function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
      const passCxt = it2.opts.passContext ? names_1.default.this : names_1.default.self;
      const passSchema = !("compile" in def && !$data || def.schema === false);
      gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
    }
    function reportErrs(errors2) {
      var _a3;
      gen.if((0, codegen_1.not)((_a3 = def.valid) !== null && _a3 !== void 0 ? _a3 : valid), errors2);
    }
  }
  keyword$1.funcKeywordCode = funcKeywordCode;
  function modifyData(cxt) {
    const { gen, data: data2, it: it2 } = cxt;
    gen.if(it2.parentData, () => gen.assign(data2, (0, codegen_1._)`${it2.parentData}[${it2.parentDataProperty}]`));
  }
  function addErrs(cxt, errs) {
    const { gen } = cxt;
    gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
      gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      (0, errors_1.extendErrors)(cxt);
    }, () => cxt.error());
  }
  function checkAsyncKeyword({ schemaEnv }, def) {
    if (def.async && !schemaEnv.$async)
      throw new Error("async keyword in sync schema");
  }
  function useKeyword(gen, keyword2, result) {
    if (result === void 0)
      throw new Error(`keyword "${keyword2}" failed to compile`);
    return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
  }
  function validSchemaType(schema, schemaType, allowUndefined = false) {
    return !schemaType.length || schemaType.some((st2) => st2 === "array" ? Array.isArray(schema) : st2 === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st2 || allowUndefined && typeof schema == "undefined");
  }
  keyword$1.validSchemaType = validSchemaType;
  function validateKeywordUsage({ schema, opts, self: self2, errSchemaPath }, def, keyword2) {
    if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword2) : def.keyword !== keyword2) {
      throw new Error("ajv implementation error");
    }
    const deps = def.dependencies;
    if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
      throw new Error(`parent schema must have dependencies of ${keyword2}: ${deps.join(",")}`);
    }
    if (def.validateSchema) {
      const valid = def.validateSchema(schema[keyword2]);
      if (!valid) {
        const msg = `keyword "${keyword2}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def.validateSchema.errors);
        if (opts.validateSchema === "log")
          self2.logger.error(msg);
        else
          throw new Error(msg);
      }
    }
  }
  keyword$1.validateKeywordUsage = validateKeywordUsage;
  return keyword$1;
}
var subschema$1 = {};
var hasRequiredSubschema$1;
function requireSubschema$1() {
  if (hasRequiredSubschema$1) return subschema$1;
  hasRequiredSubschema$1 = 1;
  Object.defineProperty(subschema$1, "__esModule", { value: true });
  subschema$1.extendSubschemaMode = subschema$1.extendSubschemaData = subschema$1.getSubschema = void 0;
  const codegen_1 = /* @__PURE__ */ requireCodegen$1();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  function getSubschema(it2, { keyword: keyword2, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
    if (keyword2 !== void 0 && schema !== void 0) {
      throw new Error('both "keyword" and "schema" passed, only one allowed');
    }
    if (keyword2 !== void 0) {
      const sch = it2.schema[keyword2];
      return schemaProp === void 0 ? {
        schema: sch,
        schemaPath: (0, codegen_1._)`${it2.schemaPath}${(0, codegen_1.getProperty)(keyword2)}`,
        errSchemaPath: `${it2.errSchemaPath}/${keyword2}`
      } : {
        schema: sch[schemaProp],
        schemaPath: (0, codegen_1._)`${it2.schemaPath}${(0, codegen_1.getProperty)(keyword2)}${(0, codegen_1.getProperty)(schemaProp)}`,
        errSchemaPath: `${it2.errSchemaPath}/${keyword2}/${(0, util_1.escapeFragment)(schemaProp)}`
      };
    }
    if (schema !== void 0) {
      if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
        throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
      }
      return {
        schema,
        schemaPath,
        topSchemaRef,
        errSchemaPath
      };
    }
    throw new Error('either "keyword" or "schema" must be passed');
  }
  subschema$1.getSubschema = getSubschema;
  function extendSubschemaData(subschema2, it2, { dataProp, dataPropType: dpType, data: data2, dataTypes, propertyName }) {
    if (data2 !== void 0 && dataProp !== void 0) {
      throw new Error('both "data" and "dataProp" passed, only one allowed');
    }
    const { gen } = it2;
    if (dataProp !== void 0) {
      const { errorPath, dataPathArr, opts } = it2;
      const nextData = gen.let("data", (0, codegen_1._)`${it2.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
      dataContextProps(nextData);
      subschema2.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
      subschema2.parentDataProperty = (0, codegen_1._)`${dataProp}`;
      subschema2.dataPathArr = [...dataPathArr, subschema2.parentDataProperty];
    }
    if (data2 !== void 0) {
      const nextData = data2 instanceof codegen_1.Name ? data2 : gen.let("data", data2, true);
      dataContextProps(nextData);
      if (propertyName !== void 0)
        subschema2.propertyName = propertyName;
    }
    if (dataTypes)
      subschema2.dataTypes = dataTypes;
    function dataContextProps(_nextData) {
      subschema2.data = _nextData;
      subschema2.dataLevel = it2.dataLevel + 1;
      subschema2.dataTypes = [];
      it2.definedProperties = /* @__PURE__ */ new Set();
      subschema2.parentData = it2.data;
      subschema2.dataNames = [...it2.dataNames, _nextData];
    }
  }
  subschema$1.extendSubschemaData = extendSubschemaData;
  function extendSubschemaMode(subschema2, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
    if (compositeRule !== void 0)
      subschema2.compositeRule = compositeRule;
    if (createErrors !== void 0)
      subschema2.createErrors = createErrors;
    if (allErrors !== void 0)
      subschema2.allErrors = allErrors;
    subschema2.jtdDiscriminator = jtdDiscriminator;
    subschema2.jtdMetadata = jtdMetadata;
  }
  subschema$1.extendSubschemaMode = extendSubschemaMode;
  return subschema$1;
}
var resolve$1 = {};
var jsonSchemaTraverse$1 = { exports: {} };
var hasRequiredJsonSchemaTraverse$1;
function requireJsonSchemaTraverse$1() {
  if (hasRequiredJsonSchemaTraverse$1) return jsonSchemaTraverse$1.exports;
  hasRequiredJsonSchemaTraverse$1 = 1;
  var traverse = jsonSchemaTraverse$1.exports = function(schema, opts, cb) {
    if (typeof opts == "function") {
      cb = opts;
      opts = {};
    }
    cb = opts.cb || cb;
    var pre = typeof cb == "function" ? cb : cb.pre || function() {
    };
    var post = cb.post || function() {
    };
    _traverse(opts, pre, post, schema, "", schema);
  };
  traverse.keywords = {
    additionalItems: true,
    items: true,
    contains: true,
    additionalProperties: true,
    propertyNames: true,
    not: true,
    if: true,
    then: true,
    else: true
  };
  traverse.arrayKeywords = {
    items: true,
    allOf: true,
    anyOf: true,
    oneOf: true
  };
  traverse.propsKeywords = {
    $defs: true,
    definitions: true,
    properties: true,
    patternProperties: true,
    dependencies: true
  };
  traverse.skipKeywords = {
    default: true,
    enum: true,
    const: true,
    required: true,
    maximum: true,
    minimum: true,
    exclusiveMaximum: true,
    exclusiveMinimum: true,
    multipleOf: true,
    maxLength: true,
    minLength: true,
    pattern: true,
    format: true,
    maxItems: true,
    minItems: true,
    uniqueItems: true,
    maxProperties: true,
    minProperties: true
  };
  function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
    if (schema && typeof schema == "object" && !Array.isArray(schema)) {
      pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      for (var key in schema) {
        var sch = schema[key];
        if (Array.isArray(sch)) {
          if (key in traverse.arrayKeywords) {
            for (var i = 0; i < sch.length; i++)
              _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
          }
        } else if (key in traverse.propsKeywords) {
          if (sch && typeof sch == "object") {
            for (var prop in sch)
              _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
          }
        } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
          _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
        }
      }
      post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    }
  }
  function escapeJsonPtr(str) {
    return str.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  return jsonSchemaTraverse$1.exports;
}
var hasRequiredResolve$1;
function requireResolve$1() {
  if (hasRequiredResolve$1) return resolve$1;
  hasRequiredResolve$1 = 1;
  Object.defineProperty(resolve$1, "__esModule", { value: true });
  resolve$1.getSchemaRefs = resolve$1.resolveUrl = resolve$1.normalizeId = resolve$1._getFullPath = resolve$1.getFullPath = resolve$1.inlineRef = void 0;
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const equal2 = requireFastDeepEqual();
  const traverse = requireJsonSchemaTraverse$1();
  const SIMPLE_INLINED = /* @__PURE__ */ new Set([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum",
    "const"
  ]);
  function inlineRef(schema, limit2 = true) {
    if (typeof schema == "boolean")
      return true;
    if (limit2 === true)
      return !hasRef(schema);
    if (!limit2)
      return false;
    return countKeys(schema) <= limit2;
  }
  resolve$1.inlineRef = inlineRef;
  const REF_KEYWORDS = /* @__PURE__ */ new Set([
    "$ref",
    "$recursiveRef",
    "$recursiveAnchor",
    "$dynamicRef",
    "$dynamicAnchor"
  ]);
  function hasRef(schema) {
    for (const key in schema) {
      if (REF_KEYWORDS.has(key))
        return true;
      const sch = schema[key];
      if (Array.isArray(sch) && sch.some(hasRef))
        return true;
      if (typeof sch == "object" && hasRef(sch))
        return true;
    }
    return false;
  }
  function countKeys(schema) {
    let count2 = 0;
    for (const key in schema) {
      if (key === "$ref")
        return Infinity;
      count2++;
      if (SIMPLE_INLINED.has(key))
        continue;
      if (typeof schema[key] == "object") {
        (0, util_1.eachItem)(schema[key], (sch) => count2 += countKeys(sch));
      }
      if (count2 === Infinity)
        return Infinity;
    }
    return count2;
  }
  function getFullPath(resolver, id2 = "", normalize) {
    if (normalize !== false)
      id2 = normalizeId(id2);
    const p2 = resolver.parse(id2);
    return _getFullPath(resolver, p2);
  }
  resolve$1.getFullPath = getFullPath;
  function _getFullPath(resolver, p2) {
    const serialized = resolver.serialize(p2);
    return serialized.split("#")[0] + "#";
  }
  resolve$1._getFullPath = _getFullPath;
  const TRAILING_SLASH_HASH = /#\/?$/;
  function normalizeId(id2) {
    return id2 ? id2.replace(TRAILING_SLASH_HASH, "") : "";
  }
  resolve$1.normalizeId = normalizeId;
  function resolveUrl(resolver, baseId, id2) {
    id2 = normalizeId(id2);
    return resolver.resolve(baseId, id2);
  }
  resolve$1.resolveUrl = resolveUrl;
  const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
  function getSchemaRefs(schema, baseId) {
    if (typeof schema == "boolean")
      return {};
    const { schemaId, uriResolver } = this.opts;
    const schId = normalizeId(schema[schemaId] || baseId);
    const baseIds = { "": schId };
    const pathPrefix = getFullPath(uriResolver, schId, false);
    const localRefs = {};
    const schemaRefs = /* @__PURE__ */ new Set();
    traverse(schema, { allKeys: true }, (sch, jsonPtr, _2, parentJsonPtr) => {
      if (parentJsonPtr === void 0)
        return;
      const fullPath = pathPrefix + jsonPtr;
      let innerBaseId = baseIds[parentJsonPtr];
      if (typeof sch[schemaId] == "string")
        innerBaseId = addRef.call(this, sch[schemaId]);
      addAnchor.call(this, sch.$anchor);
      addAnchor.call(this, sch.$dynamicAnchor);
      baseIds[jsonPtr] = innerBaseId;
      function addRef(ref2) {
        const _resolve = this.opts.uriResolver.resolve;
        ref2 = normalizeId(innerBaseId ? _resolve(innerBaseId, ref2) : ref2);
        if (schemaRefs.has(ref2))
          throw ambiguos(ref2);
        schemaRefs.add(ref2);
        let schOrRef = this.refs[ref2];
        if (typeof schOrRef == "string")
          schOrRef = this.refs[schOrRef];
        if (typeof schOrRef == "object") {
          checkAmbiguosRef(sch, schOrRef.schema, ref2);
        } else if (ref2 !== normalizeId(fullPath)) {
          if (ref2[0] === "#") {
            checkAmbiguosRef(sch, localRefs[ref2], ref2);
            localRefs[ref2] = sch;
          } else {
            this.refs[ref2] = fullPath;
          }
        }
        return ref2;
      }
      function addAnchor(anchor) {
        if (typeof anchor == "string") {
          if (!ANCHOR.test(anchor))
            throw new Error(`invalid anchor "${anchor}"`);
          addRef.call(this, `#${anchor}`);
        }
      }
    });
    return localRefs;
    function checkAmbiguosRef(sch1, sch2, ref2) {
      if (sch2 !== void 0 && !equal2(sch1, sch2))
        throw ambiguos(ref2);
    }
    function ambiguos(ref2) {
      return new Error(`reference "${ref2}" resolves to more than one schema`);
    }
  }
  resolve$1.getSchemaRefs = getSchemaRefs;
  return resolve$1;
}
var hasRequiredValidate$1;
function requireValidate$1() {
  if (hasRequiredValidate$1) return validate$1;
  hasRequiredValidate$1 = 1;
  Object.defineProperty(validate$1, "__esModule", { value: true });
  validate$1.getData = validate$1.KeywordCxt = validate$1.validateFunctionCode = void 0;
  const boolSchema_1 = /* @__PURE__ */ requireBoolSchema$1();
  const dataType_1 = /* @__PURE__ */ requireDataType$1();
  const applicability_1 = /* @__PURE__ */ requireApplicability$1();
  const dataType_2 = /* @__PURE__ */ requireDataType$1();
  const defaults_1 = /* @__PURE__ */ requireDefaults$1();
  const keyword_1 = /* @__PURE__ */ requireKeyword$1();
  const subschema_1 = /* @__PURE__ */ requireSubschema$1();
  const codegen_1 = /* @__PURE__ */ requireCodegen$1();
  const names_1 = /* @__PURE__ */ requireNames$1();
  const resolve_12 = /* @__PURE__ */ requireResolve$1();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const errors_1 = /* @__PURE__ */ requireErrors$1();
  function validateFunctionCode(it2) {
    if (isSchemaObj(it2)) {
      checkKeywords(it2);
      if (schemaCxtHasRules(it2)) {
        topSchemaObjCode(it2);
        return;
      }
    }
    validateFunction(it2, () => (0, boolSchema_1.topBoolOrEmptySchema)(it2));
  }
  validate$1.validateFunctionCode = validateFunctionCode;
  function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
    if (opts.code.es5) {
      gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
        gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
        destructureValCxtES5(gen, opts);
        gen.code(body);
      });
    } else {
      gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
    }
  }
  function destructureValCxt(opts) {
    return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
  }
  function destructureValCxtES5(gen, opts) {
    gen.if(names_1.default.valCxt, () => {
      gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
      gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
      gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
      gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
      if (opts.dynamicRef)
        gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
    }, () => {
      gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
      gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
      gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
      gen.var(names_1.default.rootData, names_1.default.data);
      if (opts.dynamicRef)
        gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
    });
  }
  function topSchemaObjCode(it2) {
    const { schema, opts, gen } = it2;
    validateFunction(it2, () => {
      if (opts.$comment && schema.$comment)
        commentKeyword(it2);
      checkNoDefault(it2);
      gen.let(names_1.default.vErrors, null);
      gen.let(names_1.default.errors, 0);
      if (opts.unevaluated)
        resetEvaluated(it2);
      typeAndKeywords(it2);
      returnResults(it2);
    });
    return;
  }
  function resetEvaluated(it2) {
    const { gen, validateName } = it2;
    it2.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
    gen.if((0, codegen_1._)`${it2.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it2.evaluated}.props`, (0, codegen_1._)`undefined`));
    gen.if((0, codegen_1._)`${it2.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it2.evaluated}.items`, (0, codegen_1._)`undefined`));
  }
  function funcSourceUrl(schema, opts) {
    const schId = typeof schema == "object" && schema[opts.schemaId];
    return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
  }
  function subschemaCode(it2, valid) {
    if (isSchemaObj(it2)) {
      checkKeywords(it2);
      if (schemaCxtHasRules(it2)) {
        subSchemaObjCode(it2, valid);
        return;
      }
    }
    (0, boolSchema_1.boolOrEmptySchema)(it2, valid);
  }
  function schemaCxtHasRules({ schema, self: self2 }) {
    if (typeof schema == "boolean")
      return !schema;
    for (const key in schema)
      if (self2.RULES.all[key])
        return true;
    return false;
  }
  function isSchemaObj(it2) {
    return typeof it2.schema != "boolean";
  }
  function subSchemaObjCode(it2, valid) {
    const { schema, gen, opts } = it2;
    if (opts.$comment && schema.$comment)
      commentKeyword(it2);
    updateContext(it2);
    checkAsyncSchema(it2);
    const errsCount = gen.const("_errs", names_1.default.errors);
    typeAndKeywords(it2, errsCount);
    gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
  }
  function checkKeywords(it2) {
    (0, util_1.checkUnknownRules)(it2);
    checkRefsAndKeywords(it2);
  }
  function typeAndKeywords(it2, errsCount) {
    if (it2.opts.jtd)
      return schemaKeywords(it2, [], false, errsCount);
    const types2 = (0, dataType_1.getSchemaTypes)(it2.schema);
    const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it2, types2);
    schemaKeywords(it2, types2, !checkedTypes, errsCount);
  }
  function checkRefsAndKeywords(it2) {
    const { schema, errSchemaPath, opts, self: self2 } = it2;
    if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self2.RULES)) {
      self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
    }
  }
  function checkNoDefault(it2) {
    const { schema, opts } = it2;
    if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
      (0, util_1.checkStrictMode)(it2, "default is ignored in the schema root");
    }
  }
  function updateContext(it2) {
    const schId = it2.schema[it2.opts.schemaId];
    if (schId)
      it2.baseId = (0, resolve_12.resolveUrl)(it2.opts.uriResolver, it2.baseId, schId);
  }
  function checkAsyncSchema(it2) {
    if (it2.schema.$async && !it2.schemaEnv.$async)
      throw new Error("async schema in sync schema");
  }
  function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
    const msg = schema.$comment;
    if (opts.$comment === true) {
      gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
    } else if (typeof opts.$comment == "function") {
      const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
      const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
      gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
    }
  }
  function returnResults(it2) {
    const { gen, schemaEnv, validateName, ValidationError, opts } = it2;
    if (schemaEnv.$async) {
      gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));
    } else {
      gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
      if (opts.unevaluated)
        assignEvaluated(it2);
      gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
    }
  }
  function assignEvaluated({ gen, evaluated, props, items: items2 }) {
    if (props instanceof codegen_1.Name)
      gen.assign((0, codegen_1._)`${evaluated}.props`, props);
    if (items2 instanceof codegen_1.Name)
      gen.assign((0, codegen_1._)`${evaluated}.items`, items2);
  }
  function schemaKeywords(it2, types2, typeErrors, errsCount) {
    const { gen, schema, data: data2, allErrors, opts, self: self2 } = it2;
    const { RULES } = self2;
    if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
      gen.block(() => keywordCode(it2, "$ref", RULES.all.$ref.definition));
      return;
    }
    if (!opts.jtd)
      checkStrictTypes(it2, types2);
    gen.block(() => {
      for (const group of RULES.rules)
        groupKeywords(group);
      groupKeywords(RULES.post);
    });
    function groupKeywords(group) {
      if (!(0, applicability_1.shouldUseGroup)(schema, group))
        return;
      if (group.type) {
        gen.if((0, dataType_2.checkDataType)(group.type, data2, opts.strictNumbers));
        iterateKeywords(it2, group);
        if (types2.length === 1 && types2[0] === group.type && typeErrors) {
          gen.else();
          (0, dataType_2.reportTypeError)(it2);
        }
        gen.endIf();
      } else {
        iterateKeywords(it2, group);
      }
      if (!allErrors)
        gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
    }
  }
  function iterateKeywords(it2, group) {
    const { gen, schema, opts: { useDefaults } } = it2;
    if (useDefaults)
      (0, defaults_1.assignDefaults)(it2, group.type);
    gen.block(() => {
      for (const rule of group.rules) {
        if ((0, applicability_1.shouldUseRule)(schema, rule)) {
          keywordCode(it2, rule.keyword, rule.definition, group.type);
        }
      }
    });
  }
  function checkStrictTypes(it2, types2) {
    if (it2.schemaEnv.meta || !it2.opts.strictTypes)
      return;
    checkContextTypes(it2, types2);
    if (!it2.opts.allowUnionTypes)
      checkMultipleTypes(it2, types2);
    checkKeywordTypes(it2, it2.dataTypes);
  }
  function checkContextTypes(it2, types2) {
    if (!types2.length)
      return;
    if (!it2.dataTypes.length) {
      it2.dataTypes = types2;
      return;
    }
    types2.forEach((t) => {
      if (!includesType(it2.dataTypes, t)) {
        strictTypesError(it2, `type "${t}" not allowed by context "${it2.dataTypes.join(",")}"`);
      }
    });
    narrowSchemaTypes(it2, types2);
  }
  function checkMultipleTypes(it2, ts2) {
    if (ts2.length > 1 && !(ts2.length === 2 && ts2.includes("null"))) {
      strictTypesError(it2, "use allowUnionTypes to allow union type keyword");
    }
  }
  function checkKeywordTypes(it2, ts2) {
    const rules2 = it2.self.RULES.all;
    for (const keyword2 in rules2) {
      const rule = rules2[keyword2];
      if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it2.schema, rule)) {
        const { type: type2 } = rule.definition;
        if (type2.length && !type2.some((t) => hasApplicableType(ts2, t))) {
          strictTypesError(it2, `missing type "${type2.join(",")}" for keyword "${keyword2}"`);
        }
      }
    }
  }
  function hasApplicableType(schTs, kwdT) {
    return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
  }
  function includesType(ts2, t) {
    return ts2.includes(t) || t === "integer" && ts2.includes("number");
  }
  function narrowSchemaTypes(it2, withTypes) {
    const ts2 = [];
    for (const t of it2.dataTypes) {
      if (includesType(withTypes, t))
        ts2.push(t);
      else if (withTypes.includes("integer") && t === "number")
        ts2.push("integer");
    }
    it2.dataTypes = ts2;
  }
  function strictTypesError(it2, msg) {
    const schemaPath = it2.schemaEnv.baseId + it2.errSchemaPath;
    msg += ` at "${schemaPath}" (strictTypes)`;
    (0, util_1.checkStrictMode)(it2, msg, it2.opts.strictTypes);
  }
  class KeywordCxt {
    constructor(it2, def, keyword2) {
      (0, keyword_1.validateKeywordUsage)(it2, def, keyword2);
      this.gen = it2.gen;
      this.allErrors = it2.allErrors;
      this.keyword = keyword2;
      this.data = it2.data;
      this.schema = it2.schema[keyword2];
      this.$data = def.$data && it2.opts.$data && this.schema && this.schema.$data;
      this.schemaValue = (0, util_1.schemaRefOrVal)(it2, this.schema, keyword2, this.$data);
      this.schemaType = def.schemaType;
      this.parentSchema = it2.schema;
      this.params = {};
      this.it = it2;
      this.def = def;
      if (this.$data) {
        this.schemaCode = it2.gen.const("vSchema", getData(this.$data, it2));
      } else {
        this.schemaCode = this.schemaValue;
        if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
          throw new Error(`${keyword2} value must be ${JSON.stringify(def.schemaType)}`);
        }
      }
      if ("code" in def ? def.trackErrors : def.errors !== false) {
        this.errsCount = it2.gen.const("_errs", names_1.default.errors);
      }
    }
    result(condition, successAction, failAction) {
      this.failResult((0, codegen_1.not)(condition), successAction, failAction);
    }
    failResult(condition, successAction, failAction) {
      this.gen.if(condition);
      if (failAction)
        failAction();
      else
        this.error();
      if (successAction) {
        this.gen.else();
        successAction();
        if (this.allErrors)
          this.gen.endIf();
      } else {
        if (this.allErrors)
          this.gen.endIf();
        else
          this.gen.else();
      }
    }
    pass(condition, failAction) {
      this.failResult((0, codegen_1.not)(condition), void 0, failAction);
    }
    fail(condition) {
      if (condition === void 0) {
        this.error();
        if (!this.allErrors)
          this.gen.if(false);
        return;
      }
      this.gen.if(condition);
      this.error();
      if (this.allErrors)
        this.gen.endIf();
      else
        this.gen.else();
    }
    fail$data(condition) {
      if (!this.$data)
        return this.fail(condition);
      const { schemaCode } = this;
      this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
    }
    error(append, errorParams, errorPaths) {
      if (errorParams) {
        this.setParams(errorParams);
        this._error(append, errorPaths);
        this.setParams({});
        return;
      }
      this._error(append, errorPaths);
    }
    _error(append, errorPaths) {
      (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
    }
    $dataError() {
      (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
    }
    reset() {
      if (this.errsCount === void 0)
        throw new Error('add "trackErrors" to keyword definition');
      (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
    }
    ok(cond) {
      if (!this.allErrors)
        this.gen.if(cond);
    }
    setParams(obj, assign) {
      if (assign)
        Object.assign(this.params, obj);
      else
        this.params = obj;
    }
    block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
      this.gen.block(() => {
        this.check$data(valid, $dataValid);
        codeBlock();
      });
    }
    check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
      if (!this.$data)
        return;
      const { gen, schemaCode, schemaType, def } = this;
      gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
      if (valid !== codegen_1.nil)
        gen.assign(valid, true);
      if (schemaType.length || def.validateSchema) {
        gen.elseIf(this.invalid$data());
        this.$dataError();
        if (valid !== codegen_1.nil)
          gen.assign(valid, false);
      }
      gen.else();
    }
    invalid$data() {
      const { gen, schemaCode, schemaType, def, it: it2 } = this;
      return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
      function wrong$DataType() {
        if (schemaType.length) {
          if (!(schemaCode instanceof codegen_1.Name))
            throw new Error("ajv implementation error");
          const st2 = Array.isArray(schemaType) ? schemaType : [schemaType];
          return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st2, schemaCode, it2.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
        }
        return codegen_1.nil;
      }
      function invalid$DataSchema() {
        if (def.validateSchema) {
          const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema });
          return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
        }
        return codegen_1.nil;
      }
    }
    subschema(appl, valid) {
      const subschema2 = (0, subschema_1.getSubschema)(this.it, appl);
      (0, subschema_1.extendSubschemaData)(subschema2, this.it, appl);
      (0, subschema_1.extendSubschemaMode)(subschema2, appl);
      const nextContext = { ...this.it, ...subschema2, items: void 0, props: void 0 };
      subschemaCode(nextContext, valid);
      return nextContext;
    }
    mergeEvaluated(schemaCxt, toName) {
      const { it: it2, gen } = this;
      if (!it2.opts.unevaluated)
        return;
      if (it2.props !== true && schemaCxt.props !== void 0) {
        it2.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it2.props, toName);
      }
      if (it2.items !== true && schemaCxt.items !== void 0) {
        it2.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it2.items, toName);
      }
    }
    mergeValidEvaluated(schemaCxt, valid) {
      const { it: it2, gen } = this;
      if (it2.opts.unevaluated && (it2.props !== true || it2.items !== true)) {
        gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
        return true;
      }
    }
  }
  validate$1.KeywordCxt = KeywordCxt;
  function keywordCode(it2, keyword2, def, ruleType) {
    const cxt = new KeywordCxt(it2, def, keyword2);
    if ("code" in def) {
      def.code(cxt, ruleType);
    } else if (cxt.$data && def.validate) {
      (0, keyword_1.funcKeywordCode)(cxt, def);
    } else if ("macro" in def) {
      (0, keyword_1.macroKeywordCode)(cxt, def);
    } else if (def.compile || def.validate) {
      (0, keyword_1.funcKeywordCode)(cxt, def);
    }
  }
  const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
  const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
  function getData($data, { dataLevel, dataNames, dataPathArr }) {
    let jsonPointer;
    let data2;
    if ($data === "")
      return names_1.default.rootData;
    if ($data[0] === "/") {
      if (!JSON_POINTER.test($data))
        throw new Error(`Invalid JSON-pointer: ${$data}`);
      jsonPointer = $data;
      data2 = names_1.default.rootData;
    } else {
      const matches = RELATIVE_JSON_POINTER.exec($data);
      if (!matches)
        throw new Error(`Invalid JSON-pointer: ${$data}`);
      const up2 = +matches[1];
      jsonPointer = matches[2];
      if (jsonPointer === "#") {
        if (up2 >= dataLevel)
          throw new Error(errorMsg("property/index", up2));
        return dataPathArr[dataLevel - up2];
      }
      if (up2 > dataLevel)
        throw new Error(errorMsg("data", up2));
      data2 = dataNames[dataLevel - up2];
      if (!jsonPointer)
        return data2;
    }
    let expr = data2;
    const segments = jsonPointer.split("/");
    for (const segment of segments) {
      if (segment) {
        data2 = (0, codegen_1._)`${data2}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
        expr = (0, codegen_1._)`${expr} && ${data2}`;
      }
    }
    return expr;
    function errorMsg(pointerType, up2) {
      return `Cannot access ${pointerType} ${up2} levels up, current level is ${dataLevel}`;
    }
  }
  validate$1.getData = getData;
  return validate$1;
}
var validation_error$1 = {};
var hasRequiredValidation_error$1;
function requireValidation_error$1() {
  if (hasRequiredValidation_error$1) return validation_error$1;
  hasRequiredValidation_error$1 = 1;
  Object.defineProperty(validation_error$1, "__esModule", { value: true });
  class ValidationError extends Error {
    constructor(errors2) {
      super("validation failed");
      this.errors = errors2;
      this.ajv = this.validation = true;
    }
  }
  validation_error$1.default = ValidationError;
  return validation_error$1;
}
var ref_error$1 = {};
var hasRequiredRef_error$1;
function requireRef_error$1() {
  if (hasRequiredRef_error$1) return ref_error$1;
  hasRequiredRef_error$1 = 1;
  Object.defineProperty(ref_error$1, "__esModule", { value: true });
  const resolve_12 = /* @__PURE__ */ requireResolve$1();
  class MissingRefError extends Error {
    constructor(resolver, baseId, ref2, msg) {
      super(msg || `can't resolve reference ${ref2} from id ${baseId}`);
      this.missingRef = (0, resolve_12.resolveUrl)(resolver, baseId, ref2);
      this.missingSchema = (0, resolve_12.normalizeId)((0, resolve_12.getFullPath)(resolver, this.missingRef));
    }
  }
  ref_error$1.default = MissingRefError;
  return ref_error$1;
}
var compile$1 = {};
var hasRequiredCompile$1;
function requireCompile$1() {
  if (hasRequiredCompile$1) return compile$1;
  hasRequiredCompile$1 = 1;
  Object.defineProperty(compile$1, "__esModule", { value: true });
  compile$1.resolveSchema = compile$1.getCompilingSchema = compile$1.resolveRef = compile$1.compileSchema = compile$1.SchemaEnv = void 0;
  const codegen_1 = /* @__PURE__ */ requireCodegen$1();
  const validation_error_1 = /* @__PURE__ */ requireValidation_error$1();
  const names_1 = /* @__PURE__ */ requireNames$1();
  const resolve_12 = /* @__PURE__ */ requireResolve$1();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const validate_1 = /* @__PURE__ */ requireValidate$1();
  class SchemaEnv {
    constructor(env) {
      var _a2;
      this.refs = {};
      this.dynamicAnchors = {};
      let schema;
      if (typeof env.schema == "object")
        schema = env.schema;
      this.schema = env.schema;
      this.schemaId = env.schemaId;
      this.root = env.root || this;
      this.baseId = (_a2 = env.baseId) !== null && _a2 !== void 0 ? _a2 : (0, resolve_12.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
      this.schemaPath = env.schemaPath;
      this.localRefs = env.localRefs;
      this.meta = env.meta;
      this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
      this.refs = {};
    }
  }
  compile$1.SchemaEnv = SchemaEnv;
  function compileSchema(sch) {
    const _sch = getCompilingSchema.call(this, sch);
    if (_sch)
      return _sch;
    const rootId = (0, resolve_12.getFullPath)(this.opts.uriResolver, sch.root.baseId);
    const { es5, lines } = this.opts.code;
    const { ownProperties } = this.opts;
    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
    let _ValidationError;
    if (sch.$async) {
      _ValidationError = gen.scopeValue("Error", {
        ref: validation_error_1.default,
        code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
      });
    }
    const validateName = gen.scopeName("validate");
    sch.validateName = validateName;
    const schemaCxt = {
      gen,
      allErrors: this.opts.allErrors,
      data: names_1.default.data,
      parentData: names_1.default.parentData,
      parentDataProperty: names_1.default.parentDataProperty,
      dataNames: [names_1.default.data],
      dataPathArr: [codegen_1.nil],
      // TODO can its length be used as dataLevel if nil is removed?
      dataLevel: 0,
      dataTypes: [],
      definedProperties: /* @__PURE__ */ new Set(),
      topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
      validateName,
      ValidationError: _ValidationError,
      schema: sch.schema,
      schemaEnv: sch,
      rootId,
      baseId: sch.baseId || rootId,
      schemaPath: codegen_1.nil,
      errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
      errorPath: (0, codegen_1._)`""`,
      opts: this.opts,
      self: this
    };
    let sourceCode;
    try {
      this._compilations.add(sch);
      (0, validate_1.validateFunctionCode)(schemaCxt);
      gen.optimize(this.opts.code.optimize);
      const validateCode = gen.toString();
      sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
      if (this.opts.code.process)
        sourceCode = this.opts.code.process(sourceCode, sch);
      const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
      const validate2 = makeValidate(this, this.scope.get());
      this.scope.value(validateName, { ref: validate2 });
      validate2.errors = null;
      validate2.schema = sch.schema;
      validate2.schemaEnv = sch;
      if (sch.$async)
        validate2.$async = true;
      if (this.opts.code.source === true) {
        validate2.source = { validateName, validateCode, scopeValues: gen._values };
      }
      if (this.opts.unevaluated) {
        const { props, items: items2 } = schemaCxt;
        validate2.evaluated = {
          props: props instanceof codegen_1.Name ? void 0 : props,
          items: items2 instanceof codegen_1.Name ? void 0 : items2,
          dynamicProps: props instanceof codegen_1.Name,
          dynamicItems: items2 instanceof codegen_1.Name
        };
        if (validate2.source)
          validate2.source.evaluated = (0, codegen_1.stringify)(validate2.evaluated);
      }
      sch.validate = validate2;
      return sch;
    } catch (e) {
      delete sch.validate;
      delete sch.validateName;
      if (sourceCode)
        this.logger.error("Error compiling schema, function code:", sourceCode);
      throw e;
    } finally {
      this._compilations.delete(sch);
    }
  }
  compile$1.compileSchema = compileSchema;
  function resolveRef2(root, baseId, ref2) {
    var _a2;
    ref2 = (0, resolve_12.resolveUrl)(this.opts.uriResolver, baseId, ref2);
    const schOrFunc = root.refs[ref2];
    if (schOrFunc)
      return schOrFunc;
    let _sch = resolve2.call(this, root, ref2);
    if (_sch === void 0) {
      const schema = (_a2 = root.localRefs) === null || _a2 === void 0 ? void 0 : _a2[ref2];
      const { schemaId } = this.opts;
      if (schema)
        _sch = new SchemaEnv({ schema, schemaId, root, baseId });
    }
    if (_sch === void 0)
      return;
    return root.refs[ref2] = inlineOrCompile.call(this, _sch);
  }
  compile$1.resolveRef = resolveRef2;
  function inlineOrCompile(sch) {
    if ((0, resolve_12.inlineRef)(sch.schema, this.opts.inlineRefs))
      return sch.schema;
    return sch.validate ? sch : compileSchema.call(this, sch);
  }
  function getCompilingSchema(schEnv) {
    for (const sch of this._compilations) {
      if (sameSchemaEnv(sch, schEnv))
        return sch;
    }
  }
  compile$1.getCompilingSchema = getCompilingSchema;
  function sameSchemaEnv(s1, s2) {
    return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
  }
  function resolve2(root, ref2) {
    let sch;
    while (typeof (sch = this.refs[ref2]) == "string")
      ref2 = sch;
    return sch || this.schemas[ref2] || resolveSchema.call(this, root, ref2);
  }
  function resolveSchema(root, ref2) {
    const p2 = this.opts.uriResolver.parse(ref2);
    const refPath = (0, resolve_12._getFullPath)(this.opts.uriResolver, p2);
    let baseId = (0, resolve_12.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
    if (Object.keys(root.schema).length > 0 && refPath === baseId) {
      return getJsonPointer.call(this, p2, root);
    }
    const id2 = (0, resolve_12.normalizeId)(refPath);
    const schOrRef = this.refs[id2] || this.schemas[id2];
    if (typeof schOrRef == "string") {
      const sch = resolveSchema.call(this, root, schOrRef);
      if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
        return;
      return getJsonPointer.call(this, p2, sch);
    }
    if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
      return;
    if (!schOrRef.validate)
      compileSchema.call(this, schOrRef);
    if (id2 === (0, resolve_12.normalizeId)(ref2)) {
      const { schema } = schOrRef;
      const { schemaId } = this.opts;
      const schId = schema[schemaId];
      if (schId)
        baseId = (0, resolve_12.resolveUrl)(this.opts.uriResolver, baseId, schId);
      return new SchemaEnv({ schema, schemaId, root, baseId });
    }
    return getJsonPointer.call(this, p2, schOrRef);
  }
  compile$1.resolveSchema = resolveSchema;
  const PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
    "properties",
    "patternProperties",
    "enum",
    "dependencies",
    "definitions"
  ]);
  function getJsonPointer(parsedRef, { baseId, schema, root }) {
    var _a2;
    if (((_a2 = parsedRef.fragment) === null || _a2 === void 0 ? void 0 : _a2[0]) !== "/")
      return;
    for (const part of parsedRef.fragment.slice(1).split("/")) {
      if (typeof schema === "boolean")
        return;
      const partSchema = schema[(0, util_1.unescapeFragment)(part)];
      if (partSchema === void 0)
        return;
      schema = partSchema;
      const schId = typeof schema === "object" && schema[this.opts.schemaId];
      if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
        baseId = (0, resolve_12.resolveUrl)(this.opts.uriResolver, baseId, schId);
      }
    }
    let env;
    if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
      const $ref = (0, resolve_12.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
      env = resolveSchema.call(this, root, $ref);
    }
    const { schemaId } = this.opts;
    env = env || new SchemaEnv({ schema, schemaId, root, baseId });
    if (env.schema !== env.root.schema)
      return env;
    return void 0;
  }
  return compile$1;
}
const $id$3 = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
const description$1 = "Meta-schema for $data reference (JSON AnySchema extension proposal)";
const type$3 = "object";
const required$3 = ["$data"];
const properties$5 = { "$data": { "type": "string", "anyOf": [{ "format": "relative-json-pointer" }, { "format": "json-pointer" }] } };
const additionalProperties$3 = false;
const require$$9$1 = {
  $id: $id$3,
  description: description$1,
  type: type$3,
  required: required$3,
  properties: properties$5,
  additionalProperties: additionalProperties$3
};
var uri$1 = {};
var fastUri = { exports: {} };
var utils;
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  const isUUID = RegExp.prototype.test.bind(/^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu);
  const isIPv4 = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u);
  function stringArrayToHexStripped(input) {
    let acc = "";
    let code2 = 0;
    let i = 0;
    for (i = 0; i < input.length; i++) {
      code2 = input[i].charCodeAt(0);
      if (code2 === 48) {
        continue;
      }
      if (!(code2 >= 48 && code2 <= 57 || code2 >= 65 && code2 <= 70 || code2 >= 97 && code2 <= 102)) {
        return "";
      }
      acc += input[i];
      break;
    }
    for (i += 1; i < input.length; i++) {
      code2 = input[i].charCodeAt(0);
      if (!(code2 >= 48 && code2 <= 57 || code2 >= 65 && code2 <= 70 || code2 >= 97 && code2 <= 102)) {
        return "";
      }
      acc += input[i];
    }
    return acc;
  }
  const nonSimpleDomain = RegExp.prototype.test.bind(/[^!"$&'()*+,\-.;=_`a-z{}~]/u);
  function consumeIsZone(buffer) {
    buffer.length = 0;
    return true;
  }
  function consumeHextets(buffer, address, output) {
    if (buffer.length) {
      const hex = stringArrayToHexStripped(buffer);
      if (hex !== "") {
        address.push(hex);
      } else {
        output.error = true;
        return false;
      }
      buffer.length = 0;
    }
    return true;
  }
  function getIPV6(input) {
    let tokenCount = 0;
    const output = { error: false, address: "", zone: "" };
    const address = [];
    const buffer = [];
    let endipv6Encountered = false;
    let endIpv6 = false;
    let consume = consumeHextets;
    for (let i = 0; i < input.length; i++) {
      const cursor = input[i];
      if (cursor === "[" || cursor === "]") {
        continue;
      }
      if (cursor === ":") {
        if (endipv6Encountered === true) {
          endIpv6 = true;
        }
        if (!consume(buffer, address, output)) {
          break;
        }
        if (++tokenCount > 7) {
          output.error = true;
          break;
        }
        if (i > 0 && input[i - 1] === ":") {
          endipv6Encountered = true;
        }
        address.push(":");
        continue;
      } else if (cursor === "%") {
        if (!consume(buffer, address, output)) {
          break;
        }
        consume = consumeIsZone;
      } else {
        buffer.push(cursor);
        continue;
      }
    }
    if (buffer.length) {
      if (consume === consumeIsZone) {
        output.zone = buffer.join("");
      } else if (endIpv6) {
        address.push(buffer.join(""));
      } else {
        address.push(stringArrayToHexStripped(buffer));
      }
    }
    output.address = address.join("");
    return output;
  }
  function normalizeIPv6(host) {
    if (findToken(host, ":") < 2) {
      return { host, isIPV6: false };
    }
    const ipv62 = getIPV6(host);
    if (!ipv62.error) {
      let newHost = ipv62.address;
      let escapedHost = ipv62.address;
      if (ipv62.zone) {
        newHost += "%" + ipv62.zone;
        escapedHost += "%25" + ipv62.zone;
      }
      return { host: newHost, isIPV6: true, escapedHost };
    } else {
      return { host, isIPV6: false };
    }
  }
  function findToken(str, token) {
    let ind = 0;
    for (let i = 0; i < str.length; i++) {
      if (str[i] === token) ind++;
    }
    return ind;
  }
  function removeDotSegments(path) {
    let input = path;
    const output = [];
    let nextSlash = -1;
    let len = 0;
    while (len = input.length) {
      if (len === 1) {
        if (input === ".") {
          break;
        } else if (input === "/") {
          output.push("/");
          break;
        } else {
          output.push(input);
          break;
        }
      } else if (len === 2) {
        if (input[0] === ".") {
          if (input[1] === ".") {
            break;
          } else if (input[1] === "/") {
            input = input.slice(2);
            continue;
          }
        } else if (input[0] === "/") {
          if (input[1] === "." || input[1] === "/") {
            output.push("/");
            break;
          }
        }
      } else if (len === 3) {
        if (input === "/..") {
          if (output.length !== 0) {
            output.pop();
          }
          output.push("/");
          break;
        }
      }
      if (input[0] === ".") {
        if (input[1] === ".") {
          if (input[2] === "/") {
            input = input.slice(3);
            continue;
          }
        } else if (input[1] === "/") {
          input = input.slice(2);
          continue;
        }
      } else if (input[0] === "/") {
        if (input[1] === ".") {
          if (input[2] === "/") {
            input = input.slice(2);
            continue;
          } else if (input[2] === ".") {
            if (input[3] === "/") {
              input = input.slice(3);
              if (output.length !== 0) {
                output.pop();
              }
              continue;
            }
          }
        }
      }
      if ((nextSlash = input.indexOf("/", 1)) === -1) {
        output.push(input);
        break;
      } else {
        output.push(input.slice(0, nextSlash));
        input = input.slice(nextSlash);
      }
    }
    return output.join("");
  }
  function normalizeComponentEncoding(component, esc2) {
    const func = esc2 !== true ? escape : unescape;
    if (component.scheme !== void 0) {
      component.scheme = func(component.scheme);
    }
    if (component.userinfo !== void 0) {
      component.userinfo = func(component.userinfo);
    }
    if (component.host !== void 0) {
      component.host = func(component.host);
    }
    if (component.path !== void 0) {
      component.path = func(component.path);
    }
    if (component.query !== void 0) {
      component.query = func(component.query);
    }
    if (component.fragment !== void 0) {
      component.fragment = func(component.fragment);
    }
    return component;
  }
  function recomposeAuthority(component) {
    const uriTokens = [];
    if (component.userinfo !== void 0) {
      uriTokens.push(component.userinfo);
      uriTokens.push("@");
    }
    if (component.host !== void 0) {
      let host = unescape(component.host);
      if (!isIPv4(host)) {
        const ipV6res = normalizeIPv6(host);
        if (ipV6res.isIPV6 === true) {
          host = `[${ipV6res.escapedHost}]`;
        } else {
          host = component.host;
        }
      }
      uriTokens.push(host);
    }
    if (typeof component.port === "number" || typeof component.port === "string") {
      uriTokens.push(":");
      uriTokens.push(String(component.port));
    }
    return uriTokens.length ? uriTokens.join("") : void 0;
  }
  utils = {
    nonSimpleDomain,
    recomposeAuthority,
    normalizeComponentEncoding,
    removeDotSegments,
    isIPv4,
    isUUID,
    normalizeIPv6,
    stringArrayToHexStripped
  };
  return utils;
}
var schemes;
var hasRequiredSchemes;
function requireSchemes() {
  if (hasRequiredSchemes) return schemes;
  hasRequiredSchemes = 1;
  const { isUUID } = requireUtils();
  const URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
  const supportedSchemeNames = (
    /** @type {const} */
    [
      "http",
      "https",
      "ws",
      "wss",
      "urn",
      "urn:uuid"
    ]
  );
  function isValidSchemeName(name2) {
    return supportedSchemeNames.indexOf(
      /** @type {*} */
      name2
    ) !== -1;
  }
  function wsIsSecure(wsComponent) {
    if (wsComponent.secure === true) {
      return true;
    } else if (wsComponent.secure === false) {
      return false;
    } else if (wsComponent.scheme) {
      return wsComponent.scheme.length === 3 && (wsComponent.scheme[0] === "w" || wsComponent.scheme[0] === "W") && (wsComponent.scheme[1] === "s" || wsComponent.scheme[1] === "S") && (wsComponent.scheme[2] === "s" || wsComponent.scheme[2] === "S");
    } else {
      return false;
    }
  }
  function httpParse(component) {
    if (!component.host) {
      component.error = component.error || "HTTP URIs must have a host.";
    }
    return component;
  }
  function httpSerialize(component) {
    const secure = String(component.scheme).toLowerCase() === "https";
    if (component.port === (secure ? 443 : 80) || component.port === "") {
      component.port = void 0;
    }
    if (!component.path) {
      component.path = "/";
    }
    return component;
  }
  function wsParse(wsComponent) {
    wsComponent.secure = wsIsSecure(wsComponent);
    wsComponent.resourceName = (wsComponent.path || "/") + (wsComponent.query ? "?" + wsComponent.query : "");
    wsComponent.path = void 0;
    wsComponent.query = void 0;
    return wsComponent;
  }
  function wsSerialize(wsComponent) {
    if (wsComponent.port === (wsIsSecure(wsComponent) ? 443 : 80) || wsComponent.port === "") {
      wsComponent.port = void 0;
    }
    if (typeof wsComponent.secure === "boolean") {
      wsComponent.scheme = wsComponent.secure ? "wss" : "ws";
      wsComponent.secure = void 0;
    }
    if (wsComponent.resourceName) {
      const [path, query] = wsComponent.resourceName.split("?");
      wsComponent.path = path && path !== "/" ? path : void 0;
      wsComponent.query = query;
      wsComponent.resourceName = void 0;
    }
    wsComponent.fragment = void 0;
    return wsComponent;
  }
  function urnParse(urnComponent, options) {
    if (!urnComponent.path) {
      urnComponent.error = "URN can not be parsed";
      return urnComponent;
    }
    const matches = urnComponent.path.match(URN_REG);
    if (matches) {
      const scheme = options.scheme || urnComponent.scheme || "urn";
      urnComponent.nid = matches[1].toLowerCase();
      urnComponent.nss = matches[2];
      const urnScheme = `${scheme}:${options.nid || urnComponent.nid}`;
      const schemeHandler = getSchemeHandler(urnScheme);
      urnComponent.path = void 0;
      if (schemeHandler) {
        urnComponent = schemeHandler.parse(urnComponent, options);
      }
    } else {
      urnComponent.error = urnComponent.error || "URN can not be parsed.";
    }
    return urnComponent;
  }
  function urnSerialize(urnComponent, options) {
    if (urnComponent.nid === void 0) {
      throw new Error("URN without nid cannot be serialized");
    }
    const scheme = options.scheme || urnComponent.scheme || "urn";
    const nid = urnComponent.nid.toLowerCase();
    const urnScheme = `${scheme}:${options.nid || nid}`;
    const schemeHandler = getSchemeHandler(urnScheme);
    if (schemeHandler) {
      urnComponent = schemeHandler.serialize(urnComponent, options);
    }
    const uriComponent = urnComponent;
    const nss = urnComponent.nss;
    uriComponent.path = `${nid || options.nid}:${nss}`;
    options.skipEscape = true;
    return uriComponent;
  }
  function urnuuidParse(urnComponent, options) {
    const uuidComponent = urnComponent;
    uuidComponent.uuid = uuidComponent.nss;
    uuidComponent.nss = void 0;
    if (!options.tolerant && (!uuidComponent.uuid || !isUUID(uuidComponent.uuid))) {
      uuidComponent.error = uuidComponent.error || "UUID is not valid.";
    }
    return uuidComponent;
  }
  function urnuuidSerialize(uuidComponent) {
    const urnComponent = uuidComponent;
    urnComponent.nss = (uuidComponent.uuid || "").toLowerCase();
    return urnComponent;
  }
  const http = (
    /** @type {SchemeHandler} */
    {
      scheme: "http",
      domainHost: true,
      parse: httpParse,
      serialize: httpSerialize
    }
  );
  const https = (
    /** @type {SchemeHandler} */
    {
      scheme: "https",
      domainHost: http.domainHost,
      parse: httpParse,
      serialize: httpSerialize
    }
  );
  const ws2 = (
    /** @type {SchemeHandler} */
    {
      scheme: "ws",
      domainHost: true,
      parse: wsParse,
      serialize: wsSerialize
    }
  );
  const wss = (
    /** @type {SchemeHandler} */
    {
      scheme: "wss",
      domainHost: ws2.domainHost,
      parse: ws2.parse,
      serialize: ws2.serialize
    }
  );
  const urn = (
    /** @type {SchemeHandler} */
    {
      scheme: "urn",
      parse: urnParse,
      serialize: urnSerialize,
      skipNormalize: true
    }
  );
  const urnuuid = (
    /** @type {SchemeHandler} */
    {
      scheme: "urn:uuid",
      parse: urnuuidParse,
      serialize: urnuuidSerialize,
      skipNormalize: true
    }
  );
  const SCHEMES = (
    /** @type {Record<SchemeName, SchemeHandler>} */
    {
      http,
      https,
      ws: ws2,
      wss,
      urn,
      "urn:uuid": urnuuid
    }
  );
  Object.setPrototypeOf(SCHEMES, null);
  function getSchemeHandler(scheme) {
    return scheme && (SCHEMES[
      /** @type {SchemeName} */
      scheme
    ] || SCHEMES[
      /** @type {SchemeName} */
      scheme.toLowerCase()
    ]) || void 0;
  }
  schemes = {
    wsIsSecure,
    SCHEMES,
    isValidSchemeName,
    getSchemeHandler
  };
  return schemes;
}
var hasRequiredFastUri;
function requireFastUri() {
  if (hasRequiredFastUri) return fastUri.exports;
  hasRequiredFastUri = 1;
  const { normalizeIPv6, removeDotSegments, recomposeAuthority, normalizeComponentEncoding, isIPv4, nonSimpleDomain } = requireUtils();
  const { SCHEMES, getSchemeHandler } = requireSchemes();
  function normalize(uri2, options) {
    if (typeof uri2 === "string") {
      uri2 = /** @type {T} */
      serialize(parse2(uri2, options), options);
    } else if (typeof uri2 === "object") {
      uri2 = /** @type {T} */
      parse2(serialize(uri2, options), options);
    }
    return uri2;
  }
  function resolve2(baseURI, relativeURI, options) {
    const schemelessOptions = options ? Object.assign({ scheme: "null" }, options) : { scheme: "null" };
    const resolved = resolveComponent(parse2(baseURI, schemelessOptions), parse2(relativeURI, schemelessOptions), schemelessOptions, true);
    schemelessOptions.skipEscape = true;
    return serialize(resolved, schemelessOptions);
  }
  function resolveComponent(base, relative, options, skipNormalization) {
    const target = {};
    if (!skipNormalization) {
      base = parse2(serialize(base, options), options);
      relative = parse2(serialize(relative, options), options);
    }
    options = options || {};
    if (!options.tolerant && relative.scheme) {
      target.scheme = relative.scheme;
      target.userinfo = relative.userinfo;
      target.host = relative.host;
      target.port = relative.port;
      target.path = removeDotSegments(relative.path || "");
      target.query = relative.query;
    } else {
      if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
      } else {
        if (!relative.path) {
          target.path = base.path;
          if (relative.query !== void 0) {
            target.query = relative.query;
          } else {
            target.query = base.query;
          }
        } else {
          if (relative.path[0] === "/") {
            target.path = removeDotSegments(relative.path);
          } else {
            if ((base.userinfo !== void 0 || base.host !== void 0 || base.port !== void 0) && !base.path) {
              target.path = "/" + relative.path;
            } else if (!base.path) {
              target.path = relative.path;
            } else {
              target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
            }
            target.path = removeDotSegments(target.path);
          }
          target.query = relative.query;
        }
        target.userinfo = base.userinfo;
        target.host = base.host;
        target.port = base.port;
      }
      target.scheme = base.scheme;
    }
    target.fragment = relative.fragment;
    return target;
  }
  function equal2(uriA, uriB, options) {
    if (typeof uriA === "string") {
      uriA = unescape(uriA);
      uriA = serialize(normalizeComponentEncoding(parse2(uriA, options), true), { ...options, skipEscape: true });
    } else if (typeof uriA === "object") {
      uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true });
    }
    if (typeof uriB === "string") {
      uriB = unescape(uriB);
      uriB = serialize(normalizeComponentEncoding(parse2(uriB, options), true), { ...options, skipEscape: true });
    } else if (typeof uriB === "object") {
      uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true });
    }
    return uriA.toLowerCase() === uriB.toLowerCase();
  }
  function serialize(cmpts, opts) {
    const component = {
      host: cmpts.host,
      scheme: cmpts.scheme,
      userinfo: cmpts.userinfo,
      port: cmpts.port,
      path: cmpts.path,
      query: cmpts.query,
      nid: cmpts.nid,
      nss: cmpts.nss,
      uuid: cmpts.uuid,
      fragment: cmpts.fragment,
      reference: cmpts.reference,
      resourceName: cmpts.resourceName,
      secure: cmpts.secure,
      error: ""
    };
    const options = Object.assign({}, opts);
    const uriTokens = [];
    const schemeHandler = getSchemeHandler(options.scheme || component.scheme);
    if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(component, options);
    if (component.path !== void 0) {
      if (!options.skipEscape) {
        component.path = escape(component.path);
        if (component.scheme !== void 0) {
          component.path = component.path.split("%3A").join(":");
        }
      } else {
        component.path = unescape(component.path);
      }
    }
    if (options.reference !== "suffix" && component.scheme) {
      uriTokens.push(component.scheme, ":");
    }
    const authority = recomposeAuthority(component);
    if (authority !== void 0) {
      if (options.reference !== "suffix") {
        uriTokens.push("//");
      }
      uriTokens.push(authority);
      if (component.path && component.path[0] !== "/") {
        uriTokens.push("/");
      }
    }
    if (component.path !== void 0) {
      let s2 = component.path;
      if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
        s2 = removeDotSegments(s2);
      }
      if (authority === void 0 && s2[0] === "/" && s2[1] === "/") {
        s2 = "/%2F" + s2.slice(2);
      }
      uriTokens.push(s2);
    }
    if (component.query !== void 0) {
      uriTokens.push("?", component.query);
    }
    if (component.fragment !== void 0) {
      uriTokens.push("#", component.fragment);
    }
    return uriTokens.join("");
  }
  const URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
  function parse2(uri2, opts) {
    const options = Object.assign({}, opts);
    const parsed = {
      scheme: void 0,
      userinfo: void 0,
      host: "",
      port: void 0,
      path: "",
      query: void 0,
      fragment: void 0
    };
    let isIP = false;
    if (options.reference === "suffix") {
      if (options.scheme) {
        uri2 = options.scheme + ":" + uri2;
      } else {
        uri2 = "//" + uri2;
      }
    }
    const matches = uri2.match(URI_PARSE);
    if (matches) {
      parsed.scheme = matches[1];
      parsed.userinfo = matches[3];
      parsed.host = matches[4];
      parsed.port = parseInt(matches[5], 10);
      parsed.path = matches[6] || "";
      parsed.query = matches[7];
      parsed.fragment = matches[8];
      if (isNaN(parsed.port)) {
        parsed.port = matches[5];
      }
      if (parsed.host) {
        const ipv4result = isIPv4(parsed.host);
        if (ipv4result === false) {
          const ipv6result = normalizeIPv6(parsed.host);
          parsed.host = ipv6result.host.toLowerCase();
          isIP = ipv6result.isIPV6;
        } else {
          isIP = true;
        }
      }
      if (parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && parsed.query === void 0 && !parsed.path) {
        parsed.reference = "same-document";
      } else if (parsed.scheme === void 0) {
        parsed.reference = "relative";
      } else if (parsed.fragment === void 0) {
        parsed.reference = "absolute";
      } else {
        parsed.reference = "uri";
      }
      if (options.reference && options.reference !== "suffix" && options.reference !== parsed.reference) {
        parsed.error = parsed.error || "URI is not a " + options.reference + " reference.";
      }
      const schemeHandler = getSchemeHandler(options.scheme || parsed.scheme);
      if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
        if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) {
          try {
            parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
          } catch (e) {
            parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
          }
        }
      }
      if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
        if (uri2.indexOf("%") !== -1) {
          if (parsed.scheme !== void 0) {
            parsed.scheme = unescape(parsed.scheme);
          }
          if (parsed.host !== void 0) {
            parsed.host = unescape(parsed.host);
          }
        }
        if (parsed.path) {
          parsed.path = escape(unescape(parsed.path));
        }
        if (parsed.fragment) {
          parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
        }
      }
      if (schemeHandler && schemeHandler.parse) {
        schemeHandler.parse(parsed, options);
      }
    } else {
      parsed.error = parsed.error || "URI can not be parsed.";
    }
    return parsed;
  }
  const fastUri$1 = {
    SCHEMES,
    normalize,
    resolve: resolve2,
    resolveComponent,
    equal: equal2,
    serialize,
    parse: parse2
  };
  fastUri.exports = fastUri$1;
  fastUri.exports.default = fastUri$1;
  fastUri.exports.fastUri = fastUri$1;
  return fastUri.exports;
}
var hasRequiredUri$1;
function requireUri$1() {
  if (hasRequiredUri$1) return uri$1;
  hasRequiredUri$1 = 1;
  Object.defineProperty(uri$1, "__esModule", { value: true });
  const uri2 = requireFastUri();
  uri2.code = 'require("ajv/dist/runtime/uri").default';
  uri$1.default = uri2;
  return uri$1;
}
var hasRequiredCore$3;
function requireCore$3() {
  if (hasRequiredCore$3) return core$3;
  hasRequiredCore$3 = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.CodeGen = exports$1.Name = exports$1.nil = exports$1.stringify = exports$1.str = exports$1._ = exports$1.KeywordCxt = void 0;
    var validate_1 = /* @__PURE__ */ requireValidate$1();
    Object.defineProperty(exports$1, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = /* @__PURE__ */ requireCodegen$1();
    Object.defineProperty(exports$1, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports$1, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports$1, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports$1, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports$1, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports$1, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    const validation_error_1 = /* @__PURE__ */ requireValidation_error$1();
    const ref_error_1 = /* @__PURE__ */ requireRef_error$1();
    const rules_1 = /* @__PURE__ */ requireRules$1();
    const compile_12 = /* @__PURE__ */ requireCompile$1();
    const codegen_2 = /* @__PURE__ */ requireCodegen$1();
    const resolve_12 = /* @__PURE__ */ requireResolve$1();
    const dataType_1 = /* @__PURE__ */ requireDataType$1();
    const util_1 = /* @__PURE__ */ requireUtil$1();
    const $dataRefSchema = require$$9$1;
    const uri_1 = /* @__PURE__ */ requireUri$1();
    const defaultRegExp = (str, flags) => new RegExp(str, flags);
    defaultRegExp.code = "new RegExp";
    const META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
    const EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]);
    const removedOptions = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    };
    const deprecatedOptions = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    };
    const MAX_EXPRESSION = 200;
    function requiredOptions(o) {
      var _a2, _b, _c2, _d2, _e2, _f, _g2, _h2, _j, _k, _l2, _m, _o2, _p2, _q, _r2, _s2, _t2, _u2, _v2, _w, _x, _y, _z, _0;
      const s2 = o.strict;
      const _optz = (_a2 = o.code) === null || _a2 === void 0 ? void 0 : _a2.optimize;
      const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
      const regExp = (_c2 = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c2 !== void 0 ? _c2 : defaultRegExp;
      const uriResolver = (_d2 = o.uriResolver) !== null && _d2 !== void 0 ? _d2 : uri_1.default;
      return {
        strictSchema: (_f = (_e2 = o.strictSchema) !== null && _e2 !== void 0 ? _e2 : s2) !== null && _f !== void 0 ? _f : true,
        strictNumbers: (_h2 = (_g2 = o.strictNumbers) !== null && _g2 !== void 0 ? _g2 : s2) !== null && _h2 !== void 0 ? _h2 : true,
        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s2) !== null && _k !== void 0 ? _k : "log",
        strictTuples: (_m = (_l2 = o.strictTuples) !== null && _l2 !== void 0 ? _l2 : s2) !== null && _m !== void 0 ? _m : "log",
        strictRequired: (_p2 = (_o2 = o.strictRequired) !== null && _o2 !== void 0 ? _o2 : s2) !== null && _p2 !== void 0 ? _p2 : false,
        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
        loopEnum: (_r2 = o.loopEnum) !== null && _r2 !== void 0 ? _r2 : MAX_EXPRESSION,
        meta: (_s2 = o.meta) !== null && _s2 !== void 0 ? _s2 : true,
        messages: (_t2 = o.messages) !== null && _t2 !== void 0 ? _t2 : true,
        inlineRefs: (_u2 = o.inlineRefs) !== null && _u2 !== void 0 ? _u2 : true,
        schemaId: (_v2 = o.schemaId) !== null && _v2 !== void 0 ? _v2 : "$id",
        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
        uriResolver
      };
    }
    class Ajv2 {
      constructor(opts = {}) {
        this.schemas = {};
        this.refs = {};
        this.formats = {};
        this._compilations = /* @__PURE__ */ new Set();
        this._loading = {};
        this._cache = /* @__PURE__ */ new Map();
        opts = this.opts = { ...opts, ...requiredOptions(opts) };
        const { es5, lines } = this.opts.code;
        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
        this.logger = getLogger(opts.logger);
        const formatOpt = opts.validateFormats;
        opts.validateFormats = false;
        this.RULES = (0, rules_1.getRules)();
        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
        this._metaOpts = getMetaSchemaOptions.call(this);
        if (opts.formats)
          addInitialFormats.call(this);
        this._addVocabularies();
        this._addDefaultMetaSchema();
        if (opts.keywords)
          addInitialKeywords.call(this, opts.keywords);
        if (typeof opts.meta == "object")
          this.addMetaSchema(opts.meta);
        addInitialSchemas.call(this);
        opts.validateFormats = formatOpt;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data, meta, schemaId } = this.opts;
        let _dataRefSchema = $dataRefSchema;
        if (schemaId === "id") {
          _dataRefSchema = { ...$dataRefSchema };
          _dataRefSchema.id = _dataRefSchema.$id;
          delete _dataRefSchema.$id;
        }
        if (meta && $data)
          this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
      }
      defaultMeta() {
        const { meta, schemaId } = this.opts;
        return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
      }
      validate(schemaKeyRef, data2) {
        let v;
        if (typeof schemaKeyRef == "string") {
          v = this.getSchema(schemaKeyRef);
          if (!v)
            throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
        } else {
          v = this.compile(schemaKeyRef);
        }
        const valid = v(data2);
        if (!("$async" in v))
          this.errors = v.errors;
        return valid;
      }
      compile(schema, _meta) {
        const sch = this._addSchema(schema, _meta);
        return sch.validate || this._compileSchemaEnv(sch);
      }
      compileAsync(schema, meta) {
        if (typeof this.opts.loadSchema != "function") {
          throw new Error("options.loadSchema should be a function");
        }
        const { loadSchema } = this.opts;
        return runCompileAsync.call(this, schema, meta);
        async function runCompileAsync(_schema, _meta) {
          await loadMetaSchema.call(this, _schema.$schema);
          const sch = this._addSchema(_schema, _meta);
          return sch.validate || _compileAsync.call(this, sch);
        }
        async function loadMetaSchema($ref) {
          if ($ref && !this.getSchema($ref)) {
            await runCompileAsync.call(this, { $ref }, true);
          }
        }
        async function _compileAsync(sch) {
          try {
            return this._compileSchemaEnv(sch);
          } catch (e) {
            if (!(e instanceof ref_error_1.default))
              throw e;
            checkLoaded.call(this, e);
            await loadMissingSchema.call(this, e.missingSchema);
            return _compileAsync.call(this, sch);
          }
        }
        function checkLoaded({ missingSchema: ref2, missingRef }) {
          if (this.refs[ref2]) {
            throw new Error(`AnySchema ${ref2} is loaded but ${missingRef} cannot be resolved`);
          }
        }
        async function loadMissingSchema(ref2) {
          const _schema = await _loadSchema.call(this, ref2);
          if (!this.refs[ref2])
            await loadMetaSchema.call(this, _schema.$schema);
          if (!this.refs[ref2])
            this.addSchema(_schema, ref2, meta);
        }
        async function _loadSchema(ref2) {
          const p2 = this._loading[ref2];
          if (p2)
            return p2;
          try {
            return await (this._loading[ref2] = loadSchema(ref2));
          } finally {
            delete this._loading[ref2];
          }
        }
      }
      // Adds schema to the instance
      addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
        if (Array.isArray(schema)) {
          for (const sch of schema)
            this.addSchema(sch, void 0, _meta, _validateSchema);
          return this;
        }
        let id2;
        if (typeof schema === "object") {
          const { schemaId } = this.opts;
          id2 = schema[schemaId];
          if (id2 !== void 0 && typeof id2 != "string") {
            throw new Error(`schema ${schemaId} must be string`);
          }
        }
        key = (0, resolve_12.normalizeId)(key || id2);
        this._checkUnique(key);
        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
        return this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
        this.addSchema(schema, key, true, _validateSchema);
        return this;
      }
      //  Validate schema against its meta-schema
      validateSchema(schema, throwOrLogError) {
        if (typeof schema == "boolean")
          return true;
        let $schema2;
        $schema2 = schema.$schema;
        if ($schema2 !== void 0 && typeof $schema2 != "string") {
          throw new Error("$schema must be a string");
        }
        $schema2 = $schema2 || this.opts.defaultMeta || this.defaultMeta();
        if (!$schema2) {
          this.logger.warn("meta-schema not available");
          this.errors = null;
          return true;
        }
        const valid = this.validate($schema2, schema);
        if (!valid && throwOrLogError) {
          const message = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(message);
          else
            throw new Error(message);
        }
        return valid;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(keyRef) {
        let sch;
        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
          keyRef = sch;
        if (sch === void 0) {
          const { schemaId } = this.opts;
          const root = new compile_12.SchemaEnv({ schema: {}, schemaId });
          sch = compile_12.resolveSchema.call(this, root, keyRef);
          if (!sch)
            return;
          this.refs[keyRef] = sch;
        }
        return sch.validate || this._compileSchemaEnv(sch);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp) {
          this._removeAllSchemas(this.schemas, schemaKeyRef);
          this._removeAllSchemas(this.refs, schemaKeyRef);
          return this;
        }
        switch (typeof schemaKeyRef) {
          case "undefined":
            this._removeAllSchemas(this.schemas);
            this._removeAllSchemas(this.refs);
            this._cache.clear();
            return this;
          case "string": {
            const sch = getSchEnv.call(this, schemaKeyRef);
            if (typeof sch == "object")
              this._cache.delete(sch.schema);
            delete this.schemas[schemaKeyRef];
            delete this.refs[schemaKeyRef];
            return this;
          }
          case "object": {
            const cacheKey = schemaKeyRef;
            this._cache.delete(cacheKey);
            let id2 = schemaKeyRef[this.opts.schemaId];
            if (id2) {
              id2 = (0, resolve_12.normalizeId)(id2);
              delete this.schemas[id2];
              delete this.refs[id2];
            }
            return this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(definitions2) {
        for (const def of definitions2)
          this.addKeyword(def);
        return this;
      }
      addKeyword(kwdOrDef, def) {
        let keyword2;
        if (typeof kwdOrDef == "string") {
          keyword2 = kwdOrDef;
          if (typeof def == "object") {
            this.logger.warn("these parameters are deprecated, see docs for addKeyword");
            def.keyword = keyword2;
          }
        } else if (typeof kwdOrDef == "object" && def === void 0) {
          def = kwdOrDef;
          keyword2 = def.keyword;
          if (Array.isArray(keyword2) && !keyword2.length) {
            throw new Error("addKeywords: keyword must be string or non-empty array");
          }
        } else {
          throw new Error("invalid addKeywords parameters");
        }
        checkKeyword.call(this, keyword2, def);
        if (!def) {
          (0, util_1.eachItem)(keyword2, (kwd) => addRule.call(this, kwd));
          return this;
        }
        keywordMetaschema.call(this, def);
        const definition = {
          ...def,
          type: (0, dataType_1.getJSONTypes)(def.type),
          schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
        };
        (0, util_1.eachItem)(keyword2, definition.type.length === 0 ? (k2) => addRule.call(this, k2, definition) : (k2) => definition.type.forEach((t) => addRule.call(this, k2, definition, t)));
        return this;
      }
      getKeyword(keyword2) {
        const rule = this.RULES.all[keyword2];
        return typeof rule == "object" ? rule.definition : !!rule;
      }
      // Remove keyword
      removeKeyword(keyword2) {
        const { RULES } = this;
        delete RULES.keywords[keyword2];
        delete RULES.all[keyword2];
        for (const group of RULES.rules) {
          const i = group.rules.findIndex((rule) => rule.keyword === keyword2);
          if (i >= 0)
            group.rules.splice(i, 1);
        }
        return this;
      }
      // Add format
      addFormat(name2, format2) {
        if (typeof format2 == "string")
          format2 = new RegExp(format2);
        this.formats[name2] = format2;
        return this;
      }
      errorsText(errors2 = this.errors, { separator = ", ", dataVar = "data" } = {}) {
        if (!errors2 || errors2.length === 0)
          return "No errors";
        return errors2.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
      }
      $dataMetaSchema(metaSchema, keywordsJsonPointers) {
        const rules2 = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (const jsonPointer of keywordsJsonPointers) {
          const segments = jsonPointer.split("/").slice(1);
          let keywords = metaSchema;
          for (const seg of segments)
            keywords = keywords[seg];
          for (const key in rules2) {
            const rule = rules2[key];
            if (typeof rule != "object")
              continue;
            const { $data } = rule.definition;
            const schema = keywords[key];
            if ($data && schema)
              keywords[key] = schemaOrData(schema);
          }
        }
        return metaSchema;
      }
      _removeAllSchemas(schemas, regex) {
        for (const keyRef in schemas) {
          const sch = schemas[keyRef];
          if (!regex || regex.test(keyRef)) {
            if (typeof sch == "string") {
              delete schemas[keyRef];
            } else if (sch && !sch.meta) {
              this._cache.delete(sch.schema);
              delete schemas[keyRef];
            }
          }
        }
      }
      _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
        let id2;
        const { schemaId } = this.opts;
        if (typeof schema == "object") {
          id2 = schema[schemaId];
        } else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          else if (typeof schema != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let sch = this._cache.get(schema);
        if (sch !== void 0)
          return sch;
        baseId = (0, resolve_12.normalizeId)(id2 || baseId);
        const localRefs = resolve_12.getSchemaRefs.call(this, schema, baseId);
        sch = new compile_12.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
        this._cache.set(sch.schema, sch);
        if (addSchema && !baseId.startsWith("#")) {
          if (baseId)
            this._checkUnique(baseId);
          this.refs[baseId] = sch;
        }
        if (validateSchema)
          this.validateSchema(schema, true);
        return sch;
      }
      _checkUnique(id2) {
        if (this.schemas[id2] || this.refs[id2]) {
          throw new Error(`schema with key or id "${id2}" already exists`);
        }
      }
      _compileSchemaEnv(sch) {
        if (sch.meta)
          this._compileMetaSchema(sch);
        else
          compile_12.compileSchema.call(this, sch);
        if (!sch.validate)
          throw new Error("ajv implementation error");
        return sch.validate;
      }
      _compileMetaSchema(sch) {
        const currentOpts = this.opts;
        this.opts = this._metaOpts;
        try {
          compile_12.compileSchema.call(this, sch);
        } finally {
          this.opts = currentOpts;
        }
      }
    }
    Ajv2.ValidationError = validation_error_1.default;
    Ajv2.MissingRefError = ref_error_1.default;
    exports$1.default = Ajv2;
    function checkOptions(checkOpts, options, msg, log = "error") {
      for (const key in checkOpts) {
        const opt = key;
        if (opt in options)
          this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
      }
    }
    function getSchEnv(keyRef) {
      keyRef = (0, resolve_12.normalizeId)(keyRef);
      return this.schemas[keyRef] || this.refs[keyRef];
    }
    function addInitialSchemas() {
      const optsSchemas = this.opts.schemas;
      if (!optsSchemas)
        return;
      if (Array.isArray(optsSchemas))
        this.addSchema(optsSchemas);
      else
        for (const key in optsSchemas)
          this.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats() {
      for (const name2 in this.opts.formats) {
        const format2 = this.opts.formats[name2];
        if (format2)
          this.addFormat(name2, format2);
      }
    }
    function addInitialKeywords(defs) {
      if (Array.isArray(defs)) {
        this.addVocabulary(defs);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const keyword2 in defs) {
        const def = defs[keyword2];
        if (!def.keyword)
          def.keyword = keyword2;
        this.addKeyword(def);
      }
    }
    function getMetaSchemaOptions() {
      const metaOpts = { ...this.opts };
      for (const opt of META_IGNORE_OPTIONS)
        delete metaOpts[opt];
      return metaOpts;
    }
    const noLogs = { log() {
    }, warn() {
    }, error() {
    } };
    function getLogger(logger) {
      if (logger === false)
        return noLogs;
      if (logger === void 0)
        return console;
      if (logger.log && logger.warn && logger.error)
        return logger;
      throw new Error("logger must implement log, warn and error methods");
    }
    const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
    function checkKeyword(keyword2, def) {
      const { RULES } = this;
      (0, util_1.eachItem)(keyword2, (kwd) => {
        if (RULES.keywords[kwd])
          throw new Error(`Keyword ${kwd} is already defined`);
        if (!KEYWORD_NAME.test(kwd))
          throw new Error(`Keyword ${kwd} has invalid name`);
      });
      if (!def)
        return;
      if (def.$data && !("code" in def || "validate" in def)) {
        throw new Error('$data keyword must have "code" or "validate" function');
      }
    }
    function addRule(keyword2, definition, dataType2) {
      var _a2;
      const post = definition === null || definition === void 0 ? void 0 : definition.post;
      if (dataType2 && post)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES } = this;
      let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType2);
      if (!ruleGroup) {
        ruleGroup = { type: dataType2, rules: [] };
        RULES.rules.push(ruleGroup);
      }
      RULES.keywords[keyword2] = true;
      if (!definition)
        return;
      const rule = {
        keyword: keyword2,
        definition: {
          ...definition,
          type: (0, dataType_1.getJSONTypes)(definition.type),
          schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
        }
      };
      if (definition.before)
        addBeforeRule.call(this, ruleGroup, rule, definition.before);
      else
        ruleGroup.rules.push(rule);
      RULES.all[keyword2] = rule;
      (_a2 = definition.implements) === null || _a2 === void 0 ? void 0 : _a2.forEach((kwd) => this.addKeyword(kwd));
    }
    function addBeforeRule(ruleGroup, rule, before) {
      const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
      if (i >= 0) {
        ruleGroup.rules.splice(i, 0, rule);
      } else {
        ruleGroup.rules.push(rule);
        this.logger.warn(`rule ${before} is not defined`);
      }
    }
    function keywordMetaschema(def) {
      let { metaSchema } = def;
      if (metaSchema === void 0)
        return;
      if (def.$data && this.opts.$data)
        metaSchema = schemaOrData(metaSchema);
      def.validateSchema = this.compile(metaSchema, true);
    }
    const $dataRef = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function schemaOrData(schema) {
      return { anyOf: [schema, $dataRef] };
    }
  })(core$3);
  return core$3;
}
var draft7$1 = {};
var core$2 = {};
var id$2 = {};
var hasRequiredId$1;
function requireId$1() {
  if (hasRequiredId$1) return id$2;
  hasRequiredId$1 = 1;
  Object.defineProperty(id$2, "__esModule", { value: true });
  const def = {
    keyword: "id",
    code() {
      throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
    }
  };
  id$2.default = def;
  return id$2;
}
var ref$1 = {};
var hasRequiredRef$1;
function requireRef$1() {
  if (hasRequiredRef$1) return ref$1;
  hasRequiredRef$1 = 1;
  Object.defineProperty(ref$1, "__esModule", { value: true });
  ref$1.callRef = ref$1.getValidate = void 0;
  const ref_error_1 = /* @__PURE__ */ requireRef_error$1();
  const code_1 = /* @__PURE__ */ requireCode$2();
  const codegen_1 = /* @__PURE__ */ requireCodegen$1();
  const names_1 = /* @__PURE__ */ requireNames$1();
  const compile_12 = /* @__PURE__ */ requireCompile$1();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const def = {
    keyword: "$ref",
    schemaType: "string",
    code(cxt) {
      const { gen, schema: $ref, it: it2 } = cxt;
      const { baseId, schemaEnv: env, validateName, opts, self: self2 } = it2;
      const { root } = env;
      if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
        return callRootRef();
      const schOrEnv = compile_12.resolveRef.call(self2, root, baseId, $ref);
      if (schOrEnv === void 0)
        throw new ref_error_1.default(it2.opts.uriResolver, baseId, $ref);
      if (schOrEnv instanceof compile_12.SchemaEnv)
        return callValidate(schOrEnv);
      return inlineRefSchema(schOrEnv);
      function callRootRef() {
        if (env === root)
          return callRef(cxt, validateName, env, env.$async);
        const rootName = gen.scopeValue("root", { ref: root });
        return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
      }
      function callValidate(sch) {
        const v = getValidate(cxt, sch);
        callRef(cxt, v, sch, sch.$async);
      }
      function inlineRefSchema(sch) {
        const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
        const valid = gen.name("valid");
        const schCxt = cxt.subschema({
          schema: sch,
          dataTypes: [],
          schemaPath: codegen_1.nil,
          topSchemaRef: schName,
          errSchemaPath: $ref
        }, valid);
        cxt.mergeEvaluated(schCxt);
        cxt.ok(valid);
      }
    }
  };
  function getValidate(cxt, sch) {
    const { gen } = cxt;
    return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
  }
  ref$1.getValidate = getValidate;
  function callRef(cxt, v, sch, $async) {
    const { gen, it: it2 } = cxt;
    const { allErrors, schemaEnv: env, opts } = it2;
    const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
    if ($async)
      callAsyncRef();
    else
      callSyncRef();
    function callAsyncRef() {
      if (!env.$async)
        throw new Error("async schema referenced by sync schema");
      const valid = gen.let("valid");
      gen.try(() => {
        gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
        addEvaluatedFrom(v);
        if (!allErrors)
          gen.assign(valid, true);
      }, (e) => {
        gen.if((0, codegen_1._)`!(${e} instanceof ${it2.ValidationError})`, () => gen.throw(e));
        addErrorsFrom(e);
        if (!allErrors)
          gen.assign(valid, false);
      });
      cxt.ok(valid);
    }
    function callSyncRef() {
      cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
    }
    function addErrorsFrom(source) {
      const errs = (0, codegen_1._)`${source}.errors`;
      gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
      gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
    }
    function addEvaluatedFrom(source) {
      var _a2;
      if (!it2.opts.unevaluated)
        return;
      const schEvaluated = (_a2 = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a2 === void 0 ? void 0 : _a2.evaluated;
      if (it2.props !== true) {
        if (schEvaluated && !schEvaluated.dynamicProps) {
          if (schEvaluated.props !== void 0) {
            it2.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it2.props);
          }
        } else {
          const props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
          it2.props = util_1.mergeEvaluated.props(gen, props, it2.props, codegen_1.Name);
        }
      }
      if (it2.items !== true) {
        if (schEvaluated && !schEvaluated.dynamicItems) {
          if (schEvaluated.items !== void 0) {
            it2.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it2.items);
          }
        } else {
          const items2 = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
          it2.items = util_1.mergeEvaluated.items(gen, items2, it2.items, codegen_1.Name);
        }
      }
    }
  }
  ref$1.callRef = callRef;
  ref$1.default = def;
  return ref$1;
}
var hasRequiredCore$2;
function requireCore$2() {
  if (hasRequiredCore$2) return core$2;
  hasRequiredCore$2 = 1;
  Object.defineProperty(core$2, "__esModule", { value: true });
  const id_1 = /* @__PURE__ */ requireId$1();
  const ref_1 = /* @__PURE__ */ requireRef$1();
  const core2 = [
    "$schema",
    "$id",
    "$defs",
    "$vocabulary",
    { keyword: "$comment" },
    "definitions",
    id_1.default,
    ref_1.default
  ];
  core$2.default = core2;
  return core$2;
}
var validation$1 = {};
var limitNumber$1 = {};
var hasRequiredLimitNumber$1;
function requireLimitNumber$1() {
  if (hasRequiredLimitNumber$1) return limitNumber$1;
  hasRequiredLimitNumber$1 = 1;
  Object.defineProperty(limitNumber$1, "__esModule", { value: true });
  const codegen_1 = /* @__PURE__ */ requireCodegen$1();
  const ops = codegen_1.operators;
  const KWDs = {
    maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
    minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
    exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
    exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
  };
  const error = {
    message: ({ keyword: keyword2, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword2].okStr} ${schemaCode}`,
    params: ({ keyword: keyword2, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword2].okStr}, limit: ${schemaCode}}`
  };
  const def = {
    keyword: Object.keys(KWDs),
    type: "number",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
      const { keyword: keyword2, data: data2, schemaCode } = cxt;
      cxt.fail$data((0, codegen_1._)`${data2} ${KWDs[keyword2].fail} ${schemaCode} || isNaN(${data2})`);
    }
  };
  limitNumber$1.default = def;
  return limitNumber$1;
}
var multipleOf$1 = {};
var hasRequiredMultipleOf$1;
function requireMultipleOf$1() {
  if (hasRequiredMultipleOf$1) return multipleOf$1;
  hasRequiredMultipleOf$1 = 1;
  Object.defineProperty(multipleOf$1, "__esModule", { value: true });
  const codegen_1 = /* @__PURE__ */ requireCodegen$1();
  const error = {
    message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
    params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
  };
  const def = {
    keyword: "multipleOf",
    type: "number",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
      const { gen, data: data2, schemaCode, it: it2 } = cxt;
      const prec = it2.opts.multipleOfPrecision;
      const res = gen.let("res");
      const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
      cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data2}/${schemaCode}, ${invalid}))`);
    }
  };
  multipleOf$1.default = def;
  return multipleOf$1;
}
var limitLength$1 = {};
var ucs2length$1 = {};
var hasRequiredUcs2length$1;
function requireUcs2length$1() {
  if (hasRequiredUcs2length$1) return ucs2length$1;
  hasRequiredUcs2length$1 = 1;
  Object.defineProperty(ucs2length$1, "__esModule", { value: true });
  function ucs2length2(str) {
    const len = str.length;
    let length = 0;
    let pos = 0;
    let value;
    while (pos < len) {
      length++;
      value = str.charCodeAt(pos++);
      if (value >= 55296 && value <= 56319 && pos < len) {
        value = str.charCodeAt(pos);
        if ((value & 64512) === 56320)
          pos++;
      }
    }
    return length;
  }
  ucs2length$1.default = ucs2length2;
  ucs2length2.code = 'require("ajv/dist/runtime/ucs2length").default';
  return ucs2length$1;
}
var hasRequiredLimitLength$1;
function requireLimitLength$1() {
  if (hasRequiredLimitLength$1) return limitLength$1;
  hasRequiredLimitLength$1 = 1;
  Object.defineProperty(limitLength$1, "__esModule", { value: true });
  const codegen_1 = /* @__PURE__ */ requireCodegen$1();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const ucs2length_1 = /* @__PURE__ */ requireUcs2length$1();
  const error = {
    message({ keyword: keyword2, schemaCode }) {
      const comp = keyword2 === "maxLength" ? "more" : "fewer";
      return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
    },
    params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
  };
  const def = {
    keyword: ["maxLength", "minLength"],
    type: "string",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
      const { keyword: keyword2, data: data2, schemaCode, it: it2 } = cxt;
      const op2 = keyword2 === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
      const len = it2.opts.unicode === false ? (0, codegen_1._)`${data2}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data2})`;
      cxt.fail$data((0, codegen_1._)`${len} ${op2} ${schemaCode}`);
    }
  };
  limitLength$1.default = def;
  return limitLength$1;
}
var pattern$1 = {};
var hasRequiredPattern$1;
function requirePattern$1() {
  if (hasRequiredPattern$1) return pattern$1;
  hasRequiredPattern$1 = 1;
  Object.defineProperty(pattern$1, "__esModule", { value: true });
  const code_1 = /* @__PURE__ */ requireCode$2();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const codegen_1 = /* @__PURE__ */ requireCodegen$1();
  const error = {
    message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
    params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
  };
  const def = {
    keyword: "pattern",
    type: "string",
    schemaType: "string",
    $data: true,
    error,
    code(cxt) {
      const { gen, data: data2, $data, schema, schemaCode, it: it2 } = cxt;
      const u2 = it2.opts.unicodeRegExp ? "u" : "";
      if ($data) {
        const { regExp } = it2.opts.code;
        const regExpCode = regExp.code === "new RegExp" ? (0, codegen_1._)`new RegExp` : (0, util_1.useFunc)(gen, regExp);
        const valid = gen.let("valid");
        gen.try(() => gen.assign(valid, (0, codegen_1._)`${regExpCode}(${schemaCode}, ${u2}).test(${data2})`), () => gen.assign(valid, false));
        cxt.fail$data((0, codegen_1._)`!${valid}`);
      } else {
        const regExp = (0, code_1.usePattern)(cxt, schema);
        cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data2})`);
      }
    }
  };
  pattern$1.default = def;
  return pattern$1;
}
var limitProperties$1 = {};
var hasRequiredLimitProperties$1;
function requireLimitProperties$1() {
  if (hasRequiredLimitProperties$1) return limitProperties$1;
  hasRequiredLimitProperties$1 = 1;
  Object.defineProperty(limitProperties$1, "__esModule", { value: true });
  const codegen_1 = /* @__PURE__ */ requireCodegen$1();
  const error = {
    message({ keyword: keyword2, schemaCode }) {
      const comp = keyword2 === "maxProperties" ? "more" : "fewer";
      return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
    },
    params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
  };
  const def = {
    keyword: ["maxProperties", "minProperties"],
    type: "object",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
      const { keyword: keyword2, data: data2, schemaCode } = cxt;
      const op2 = keyword2 === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
      cxt.fail$data((0, codegen_1._)`Object.keys(${data2}).length ${op2} ${schemaCode}`);
    }
  };
  limitProperties$1.default = def;
  return limitProperties$1;
}
var required$2 = {};
var hasRequiredRequired$1;
function requireRequired$1() {
  if (hasRequiredRequired$1) return required$2;
  hasRequiredRequired$1 = 1;
  Object.defineProperty(required$2, "__esModule", { value: true });
  const code_1 = /* @__PURE__ */ requireCode$2();
  const codegen_1 = /* @__PURE__ */ requireCodegen$1();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const error = {
    message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
    params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
  };
  const def = {
    keyword: "required",
    type: "object",
    schemaType: "array",
    $data: true,
    error,
    code(cxt) {
      const { gen, schema, schemaCode, data: data2, $data, it: it2 } = cxt;
      const { opts } = it2;
      if (!$data && schema.length === 0)
        return;
      const useLoop = schema.length >= opts.loopRequired;
      if (it2.allErrors)
        allErrorsMode();
      else
        exitOnErrorMode();
      if (opts.strictRequired) {
        const props = cxt.parentSchema.properties;
        const { definedProperties } = cxt.it;
        for (const requiredKey of schema) {
          if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
            const schemaPath = it2.schemaEnv.baseId + it2.errSchemaPath;
            const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
            (0, util_1.checkStrictMode)(it2, msg, it2.opts.strictRequired);
          }
        }
      }
      function allErrorsMode() {
        if (useLoop || $data) {
          cxt.block$data(codegen_1.nil, loopAllRequired);
        } else {
          for (const prop of schema) {
            (0, code_1.checkReportMissingProp)(cxt, prop);
          }
        }
      }
      function exitOnErrorMode() {
        const missing = gen.let("missing");
        if (useLoop || $data) {
          const valid = gen.let("valid", true);
          cxt.block$data(valid, () => loopUntilMissing(missing, valid));
          cxt.ok(valid);
        } else {
          gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
          (0, code_1.reportMissingProp)(cxt, missing);
          gen.else();
        }
      }
      function loopAllRequired() {
        gen.forOf("prop", schemaCode, (prop) => {
          cxt.setParams({ missingProperty: prop });
          gen.if((0, code_1.noPropertyInData)(gen, data2, prop, opts.ownProperties), () => cxt.error());
        });
      }
      function loopUntilMissing(missing, valid) {
        cxt.setParams({ missingProperty: missing });
        gen.forOf(missing, schemaCode, () => {
          gen.assign(valid, (0, code_1.propertyInData)(gen, data2, missing, opts.ownProperties));
          gen.if((0, codegen_1.not)(valid), () => {
            cxt.error();
            gen.break();
          });
        }, codegen_1.nil);
      }
    }
  };
  required$2.default = def;
  return required$2;
}
var limitItems$1 = {};
var hasRequiredLimitItems$1;
function requireLimitItems$1() {
  if (hasRequiredLimitItems$1) return limitItems$1;
  hasRequiredLimitItems$1 = 1;
  Object.defineProperty(limitItems$1, "__esModule", { value: true });
  const codegen_1 = /* @__PURE__ */ requireCodegen$1();
  const error = {
    message({ keyword: keyword2, schemaCode }) {
      const comp = keyword2 === "maxItems" ? "more" : "fewer";
      return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
    },
    params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
  };
  const def = {
    keyword: ["maxItems", "minItems"],
    type: "array",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
      const { keyword: keyword2, data: data2, schemaCode } = cxt;
      const op2 = keyword2 === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
      cxt.fail$data((0, codegen_1._)`${data2}.length ${op2} ${schemaCode}`);
    }
  };
  limitItems$1.default = def;
  return limitItems$1;
}
var uniqueItems$1 = {};
var equal$1 = {};
var hasRequiredEqual$1;
function requireEqual$1() {
  if (hasRequiredEqual$1) return equal$1;
  hasRequiredEqual$1 = 1;
  Object.defineProperty(equal$1, "__esModule", { value: true });
  const equal2 = requireFastDeepEqual();
  equal2.code = 'require("ajv/dist/runtime/equal").default';
  equal$1.default = equal2;
  return equal$1;
}
var hasRequiredUniqueItems$1;
function requireUniqueItems$1() {
  if (hasRequiredUniqueItems$1) return uniqueItems$1;
  hasRequiredUniqueItems$1 = 1;
  Object.defineProperty(uniqueItems$1, "__esModule", { value: true });
  const dataType_1 = /* @__PURE__ */ requireDataType$1();
  const codegen_1 = /* @__PURE__ */ requireCodegen$1();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const equal_1 = /* @__PURE__ */ requireEqual$1();
  const error = {
    message: ({ params: { i, j: j2 } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j2} and ${i} are identical)`,
    params: ({ params: { i, j: j2 } }) => (0, codegen_1._)`{i: ${i}, j: ${j2}}`
  };
  const def = {
    keyword: "uniqueItems",
    type: "array",
    schemaType: "boolean",
    $data: true,
    error,
    code(cxt) {
      const { gen, data: data2, $data, schema, parentSchema, schemaCode, it: it2 } = cxt;
      if (!$data && !schema)
        return;
      const valid = gen.let("valid");
      const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
      cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
      cxt.ok(valid);
      function validateUniqueItems() {
        const i = gen.let("i", (0, codegen_1._)`${data2}.length`);
        const j2 = gen.let("j");
        cxt.setParams({ i, j: j2 });
        gen.assign(valid, true);
        gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j2));
      }
      function canOptimize() {
        return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
      }
      function loopN(i, j2) {
        const item = gen.name("item");
        const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it2.opts.strictNumbers, dataType_1.DataType.Wrong);
        const indices = gen.const("indices", (0, codegen_1._)`{}`);
        gen.for((0, codegen_1._)`;${i}--;`, () => {
          gen.let(item, (0, codegen_1._)`${data2}[${i}]`);
          gen.if(wrongType, (0, codegen_1._)`continue`);
          if (itemTypes.length > 1)
            gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
          gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
            gen.assign(j2, (0, codegen_1._)`${indices}[${item}]`);
            cxt.error();
            gen.assign(valid, false).break();
          }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
        });
      }
      function loopN2(i, j2) {
        const eql = (0, util_1.useFunc)(gen, equal_1.default);
        const outer = gen.name("outer");
        gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j2} = ${i}; ${j2}--;`, () => gen.if((0, codegen_1._)`${eql}(${data2}[${i}], ${data2}[${j2}])`, () => {
          cxt.error();
          gen.assign(valid, false).break(outer);
        })));
      }
    }
  };
  uniqueItems$1.default = def;
  return uniqueItems$1;
}
var _const$1 = {};
var hasRequired_const$1;
function require_const$1() {
  if (hasRequired_const$1) return _const$1;
  hasRequired_const$1 = 1;
  Object.defineProperty(_const$1, "__esModule", { value: true });
  const codegen_1 = /* @__PURE__ */ requireCodegen$1();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const equal_1 = /* @__PURE__ */ requireEqual$1();
  const error = {
    message: "must be equal to constant",
    params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
  };
  const def = {
    keyword: "const",
    $data: true,
    error,
    code(cxt) {
      const { gen, data: data2, $data, schemaCode, schema } = cxt;
      if ($data || schema && typeof schema == "object") {
        cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data2}, ${schemaCode})`);
      } else {
        cxt.fail((0, codegen_1._)`${schema} !== ${data2}`);
      }
    }
  };
  _const$1.default = def;
  return _const$1;
}
var _enum$1 = {};
var hasRequired_enum$1;
function require_enum$1() {
  if (hasRequired_enum$1) return _enum$1;
  hasRequired_enum$1 = 1;
  Object.defineProperty(_enum$1, "__esModule", { value: true });
  const codegen_1 = /* @__PURE__ */ requireCodegen$1();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const equal_1 = /* @__PURE__ */ requireEqual$1();
  const error = {
    message: "must be equal to one of the allowed values",
    params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
  };
  const def = {
    keyword: "enum",
    schemaType: "array",
    $data: true,
    error,
    code(cxt) {
      const { gen, data: data2, $data, schema, schemaCode, it: it2 } = cxt;
      if (!$data && schema.length === 0)
        throw new Error("enum must have non-empty array");
      const useLoop = schema.length >= it2.opts.loopEnum;
      let eql;
      const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);
      let valid;
      if (useLoop || $data) {
        valid = gen.let("valid");
        cxt.block$data(valid, loopEnum);
      } else {
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        const vSchema = gen.const("vSchema", schemaCode);
        valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
      }
      cxt.pass(valid);
      function loopEnum() {
        gen.assign(valid, false);
        gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._)`${getEql()}(${data2}, ${v})`, () => gen.assign(valid, true).break()));
      }
      function equalCode(vSchema, i) {
        const sch = schema[i];
        return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data2}, ${vSchema}[${i}])` : (0, codegen_1._)`${data2} === ${sch}`;
      }
    }
  };
  _enum$1.default = def;
  return _enum$1;
}
var hasRequiredValidation$1;
function requireValidation$1() {
  if (hasRequiredValidation$1) return validation$1;
  hasRequiredValidation$1 = 1;
  Object.defineProperty(validation$1, "__esModule", { value: true });
  const limitNumber_1 = /* @__PURE__ */ requireLimitNumber$1();
  const multipleOf_1 = /* @__PURE__ */ requireMultipleOf$1();
  const limitLength_1 = /* @__PURE__ */ requireLimitLength$1();
  const pattern_1 = /* @__PURE__ */ requirePattern$1();
  const limitProperties_1 = /* @__PURE__ */ requireLimitProperties$1();
  const required_1 = /* @__PURE__ */ requireRequired$1();
  const limitItems_1 = /* @__PURE__ */ requireLimitItems$1();
  const uniqueItems_1 = /* @__PURE__ */ requireUniqueItems$1();
  const const_1 = /* @__PURE__ */ require_const$1();
  const enum_1 = /* @__PURE__ */ require_enum$1();
  const validation2 = [
    // number
    limitNumber_1.default,
    multipleOf_1.default,
    // string
    limitLength_1.default,
    pattern_1.default,
    // object
    limitProperties_1.default,
    required_1.default,
    // array
    limitItems_1.default,
    uniqueItems_1.default,
    // any
    { keyword: "type", schemaType: ["string", "array"] },
    { keyword: "nullable", schemaType: "boolean" },
    const_1.default,
    enum_1.default
  ];
  validation$1.default = validation2;
  return validation$1;
}
var applicator$1 = {};
var additionalItems$1 = {};
var hasRequiredAdditionalItems$1;
function requireAdditionalItems$1() {
  if (hasRequiredAdditionalItems$1) return additionalItems$1;
  hasRequiredAdditionalItems$1 = 1;
  Object.defineProperty(additionalItems$1, "__esModule", { value: true });
  additionalItems$1.validateAdditionalItems = void 0;
  const codegen_1 = /* @__PURE__ */ requireCodegen$1();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const error = {
    message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
    params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
  };
  const def = {
    keyword: "additionalItems",
    type: "array",
    schemaType: ["boolean", "object"],
    before: "uniqueItems",
    error,
    code(cxt) {
      const { parentSchema, it: it2 } = cxt;
      const { items: items2 } = parentSchema;
      if (!Array.isArray(items2)) {
        (0, util_1.checkStrictMode)(it2, '"additionalItems" is ignored when "items" is not an array of schemas');
        return;
      }
      validateAdditionalItems(cxt, items2);
    }
  };
  function validateAdditionalItems(cxt, items2) {
    const { gen, schema, data: data2, keyword: keyword2, it: it2 } = cxt;
    it2.items = true;
    const len = gen.const("len", (0, codegen_1._)`${data2}.length`);
    if (schema === false) {
      cxt.setParams({ len: items2.length });
      cxt.pass((0, codegen_1._)`${len} <= ${items2.length}`);
    } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it2, schema)) {
      const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items2.length}`);
      gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
      cxt.ok(valid);
    }
    function validateItems(valid) {
      gen.forRange("i", items2.length, len, (i) => {
        cxt.subschema({ keyword: keyword2, dataProp: i, dataPropType: util_1.Type.Num }, valid);
        if (!it2.allErrors)
          gen.if((0, codegen_1.not)(valid), () => gen.break());
      });
    }
  }
  additionalItems$1.validateAdditionalItems = validateAdditionalItems;
  additionalItems$1.default = def;
  return additionalItems$1;
}
var prefixItems$1 = {};
var items$1 = {};
var hasRequiredItems$1;
function requireItems$1() {
  if (hasRequiredItems$1) return items$1;
  hasRequiredItems$1 = 1;
  Object.defineProperty(items$1, "__esModule", { value: true });
  items$1.validateTuple = void 0;
  const codegen_1 = /* @__PURE__ */ requireCodegen$1();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const code_1 = /* @__PURE__ */ requireCode$2();
  const def = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "array", "boolean"],
    before: "uniqueItems",
    code(cxt) {
      const { schema, it: it2 } = cxt;
      if (Array.isArray(schema))
        return validateTuple(cxt, "additionalItems", schema);
      it2.items = true;
      if ((0, util_1.alwaysValidSchema)(it2, schema))
        return;
      cxt.ok((0, code_1.validateArray)(cxt));
    }
  };
  function validateTuple(cxt, extraItems, schArr = cxt.schema) {
    const { gen, parentSchema, data: data2, keyword: keyword2, it: it2 } = cxt;
    checkStrictTuple(parentSchema);
    if (it2.opts.unevaluated && schArr.length && it2.items !== true) {
      it2.items = util_1.mergeEvaluated.items(gen, schArr.length, it2.items);
    }
    const valid = gen.name("valid");
    const len = gen.const("len", (0, codegen_1._)`${data2}.length`);
    schArr.forEach((sch, i) => {
      if ((0, util_1.alwaysValidSchema)(it2, sch))
        return;
      gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
        keyword: keyword2,
        schemaProp: i,
        dataProp: i
      }, valid));
      cxt.ok(valid);
    });
    function checkStrictTuple(sch) {
      const { opts, errSchemaPath } = it2;
      const l = schArr.length;
      const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
      if (opts.strictTuples && !fullTuple) {
        const msg = `"${keyword2}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
        (0, util_1.checkStrictMode)(it2, msg, opts.strictTuples);
      }
    }
  }
  items$1.validateTuple = validateTuple;
  items$1.default = def;
  return items$1;
}
var hasRequiredPrefixItems$1;
function requirePrefixItems$1() {
  if (hasRequiredPrefixItems$1) return prefixItems$1;
  hasRequiredPrefixItems$1 = 1;
  Object.defineProperty(prefixItems$1, "__esModule", { value: true });
  const items_1 = /* @__PURE__ */ requireItems$1();
  const def = {
    keyword: "prefixItems",
    type: "array",
    schemaType: ["array"],
    before: "uniqueItems",
    code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
  };
  prefixItems$1.default = def;
  return prefixItems$1;
}
var items2020$1 = {};
var hasRequiredItems2020$1;
function requireItems2020$1() {
  if (hasRequiredItems2020$1) return items2020$1;
  hasRequiredItems2020$1 = 1;
  Object.defineProperty(items2020$1, "__esModule", { value: true });
  const codegen_1 = /* @__PURE__ */ requireCodegen$1();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const code_1 = /* @__PURE__ */ requireCode$2();
  const additionalItems_1 = /* @__PURE__ */ requireAdditionalItems$1();
  const error = {
    message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
    params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
  };
  const def = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    error,
    code(cxt) {
      const { schema, parentSchema, it: it2 } = cxt;
      const { prefixItems: prefixItems2 } = parentSchema;
      it2.items = true;
      if ((0, util_1.alwaysValidSchema)(it2, schema))
        return;
      if (prefixItems2)
        (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems2);
      else
        cxt.ok((0, code_1.validateArray)(cxt));
    }
  };
  items2020$1.default = def;
  return items2020$1;
}
var contains$1 = {};
var hasRequiredContains$1;
function requireContains$1() {
  if (hasRequiredContains$1) return contains$1;
  hasRequiredContains$1 = 1;
  Object.defineProperty(contains$1, "__esModule", { value: true });
  const codegen_1 = /* @__PURE__ */ requireCodegen$1();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const error = {
    message: ({ params: { min: min2, max: max2 } }) => max2 === void 0 ? (0, codegen_1.str)`must contain at least ${min2} valid item(s)` : (0, codegen_1.str)`must contain at least ${min2} and no more than ${max2} valid item(s)`,
    params: ({ params: { min: min2, max: max2 } }) => max2 === void 0 ? (0, codegen_1._)`{minContains: ${min2}}` : (0, codegen_1._)`{minContains: ${min2}, maxContains: ${max2}}`
  };
  const def = {
    keyword: "contains",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    trackErrors: true,
    error,
    code(cxt) {
      const { gen, schema, parentSchema, data: data2, it: it2 } = cxt;
      let min2;
      let max2;
      const { minContains, maxContains } = parentSchema;
      if (it2.opts.next) {
        min2 = minContains === void 0 ? 1 : minContains;
        max2 = maxContains;
      } else {
        min2 = 1;
      }
      const len = gen.const("len", (0, codegen_1._)`${data2}.length`);
      cxt.setParams({ min: min2, max: max2 });
      if (max2 === void 0 && min2 === 0) {
        (0, util_1.checkStrictMode)(it2, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
        return;
      }
      if (max2 !== void 0 && min2 > max2) {
        (0, util_1.checkStrictMode)(it2, `"minContains" > "maxContains" is always invalid`);
        cxt.fail();
        return;
      }
      if ((0, util_1.alwaysValidSchema)(it2, schema)) {
        let cond = (0, codegen_1._)`${len} >= ${min2}`;
        if (max2 !== void 0)
          cond = (0, codegen_1._)`${cond} && ${len} <= ${max2}`;
        cxt.pass(cond);
        return;
      }
      it2.items = true;
      const valid = gen.name("valid");
      if (max2 === void 0 && min2 === 1) {
        validateItems(valid, () => gen.if(valid, () => gen.break()));
      } else if (min2 === 0) {
        gen.let(valid, true);
        if (max2 !== void 0)
          gen.if((0, codegen_1._)`${data2}.length > 0`, validateItemsWithCount);
      } else {
        gen.let(valid, false);
        validateItemsWithCount();
      }
      cxt.result(valid, () => cxt.reset());
      function validateItemsWithCount() {
        const schValid = gen.name("_valid");
        const count2 = gen.let("count", 0);
        validateItems(schValid, () => gen.if(schValid, () => checkLimits(count2)));
      }
      function validateItems(_valid, block) {
        gen.forRange("i", 0, len, (i) => {
          cxt.subschema({
            keyword: "contains",
            dataProp: i,
            dataPropType: util_1.Type.Num,
            compositeRule: true
          }, _valid);
          block();
        });
      }
      function checkLimits(count2) {
        gen.code((0, codegen_1._)`${count2}++`);
        if (max2 === void 0) {
          gen.if((0, codegen_1._)`${count2} >= ${min2}`, () => gen.assign(valid, true).break());
        } else {
          gen.if((0, codegen_1._)`${count2} > ${max2}`, () => gen.assign(valid, false).break());
          if (min2 === 1)
            gen.assign(valid, true);
          else
            gen.if((0, codegen_1._)`${count2} >= ${min2}`, () => gen.assign(valid, true));
        }
      }
    }
  };
  contains$1.default = def;
  return contains$1;
}
var dependencies$1 = {};
var hasRequiredDependencies$1;
function requireDependencies$1() {
  if (hasRequiredDependencies$1) return dependencies$1;
  hasRequiredDependencies$1 = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.validateSchemaDeps = exports$1.validatePropertyDeps = exports$1.error = void 0;
    const codegen_1 = /* @__PURE__ */ requireCodegen$1();
    const util_1 = /* @__PURE__ */ requireUtil$1();
    const code_1 = /* @__PURE__ */ requireCode$2();
    exports$1.error = {
      message: ({ params: { property, depsCount, deps } }) => {
        const property_ies = depsCount === 1 ? "property" : "properties";
        return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
      },
      params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
      // TODO change to reference
    };
    const def = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: exports$1.error,
      code(cxt) {
        const [propDeps, schDeps] = splitDependencies(cxt);
        validatePropertyDeps(cxt, propDeps);
        validateSchemaDeps(cxt, schDeps);
      }
    };
    function splitDependencies({ schema }) {
      const propertyDeps = {};
      const schemaDeps = {};
      for (const key in schema) {
        if (key === "__proto__")
          continue;
        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
        deps[key] = schema[key];
      }
      return [propertyDeps, schemaDeps];
    }
    function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
      const { gen, data: data2, it: it2 } = cxt;
      if (Object.keys(propertyDeps).length === 0)
        return;
      const missing = gen.let("missing");
      for (const prop in propertyDeps) {
        const deps = propertyDeps[prop];
        if (deps.length === 0)
          continue;
        const hasProperty = (0, code_1.propertyInData)(gen, data2, prop, it2.opts.ownProperties);
        cxt.setParams({
          property: prop,
          depsCount: deps.length,
          deps: deps.join(", ")
        });
        if (it2.allErrors) {
          gen.if(hasProperty, () => {
            for (const depProp of deps) {
              (0, code_1.checkReportMissingProp)(cxt, depProp);
            }
          });
        } else {
          gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
          (0, code_1.reportMissingProp)(cxt, missing);
          gen.else();
        }
      }
    }
    exports$1.validatePropertyDeps = validatePropertyDeps;
    function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
      const { gen, data: data2, keyword: keyword2, it: it2 } = cxt;
      const valid = gen.name("valid");
      for (const prop in schemaDeps) {
        if ((0, util_1.alwaysValidSchema)(it2, schemaDeps[prop]))
          continue;
        gen.if(
          (0, code_1.propertyInData)(gen, data2, prop, it2.opts.ownProperties),
          () => {
            const schCxt = cxt.subschema({ keyword: keyword2, schemaProp: prop }, valid);
            cxt.mergeValidEvaluated(schCxt, valid);
          },
          () => gen.var(valid, true)
          // TODO var
        );
        cxt.ok(valid);
      }
    }
    exports$1.validateSchemaDeps = validateSchemaDeps;
    exports$1.default = def;
  })(dependencies$1);
  return dependencies$1;
}
var propertyNames$1 = {};
var hasRequiredPropertyNames$1;
function requirePropertyNames$1() {
  if (hasRequiredPropertyNames$1) return propertyNames$1;
  hasRequiredPropertyNames$1 = 1;
  Object.defineProperty(propertyNames$1, "__esModule", { value: true });
  const codegen_1 = /* @__PURE__ */ requireCodegen$1();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const error = {
    message: "property name must be valid",
    params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
  };
  const def = {
    keyword: "propertyNames",
    type: "object",
    schemaType: ["object", "boolean"],
    error,
    code(cxt) {
      const { gen, schema, data: data2, it: it2 } = cxt;
      if ((0, util_1.alwaysValidSchema)(it2, schema))
        return;
      const valid = gen.name("valid");
      gen.forIn("key", data2, (key) => {
        cxt.setParams({ propertyName: key });
        cxt.subschema({
          keyword: "propertyNames",
          data: key,
          dataTypes: ["string"],
          propertyName: key,
          compositeRule: true
        }, valid);
        gen.if((0, codegen_1.not)(valid), () => {
          cxt.error(true);
          if (!it2.allErrors)
            gen.break();
        });
      });
      cxt.ok(valid);
    }
  };
  propertyNames$1.default = def;
  return propertyNames$1;
}
var additionalProperties$2 = {};
var hasRequiredAdditionalProperties$1;
function requireAdditionalProperties$1() {
  if (hasRequiredAdditionalProperties$1) return additionalProperties$2;
  hasRequiredAdditionalProperties$1 = 1;
  Object.defineProperty(additionalProperties$2, "__esModule", { value: true });
  const code_1 = /* @__PURE__ */ requireCode$2();
  const codegen_1 = /* @__PURE__ */ requireCodegen$1();
  const names_1 = /* @__PURE__ */ requireNames$1();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const error = {
    message: "must NOT have additional properties",
    params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
  };
  const def = {
    keyword: "additionalProperties",
    type: ["object"],
    schemaType: ["boolean", "object"],
    allowUndefined: true,
    trackErrors: true,
    error,
    code(cxt) {
      const { gen, schema, parentSchema, data: data2, errsCount, it: it2 } = cxt;
      if (!errsCount)
        throw new Error("ajv implementation error");
      const { allErrors, opts } = it2;
      it2.props = true;
      if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it2, schema))
        return;
      const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
      const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
      checkAdditionalProperties();
      cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
      function checkAdditionalProperties() {
        gen.forIn("key", data2, (key) => {
          if (!props.length && !patProps.length)
            additionalPropertyCode(key);
          else
            gen.if(isAdditional(key), () => additionalPropertyCode(key));
        });
      }
      function isAdditional(key) {
        let definedProp;
        if (props.length > 8) {
          const propsSchema = (0, util_1.schemaRefOrVal)(it2, parentSchema.properties, "properties");
          definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
        } else if (props.length) {
          definedProp = (0, codegen_1.or)(...props.map((p2) => (0, codegen_1._)`${key} === ${p2}`));
        } else {
          definedProp = codegen_1.nil;
        }
        if (patProps.length) {
          definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p2) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p2)}.test(${key})`));
        }
        return (0, codegen_1.not)(definedProp);
      }
      function deleteAdditional(key) {
        gen.code((0, codegen_1._)`delete ${data2}[${key}]`);
      }
      function additionalPropertyCode(key) {
        if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
          deleteAdditional(key);
          return;
        }
        if (schema === false) {
          cxt.setParams({ additionalProperty: key });
          cxt.error();
          if (!allErrors)
            gen.break();
          return;
        }
        if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it2, schema)) {
          const valid = gen.name("valid");
          if (opts.removeAdditional === "failing") {
            applyAdditionalSchema(key, valid, false);
            gen.if((0, codegen_1.not)(valid), () => {
              cxt.reset();
              deleteAdditional(key);
            });
          } else {
            applyAdditionalSchema(key, valid);
            if (!allErrors)
              gen.if((0, codegen_1.not)(valid), () => gen.break());
          }
        }
      }
      function applyAdditionalSchema(key, valid, errors2) {
        const subschema2 = {
          keyword: "additionalProperties",
          dataProp: key,
          dataPropType: util_1.Type.Str
        };
        if (errors2 === false) {
          Object.assign(subschema2, {
            compositeRule: true,
            createErrors: false,
            allErrors: false
          });
        }
        cxt.subschema(subschema2, valid);
      }
    }
  };
  additionalProperties$2.default = def;
  return additionalProperties$2;
}
var properties$4 = {};
var hasRequiredProperties$1;
function requireProperties$1() {
  if (hasRequiredProperties$1) return properties$4;
  hasRequiredProperties$1 = 1;
  Object.defineProperty(properties$4, "__esModule", { value: true });
  const validate_1 = /* @__PURE__ */ requireValidate$1();
  const code_1 = /* @__PURE__ */ requireCode$2();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const additionalProperties_1 = /* @__PURE__ */ requireAdditionalProperties$1();
  const def = {
    keyword: "properties",
    type: "object",
    schemaType: "object",
    code(cxt) {
      const { gen, schema, parentSchema, data: data2, it: it2 } = cxt;
      if (it2.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
        additionalProperties_1.default.code(new validate_1.KeywordCxt(it2, additionalProperties_1.default, "additionalProperties"));
      }
      const allProps = (0, code_1.allSchemaProperties)(schema);
      for (const prop of allProps) {
        it2.definedProperties.add(prop);
      }
      if (it2.opts.unevaluated && allProps.length && it2.props !== true) {
        it2.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it2.props);
      }
      const properties2 = allProps.filter((p2) => !(0, util_1.alwaysValidSchema)(it2, schema[p2]));
      if (properties2.length === 0)
        return;
      const valid = gen.name("valid");
      for (const prop of properties2) {
        if (hasDefault(prop)) {
          applyPropertySchema(prop);
        } else {
          gen.if((0, code_1.propertyInData)(gen, data2, prop, it2.opts.ownProperties));
          applyPropertySchema(prop);
          if (!it2.allErrors)
            gen.else().var(valid, true);
          gen.endIf();
        }
        cxt.it.definedProperties.add(prop);
        cxt.ok(valid);
      }
      function hasDefault(prop) {
        return it2.opts.useDefaults && !it2.compositeRule && schema[prop].default !== void 0;
      }
      function applyPropertySchema(prop) {
        cxt.subschema({
          keyword: "properties",
          schemaProp: prop,
          dataProp: prop
        }, valid);
      }
    }
  };
  properties$4.default = def;
  return properties$4;
}
var patternProperties$1 = {};
var hasRequiredPatternProperties$1;
function requirePatternProperties$1() {
  if (hasRequiredPatternProperties$1) return patternProperties$1;
  hasRequiredPatternProperties$1 = 1;
  Object.defineProperty(patternProperties$1, "__esModule", { value: true });
  const code_1 = /* @__PURE__ */ requireCode$2();
  const codegen_1 = /* @__PURE__ */ requireCodegen$1();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const util_2 = /* @__PURE__ */ requireUtil$1();
  const def = {
    keyword: "patternProperties",
    type: "object",
    schemaType: "object",
    code(cxt) {
      const { gen, schema, data: data2, parentSchema, it: it2 } = cxt;
      const { opts } = it2;
      const patterns = (0, code_1.allSchemaProperties)(schema);
      const alwaysValidPatterns = patterns.filter((p2) => (0, util_1.alwaysValidSchema)(it2, schema[p2]));
      if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it2.opts.unevaluated || it2.props === true)) {
        return;
      }
      const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
      const valid = gen.name("valid");
      if (it2.props !== true && !(it2.props instanceof codegen_1.Name)) {
        it2.props = (0, util_2.evaluatedPropsToName)(gen, it2.props);
      }
      const { props } = it2;
      validatePatternProperties();
      function validatePatternProperties() {
        for (const pat of patterns) {
          if (checkProperties)
            checkMatchingProperties(pat);
          if (it2.allErrors) {
            validateProperties(pat);
          } else {
            gen.var(valid, true);
            validateProperties(pat);
            gen.if(valid);
          }
        }
      }
      function checkMatchingProperties(pat) {
        for (const prop in checkProperties) {
          if (new RegExp(pat).test(prop)) {
            (0, util_1.checkStrictMode)(it2, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
          }
        }
      }
      function validateProperties(pat) {
        gen.forIn("key", data2, (key) => {
          gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
            const alwaysValid = alwaysValidPatterns.includes(pat);
            if (!alwaysValid) {
              cxt.subschema({
                keyword: "patternProperties",
                schemaProp: pat,
                dataProp: key,
                dataPropType: util_2.Type.Str
              }, valid);
            }
            if (it2.opts.unevaluated && props !== true) {
              gen.assign((0, codegen_1._)`${props}[${key}]`, true);
            } else if (!alwaysValid && !it2.allErrors) {
              gen.if((0, codegen_1.not)(valid), () => gen.break());
            }
          });
        });
      }
    }
  };
  patternProperties$1.default = def;
  return patternProperties$1;
}
var not$1 = {};
var hasRequiredNot$1;
function requireNot$1() {
  if (hasRequiredNot$1) return not$1;
  hasRequiredNot$1 = 1;
  Object.defineProperty(not$1, "__esModule", { value: true });
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const def = {
    keyword: "not",
    schemaType: ["object", "boolean"],
    trackErrors: true,
    code(cxt) {
      const { gen, schema, it: it2 } = cxt;
      if ((0, util_1.alwaysValidSchema)(it2, schema)) {
        cxt.fail();
        return;
      }
      const valid = gen.name("valid");
      cxt.subschema({
        keyword: "not",
        compositeRule: true,
        createErrors: false,
        allErrors: false
      }, valid);
      cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
    },
    error: { message: "must NOT be valid" }
  };
  not$1.default = def;
  return not$1;
}
var anyOf$1 = {};
var hasRequiredAnyOf$1;
function requireAnyOf$1() {
  if (hasRequiredAnyOf$1) return anyOf$1;
  hasRequiredAnyOf$1 = 1;
  Object.defineProperty(anyOf$1, "__esModule", { value: true });
  const code_1 = /* @__PURE__ */ requireCode$2();
  const def = {
    keyword: "anyOf",
    schemaType: "array",
    trackErrors: true,
    code: code_1.validateUnion,
    error: { message: "must match a schema in anyOf" }
  };
  anyOf$1.default = def;
  return anyOf$1;
}
var oneOf$1 = {};
var hasRequiredOneOf$1;
function requireOneOf$1() {
  if (hasRequiredOneOf$1) return oneOf$1;
  hasRequiredOneOf$1 = 1;
  Object.defineProperty(oneOf$1, "__esModule", { value: true });
  const codegen_1 = /* @__PURE__ */ requireCodegen$1();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const error = {
    message: "must match exactly one schema in oneOf",
    params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
  };
  const def = {
    keyword: "oneOf",
    schemaType: "array",
    trackErrors: true,
    error,
    code(cxt) {
      const { gen, schema, parentSchema, it: it2 } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      if (it2.opts.discriminator && parentSchema.discriminator)
        return;
      const schArr = schema;
      const valid = gen.let("valid", false);
      const passing = gen.let("passing", null);
      const schValid = gen.name("_valid");
      cxt.setParams({ passing });
      gen.block(validateOneOf);
      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
      function validateOneOf() {
        schArr.forEach((sch, i) => {
          let schCxt;
          if ((0, util_1.alwaysValidSchema)(it2, sch)) {
            gen.var(schValid, true);
          } else {
            schCxt = cxt.subschema({
              keyword: "oneOf",
              schemaProp: i,
              compositeRule: true
            }, schValid);
          }
          if (i > 0) {
            gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();
          }
          gen.if(schValid, () => {
            gen.assign(valid, true);
            gen.assign(passing, i);
            if (schCxt)
              cxt.mergeEvaluated(schCxt, codegen_1.Name);
          });
        });
      }
    }
  };
  oneOf$1.default = def;
  return oneOf$1;
}
var allOf$1 = {};
var hasRequiredAllOf$1;
function requireAllOf$1() {
  if (hasRequiredAllOf$1) return allOf$1;
  hasRequiredAllOf$1 = 1;
  Object.defineProperty(allOf$1, "__esModule", { value: true });
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const def = {
    keyword: "allOf",
    schemaType: "array",
    code(cxt) {
      const { gen, schema, it: it2 } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const valid = gen.name("valid");
      schema.forEach((sch, i) => {
        if ((0, util_1.alwaysValidSchema)(it2, sch))
          return;
        const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
        cxt.ok(valid);
        cxt.mergeEvaluated(schCxt);
      });
    }
  };
  allOf$1.default = def;
  return allOf$1;
}
var _if$1 = {};
var hasRequired_if$1;
function require_if$1() {
  if (hasRequired_if$1) return _if$1;
  hasRequired_if$1 = 1;
  Object.defineProperty(_if$1, "__esModule", { value: true });
  const codegen_1 = /* @__PURE__ */ requireCodegen$1();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const error = {
    message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
    params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
  };
  const def = {
    keyword: "if",
    schemaType: ["object", "boolean"],
    trackErrors: true,
    error,
    code(cxt) {
      const { gen, parentSchema, it: it2 } = cxt;
      if (parentSchema.then === void 0 && parentSchema.else === void 0) {
        (0, util_1.checkStrictMode)(it2, '"if" without "then" and "else" is ignored');
      }
      const hasThen = hasSchema(it2, "then");
      const hasElse = hasSchema(it2, "else");
      if (!hasThen && !hasElse)
        return;
      const valid = gen.let("valid", true);
      const schValid = gen.name("_valid");
      validateIf();
      cxt.reset();
      if (hasThen && hasElse) {
        const ifClause = gen.let("ifClause");
        cxt.setParams({ ifClause });
        gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
      } else if (hasThen) {
        gen.if(schValid, validateClause("then"));
      } else {
        gen.if((0, codegen_1.not)(schValid), validateClause("else"));
      }
      cxt.pass(valid, () => cxt.error(true));
      function validateIf() {
        const schCxt = cxt.subschema({
          keyword: "if",
          compositeRule: true,
          createErrors: false,
          allErrors: false
        }, schValid);
        cxt.mergeEvaluated(schCxt);
      }
      function validateClause(keyword2, ifClause) {
        return () => {
          const schCxt = cxt.subschema({ keyword: keyword2 }, schValid);
          gen.assign(valid, schValid);
          cxt.mergeValidEvaluated(schCxt, valid);
          if (ifClause)
            gen.assign(ifClause, (0, codegen_1._)`${keyword2}`);
          else
            cxt.setParams({ ifClause: keyword2 });
        };
      }
    }
  };
  function hasSchema(it2, keyword2) {
    const schema = it2.schema[keyword2];
    return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it2, schema);
  }
  _if$1.default = def;
  return _if$1;
}
var thenElse$1 = {};
var hasRequiredThenElse$1;
function requireThenElse$1() {
  if (hasRequiredThenElse$1) return thenElse$1;
  hasRequiredThenElse$1 = 1;
  Object.defineProperty(thenElse$1, "__esModule", { value: true });
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const def = {
    keyword: ["then", "else"],
    schemaType: ["object", "boolean"],
    code({ keyword: keyword2, parentSchema, it: it2 }) {
      if (parentSchema.if === void 0)
        (0, util_1.checkStrictMode)(it2, `"${keyword2}" without "if" is ignored`);
    }
  };
  thenElse$1.default = def;
  return thenElse$1;
}
var hasRequiredApplicator$1;
function requireApplicator$1() {
  if (hasRequiredApplicator$1) return applicator$1;
  hasRequiredApplicator$1 = 1;
  Object.defineProperty(applicator$1, "__esModule", { value: true });
  const additionalItems_1 = /* @__PURE__ */ requireAdditionalItems$1();
  const prefixItems_1 = /* @__PURE__ */ requirePrefixItems$1();
  const items_1 = /* @__PURE__ */ requireItems$1();
  const items2020_1 = /* @__PURE__ */ requireItems2020$1();
  const contains_1 = /* @__PURE__ */ requireContains$1();
  const dependencies_1 = /* @__PURE__ */ requireDependencies$1();
  const propertyNames_1 = /* @__PURE__ */ requirePropertyNames$1();
  const additionalProperties_1 = /* @__PURE__ */ requireAdditionalProperties$1();
  const properties_1 = /* @__PURE__ */ requireProperties$1();
  const patternProperties_1 = /* @__PURE__ */ requirePatternProperties$1();
  const not_1 = /* @__PURE__ */ requireNot$1();
  const anyOf_1 = /* @__PURE__ */ requireAnyOf$1();
  const oneOf_1 = /* @__PURE__ */ requireOneOf$1();
  const allOf_1 = /* @__PURE__ */ requireAllOf$1();
  const if_1 = /* @__PURE__ */ require_if$1();
  const thenElse_1 = /* @__PURE__ */ requireThenElse$1();
  function getApplicator(draft2020 = false) {
    const applicator2 = [
      // any
      not_1.default,
      anyOf_1.default,
      oneOf_1.default,
      allOf_1.default,
      if_1.default,
      thenElse_1.default,
      // object
      propertyNames_1.default,
      additionalProperties_1.default,
      dependencies_1.default,
      properties_1.default,
      patternProperties_1.default
    ];
    if (draft2020)
      applicator2.push(prefixItems_1.default, items2020_1.default);
    else
      applicator2.push(additionalItems_1.default, items_1.default);
    applicator2.push(contains_1.default);
    return applicator2;
  }
  applicator$1.default = getApplicator;
  return applicator$1;
}
var format$3 = {};
var format$2 = {};
var hasRequiredFormat$3;
function requireFormat$3() {
  if (hasRequiredFormat$3) return format$2;
  hasRequiredFormat$3 = 1;
  Object.defineProperty(format$2, "__esModule", { value: true });
  const codegen_1 = /* @__PURE__ */ requireCodegen$1();
  const error = {
    message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
    params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
  };
  const def = {
    keyword: "format",
    type: ["number", "string"],
    schemaType: "string",
    $data: true,
    error,
    code(cxt, ruleType) {
      const { gen, data: data2, $data, schema, schemaCode, it: it2 } = cxt;
      const { opts, errSchemaPath, schemaEnv, self: self2 } = it2;
      if (!opts.validateFormats)
        return;
      if ($data)
        validate$DataFormat();
      else
        validateFormat();
      function validate$DataFormat() {
        const fmts = gen.scopeValue("formats", {
          ref: self2.formats,
          code: opts.code.formats
        });
        const fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
        const fType = gen.let("fType");
        const format2 = gen.let("format");
        gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format2, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format2, fDef));
        cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
        function unknownFmt() {
          if (opts.strictSchema === false)
            return codegen_1.nil;
          return (0, codegen_1._)`${schemaCode} && !${format2}`;
        }
        function invalidFmt() {
          const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format2}(${data2}) : ${format2}(${data2}))` : (0, codegen_1._)`${format2}(${data2})`;
          const validData = (0, codegen_1._)`(typeof ${format2} == "function" ? ${callFormat} : ${format2}.test(${data2}))`;
          return (0, codegen_1._)`${format2} && ${format2} !== true && ${fType} === ${ruleType} && !${validData}`;
        }
      }
      function validateFormat() {
        const formatDef = self2.formats[schema];
        if (!formatDef) {
          unknownFormat();
          return;
        }
        if (formatDef === true)
          return;
        const [fmtType, format2, fmtRef] = getFormat(formatDef);
        if (fmtType === ruleType)
          cxt.pass(validCondition());
        function unknownFormat() {
          if (opts.strictSchema === false) {
            self2.logger.warn(unknownMsg());
            return;
          }
          throw new Error(unknownMsg());
          function unknownMsg() {
            return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
          }
        }
        function getFormat(fmtDef) {
          const code2 = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : void 0;
          const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code: code2 });
          if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
            return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
          }
          return ["string", fmtDef, fmt];
        }
        function validCondition() {
          if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
            if (!schemaEnv.$async)
              throw new Error("async format in sync schema");
            return (0, codegen_1._)`await ${fmtRef}(${data2})`;
          }
          return typeof format2 == "function" ? (0, codegen_1._)`${fmtRef}(${data2})` : (0, codegen_1._)`${fmtRef}.test(${data2})`;
        }
      }
    }
  };
  format$2.default = def;
  return format$2;
}
var hasRequiredFormat$2;
function requireFormat$2() {
  if (hasRequiredFormat$2) return format$3;
  hasRequiredFormat$2 = 1;
  Object.defineProperty(format$3, "__esModule", { value: true });
  const format_1 = /* @__PURE__ */ requireFormat$3();
  const format2 = [format_1.default];
  format$3.default = format2;
  return format$3;
}
var metadata$1 = {};
var hasRequiredMetadata$1;
function requireMetadata$1() {
  if (hasRequiredMetadata$1) return metadata$1;
  hasRequiredMetadata$1 = 1;
  Object.defineProperty(metadata$1, "__esModule", { value: true });
  metadata$1.contentVocabulary = metadata$1.metadataVocabulary = void 0;
  metadata$1.metadataVocabulary = [
    "title",
    "description",
    "default",
    "deprecated",
    "readOnly",
    "writeOnly",
    "examples"
  ];
  metadata$1.contentVocabulary = [
    "contentMediaType",
    "contentEncoding",
    "contentSchema"
  ];
  return metadata$1;
}
var hasRequiredDraft7$1;
function requireDraft7$1() {
  if (hasRequiredDraft7$1) return draft7$1;
  hasRequiredDraft7$1 = 1;
  Object.defineProperty(draft7$1, "__esModule", { value: true });
  const core_1 = /* @__PURE__ */ requireCore$2();
  const validation_1 = /* @__PURE__ */ requireValidation$1();
  const applicator_1 = /* @__PURE__ */ requireApplicator$1();
  const format_1 = /* @__PURE__ */ requireFormat$2();
  const metadata_1 = /* @__PURE__ */ requireMetadata$1();
  const draft7Vocabularies = [
    core_1.default,
    validation_1.default,
    (0, applicator_1.default)(),
    format_1.default,
    metadata_1.metadataVocabulary,
    metadata_1.contentVocabulary
  ];
  draft7$1.default = draft7Vocabularies;
  return draft7$1;
}
var discriminator$1 = {};
var types$1 = {};
var hasRequiredTypes$1;
function requireTypes$1() {
  if (hasRequiredTypes$1) return types$1;
  hasRequiredTypes$1 = 1;
  Object.defineProperty(types$1, "__esModule", { value: true });
  types$1.DiscrError = void 0;
  var DiscrError;
  (function(DiscrError2) {
    DiscrError2["Tag"] = "tag";
    DiscrError2["Mapping"] = "mapping";
  })(DiscrError || (types$1.DiscrError = DiscrError = {}));
  return types$1;
}
var hasRequiredDiscriminator$1;
function requireDiscriminator$1() {
  if (hasRequiredDiscriminator$1) return discriminator$1;
  hasRequiredDiscriminator$1 = 1;
  Object.defineProperty(discriminator$1, "__esModule", { value: true });
  const codegen_1 = /* @__PURE__ */ requireCodegen$1();
  const types_1 = /* @__PURE__ */ requireTypes$1();
  const compile_12 = /* @__PURE__ */ requireCompile$1();
  const ref_error_1 = /* @__PURE__ */ requireRef_error$1();
  const util_1 = /* @__PURE__ */ requireUtil$1();
  const error = {
    message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
    params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
  };
  const def = {
    keyword: "discriminator",
    type: "object",
    schemaType: "object",
    error,
    code(cxt) {
      const { gen, data: data2, schema, parentSchema, it: it2 } = cxt;
      const { oneOf: oneOf2 } = parentSchema;
      if (!it2.opts.discriminator) {
        throw new Error("discriminator: requires discriminator option");
      }
      const tagName = schema.propertyName;
      if (typeof tagName != "string")
        throw new Error("discriminator: requires propertyName");
      if (schema.mapping)
        throw new Error("discriminator: mapping is not supported");
      if (!oneOf2)
        throw new Error("discriminator: requires oneOf keyword");
      const valid = gen.let("valid", false);
      const tag = gen.const("tag", (0, codegen_1._)`${data2}${(0, codegen_1.getProperty)(tagName)}`);
      gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
      cxt.ok(valid);
      function validateMapping() {
        const mapping = getMapping();
        gen.if(false);
        for (const tagValue in mapping) {
          gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
          gen.assign(valid, applyTagSchema(mapping[tagValue]));
        }
        gen.else();
        cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
        gen.endIf();
      }
      function applyTagSchema(schemaProp) {
        const _valid = gen.name("valid");
        const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
        cxt.mergeEvaluated(schCxt, codegen_1.Name);
        return _valid;
      }
      function getMapping() {
        var _a2;
        const oneOfMapping = {};
        const topRequired = hasRequired(parentSchema);
        let tagRequired = true;
        for (let i = 0; i < oneOf2.length; i++) {
          let sch = oneOf2[i];
          if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it2.self.RULES)) {
            const ref2 = sch.$ref;
            sch = compile_12.resolveRef.call(it2.self, it2.schemaEnv.root, it2.baseId, ref2);
            if (sch instanceof compile_12.SchemaEnv)
              sch = sch.schema;
            if (sch === void 0)
              throw new ref_error_1.default(it2.opts.uriResolver, it2.baseId, ref2);
          }
          const propSch = (_a2 = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a2 === void 0 ? void 0 : _a2[tagName];
          if (typeof propSch != "object") {
            throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
          }
          tagRequired = tagRequired && (topRequired || hasRequired(sch));
          addMappings(propSch, i);
        }
        if (!tagRequired)
          throw new Error(`discriminator: "${tagName}" must be required`);
        return oneOfMapping;
        function hasRequired({ required: required2 }) {
          return Array.isArray(required2) && required2.includes(tagName);
        }
        function addMappings(sch, i) {
          if (sch.const) {
            addMapping(sch.const, i);
          } else if (sch.enum) {
            for (const tagValue of sch.enum) {
              addMapping(tagValue, i);
            }
          } else {
            throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
          }
        }
        function addMapping(tagValue, i) {
          if (typeof tagValue != "string" || tagValue in oneOfMapping) {
            throw new Error(`discriminator: "${tagName}" values must be unique strings`);
          }
          oneOfMapping[tagValue] = i;
        }
      }
    }
  };
  discriminator$1.default = def;
  return discriminator$1;
}
const $schema$1 = "http://json-schema.org/draft-07/schema#";
const $id$2 = "http://json-schema.org/draft-07/schema#";
const title$1 = "Core schema meta-schema";
const definitions$1 = { "schemaArray": { "type": "array", "minItems": 1, "items": { "$ref": "#" } }, "nonNegativeInteger": { "type": "integer", "minimum": 0 }, "nonNegativeIntegerDefault0": { "allOf": [{ "$ref": "#/definitions/nonNegativeInteger" }, { "default": 0 }] }, "simpleTypes": { "enum": ["array", "boolean", "integer", "null", "number", "object", "string"] }, "stringArray": { "type": "array", "items": { "type": "string" }, "uniqueItems": true, "default": [] } };
const type$2 = ["object", "boolean"];
const properties$3 = { "$id": { "type": "string", "format": "uri-reference" }, "$schema": { "type": "string", "format": "uri" }, "$ref": { "type": "string", "format": "uri-reference" }, "$comment": { "type": "string" }, "title": { "type": "string" }, "description": { "type": "string" }, "default": true, "readOnly": { "type": "boolean", "default": false }, "examples": { "type": "array", "items": true }, "multipleOf": { "type": "number", "exclusiveMinimum": 0 }, "maximum": { "type": "number" }, "exclusiveMaximum": { "type": "number" }, "minimum": { "type": "number" }, "exclusiveMinimum": { "type": "number" }, "maxLength": { "$ref": "#/definitions/nonNegativeInteger" }, "minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "pattern": { "type": "string", "format": "regex" }, "additionalItems": { "$ref": "#" }, "items": { "anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/schemaArray" }], "default": true }, "maxItems": { "$ref": "#/definitions/nonNegativeInteger" }, "minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "uniqueItems": { "type": "boolean", "default": false }, "contains": { "$ref": "#" }, "maxProperties": { "$ref": "#/definitions/nonNegativeInteger" }, "minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "required": { "$ref": "#/definitions/stringArray" }, "additionalProperties": { "$ref": "#" }, "definitions": { "type": "object", "additionalProperties": { "$ref": "#" }, "default": {} }, "properties": { "type": "object", "additionalProperties": { "$ref": "#" }, "default": {} }, "patternProperties": { "type": "object", "additionalProperties": { "$ref": "#" }, "propertyNames": { "format": "regex" }, "default": {} }, "dependencies": { "type": "object", "additionalProperties": { "anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/stringArray" }] } }, "propertyNames": { "$ref": "#" }, "const": true, "enum": { "type": "array", "items": true, "minItems": 1, "uniqueItems": true }, "type": { "anyOf": [{ "$ref": "#/definitions/simpleTypes" }, { "type": "array", "items": { "$ref": "#/definitions/simpleTypes" }, "minItems": 1, "uniqueItems": true }] }, "format": { "type": "string" }, "contentMediaType": { "type": "string" }, "contentEncoding": { "type": "string" }, "if": { "$ref": "#" }, "then": { "$ref": "#" }, "else": { "$ref": "#" }, "allOf": { "$ref": "#/definitions/schemaArray" }, "anyOf": { "$ref": "#/definitions/schemaArray" }, "oneOf": { "$ref": "#/definitions/schemaArray" }, "not": { "$ref": "#" } };
const require$$3$1 = {
  $schema: $schema$1,
  $id: $id$2,
  title: title$1,
  definitions: definitions$1,
  type: type$2,
  properties: properties$3,
  "default": true
};
var hasRequiredAjv$1;
function requireAjv$1() {
  if (hasRequiredAjv$1) return ajv$1.exports;
  hasRequiredAjv$1 = 1;
  (function(module, exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.MissingRefError = exports$1.ValidationError = exports$1.CodeGen = exports$1.Name = exports$1.nil = exports$1.stringify = exports$1.str = exports$1._ = exports$1.KeywordCxt = exports$1.Ajv = void 0;
    const core_1 = /* @__PURE__ */ requireCore$3();
    const draft7_1 = /* @__PURE__ */ requireDraft7$1();
    const discriminator_1 = /* @__PURE__ */ requireDiscriminator$1();
    const draft7MetaSchema = require$$3$1;
    const META_SUPPORT_DATA = ["/properties"];
    const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
    class Ajv2 extends core_1.default {
      _addVocabularies() {
        super._addVocabularies();
        draft7_1.default.forEach((v) => this.addVocabulary(v));
        if (this.opts.discriminator)
          this.addKeyword(discriminator_1.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        if (!this.opts.meta)
          return;
        const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
    }
    exports$1.Ajv = Ajv2;
    module.exports = exports$1 = Ajv2;
    module.exports.Ajv = Ajv2;
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.default = Ajv2;
    var validate_1 = /* @__PURE__ */ requireValidate$1();
    Object.defineProperty(exports$1, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = /* @__PURE__ */ requireCodegen$1();
    Object.defineProperty(exports$1, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports$1, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports$1, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports$1, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports$1, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports$1, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = /* @__PURE__ */ requireValidation_error$1();
    Object.defineProperty(exports$1, "ValidationError", { enumerable: true, get: function() {
      return validation_error_1.default;
    } });
    var ref_error_1 = /* @__PURE__ */ requireRef_error$1();
    Object.defineProperty(exports$1, "MissingRefError", { enumerable: true, get: function() {
      return ref_error_1.default;
    } });
  })(ajv$1, ajv$1.exports);
  return ajv$1.exports;
}
var ajvExports = /* @__PURE__ */ requireAjv$1();
const Ajv = /* @__PURE__ */ getDefaultExportFromCjs(ajvExports);
var dist = { exports: {} };
var formats = {};
var hasRequiredFormats;
function requireFormats() {
  if (hasRequiredFormats) return formats;
  hasRequiredFormats = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.formatNames = exports$1.fastFormats = exports$1.fullFormats = void 0;
    function fmtDef(validate2, compare) {
      return { validate: validate2, compare };
    }
    exports$1.fullFormats = {
      // date: http://tools.ietf.org/html/rfc3339#section-5.6
      date: fmtDef(date2, compareDate),
      // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
      time: fmtDef(getTime(true), compareTime),
      "date-time": fmtDef(getDateTime(true), compareDateTime),
      "iso-time": fmtDef(getTime(), compareIsoTime),
      "iso-date-time": fmtDef(getDateTime(), compareIsoDateTime),
      // duration: https://tools.ietf.org/html/rfc3339#appendix-A
      duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
      uri: uri2,
      "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
      // uri-template: https://tools.ietf.org/html/rfc6570
      "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
      // For the source: https://gist.github.com/dperini/729294
      // For test cases: https://mathiasbynens.be/demo/url-regex
      url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
      email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
      hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
      // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
      ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
      regex,
      // uuid: http://tools.ietf.org/html/rfc4122
      uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
      // JSON-pointer: https://tools.ietf.org/html/rfc6901
      // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
      "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
      "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
      // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
      "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
      // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
      // byte: https://github.com/miguelmota/is-base64
      byte,
      // signed 32 bit integer
      int32: { type: "number", validate: validateInt32 },
      // signed 64 bit integer
      int64: { type: "number", validate: validateInt64 },
      // C-type float
      float: { type: "number", validate: validateNumber },
      // C-type double
      double: { type: "number", validate: validateNumber },
      // hint to the UI to hide input strings
      password: true,
      // unchecked string payload
      binary: true
    };
    exports$1.fastFormats = {
      ...exports$1.fullFormats,
      date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
      time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareTime),
      "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
      "iso-time": fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoTime),
      "iso-date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoDateTime),
      // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
      uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
      "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
      // email (sources from jsen validator):
      // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
      // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
      email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
    };
    exports$1.formatNames = Object.keys(exports$1.fullFormats);
    function isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    const DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
    const DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    function date2(str) {
      const matches = DATE.exec(str);
      if (!matches)
        return false;
      const year = +matches[1];
      const month = +matches[2];
      const day = +matches[3];
      return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
    }
    function compareDate(d1, d2) {
      if (!(d1 && d2))
        return void 0;
      if (d1 > d2)
        return 1;
      if (d1 < d2)
        return -1;
      return 0;
    }
    const TIME = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
    function getTime(strictTimeZone) {
      return function time2(str) {
        const matches = TIME.exec(str);
        if (!matches)
          return false;
        const hr2 = +matches[1];
        const min2 = +matches[2];
        const sec = +matches[3];
        const tz = matches[4];
        const tzSign = matches[5] === "-" ? -1 : 1;
        const tzH = +(matches[6] || 0);
        const tzM = +(matches[7] || 0);
        if (tzH > 23 || tzM > 59 || strictTimeZone && !tz)
          return false;
        if (hr2 <= 23 && min2 <= 59 && sec < 60)
          return true;
        const utcMin = min2 - tzM * tzSign;
        const utcHr = hr2 - tzH * tzSign - (utcMin < 0 ? 1 : 0);
        return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
      };
    }
    function compareTime(s1, s2) {
      if (!(s1 && s2))
        return void 0;
      const t1 = (/* @__PURE__ */ new Date("2020-01-01T" + s1)).valueOf();
      const t2 = (/* @__PURE__ */ new Date("2020-01-01T" + s2)).valueOf();
      if (!(t1 && t2))
        return void 0;
      return t1 - t2;
    }
    function compareIsoTime(t1, t2) {
      if (!(t1 && t2))
        return void 0;
      const a1 = TIME.exec(t1);
      const a2 = TIME.exec(t2);
      if (!(a1 && a2))
        return void 0;
      t1 = a1[1] + a1[2] + a1[3];
      t2 = a2[1] + a2[2] + a2[3];
      if (t1 > t2)
        return 1;
      if (t1 < t2)
        return -1;
      return 0;
    }
    const DATE_TIME_SEPARATOR = /t|\s/i;
    function getDateTime(strictTimeZone) {
      const time2 = getTime(strictTimeZone);
      return function date_time(str) {
        const dateTime = str.split(DATE_TIME_SEPARATOR);
        return dateTime.length === 2 && date2(dateTime[0]) && time2(dateTime[1]);
      };
    }
    function compareDateTime(dt1, dt2) {
      if (!(dt1 && dt2))
        return void 0;
      const d1 = new Date(dt1).valueOf();
      const d2 = new Date(dt2).valueOf();
      if (!(d1 && d2))
        return void 0;
      return d1 - d2;
    }
    function compareIsoDateTime(dt1, dt2) {
      if (!(dt1 && dt2))
        return void 0;
      const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
      const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
      const res = compareDate(d1, d2);
      if (res === void 0)
        return void 0;
      return res || compareTime(t1, t2);
    }
    const NOT_URI_FRAGMENT = /\/|:/;
    const URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    function uri2(str) {
      return NOT_URI_FRAGMENT.test(str) && URI.test(str);
    }
    const BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
    function byte(str) {
      BYTE.lastIndex = 0;
      return BYTE.test(str);
    }
    const MIN_INT32 = -2147483648;
    const MAX_INT32 = 2 ** 31 - 1;
    function validateInt32(value) {
      return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
    }
    function validateInt64(value) {
      return Number.isInteger(value);
    }
    function validateNumber() {
      return true;
    }
    const Z_ANCHOR = /[^\\]\\Z/;
    function regex(str) {
      if (Z_ANCHOR.test(str))
        return false;
      try {
        new RegExp(str);
        return true;
      } catch (e) {
        return false;
      }
    }
  })(formats);
  return formats;
}
var limit = {};
var ajv = { exports: {} };
var core$1 = {};
var validate = {};
var boolSchema = {};
var errors = {};
var codegen = {};
var code$1 = {};
var hasRequiredCode$1;
function requireCode$1() {
  if (hasRequiredCode$1) return code$1;
  hasRequiredCode$1 = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.regexpCode = exports$1.getEsmExportName = exports$1.getProperty = exports$1.safeStringify = exports$1.stringify = exports$1.strConcat = exports$1.addCodeArg = exports$1.str = exports$1._ = exports$1.nil = exports$1._Code = exports$1.Name = exports$1.IDENTIFIER = exports$1._CodeOrName = void 0;
    class _CodeOrName {
    }
    exports$1._CodeOrName = _CodeOrName;
    exports$1.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    class Name extends _CodeOrName {
      constructor(s2) {
        super();
        if (!exports$1.IDENTIFIER.test(s2))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = s2;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return false;
      }
      get names() {
        return { [this.str]: 1 };
      }
    }
    exports$1.Name = Name;
    class _Code extends _CodeOrName {
      constructor(code2) {
        super();
        this._items = typeof code2 === "string" ? [code2] : code2;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return false;
        const item = this._items[0];
        return item === "" || item === '""';
      }
      get str() {
        var _a2;
        return (_a2 = this._str) !== null && _a2 !== void 0 ? _a2 : this._str = this._items.reduce((s2, c) => `${s2}${c}`, "");
      }
      get names() {
        var _a2;
        return (_a2 = this._names) !== null && _a2 !== void 0 ? _a2 : this._names = this._items.reduce((names2, c) => {
          if (c instanceof Name)
            names2[c.str] = (names2[c.str] || 0) + 1;
          return names2;
        }, {});
      }
    }
    exports$1._Code = _Code;
    exports$1.nil = new _Code("");
    function _2(strs, ...args) {
      const code2 = [strs[0]];
      let i = 0;
      while (i < args.length) {
        addCodeArg(code2, args[i]);
        code2.push(strs[++i]);
      }
      return new _Code(code2);
    }
    exports$1._ = _2;
    const plus = new _Code("+");
    function str(strs, ...args) {
      const expr = [safeStringify(strs[0])];
      let i = 0;
      while (i < args.length) {
        expr.push(plus);
        addCodeArg(expr, args[i]);
        expr.push(plus, safeStringify(strs[++i]));
      }
      optimize(expr);
      return new _Code(expr);
    }
    exports$1.str = str;
    function addCodeArg(code2, arg) {
      if (arg instanceof _Code)
        code2.push(...arg._items);
      else if (arg instanceof Name)
        code2.push(arg);
      else
        code2.push(interpolate(arg));
    }
    exports$1.addCodeArg = addCodeArg;
    function optimize(expr) {
      let i = 1;
      while (i < expr.length - 1) {
        if (expr[i] === plus) {
          const res = mergeExprItems(expr[i - 1], expr[i + 1]);
          if (res !== void 0) {
            expr.splice(i - 1, 3, res);
            continue;
          }
          expr[i++] = "+";
        }
        i++;
      }
    }
    function mergeExprItems(a2, b) {
      if (b === '""')
        return a2;
      if (a2 === '""')
        return b;
      if (typeof a2 == "string") {
        if (b instanceof Name || a2[a2.length - 1] !== '"')
          return;
        if (typeof b != "string")
          return `${a2.slice(0, -1)}${b}"`;
        if (b[0] === '"')
          return a2.slice(0, -1) + b.slice(1);
        return;
      }
      if (typeof b == "string" && b[0] === '"' && !(a2 instanceof Name))
        return `"${a2}${b.slice(1)}`;
      return;
    }
    function strConcat(c1, c2) {
      return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
    }
    exports$1.strConcat = strConcat;
    function interpolate(x2) {
      return typeof x2 == "number" || typeof x2 == "boolean" || x2 === null ? x2 : safeStringify(Array.isArray(x2) ? x2.join(",") : x2);
    }
    function stringify(x2) {
      return new _Code(safeStringify(x2));
    }
    exports$1.stringify = stringify;
    function safeStringify(x2) {
      return JSON.stringify(x2).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    exports$1.safeStringify = safeStringify;
    function getProperty(key) {
      return typeof key == "string" && exports$1.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _2`[${key}]`;
    }
    exports$1.getProperty = getProperty;
    function getEsmExportName(key) {
      if (typeof key == "string" && exports$1.IDENTIFIER.test(key)) {
        return new _Code(`${key}`);
      }
      throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
    }
    exports$1.getEsmExportName = getEsmExportName;
    function regexpCode(rx) {
      return new _Code(rx.toString());
    }
    exports$1.regexpCode = regexpCode;
  })(code$1);
  return code$1;
}
var scope = {};
var hasRequiredScope;
function requireScope() {
  if (hasRequiredScope) return scope;
  hasRequiredScope = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.ValueScope = exports$1.ValueScopeName = exports$1.Scope = exports$1.varKinds = exports$1.UsedValueState = void 0;
    const code_1 = /* @__PURE__ */ requireCode$1();
    class ValueError extends Error {
      constructor(name2) {
        super(`CodeGen: "code" for ${name2} not defined`);
        this.value = name2.value;
      }
    }
    var UsedValueState;
    (function(UsedValueState2) {
      UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
      UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
    })(UsedValueState || (exports$1.UsedValueState = UsedValueState = {}));
    exports$1.varKinds = {
      const: new code_1.Name("const"),
      let: new code_1.Name("let"),
      var: new code_1.Name("var")
    };
    class Scope {
      constructor({ prefixes, parent } = {}) {
        this._names = {};
        this._prefixes = prefixes;
        this._parent = parent;
      }
      toName(nameOrPrefix) {
        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
      }
      name(prefix) {
        return new code_1.Name(this._newName(prefix));
      }
      _newName(prefix) {
        const ng2 = this._names[prefix] || this._nameGroup(prefix);
        return `${prefix}${ng2.index++}`;
      }
      _nameGroup(prefix) {
        var _a2, _b;
        if (((_b = (_a2 = this._parent) === null || _a2 === void 0 ? void 0 : _a2._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
          throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
        }
        return this._names[prefix] = { prefix, index: 0 };
      }
    }
    exports$1.Scope = Scope;
    class ValueScopeName extends code_1.Name {
      constructor(prefix, nameStr) {
        super(nameStr);
        this.prefix = prefix;
      }
      setValue(value, { property, itemIndex }) {
        this.value = value;
        this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
      }
    }
    exports$1.ValueScopeName = ValueScopeName;
    const line = (0, code_1._)`\n`;
    class ValueScope extends Scope {
      constructor(opts) {
        super(opts);
        this._values = {};
        this._scope = opts.scope;
        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
      }
      get() {
        return this._scope;
      }
      name(prefix) {
        return new ValueScopeName(prefix, this._newName(prefix));
      }
      value(nameOrPrefix, value) {
        var _a2;
        if (value.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const name2 = this.toName(nameOrPrefix);
        const { prefix } = name2;
        const valueKey = (_a2 = value.key) !== null && _a2 !== void 0 ? _a2 : value.ref;
        let vs2 = this._values[prefix];
        if (vs2) {
          const _name = vs2.get(valueKey);
          if (_name)
            return _name;
        } else {
          vs2 = this._values[prefix] = /* @__PURE__ */ new Map();
        }
        vs2.set(valueKey, name2);
        const s2 = this._scope[prefix] || (this._scope[prefix] = []);
        const itemIndex = s2.length;
        s2[itemIndex] = value.ref;
        name2.setValue(value, { property: prefix, itemIndex });
        return name2;
      }
      getValue(prefix, keyOrRef) {
        const vs2 = this._values[prefix];
        if (!vs2)
          return;
        return vs2.get(keyOrRef);
      }
      scopeRefs(scopeName, values = this._values) {
        return this._reduceValues(values, (name2) => {
          if (name2.scopePath === void 0)
            throw new Error(`CodeGen: name "${name2}" has no value`);
          return (0, code_1._)`${scopeName}${name2.scopePath}`;
        });
      }
      scopeCode(values = this._values, usedValues, getCode) {
        return this._reduceValues(values, (name2) => {
          if (name2.value === void 0)
            throw new Error(`CodeGen: name "${name2}" has no value`);
          return name2.value.code;
        }, usedValues, getCode);
      }
      _reduceValues(values, valueCode, usedValues = {}, getCode) {
        let code2 = code_1.nil;
        for (const prefix in values) {
          const vs2 = values[prefix];
          if (!vs2)
            continue;
          const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
          vs2.forEach((name2) => {
            if (nameSet.has(name2))
              return;
            nameSet.set(name2, UsedValueState.Started);
            let c = valueCode(name2);
            if (c) {
              const def = this.opts.es5 ? exports$1.varKinds.var : exports$1.varKinds.const;
              code2 = (0, code_1._)`${code2}${def} ${name2} = ${c};${this.opts._n}`;
            } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name2)) {
              code2 = (0, code_1._)`${code2}${c}${this.opts._n}`;
            } else {
              throw new ValueError(name2);
            }
            nameSet.set(name2, UsedValueState.Completed);
          });
        }
        return code2;
      }
    }
    exports$1.ValueScope = ValueScope;
  })(scope);
  return scope;
}
var hasRequiredCodegen;
function requireCodegen() {
  if (hasRequiredCodegen) return codegen;
  hasRequiredCodegen = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.or = exports$1.and = exports$1.not = exports$1.CodeGen = exports$1.operators = exports$1.varKinds = exports$1.ValueScopeName = exports$1.ValueScope = exports$1.Scope = exports$1.Name = exports$1.regexpCode = exports$1.stringify = exports$1.getProperty = exports$1.nil = exports$1.strConcat = exports$1.str = exports$1._ = void 0;
    const code_1 = /* @__PURE__ */ requireCode$1();
    const scope_1 = /* @__PURE__ */ requireScope();
    var code_2 = /* @__PURE__ */ requireCode$1();
    Object.defineProperty(exports$1, "_", { enumerable: true, get: function() {
      return code_2._;
    } });
    Object.defineProperty(exports$1, "str", { enumerable: true, get: function() {
      return code_2.str;
    } });
    Object.defineProperty(exports$1, "strConcat", { enumerable: true, get: function() {
      return code_2.strConcat;
    } });
    Object.defineProperty(exports$1, "nil", { enumerable: true, get: function() {
      return code_2.nil;
    } });
    Object.defineProperty(exports$1, "getProperty", { enumerable: true, get: function() {
      return code_2.getProperty;
    } });
    Object.defineProperty(exports$1, "stringify", { enumerable: true, get: function() {
      return code_2.stringify;
    } });
    Object.defineProperty(exports$1, "regexpCode", { enumerable: true, get: function() {
      return code_2.regexpCode;
    } });
    Object.defineProperty(exports$1, "Name", { enumerable: true, get: function() {
      return code_2.Name;
    } });
    var scope_2 = /* @__PURE__ */ requireScope();
    Object.defineProperty(exports$1, "Scope", { enumerable: true, get: function() {
      return scope_2.Scope;
    } });
    Object.defineProperty(exports$1, "ValueScope", { enumerable: true, get: function() {
      return scope_2.ValueScope;
    } });
    Object.defineProperty(exports$1, "ValueScopeName", { enumerable: true, get: function() {
      return scope_2.ValueScopeName;
    } });
    Object.defineProperty(exports$1, "varKinds", { enumerable: true, get: function() {
      return scope_2.varKinds;
    } });
    exports$1.operators = {
      GT: new code_1._Code(">"),
      GTE: new code_1._Code(">="),
      LT: new code_1._Code("<"),
      LTE: new code_1._Code("<="),
      EQ: new code_1._Code("==="),
      NEQ: new code_1._Code("!=="),
      NOT: new code_1._Code("!"),
      OR: new code_1._Code("||"),
      AND: new code_1._Code("&&"),
      ADD: new code_1._Code("+")
    };
    class Node2 {
      optimizeNodes() {
        return this;
      }
      optimizeNames(_names, _constants) {
        return this;
      }
    }
    class Def extends Node2 {
      constructor(varKind, name2, rhs) {
        super();
        this.varKind = varKind;
        this.name = name2;
        this.rhs = rhs;
      }
      render({ es5, _n: _n2 }) {
        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
        const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${varKind} ${this.name}${rhs};` + _n2;
      }
      optimizeNames(names2, constants) {
        if (!names2[this.name.str])
          return;
        if (this.rhs)
          this.rhs = optimizeExpr(this.rhs, names2, constants);
        return this;
      }
      get names() {
        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
      }
    }
    class Assign extends Node2 {
      constructor(lhs, rhs, sideEffects) {
        super();
        this.lhs = lhs;
        this.rhs = rhs;
        this.sideEffects = sideEffects;
      }
      render({ _n: _n2 }) {
        return `${this.lhs} = ${this.rhs};` + _n2;
      }
      optimizeNames(names2, constants) {
        if (this.lhs instanceof code_1.Name && !names2[this.lhs.str] && !this.sideEffects)
          return;
        this.rhs = optimizeExpr(this.rhs, names2, constants);
        return this;
      }
      get names() {
        const names2 = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
        return addExprNames(names2, this.rhs);
      }
    }
    class AssignOp extends Assign {
      constructor(lhs, op2, rhs, sideEffects) {
        super(lhs, rhs, sideEffects);
        this.op = op2;
      }
      render({ _n: _n2 }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + _n2;
      }
    }
    class Label2 extends Node2 {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n: _n2 }) {
        return `${this.label}:` + _n2;
      }
    }
    class Break extends Node2 {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n: _n2 }) {
        const label = this.label ? ` ${this.label}` : "";
        return `break${label};` + _n2;
      }
    }
    class Throw extends Node2 {
      constructor(error) {
        super();
        this.error = error;
      }
      render({ _n: _n2 }) {
        return `throw ${this.error};` + _n2;
      }
      get names() {
        return this.error.names;
      }
    }
    class AnyCode extends Node2 {
      constructor(code2) {
        super();
        this.code = code2;
      }
      render({ _n: _n2 }) {
        return `${this.code};` + _n2;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(names2, constants) {
        this.code = optimizeExpr(this.code, names2, constants);
        return this;
      }
      get names() {
        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
      }
    }
    class ParentNode extends Node2 {
      constructor(nodes = []) {
        super();
        this.nodes = nodes;
      }
      render(opts) {
        return this.nodes.reduce((code2, n) => code2 + n.render(opts), "");
      }
      optimizeNodes() {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i].optimizeNodes();
          if (Array.isArray(n))
            nodes.splice(i, 1, ...n);
          else if (n)
            nodes[i] = n;
          else
            nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      optimizeNames(names2, constants) {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i];
          if (n.optimizeNames(names2, constants))
            continue;
          subtractNames(names2, n.names);
          nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((names2, n) => addNames(names2, n.names), {});
      }
    }
    class BlockNode extends ParentNode {
      render(opts) {
        return "{" + opts._n + super.render(opts) + "}" + opts._n;
      }
    }
    class Root4 extends ParentNode {
    }
    class Else extends BlockNode {
    }
    Else.kind = "else";
    class If2 extends BlockNode {
      constructor(condition, nodes) {
        super(nodes);
        this.condition = condition;
      }
      render(opts) {
        let code2 = `if(${this.condition})` + super.render(opts);
        if (this.else)
          code2 += "else " + this.else.render(opts);
        return code2;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const cond = this.condition;
        if (cond === true)
          return this.nodes;
        let e = this.else;
        if (e) {
          const ns2 = e.optimizeNodes();
          e = this.else = Array.isArray(ns2) ? new Else(ns2) : ns2;
        }
        if (e) {
          if (cond === false)
            return e instanceof If2 ? e : e.nodes;
          if (this.nodes.length)
            return this;
          return new If2(not2(cond), e instanceof If2 ? [e] : e.nodes);
        }
        if (cond === false || !this.nodes.length)
          return void 0;
        return this;
      }
      optimizeNames(names2, constants) {
        var _a2;
        this.else = (_a2 = this.else) === null || _a2 === void 0 ? void 0 : _a2.optimizeNames(names2, constants);
        if (!(super.optimizeNames(names2, constants) || this.else))
          return;
        this.condition = optimizeExpr(this.condition, names2, constants);
        return this;
      }
      get names() {
        const names2 = super.names;
        addExprNames(names2, this.condition);
        if (this.else)
          addNames(names2, this.else.names);
        return names2;
      }
    }
    If2.kind = "if";
    class For extends BlockNode {
    }
    For.kind = "for";
    class ForLoop extends For {
      constructor(iteration) {
        super();
        this.iteration = iteration;
      }
      render(opts) {
        return `for(${this.iteration})` + super.render(opts);
      }
      optimizeNames(names2, constants) {
        if (!super.optimizeNames(names2, constants))
          return;
        this.iteration = optimizeExpr(this.iteration, names2, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iteration.names);
      }
    }
    class ForRange extends For {
      constructor(varKind, name2, from, to2) {
        super();
        this.varKind = varKind;
        this.name = name2;
        this.from = from;
        this.to = to2;
      }
      render(opts) {
        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
        const { name: name2, from, to: to2 } = this;
        return `for(${varKind} ${name2}=${from}; ${name2}<${to2}; ${name2}++)` + super.render(opts);
      }
      get names() {
        const names2 = addExprNames(super.names, this.from);
        return addExprNames(names2, this.to);
      }
    }
    class ForIter extends For {
      constructor(loop, varKind, name2, iterable) {
        super();
        this.loop = loop;
        this.varKind = varKind;
        this.name = name2;
        this.iterable = iterable;
      }
      render(opts) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
      }
      optimizeNames(names2, constants) {
        if (!super.optimizeNames(names2, constants))
          return;
        this.iterable = optimizeExpr(this.iterable, names2, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iterable.names);
      }
    }
    class Func extends BlockNode {
      constructor(name2, args, async2) {
        super();
        this.name = name2;
        this.args = args;
        this.async = async2;
      }
      render(opts) {
        const _async = this.async ? "async " : "";
        return `${_async}function ${this.name}(${this.args})` + super.render(opts);
      }
    }
    Func.kind = "func";
    class Return extends ParentNode {
      render(opts) {
        return "return " + super.render(opts);
      }
    }
    Return.kind = "return";
    class Try extends BlockNode {
      render(opts) {
        let code2 = "try" + super.render(opts);
        if (this.catch)
          code2 += this.catch.render(opts);
        if (this.finally)
          code2 += this.finally.render(opts);
        return code2;
      }
      optimizeNodes() {
        var _a2, _b;
        super.optimizeNodes();
        (_a2 = this.catch) === null || _a2 === void 0 ? void 0 : _a2.optimizeNodes();
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
        return this;
      }
      optimizeNames(names2, constants) {
        var _a2, _b;
        super.optimizeNames(names2, constants);
        (_a2 = this.catch) === null || _a2 === void 0 ? void 0 : _a2.optimizeNames(names2, constants);
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names2, constants);
        return this;
      }
      get names() {
        const names2 = super.names;
        if (this.catch)
          addNames(names2, this.catch.names);
        if (this.finally)
          addNames(names2, this.finally.names);
        return names2;
      }
    }
    class Catch extends BlockNode {
      constructor(error) {
        super();
        this.error = error;
      }
      render(opts) {
        return `catch(${this.error})` + super.render(opts);
      }
    }
    Catch.kind = "catch";
    class Finally extends BlockNode {
      render(opts) {
        return "finally" + super.render(opts);
      }
    }
    Finally.kind = "finally";
    class CodeGen {
      constructor(extScope, opts = {}) {
        this._values = {};
        this._blockStarts = [];
        this._constants = {};
        this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
        this._extScope = extScope;
        this._scope = new scope_1.Scope({ parent: extScope });
        this._nodes = [new Root4()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(prefix) {
        return this._scope.name(prefix);
      }
      // reserves unique name in the external scope
      scopeName(prefix) {
        return this._extScope.name(prefix);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(prefixOrName, value) {
        const name2 = this._extScope.value(prefixOrName, value);
        const vs2 = this._values[name2.prefix] || (this._values[name2.prefix] = /* @__PURE__ */ new Set());
        vs2.add(name2);
        return name2;
      }
      getScopeValue(prefix, keyOrRef) {
        return this._extScope.getValue(prefix, keyOrRef);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(scopeName) {
        return this._extScope.scopeRefs(scopeName, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(varKind, nameOrPrefix, rhs, constant) {
        const name2 = this._scope.toName(nameOrPrefix);
        if (rhs !== void 0 && constant)
          this._constants[name2.str] = rhs;
        this._leafNode(new Def(varKind, name2, rhs));
        return name2;
      }
      // `const` declaration (`var` in es5 mode)
      const(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
      }
      // `var` declaration with optional assignment
      var(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
      }
      // assignment code
      assign(lhs, rhs, sideEffects) {
        return this._leafNode(new Assign(lhs, rhs, sideEffects));
      }
      // `+=` code
      add(lhs, rhs) {
        return this._leafNode(new AssignOp(lhs, exports$1.operators.ADD, rhs));
      }
      // appends passed SafeExpr to code or executes Block
      code(c) {
        if (typeof c == "function")
          c();
        else if (c !== code_1.nil)
          this._leafNode(new AnyCode(c));
        return this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...keyValues) {
        const code2 = ["{"];
        for (const [key, value] of keyValues) {
          if (code2.length > 1)
            code2.push(",");
          code2.push(key);
          if (key !== value || this.opts.es5) {
            code2.push(":");
            (0, code_1.addCodeArg)(code2, value);
          }
        }
        code2.push("}");
        return new code_1._Code(code2);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(condition, thenBody, elseBody) {
        this._blockNode(new If2(condition));
        if (thenBody && elseBody) {
          this.code(thenBody).else().code(elseBody).endIf();
        } else if (thenBody) {
          this.code(thenBody).endIf();
        } else if (elseBody) {
          throw new Error('CodeGen: "else" body without "then" body');
        }
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(condition) {
        return this._elseNode(new If2(condition));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new Else());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(If2, Else);
      }
      _for(node, forBody) {
        this._blockNode(node);
        if (forBody)
          this.code(forBody).endFor();
        return this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(iteration, forBody) {
        return this._for(new ForLoop(iteration), forBody);
      }
      // `for` statement for a range of values
      forRange(nameOrPrefix, from, to2, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
        const name2 = this._scope.toName(nameOrPrefix);
        return this._for(new ForRange(varKind, name2, from, to2), () => forBody(name2));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
        const name2 = this._scope.toName(nameOrPrefix);
        if (this.opts.es5) {
          const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
          return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
            this.var(name2, (0, code_1._)`${arr}[${i}]`);
            forBody(name2);
          });
        }
        return this._for(new ForIter("of", varKind, name2, iterable), () => forBody(name2));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
        if (this.opts.ownProperties) {
          return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
        }
        const name2 = this._scope.toName(nameOrPrefix);
        return this._for(new ForIter("in", varKind, name2, obj), () => forBody(name2));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(For);
      }
      // `label` statement
      label(label) {
        return this._leafNode(new Label2(label));
      }
      // `break` statement
      break(label) {
        return this._leafNode(new Break(label));
      }
      // `return` statement
      return(value) {
        const node = new Return();
        this._blockNode(node);
        this.code(value);
        if (node.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Return);
      }
      // `try` statement
      try(tryBody, catchCode, finallyCode) {
        if (!catchCode && !finallyCode)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const node = new Try();
        this._blockNode(node);
        this.code(tryBody);
        if (catchCode) {
          const error = this.name("e");
          this._currNode = node.catch = new Catch(error);
          catchCode(error);
        }
        if (finallyCode) {
          this._currNode = node.finally = new Finally();
          this.code(finallyCode);
        }
        return this._endBlockNode(Catch, Finally);
      }
      // `throw` statement
      throw(error) {
        return this._leafNode(new Throw(error));
      }
      // start self-balancing block
      block(body, nodeCount) {
        this._blockStarts.push(this._nodes.length);
        if (body)
          this.code(body).endBlock(nodeCount);
        return this;
      }
      // end the current self-balancing block
      endBlock(nodeCount) {
        const len = this._blockStarts.pop();
        if (len === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const toClose = this._nodes.length - len;
        if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
          throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
        }
        this._nodes.length = len;
        return this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(name2, args = code_1.nil, async2, funcBody) {
        this._blockNode(new Func(name2, args, async2));
        if (funcBody)
          this.code(funcBody).endFunc();
        return this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(Func);
      }
      optimize(n = 1) {
        while (n-- > 0) {
          this._root.optimizeNodes();
          this._root.optimizeNames(this._root.names, this._constants);
        }
      }
      _leafNode(node) {
        this._currNode.nodes.push(node);
        return this;
      }
      _blockNode(node) {
        this._currNode.nodes.push(node);
        this._nodes.push(node);
      }
      _endBlockNode(N1, N2) {
        const n = this._currNode;
        if (n instanceof N1 || N2 && n instanceof N2) {
          this._nodes.pop();
          return this;
        }
        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
      }
      _elseNode(node) {
        const n = this._currNode;
        if (!(n instanceof If2)) {
          throw new Error('CodeGen: "else" without "if"');
        }
        this._currNode = n.else = node;
        return this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const ns2 = this._nodes;
        return ns2[ns2.length - 1];
      }
      set _currNode(node) {
        const ns2 = this._nodes;
        ns2[ns2.length - 1] = node;
      }
    }
    exports$1.CodeGen = CodeGen;
    function addNames(names2, from) {
      for (const n in from)
        names2[n] = (names2[n] || 0) + (from[n] || 0);
      return names2;
    }
    function addExprNames(names2, from) {
      return from instanceof code_1._CodeOrName ? addNames(names2, from.names) : names2;
    }
    function optimizeExpr(expr, names2, constants) {
      if (expr instanceof code_1.Name)
        return replaceName(expr);
      if (!canOptimize(expr))
        return expr;
      return new code_1._Code(expr._items.reduce((items2, c) => {
        if (c instanceof code_1.Name)
          c = replaceName(c);
        if (c instanceof code_1._Code)
          items2.push(...c._items);
        else
          items2.push(c);
        return items2;
      }, []));
      function replaceName(n) {
        const c = constants[n.str];
        if (c === void 0 || names2[n.str] !== 1)
          return n;
        delete names2[n.str];
        return c;
      }
      function canOptimize(e) {
        return e instanceof code_1._Code && e._items.some((c) => c instanceof code_1.Name && names2[c.str] === 1 && constants[c.str] !== void 0);
      }
    }
    function subtractNames(names2, from) {
      for (const n in from)
        names2[n] = (names2[n] || 0) - (from[n] || 0);
    }
    function not2(x2) {
      return typeof x2 == "boolean" || typeof x2 == "number" || x2 === null ? !x2 : (0, code_1._)`!${par(x2)}`;
    }
    exports$1.not = not2;
    const andCode = mappend(exports$1.operators.AND);
    function and(...args) {
      return args.reduce(andCode);
    }
    exports$1.and = and;
    const orCode = mappend(exports$1.operators.OR);
    function or2(...args) {
      return args.reduce(orCode);
    }
    exports$1.or = or2;
    function mappend(op2) {
      return (x2, y2) => x2 === code_1.nil ? y2 : y2 === code_1.nil ? x2 : (0, code_1._)`${par(x2)} ${op2} ${par(y2)}`;
    }
    function par(x2) {
      return x2 instanceof code_1.Name ? x2 : (0, code_1._)`(${x2})`;
    }
  })(codegen);
  return codegen;
}
var util = {};
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  Object.defineProperty(util, "__esModule", { value: true });
  util.checkStrictMode = util.getErrorPath = util.Type = util.useFunc = util.setEvaluated = util.evaluatedPropsToName = util.mergeEvaluated = util.eachItem = util.unescapeJsonPointer = util.escapeJsonPointer = util.escapeFragment = util.unescapeFragment = util.schemaRefOrVal = util.schemaHasRulesButRef = util.schemaHasRules = util.checkUnknownRules = util.alwaysValidSchema = util.toHash = void 0;
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const code_1 = /* @__PURE__ */ requireCode$1();
  function toHash(arr) {
    const hash = {};
    for (const item of arr)
      hash[item] = true;
    return hash;
  }
  util.toHash = toHash;
  function alwaysValidSchema(it2, schema) {
    if (typeof schema == "boolean")
      return schema;
    if (Object.keys(schema).length === 0)
      return true;
    checkUnknownRules(it2, schema);
    return !schemaHasRules(schema, it2.self.RULES.all);
  }
  util.alwaysValidSchema = alwaysValidSchema;
  function checkUnknownRules(it2, schema = it2.schema) {
    const { opts, self: self2 } = it2;
    if (!opts.strictSchema)
      return;
    if (typeof schema === "boolean")
      return;
    const rules2 = self2.RULES.keywords;
    for (const key in schema) {
      if (!rules2[key])
        checkStrictMode(it2, `unknown keyword: "${key}"`);
    }
  }
  util.checkUnknownRules = checkUnknownRules;
  function schemaHasRules(schema, rules2) {
    if (typeof schema == "boolean")
      return !schema;
    for (const key in schema)
      if (rules2[key])
        return true;
    return false;
  }
  util.schemaHasRules = schemaHasRules;
  function schemaHasRulesButRef(schema, RULES) {
    if (typeof schema == "boolean")
      return !schema;
    for (const key in schema)
      if (key !== "$ref" && RULES.all[key])
        return true;
    return false;
  }
  util.schemaHasRulesButRef = schemaHasRulesButRef;
  function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword2, $data) {
    if (!$data) {
      if (typeof schema == "number" || typeof schema == "boolean")
        return schema;
      if (typeof schema == "string")
        return (0, codegen_1._)`${schema}`;
    }
    return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword2)}`;
  }
  util.schemaRefOrVal = schemaRefOrVal;
  function unescapeFragment(str) {
    return unescapeJsonPointer(decodeURIComponent(str));
  }
  util.unescapeFragment = unescapeFragment;
  function escapeFragment(str) {
    return encodeURIComponent(escapeJsonPointer(str));
  }
  util.escapeFragment = escapeFragment;
  function escapeJsonPointer(str) {
    if (typeof str == "number")
      return `${str}`;
    return str.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  util.escapeJsonPointer = escapeJsonPointer;
  function unescapeJsonPointer(str) {
    return str.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  util.unescapeJsonPointer = unescapeJsonPointer;
  function eachItem(xs2, f2) {
    if (Array.isArray(xs2)) {
      for (const x2 of xs2)
        f2(x2);
    } else {
      f2(xs2);
    }
  }
  util.eachItem = eachItem;
  function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues: mergeValues2, resultToName }) {
    return (gen, from, to2, toName) => {
      const res = to2 === void 0 ? from : to2 instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to2) : mergeToName(gen, from, to2), to2) : from instanceof codegen_1.Name ? (mergeToName(gen, to2, from), from) : mergeValues2(from, to2);
      return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
    };
  }
  util.mergeEvaluated = {
    props: makeMergeEvaluated({
      mergeNames: (gen, from, to2) => gen.if((0, codegen_1._)`${to2} !== true && ${from} !== undefined`, () => {
        gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to2, true), () => gen.assign(to2, (0, codegen_1._)`${to2} || {}`).code((0, codegen_1._)`Object.assign(${to2}, ${from})`));
      }),
      mergeToName: (gen, from, to2) => gen.if((0, codegen_1._)`${to2} !== true`, () => {
        if (from === true) {
          gen.assign(to2, true);
        } else {
          gen.assign(to2, (0, codegen_1._)`${to2} || {}`);
          setEvaluated(gen, to2, from);
        }
      }),
      mergeValues: (from, to2) => from === true ? true : { ...from, ...to2 },
      resultToName: evaluatedPropsToName
    }),
    items: makeMergeEvaluated({
      mergeNames: (gen, from, to2) => gen.if((0, codegen_1._)`${to2} !== true && ${from} !== undefined`, () => gen.assign(to2, (0, codegen_1._)`${from} === true ? true : ${to2} > ${from} ? ${to2} : ${from}`)),
      mergeToName: (gen, from, to2) => gen.if((0, codegen_1._)`${to2} !== true`, () => gen.assign(to2, from === true ? true : (0, codegen_1._)`${to2} > ${from} ? ${to2} : ${from}`)),
      mergeValues: (from, to2) => from === true ? true : Math.max(from, to2),
      resultToName: (gen, items2) => gen.var("items", items2)
    })
  };
  function evaluatedPropsToName(gen, ps2) {
    if (ps2 === true)
      return gen.var("props", true);
    const props = gen.var("props", (0, codegen_1._)`{}`);
    if (ps2 !== void 0)
      setEvaluated(gen, props, ps2);
    return props;
  }
  util.evaluatedPropsToName = evaluatedPropsToName;
  function setEvaluated(gen, props, ps2) {
    Object.keys(ps2).forEach((p2) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p2)}`, true));
  }
  util.setEvaluated = setEvaluated;
  const snippets = {};
  function useFunc(gen, f2) {
    return gen.scopeValue("func", {
      ref: f2,
      code: snippets[f2.code] || (snippets[f2.code] = new code_1._Code(f2.code))
    });
  }
  util.useFunc = useFunc;
  var Type;
  (function(Type2) {
    Type2[Type2["Num"] = 0] = "Num";
    Type2[Type2["Str"] = 1] = "Str";
  })(Type || (util.Type = Type = {}));
  function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
    if (dataProp instanceof codegen_1.Name) {
      const isNumber2 = dataPropType === Type.Num;
      return jsPropertySyntax ? isNumber2 ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber2 ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
  }
  util.getErrorPath = getErrorPath;
  function checkStrictMode(it2, msg, mode = it2.opts.strictSchema) {
    if (!mode)
      return;
    msg = `strict mode: ${msg}`;
    if (mode === true)
      throw new Error(msg);
    it2.self.logger.warn(msg);
  }
  util.checkStrictMode = checkStrictMode;
  return util;
}
var names = {};
var hasRequiredNames;
function requireNames() {
  if (hasRequiredNames) return names;
  hasRequiredNames = 1;
  Object.defineProperty(names, "__esModule", { value: true });
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const names$12 = {
    // validation function arguments
    data: new codegen_1.Name("data"),
    // data passed to validation function
    // args passed from referencing schema
    valCxt: new codegen_1.Name("valCxt"),
    // validation/data context - should not be used directly, it is destructured to the names below
    instancePath: new codegen_1.Name("instancePath"),
    parentData: new codegen_1.Name("parentData"),
    parentDataProperty: new codegen_1.Name("parentDataProperty"),
    rootData: new codegen_1.Name("rootData"),
    // root data - same as the data passed to the first/top validation function
    dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
    // used to support recursiveRef and dynamicRef
    // function scoped variables
    vErrors: new codegen_1.Name("vErrors"),
    // null or array of validation errors
    errors: new codegen_1.Name("errors"),
    // counter of validation errors
    this: new codegen_1.Name("this"),
    // "globals"
    self: new codegen_1.Name("self"),
    scope: new codegen_1.Name("scope"),
    // JTD serialize/parse name for JSON string and position
    json: new codegen_1.Name("json"),
    jsonPos: new codegen_1.Name("jsonPos"),
    jsonLen: new codegen_1.Name("jsonLen"),
    jsonPart: new codegen_1.Name("jsonPart")
  };
  names.default = names$12;
  return names;
}
var hasRequiredErrors;
function requireErrors() {
  if (hasRequiredErrors) return errors;
  hasRequiredErrors = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.extendErrors = exports$1.resetErrorsCount = exports$1.reportExtraError = exports$1.reportError = exports$1.keyword$DataError = exports$1.keywordError = void 0;
    const codegen_1 = /* @__PURE__ */ requireCodegen();
    const util_1 = /* @__PURE__ */ requireUtil();
    const names_1 = /* @__PURE__ */ requireNames();
    exports$1.keywordError = {
      message: ({ keyword: keyword2 }) => (0, codegen_1.str)`must pass "${keyword2}" keyword validation`
    };
    exports$1.keyword$DataError = {
      message: ({ keyword: keyword2, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword2}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword2}" keyword is invalid ($data)`
    };
    function reportError2(cxt, error = exports$1.keywordError, errorPaths, overrideAllErrors) {
      const { it: it2 } = cxt;
      const { gen, compositeRule, allErrors } = it2;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
        addError(gen, errObj);
      } else {
        returnErrors(it2, (0, codegen_1._)`[${errObj}]`);
      }
    }
    exports$1.reportError = reportError2;
    function reportExtraError(cxt, error = exports$1.keywordError, errorPaths) {
      const { it: it2 } = cxt;
      const { gen, compositeRule, allErrors } = it2;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      addError(gen, errObj);
      if (!(compositeRule || allErrors)) {
        returnErrors(it2, names_1.default.vErrors);
      }
    }
    exports$1.reportExtraError = reportExtraError;
    function resetErrorsCount(gen, errsCount) {
      gen.assign(names_1.default.errors, errsCount);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
    }
    exports$1.resetErrorsCount = resetErrorsCount;
    function extendErrors({ gen, keyword: keyword2, schemaValue, data: data2, errsCount, it: it2 }) {
      if (errsCount === void 0)
        throw new Error("ajv implementation error");
      const err = gen.name("err");
      gen.forRange("i", errsCount, names_1.default.errors, (i) => {
        gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
        gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it2.errorPath)));
        gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it2.errSchemaPath}/${keyword2}`);
        if (it2.opts.verbose) {
          gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
          gen.assign((0, codegen_1._)`${err}.data`, data2);
        }
      });
    }
    exports$1.extendErrors = extendErrors;
    function addError(gen, errObj) {
      const err = gen.const("err", errObj);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
      gen.code((0, codegen_1._)`${names_1.default.errors}++`);
    }
    function returnErrors(it2, errs) {
      const { gen, validateName, schemaEnv } = it2;
      if (schemaEnv.$async) {
        gen.throw((0, codegen_1._)`new ${it2.ValidationError}(${errs})`);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, errs);
        gen.return(false);
      }
    }
    const E2 = {
      keyword: new codegen_1.Name("keyword"),
      schemaPath: new codegen_1.Name("schemaPath"),
      // also used in JTD errors
      params: new codegen_1.Name("params"),
      propertyName: new codegen_1.Name("propertyName"),
      message: new codegen_1.Name("message"),
      schema: new codegen_1.Name("schema"),
      parentSchema: new codegen_1.Name("parentSchema")
    };
    function errorObjectCode(cxt, error, errorPaths) {
      const { createErrors } = cxt.it;
      if (createErrors === false)
        return (0, codegen_1._)`{}`;
      return errorObject(cxt, error, errorPaths);
    }
    function errorObject(cxt, error, errorPaths = {}) {
      const { gen, it: it2 } = cxt;
      const keyValues = [
        errorInstancePath(it2, errorPaths),
        errorSchemaPath(cxt, errorPaths)
      ];
      extraErrorProps(cxt, error, keyValues);
      return gen.object(...keyValues);
    }
    function errorInstancePath({ errorPath }, { instancePath }) {
      const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
      return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
    }
    function errorSchemaPath({ keyword: keyword2, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
      let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword2}`;
      if (schemaPath) {
        schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
      }
      return [E2.schemaPath, schPath];
    }
    function extraErrorProps(cxt, { params, message }, keyValues) {
      const { keyword: keyword2, data: data2, schemaValue, it: it2 } = cxt;
      const { opts, propertyName, topSchemaRef, schemaPath } = it2;
      keyValues.push([E2.keyword, keyword2], [E2.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]);
      if (opts.messages) {
        keyValues.push([E2.message, typeof message == "function" ? message(cxt) : message]);
      }
      if (opts.verbose) {
        keyValues.push([E2.schema, schemaValue], [E2.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data2]);
      }
      if (propertyName)
        keyValues.push([E2.propertyName, propertyName]);
    }
  })(errors);
  return errors;
}
var hasRequiredBoolSchema;
function requireBoolSchema() {
  if (hasRequiredBoolSchema) return boolSchema;
  hasRequiredBoolSchema = 1;
  Object.defineProperty(boolSchema, "__esModule", { value: true });
  boolSchema.boolOrEmptySchema = boolSchema.topBoolOrEmptySchema = void 0;
  const errors_1 = /* @__PURE__ */ requireErrors();
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const names_1 = /* @__PURE__ */ requireNames();
  const boolError = {
    message: "boolean schema is false"
  };
  function topBoolOrEmptySchema(it2) {
    const { gen, schema, validateName } = it2;
    if (schema === false) {
      falseSchemaError(it2, false);
    } else if (typeof schema == "object" && schema.$async === true) {
      gen.return(names_1.default.data);
    } else {
      gen.assign((0, codegen_1._)`${validateName}.errors`, null);
      gen.return(true);
    }
  }
  boolSchema.topBoolOrEmptySchema = topBoolOrEmptySchema;
  function boolOrEmptySchema(it2, valid) {
    const { gen, schema } = it2;
    if (schema === false) {
      gen.var(valid, false);
      falseSchemaError(it2);
    } else {
      gen.var(valid, true);
    }
  }
  boolSchema.boolOrEmptySchema = boolOrEmptySchema;
  function falseSchemaError(it2, overrideAllErrors) {
    const { gen, data: data2 } = it2;
    const cxt = {
      gen,
      keyword: "false schema",
      data: data2,
      schema: false,
      schemaCode: false,
      schemaValue: false,
      params: {},
      it: it2
    };
    (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
  }
  return boolSchema;
}
var dataType = {};
var rules = {};
var hasRequiredRules;
function requireRules() {
  if (hasRequiredRules) return rules;
  hasRequiredRules = 1;
  Object.defineProperty(rules, "__esModule", { value: true });
  rules.getRules = rules.isJSONType = void 0;
  const _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
  const jsonTypes = new Set(_jsonTypes);
  function isJSONType(x2) {
    return typeof x2 == "string" && jsonTypes.has(x2);
  }
  rules.isJSONType = isJSONType;
  function getRules() {
    const groups = {
      number: { type: "number", rules: [] },
      string: { type: "string", rules: [] },
      array: { type: "array", rules: [] },
      object: { type: "object", rules: [] }
    };
    return {
      types: { ...groups, integer: true, boolean: true, null: true },
      rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
      post: { rules: [] },
      all: {},
      keywords: {}
    };
  }
  rules.getRules = getRules;
  return rules;
}
var applicability = {};
var hasRequiredApplicability;
function requireApplicability() {
  if (hasRequiredApplicability) return applicability;
  hasRequiredApplicability = 1;
  Object.defineProperty(applicability, "__esModule", { value: true });
  applicability.shouldUseRule = applicability.shouldUseGroup = applicability.schemaHasRulesForType = void 0;
  function schemaHasRulesForType({ schema, self: self2 }, type2) {
    const group = self2.RULES.types[type2];
    return group && group !== true && shouldUseGroup(schema, group);
  }
  applicability.schemaHasRulesForType = schemaHasRulesForType;
  function shouldUseGroup(schema, group) {
    return group.rules.some((rule) => shouldUseRule(schema, rule));
  }
  applicability.shouldUseGroup = shouldUseGroup;
  function shouldUseRule(schema, rule) {
    var _a2;
    return schema[rule.keyword] !== void 0 || ((_a2 = rule.definition.implements) === null || _a2 === void 0 ? void 0 : _a2.some((kwd) => schema[kwd] !== void 0));
  }
  applicability.shouldUseRule = shouldUseRule;
  return applicability;
}
var hasRequiredDataType;
function requireDataType() {
  if (hasRequiredDataType) return dataType;
  hasRequiredDataType = 1;
  Object.defineProperty(dataType, "__esModule", { value: true });
  dataType.reportTypeError = dataType.checkDataTypes = dataType.checkDataType = dataType.coerceAndCheckDataType = dataType.getJSONTypes = dataType.getSchemaTypes = dataType.DataType = void 0;
  const rules_1 = /* @__PURE__ */ requireRules();
  const applicability_1 = /* @__PURE__ */ requireApplicability();
  const errors_1 = /* @__PURE__ */ requireErrors();
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const util_1 = /* @__PURE__ */ requireUtil();
  var DataType;
  (function(DataType2) {
    DataType2[DataType2["Correct"] = 0] = "Correct";
    DataType2[DataType2["Wrong"] = 1] = "Wrong";
  })(DataType || (dataType.DataType = DataType = {}));
  function getSchemaTypes(schema) {
    const types2 = getJSONTypes(schema.type);
    const hasNull = types2.includes("null");
    if (hasNull) {
      if (schema.nullable === false)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!types2.length && schema.nullable !== void 0) {
        throw new Error('"nullable" cannot be used without "type"');
      }
      if (schema.nullable === true)
        types2.push("null");
    }
    return types2;
  }
  dataType.getSchemaTypes = getSchemaTypes;
  function getJSONTypes(ts2) {
    const types2 = Array.isArray(ts2) ? ts2 : ts2 ? [ts2] : [];
    if (types2.every(rules_1.isJSONType))
      return types2;
    throw new Error("type must be JSONType or JSONType[]: " + types2.join(","));
  }
  dataType.getJSONTypes = getJSONTypes;
  function coerceAndCheckDataType(it2, types2) {
    const { gen, data: data2, opts } = it2;
    const coerceTo = coerceToTypes(types2, opts.coerceTypes);
    const checkTypes = types2.length > 0 && !(coerceTo.length === 0 && types2.length === 1 && (0, applicability_1.schemaHasRulesForType)(it2, types2[0]));
    if (checkTypes) {
      const wrongType = checkDataTypes(types2, data2, opts.strictNumbers, DataType.Wrong);
      gen.if(wrongType, () => {
        if (coerceTo.length)
          coerceData(it2, types2, coerceTo);
        else
          reportTypeError(it2);
      });
    }
    return checkTypes;
  }
  dataType.coerceAndCheckDataType = coerceAndCheckDataType;
  const COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
  function coerceToTypes(types2, coerceTypes) {
    return coerceTypes ? types2.filter((t) => COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
  }
  function coerceData(it2, types2, coerceTo) {
    const { gen, data: data2, opts } = it2;
    const dataType2 = gen.let("dataType", (0, codegen_1._)`typeof ${data2}`);
    const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
    if (opts.coerceTypes === "array") {
      gen.if((0, codegen_1._)`${dataType2} == 'object' && Array.isArray(${data2}) && ${data2}.length == 1`, () => gen.assign(data2, (0, codegen_1._)`${data2}[0]`).assign(dataType2, (0, codegen_1._)`typeof ${data2}`).if(checkDataTypes(types2, data2, opts.strictNumbers), () => gen.assign(coerced, data2)));
    }
    gen.if((0, codegen_1._)`${coerced} !== undefined`);
    for (const t of coerceTo) {
      if (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") {
        coerceSpecificType(t);
      }
    }
    gen.else();
    reportTypeError(it2);
    gen.endIf();
    gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
      gen.assign(data2, coerced);
      assignParentData(it2, coerced);
    });
    function coerceSpecificType(t) {
      switch (t) {
        case "string":
          gen.elseIf((0, codegen_1._)`${dataType2} == "number" || ${dataType2} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data2}`).elseIf((0, codegen_1._)`${data2} === null`).assign(coerced, (0, codegen_1._)`""`);
          return;
        case "number":
          gen.elseIf((0, codegen_1._)`${dataType2} == "boolean" || ${data2} === null
              || (${dataType2} == "string" && ${data2} && ${data2} == +${data2})`).assign(coerced, (0, codegen_1._)`+${data2}`);
          return;
        case "integer":
          gen.elseIf((0, codegen_1._)`${dataType2} === "boolean" || ${data2} === null
              || (${dataType2} === "string" && ${data2} && ${data2} == +${data2} && !(${data2} % 1))`).assign(coerced, (0, codegen_1._)`+${data2}`);
          return;
        case "boolean":
          gen.elseIf((0, codegen_1._)`${data2} === "false" || ${data2} === 0 || ${data2} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data2} === "true" || ${data2} === 1`).assign(coerced, true);
          return;
        case "null":
          gen.elseIf((0, codegen_1._)`${data2} === "" || ${data2} === 0 || ${data2} === false`);
          gen.assign(coerced, null);
          return;
        case "array":
          gen.elseIf((0, codegen_1._)`${dataType2} === "string" || ${dataType2} === "number"
              || ${dataType2} === "boolean" || ${data2} === null`).assign(coerced, (0, codegen_1._)`[${data2}]`);
      }
    }
  }
  function assignParentData({ gen, parentData, parentDataProperty }, expr) {
    gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
  }
  function checkDataType(dataType2, data2, strictNums, correct = DataType.Correct) {
    const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
    let cond;
    switch (dataType2) {
      case "null":
        return (0, codegen_1._)`${data2} ${EQ} null`;
      case "array":
        cond = (0, codegen_1._)`Array.isArray(${data2})`;
        break;
      case "object":
        cond = (0, codegen_1._)`${data2} && typeof ${data2} == "object" && !Array.isArray(${data2})`;
        break;
      case "integer":
        cond = numCond((0, codegen_1._)`!(${data2} % 1) && !isNaN(${data2})`);
        break;
      case "number":
        cond = numCond();
        break;
      default:
        return (0, codegen_1._)`typeof ${data2} ${EQ} ${dataType2}`;
    }
    return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
    function numCond(_cond = codegen_1.nil) {
      return (0, codegen_1.and)((0, codegen_1._)`typeof ${data2} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data2})` : codegen_1.nil);
    }
  }
  dataType.checkDataType = checkDataType;
  function checkDataTypes(dataTypes, data2, strictNums, correct) {
    if (dataTypes.length === 1) {
      return checkDataType(dataTypes[0], data2, strictNums, correct);
    }
    let cond;
    const types2 = (0, util_1.toHash)(dataTypes);
    if (types2.array && types2.object) {
      const notObj = (0, codegen_1._)`typeof ${data2} != "object"`;
      cond = types2.null ? notObj : (0, codegen_1._)`!${data2} || ${notObj}`;
      delete types2.null;
      delete types2.array;
      delete types2.object;
    } else {
      cond = codegen_1.nil;
    }
    if (types2.number)
      delete types2.integer;
    for (const t in types2)
      cond = (0, codegen_1.and)(cond, checkDataType(t, data2, strictNums, correct));
    return cond;
  }
  dataType.checkDataTypes = checkDataTypes;
  const typeError = {
    message: ({ schema }) => `must be ${schema}`,
    params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
  };
  function reportTypeError(it2) {
    const cxt = getTypeErrorContext(it2);
    (0, errors_1.reportError)(cxt, typeError);
  }
  dataType.reportTypeError = reportTypeError;
  function getTypeErrorContext(it2) {
    const { gen, data: data2, schema } = it2;
    const schemaCode = (0, util_1.schemaRefOrVal)(it2, schema, "type");
    return {
      gen,
      keyword: "type",
      data: data2,
      schema: schema.type,
      schemaCode,
      schemaValue: schemaCode,
      parentSchema: schema,
      params: {},
      it: it2
    };
  }
  return dataType;
}
var defaults = {};
var hasRequiredDefaults;
function requireDefaults() {
  if (hasRequiredDefaults) return defaults;
  hasRequiredDefaults = 1;
  Object.defineProperty(defaults, "__esModule", { value: true });
  defaults.assignDefaults = void 0;
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const util_1 = /* @__PURE__ */ requireUtil();
  function assignDefaults(it2, ty) {
    const { properties: properties2, items: items2 } = it2.schema;
    if (ty === "object" && properties2) {
      for (const key in properties2) {
        assignDefault(it2, key, properties2[key].default);
      }
    } else if (ty === "array" && Array.isArray(items2)) {
      items2.forEach((sch, i) => assignDefault(it2, i, sch.default));
    }
  }
  defaults.assignDefaults = assignDefaults;
  function assignDefault(it2, prop, defaultValue) {
    const { gen, compositeRule, data: data2, opts } = it2;
    if (defaultValue === void 0)
      return;
    const childData = (0, codegen_1._)`${data2}${(0, codegen_1.getProperty)(prop)}`;
    if (compositeRule) {
      (0, util_1.checkStrictMode)(it2, `default is ignored for: ${childData}`);
      return;
    }
    let condition = (0, codegen_1._)`${childData} === undefined`;
    if (opts.useDefaults === "empty") {
      condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
    }
    gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
  }
  return defaults;
}
var keyword = {};
var code = {};
var hasRequiredCode;
function requireCode() {
  if (hasRequiredCode) return code;
  hasRequiredCode = 1;
  Object.defineProperty(code, "__esModule", { value: true });
  code.validateUnion = code.validateArray = code.usePattern = code.callValidateCode = code.schemaProperties = code.allSchemaProperties = code.noPropertyInData = code.propertyInData = code.isOwnProperty = code.hasPropFunc = code.reportMissingProp = code.checkMissingProp = code.checkReportMissingProp = void 0;
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const util_1 = /* @__PURE__ */ requireUtil();
  const names_1 = /* @__PURE__ */ requireNames();
  const util_2 = /* @__PURE__ */ requireUtil();
  function checkReportMissingProp(cxt, prop) {
    const { gen, data: data2, it: it2 } = cxt;
    gen.if(noPropertyInData(gen, data2, prop, it2.opts.ownProperties), () => {
      cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
      cxt.error();
    });
  }
  code.checkReportMissingProp = checkReportMissingProp;
  function checkMissingProp({ gen, data: data2, it: { opts } }, properties2, missing) {
    return (0, codegen_1.or)(...properties2.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data2, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
  }
  code.checkMissingProp = checkMissingProp;
  function reportMissingProp(cxt, missing) {
    cxt.setParams({ missingProperty: missing }, true);
    cxt.error();
  }
  code.reportMissingProp = reportMissingProp;
  function hasPropFunc(gen) {
    return gen.scopeValue("func", {
      // eslint-disable-next-line @typescript-eslint/unbound-method
      ref: Object.prototype.hasOwnProperty,
      code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
    });
  }
  code.hasPropFunc = hasPropFunc;
  function isOwnProperty(gen, data2, property) {
    return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data2}, ${property})`;
  }
  code.isOwnProperty = isOwnProperty;
  function propertyInData(gen, data2, property, ownProperties) {
    const cond = (0, codegen_1._)`${data2}${(0, codegen_1.getProperty)(property)} !== undefined`;
    return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data2, property)}` : cond;
  }
  code.propertyInData = propertyInData;
  function noPropertyInData(gen, data2, property, ownProperties) {
    const cond = (0, codegen_1._)`${data2}${(0, codegen_1.getProperty)(property)} === undefined`;
    return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data2, property))) : cond;
  }
  code.noPropertyInData = noPropertyInData;
  function allSchemaProperties(schemaMap) {
    return schemaMap ? Object.keys(schemaMap).filter((p2) => p2 !== "__proto__") : [];
  }
  code.allSchemaProperties = allSchemaProperties;
  function schemaProperties(it2, schemaMap) {
    return allSchemaProperties(schemaMap).filter((p2) => !(0, util_1.alwaysValidSchema)(it2, schemaMap[p2]));
  }
  code.schemaProperties = schemaProperties;
  function callValidateCode({ schemaCode, data: data2, it: { gen, topSchemaRef, schemaPath, errorPath }, it: it2 }, func, context, passSchema) {
    const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data2}, ${topSchemaRef}${schemaPath}` : data2;
    const valCxt = [
      [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
      [names_1.default.parentData, it2.parentData],
      [names_1.default.parentDataProperty, it2.parentDataProperty],
      [names_1.default.rootData, names_1.default.rootData]
    ];
    if (it2.opts.dynamicRef)
      valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
    const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
    return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
  }
  code.callValidateCode = callValidateCode;
  const newRegExp = (0, codegen_1._)`new RegExp`;
  function usePattern({ gen, it: { opts } }, pattern2) {
    const u2 = opts.unicodeRegExp ? "u" : "";
    const { regExp } = opts.code;
    const rx = regExp(pattern2, u2);
    return gen.scopeValue("pattern", {
      key: rx.toString(),
      ref: rx,
      code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern2}, ${u2})`
    });
  }
  code.usePattern = usePattern;
  function validateArray(cxt) {
    const { gen, data: data2, keyword: keyword2, it: it2 } = cxt;
    const valid = gen.name("valid");
    if (it2.allErrors) {
      const validArr = gen.let("valid", true);
      validateItems(() => gen.assign(validArr, false));
      return validArr;
    }
    gen.var(valid, true);
    validateItems(() => gen.break());
    return valid;
    function validateItems(notValid) {
      const len = gen.const("len", (0, codegen_1._)`${data2}.length`);
      gen.forRange("i", 0, len, (i) => {
        cxt.subschema({
          keyword: keyword2,
          dataProp: i,
          dataPropType: util_1.Type.Num
        }, valid);
        gen.if((0, codegen_1.not)(valid), notValid);
      });
    }
  }
  code.validateArray = validateArray;
  function validateUnion(cxt) {
    const { gen, schema, keyword: keyword2, it: it2 } = cxt;
    if (!Array.isArray(schema))
      throw new Error("ajv implementation error");
    const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it2, sch));
    if (alwaysValid && !it2.opts.unevaluated)
      return;
    const valid = gen.let("valid", false);
    const schValid = gen.name("_valid");
    gen.block(() => schema.forEach((_sch, i) => {
      const schCxt = cxt.subschema({
        keyword: keyword2,
        schemaProp: i,
        compositeRule: true
      }, schValid);
      gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
      const merged = cxt.mergeValidEvaluated(schCxt, schValid);
      if (!merged)
        gen.if((0, codegen_1.not)(valid));
    }));
    cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
  }
  code.validateUnion = validateUnion;
  return code;
}
var hasRequiredKeyword;
function requireKeyword() {
  if (hasRequiredKeyword) return keyword;
  hasRequiredKeyword = 1;
  Object.defineProperty(keyword, "__esModule", { value: true });
  keyword.validateKeywordUsage = keyword.validSchemaType = keyword.funcKeywordCode = keyword.macroKeywordCode = void 0;
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const names_1 = /* @__PURE__ */ requireNames();
  const code_1 = /* @__PURE__ */ requireCode();
  const errors_1 = /* @__PURE__ */ requireErrors();
  function macroKeywordCode(cxt, def) {
    const { gen, keyword: keyword2, schema, parentSchema, it: it2 } = cxt;
    const macroSchema = def.macro.call(it2.self, schema, parentSchema, it2);
    const schemaRef = useKeyword(gen, keyword2, macroSchema);
    if (it2.opts.validateSchema !== false)
      it2.self.validateSchema(macroSchema, true);
    const valid = gen.name("valid");
    cxt.subschema({
      schema: macroSchema,
      schemaPath: codegen_1.nil,
      errSchemaPath: `${it2.errSchemaPath}/${keyword2}`,
      topSchemaRef: schemaRef,
      compositeRule: true
    }, valid);
    cxt.pass(valid, () => cxt.error(true));
  }
  keyword.macroKeywordCode = macroKeywordCode;
  function funcKeywordCode(cxt, def) {
    var _a2;
    const { gen, keyword: keyword2, schema, parentSchema, $data, it: it2 } = cxt;
    checkAsyncKeyword(it2, def);
    const validate2 = !$data && def.compile ? def.compile.call(it2.self, schema, parentSchema, it2) : def.validate;
    const validateRef = useKeyword(gen, keyword2, validate2);
    const valid = gen.let("valid");
    cxt.block$data(valid, validateKeyword);
    cxt.ok((_a2 = def.valid) !== null && _a2 !== void 0 ? _a2 : valid);
    function validateKeyword() {
      if (def.errors === false) {
        assignValid();
        if (def.modifying)
          modifyData(cxt);
        reportErrs(() => cxt.error());
      } else {
        const ruleErrs = def.async ? validateAsync() : validateSync();
        if (def.modifying)
          modifyData(cxt);
        reportErrs(() => addErrs(cxt, ruleErrs));
      }
    }
    function validateAsync() {
      const ruleErrs = gen.let("ruleErrs", null);
      gen.try(() => assignValid((0, codegen_1._)`await `), (e) => gen.assign(valid, false).if((0, codegen_1._)`${e} instanceof ${it2.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e)));
      return ruleErrs;
    }
    function validateSync() {
      const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
      gen.assign(validateErrs, null);
      assignValid(codegen_1.nil);
      return validateErrs;
    }
    function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
      const passCxt = it2.opts.passContext ? names_1.default.this : names_1.default.self;
      const passSchema = !("compile" in def && !$data || def.schema === false);
      gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
    }
    function reportErrs(errors2) {
      var _a3;
      gen.if((0, codegen_1.not)((_a3 = def.valid) !== null && _a3 !== void 0 ? _a3 : valid), errors2);
    }
  }
  keyword.funcKeywordCode = funcKeywordCode;
  function modifyData(cxt) {
    const { gen, data: data2, it: it2 } = cxt;
    gen.if(it2.parentData, () => gen.assign(data2, (0, codegen_1._)`${it2.parentData}[${it2.parentDataProperty}]`));
  }
  function addErrs(cxt, errs) {
    const { gen } = cxt;
    gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
      gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      (0, errors_1.extendErrors)(cxt);
    }, () => cxt.error());
  }
  function checkAsyncKeyword({ schemaEnv }, def) {
    if (def.async && !schemaEnv.$async)
      throw new Error("async keyword in sync schema");
  }
  function useKeyword(gen, keyword2, result) {
    if (result === void 0)
      throw new Error(`keyword "${keyword2}" failed to compile`);
    return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
  }
  function validSchemaType(schema, schemaType, allowUndefined = false) {
    return !schemaType.length || schemaType.some((st2) => st2 === "array" ? Array.isArray(schema) : st2 === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st2 || allowUndefined && typeof schema == "undefined");
  }
  keyword.validSchemaType = validSchemaType;
  function validateKeywordUsage({ schema, opts, self: self2, errSchemaPath }, def, keyword2) {
    if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword2) : def.keyword !== keyword2) {
      throw new Error("ajv implementation error");
    }
    const deps = def.dependencies;
    if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
      throw new Error(`parent schema must have dependencies of ${keyword2}: ${deps.join(",")}`);
    }
    if (def.validateSchema) {
      const valid = def.validateSchema(schema[keyword2]);
      if (!valid) {
        const msg = `keyword "${keyword2}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def.validateSchema.errors);
        if (opts.validateSchema === "log")
          self2.logger.error(msg);
        else
          throw new Error(msg);
      }
    }
  }
  keyword.validateKeywordUsage = validateKeywordUsage;
  return keyword;
}
var subschema = {};
var hasRequiredSubschema;
function requireSubschema() {
  if (hasRequiredSubschema) return subschema;
  hasRequiredSubschema = 1;
  Object.defineProperty(subschema, "__esModule", { value: true });
  subschema.extendSubschemaMode = subschema.extendSubschemaData = subschema.getSubschema = void 0;
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const util_1 = /* @__PURE__ */ requireUtil();
  function getSubschema(it2, { keyword: keyword2, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
    if (keyword2 !== void 0 && schema !== void 0) {
      throw new Error('both "keyword" and "schema" passed, only one allowed');
    }
    if (keyword2 !== void 0) {
      const sch = it2.schema[keyword2];
      return schemaProp === void 0 ? {
        schema: sch,
        schemaPath: (0, codegen_1._)`${it2.schemaPath}${(0, codegen_1.getProperty)(keyword2)}`,
        errSchemaPath: `${it2.errSchemaPath}/${keyword2}`
      } : {
        schema: sch[schemaProp],
        schemaPath: (0, codegen_1._)`${it2.schemaPath}${(0, codegen_1.getProperty)(keyword2)}${(0, codegen_1.getProperty)(schemaProp)}`,
        errSchemaPath: `${it2.errSchemaPath}/${keyword2}/${(0, util_1.escapeFragment)(schemaProp)}`
      };
    }
    if (schema !== void 0) {
      if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
        throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
      }
      return {
        schema,
        schemaPath,
        topSchemaRef,
        errSchemaPath
      };
    }
    throw new Error('either "keyword" or "schema" must be passed');
  }
  subschema.getSubschema = getSubschema;
  function extendSubschemaData(subschema2, it2, { dataProp, dataPropType: dpType, data: data2, dataTypes, propertyName }) {
    if (data2 !== void 0 && dataProp !== void 0) {
      throw new Error('both "data" and "dataProp" passed, only one allowed');
    }
    const { gen } = it2;
    if (dataProp !== void 0) {
      const { errorPath, dataPathArr, opts } = it2;
      const nextData = gen.let("data", (0, codegen_1._)`${it2.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
      dataContextProps(nextData);
      subschema2.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
      subschema2.parentDataProperty = (0, codegen_1._)`${dataProp}`;
      subschema2.dataPathArr = [...dataPathArr, subschema2.parentDataProperty];
    }
    if (data2 !== void 0) {
      const nextData = data2 instanceof codegen_1.Name ? data2 : gen.let("data", data2, true);
      dataContextProps(nextData);
      if (propertyName !== void 0)
        subschema2.propertyName = propertyName;
    }
    if (dataTypes)
      subschema2.dataTypes = dataTypes;
    function dataContextProps(_nextData) {
      subschema2.data = _nextData;
      subschema2.dataLevel = it2.dataLevel + 1;
      subschema2.dataTypes = [];
      it2.definedProperties = /* @__PURE__ */ new Set();
      subschema2.parentData = it2.data;
      subschema2.dataNames = [...it2.dataNames, _nextData];
    }
  }
  subschema.extendSubschemaData = extendSubschemaData;
  function extendSubschemaMode(subschema2, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
    if (compositeRule !== void 0)
      subschema2.compositeRule = compositeRule;
    if (createErrors !== void 0)
      subschema2.createErrors = createErrors;
    if (allErrors !== void 0)
      subschema2.allErrors = allErrors;
    subschema2.jtdDiscriminator = jtdDiscriminator;
    subschema2.jtdMetadata = jtdMetadata;
  }
  subschema.extendSubschemaMode = extendSubschemaMode;
  return subschema;
}
var resolve = {};
var jsonSchemaTraverse = { exports: {} };
var hasRequiredJsonSchemaTraverse;
function requireJsonSchemaTraverse() {
  if (hasRequiredJsonSchemaTraverse) return jsonSchemaTraverse.exports;
  hasRequiredJsonSchemaTraverse = 1;
  var traverse = jsonSchemaTraverse.exports = function(schema, opts, cb) {
    if (typeof opts == "function") {
      cb = opts;
      opts = {};
    }
    cb = opts.cb || cb;
    var pre = typeof cb == "function" ? cb : cb.pre || function() {
    };
    var post = cb.post || function() {
    };
    _traverse(opts, pre, post, schema, "", schema);
  };
  traverse.keywords = {
    additionalItems: true,
    items: true,
    contains: true,
    additionalProperties: true,
    propertyNames: true,
    not: true,
    if: true,
    then: true,
    else: true
  };
  traverse.arrayKeywords = {
    items: true,
    allOf: true,
    anyOf: true,
    oneOf: true
  };
  traverse.propsKeywords = {
    $defs: true,
    definitions: true,
    properties: true,
    patternProperties: true,
    dependencies: true
  };
  traverse.skipKeywords = {
    default: true,
    enum: true,
    const: true,
    required: true,
    maximum: true,
    minimum: true,
    exclusiveMaximum: true,
    exclusiveMinimum: true,
    multipleOf: true,
    maxLength: true,
    minLength: true,
    pattern: true,
    format: true,
    maxItems: true,
    minItems: true,
    uniqueItems: true,
    maxProperties: true,
    minProperties: true
  };
  function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
    if (schema && typeof schema == "object" && !Array.isArray(schema)) {
      pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      for (var key in schema) {
        var sch = schema[key];
        if (Array.isArray(sch)) {
          if (key in traverse.arrayKeywords) {
            for (var i = 0; i < sch.length; i++)
              _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
          }
        } else if (key in traverse.propsKeywords) {
          if (sch && typeof sch == "object") {
            for (var prop in sch)
              _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
          }
        } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
          _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
        }
      }
      post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    }
  }
  function escapeJsonPtr(str) {
    return str.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  return jsonSchemaTraverse.exports;
}
var hasRequiredResolve;
function requireResolve() {
  if (hasRequiredResolve) return resolve;
  hasRequiredResolve = 1;
  Object.defineProperty(resolve, "__esModule", { value: true });
  resolve.getSchemaRefs = resolve.resolveUrl = resolve.normalizeId = resolve._getFullPath = resolve.getFullPath = resolve.inlineRef = void 0;
  const util_1 = /* @__PURE__ */ requireUtil();
  const equal2 = requireFastDeepEqual();
  const traverse = requireJsonSchemaTraverse();
  const SIMPLE_INLINED = /* @__PURE__ */ new Set([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum",
    "const"
  ]);
  function inlineRef(schema, limit2 = true) {
    if (typeof schema == "boolean")
      return true;
    if (limit2 === true)
      return !hasRef(schema);
    if (!limit2)
      return false;
    return countKeys(schema) <= limit2;
  }
  resolve.inlineRef = inlineRef;
  const REF_KEYWORDS = /* @__PURE__ */ new Set([
    "$ref",
    "$recursiveRef",
    "$recursiveAnchor",
    "$dynamicRef",
    "$dynamicAnchor"
  ]);
  function hasRef(schema) {
    for (const key in schema) {
      if (REF_KEYWORDS.has(key))
        return true;
      const sch = schema[key];
      if (Array.isArray(sch) && sch.some(hasRef))
        return true;
      if (typeof sch == "object" && hasRef(sch))
        return true;
    }
    return false;
  }
  function countKeys(schema) {
    let count2 = 0;
    for (const key in schema) {
      if (key === "$ref")
        return Infinity;
      count2++;
      if (SIMPLE_INLINED.has(key))
        continue;
      if (typeof schema[key] == "object") {
        (0, util_1.eachItem)(schema[key], (sch) => count2 += countKeys(sch));
      }
      if (count2 === Infinity)
        return Infinity;
    }
    return count2;
  }
  function getFullPath(resolver, id2 = "", normalize) {
    if (normalize !== false)
      id2 = normalizeId(id2);
    const p2 = resolver.parse(id2);
    return _getFullPath(resolver, p2);
  }
  resolve.getFullPath = getFullPath;
  function _getFullPath(resolver, p2) {
    const serialized = resolver.serialize(p2);
    return serialized.split("#")[0] + "#";
  }
  resolve._getFullPath = _getFullPath;
  const TRAILING_SLASH_HASH = /#\/?$/;
  function normalizeId(id2) {
    return id2 ? id2.replace(TRAILING_SLASH_HASH, "") : "";
  }
  resolve.normalizeId = normalizeId;
  function resolveUrl(resolver, baseId, id2) {
    id2 = normalizeId(id2);
    return resolver.resolve(baseId, id2);
  }
  resolve.resolveUrl = resolveUrl;
  const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
  function getSchemaRefs(schema, baseId) {
    if (typeof schema == "boolean")
      return {};
    const { schemaId, uriResolver } = this.opts;
    const schId = normalizeId(schema[schemaId] || baseId);
    const baseIds = { "": schId };
    const pathPrefix = getFullPath(uriResolver, schId, false);
    const localRefs = {};
    const schemaRefs = /* @__PURE__ */ new Set();
    traverse(schema, { allKeys: true }, (sch, jsonPtr, _2, parentJsonPtr) => {
      if (parentJsonPtr === void 0)
        return;
      const fullPath = pathPrefix + jsonPtr;
      let innerBaseId = baseIds[parentJsonPtr];
      if (typeof sch[schemaId] == "string")
        innerBaseId = addRef.call(this, sch[schemaId]);
      addAnchor.call(this, sch.$anchor);
      addAnchor.call(this, sch.$dynamicAnchor);
      baseIds[jsonPtr] = innerBaseId;
      function addRef(ref2) {
        const _resolve = this.opts.uriResolver.resolve;
        ref2 = normalizeId(innerBaseId ? _resolve(innerBaseId, ref2) : ref2);
        if (schemaRefs.has(ref2))
          throw ambiguos(ref2);
        schemaRefs.add(ref2);
        let schOrRef = this.refs[ref2];
        if (typeof schOrRef == "string")
          schOrRef = this.refs[schOrRef];
        if (typeof schOrRef == "object") {
          checkAmbiguosRef(sch, schOrRef.schema, ref2);
        } else if (ref2 !== normalizeId(fullPath)) {
          if (ref2[0] === "#") {
            checkAmbiguosRef(sch, localRefs[ref2], ref2);
            localRefs[ref2] = sch;
          } else {
            this.refs[ref2] = fullPath;
          }
        }
        return ref2;
      }
      function addAnchor(anchor) {
        if (typeof anchor == "string") {
          if (!ANCHOR.test(anchor))
            throw new Error(`invalid anchor "${anchor}"`);
          addRef.call(this, `#${anchor}`);
        }
      }
    });
    return localRefs;
    function checkAmbiguosRef(sch1, sch2, ref2) {
      if (sch2 !== void 0 && !equal2(sch1, sch2))
        throw ambiguos(ref2);
    }
    function ambiguos(ref2) {
      return new Error(`reference "${ref2}" resolves to more than one schema`);
    }
  }
  resolve.getSchemaRefs = getSchemaRefs;
  return resolve;
}
var hasRequiredValidate;
function requireValidate() {
  if (hasRequiredValidate) return validate;
  hasRequiredValidate = 1;
  Object.defineProperty(validate, "__esModule", { value: true });
  validate.getData = validate.KeywordCxt = validate.validateFunctionCode = void 0;
  const boolSchema_1 = /* @__PURE__ */ requireBoolSchema();
  const dataType_1 = /* @__PURE__ */ requireDataType();
  const applicability_1 = /* @__PURE__ */ requireApplicability();
  const dataType_2 = /* @__PURE__ */ requireDataType();
  const defaults_1 = /* @__PURE__ */ requireDefaults();
  const keyword_1 = /* @__PURE__ */ requireKeyword();
  const subschema_1 = /* @__PURE__ */ requireSubschema();
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const names_1 = /* @__PURE__ */ requireNames();
  const resolve_12 = /* @__PURE__ */ requireResolve();
  const util_1 = /* @__PURE__ */ requireUtil();
  const errors_1 = /* @__PURE__ */ requireErrors();
  function validateFunctionCode(it2) {
    if (isSchemaObj(it2)) {
      checkKeywords(it2);
      if (schemaCxtHasRules(it2)) {
        topSchemaObjCode(it2);
        return;
      }
    }
    validateFunction(it2, () => (0, boolSchema_1.topBoolOrEmptySchema)(it2));
  }
  validate.validateFunctionCode = validateFunctionCode;
  function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
    if (opts.code.es5) {
      gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
        gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
        destructureValCxtES5(gen, opts);
        gen.code(body);
      });
    } else {
      gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
    }
  }
  function destructureValCxt(opts) {
    return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
  }
  function destructureValCxtES5(gen, opts) {
    gen.if(names_1.default.valCxt, () => {
      gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
      gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
      gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
      gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
      if (opts.dynamicRef)
        gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
    }, () => {
      gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
      gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
      gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
      gen.var(names_1.default.rootData, names_1.default.data);
      if (opts.dynamicRef)
        gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
    });
  }
  function topSchemaObjCode(it2) {
    const { schema, opts, gen } = it2;
    validateFunction(it2, () => {
      if (opts.$comment && schema.$comment)
        commentKeyword(it2);
      checkNoDefault(it2);
      gen.let(names_1.default.vErrors, null);
      gen.let(names_1.default.errors, 0);
      if (opts.unevaluated)
        resetEvaluated(it2);
      typeAndKeywords(it2);
      returnResults(it2);
    });
    return;
  }
  function resetEvaluated(it2) {
    const { gen, validateName } = it2;
    it2.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
    gen.if((0, codegen_1._)`${it2.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it2.evaluated}.props`, (0, codegen_1._)`undefined`));
    gen.if((0, codegen_1._)`${it2.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it2.evaluated}.items`, (0, codegen_1._)`undefined`));
  }
  function funcSourceUrl(schema, opts) {
    const schId = typeof schema == "object" && schema[opts.schemaId];
    return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
  }
  function subschemaCode(it2, valid) {
    if (isSchemaObj(it2)) {
      checkKeywords(it2);
      if (schemaCxtHasRules(it2)) {
        subSchemaObjCode(it2, valid);
        return;
      }
    }
    (0, boolSchema_1.boolOrEmptySchema)(it2, valid);
  }
  function schemaCxtHasRules({ schema, self: self2 }) {
    if (typeof schema == "boolean")
      return !schema;
    for (const key in schema)
      if (self2.RULES.all[key])
        return true;
    return false;
  }
  function isSchemaObj(it2) {
    return typeof it2.schema != "boolean";
  }
  function subSchemaObjCode(it2, valid) {
    const { schema, gen, opts } = it2;
    if (opts.$comment && schema.$comment)
      commentKeyword(it2);
    updateContext(it2);
    checkAsyncSchema(it2);
    const errsCount = gen.const("_errs", names_1.default.errors);
    typeAndKeywords(it2, errsCount);
    gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
  }
  function checkKeywords(it2) {
    (0, util_1.checkUnknownRules)(it2);
    checkRefsAndKeywords(it2);
  }
  function typeAndKeywords(it2, errsCount) {
    if (it2.opts.jtd)
      return schemaKeywords(it2, [], false, errsCount);
    const types2 = (0, dataType_1.getSchemaTypes)(it2.schema);
    const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it2, types2);
    schemaKeywords(it2, types2, !checkedTypes, errsCount);
  }
  function checkRefsAndKeywords(it2) {
    const { schema, errSchemaPath, opts, self: self2 } = it2;
    if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self2.RULES)) {
      self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
    }
  }
  function checkNoDefault(it2) {
    const { schema, opts } = it2;
    if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
      (0, util_1.checkStrictMode)(it2, "default is ignored in the schema root");
    }
  }
  function updateContext(it2) {
    const schId = it2.schema[it2.opts.schemaId];
    if (schId)
      it2.baseId = (0, resolve_12.resolveUrl)(it2.opts.uriResolver, it2.baseId, schId);
  }
  function checkAsyncSchema(it2) {
    if (it2.schema.$async && !it2.schemaEnv.$async)
      throw new Error("async schema in sync schema");
  }
  function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
    const msg = schema.$comment;
    if (opts.$comment === true) {
      gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
    } else if (typeof opts.$comment == "function") {
      const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
      const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
      gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
    }
  }
  function returnResults(it2) {
    const { gen, schemaEnv, validateName, ValidationError, opts } = it2;
    if (schemaEnv.$async) {
      gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));
    } else {
      gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
      if (opts.unevaluated)
        assignEvaluated(it2);
      gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
    }
  }
  function assignEvaluated({ gen, evaluated, props, items: items2 }) {
    if (props instanceof codegen_1.Name)
      gen.assign((0, codegen_1._)`${evaluated}.props`, props);
    if (items2 instanceof codegen_1.Name)
      gen.assign((0, codegen_1._)`${evaluated}.items`, items2);
  }
  function schemaKeywords(it2, types2, typeErrors, errsCount) {
    const { gen, schema, data: data2, allErrors, opts, self: self2 } = it2;
    const { RULES } = self2;
    if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
      gen.block(() => keywordCode(it2, "$ref", RULES.all.$ref.definition));
      return;
    }
    if (!opts.jtd)
      checkStrictTypes(it2, types2);
    gen.block(() => {
      for (const group of RULES.rules)
        groupKeywords(group);
      groupKeywords(RULES.post);
    });
    function groupKeywords(group) {
      if (!(0, applicability_1.shouldUseGroup)(schema, group))
        return;
      if (group.type) {
        gen.if((0, dataType_2.checkDataType)(group.type, data2, opts.strictNumbers));
        iterateKeywords(it2, group);
        if (types2.length === 1 && types2[0] === group.type && typeErrors) {
          gen.else();
          (0, dataType_2.reportTypeError)(it2);
        }
        gen.endIf();
      } else {
        iterateKeywords(it2, group);
      }
      if (!allErrors)
        gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
    }
  }
  function iterateKeywords(it2, group) {
    const { gen, schema, opts: { useDefaults } } = it2;
    if (useDefaults)
      (0, defaults_1.assignDefaults)(it2, group.type);
    gen.block(() => {
      for (const rule of group.rules) {
        if ((0, applicability_1.shouldUseRule)(schema, rule)) {
          keywordCode(it2, rule.keyword, rule.definition, group.type);
        }
      }
    });
  }
  function checkStrictTypes(it2, types2) {
    if (it2.schemaEnv.meta || !it2.opts.strictTypes)
      return;
    checkContextTypes(it2, types2);
    if (!it2.opts.allowUnionTypes)
      checkMultipleTypes(it2, types2);
    checkKeywordTypes(it2, it2.dataTypes);
  }
  function checkContextTypes(it2, types2) {
    if (!types2.length)
      return;
    if (!it2.dataTypes.length) {
      it2.dataTypes = types2;
      return;
    }
    types2.forEach((t) => {
      if (!includesType(it2.dataTypes, t)) {
        strictTypesError(it2, `type "${t}" not allowed by context "${it2.dataTypes.join(",")}"`);
      }
    });
    narrowSchemaTypes(it2, types2);
  }
  function checkMultipleTypes(it2, ts2) {
    if (ts2.length > 1 && !(ts2.length === 2 && ts2.includes("null"))) {
      strictTypesError(it2, "use allowUnionTypes to allow union type keyword");
    }
  }
  function checkKeywordTypes(it2, ts2) {
    const rules2 = it2.self.RULES.all;
    for (const keyword2 in rules2) {
      const rule = rules2[keyword2];
      if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it2.schema, rule)) {
        const { type: type2 } = rule.definition;
        if (type2.length && !type2.some((t) => hasApplicableType(ts2, t))) {
          strictTypesError(it2, `missing type "${type2.join(",")}" for keyword "${keyword2}"`);
        }
      }
    }
  }
  function hasApplicableType(schTs, kwdT) {
    return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
  }
  function includesType(ts2, t) {
    return ts2.includes(t) || t === "integer" && ts2.includes("number");
  }
  function narrowSchemaTypes(it2, withTypes) {
    const ts2 = [];
    for (const t of it2.dataTypes) {
      if (includesType(withTypes, t))
        ts2.push(t);
      else if (withTypes.includes("integer") && t === "number")
        ts2.push("integer");
    }
    it2.dataTypes = ts2;
  }
  function strictTypesError(it2, msg) {
    const schemaPath = it2.schemaEnv.baseId + it2.errSchemaPath;
    msg += ` at "${schemaPath}" (strictTypes)`;
    (0, util_1.checkStrictMode)(it2, msg, it2.opts.strictTypes);
  }
  class KeywordCxt {
    constructor(it2, def, keyword2) {
      (0, keyword_1.validateKeywordUsage)(it2, def, keyword2);
      this.gen = it2.gen;
      this.allErrors = it2.allErrors;
      this.keyword = keyword2;
      this.data = it2.data;
      this.schema = it2.schema[keyword2];
      this.$data = def.$data && it2.opts.$data && this.schema && this.schema.$data;
      this.schemaValue = (0, util_1.schemaRefOrVal)(it2, this.schema, keyword2, this.$data);
      this.schemaType = def.schemaType;
      this.parentSchema = it2.schema;
      this.params = {};
      this.it = it2;
      this.def = def;
      if (this.$data) {
        this.schemaCode = it2.gen.const("vSchema", getData(this.$data, it2));
      } else {
        this.schemaCode = this.schemaValue;
        if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
          throw new Error(`${keyword2} value must be ${JSON.stringify(def.schemaType)}`);
        }
      }
      if ("code" in def ? def.trackErrors : def.errors !== false) {
        this.errsCount = it2.gen.const("_errs", names_1.default.errors);
      }
    }
    result(condition, successAction, failAction) {
      this.failResult((0, codegen_1.not)(condition), successAction, failAction);
    }
    failResult(condition, successAction, failAction) {
      this.gen.if(condition);
      if (failAction)
        failAction();
      else
        this.error();
      if (successAction) {
        this.gen.else();
        successAction();
        if (this.allErrors)
          this.gen.endIf();
      } else {
        if (this.allErrors)
          this.gen.endIf();
        else
          this.gen.else();
      }
    }
    pass(condition, failAction) {
      this.failResult((0, codegen_1.not)(condition), void 0, failAction);
    }
    fail(condition) {
      if (condition === void 0) {
        this.error();
        if (!this.allErrors)
          this.gen.if(false);
        return;
      }
      this.gen.if(condition);
      this.error();
      if (this.allErrors)
        this.gen.endIf();
      else
        this.gen.else();
    }
    fail$data(condition) {
      if (!this.$data)
        return this.fail(condition);
      const { schemaCode } = this;
      this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
    }
    error(append, errorParams, errorPaths) {
      if (errorParams) {
        this.setParams(errorParams);
        this._error(append, errorPaths);
        this.setParams({});
        return;
      }
      this._error(append, errorPaths);
    }
    _error(append, errorPaths) {
      (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
    }
    $dataError() {
      (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
    }
    reset() {
      if (this.errsCount === void 0)
        throw new Error('add "trackErrors" to keyword definition');
      (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
    }
    ok(cond) {
      if (!this.allErrors)
        this.gen.if(cond);
    }
    setParams(obj, assign) {
      if (assign)
        Object.assign(this.params, obj);
      else
        this.params = obj;
    }
    block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
      this.gen.block(() => {
        this.check$data(valid, $dataValid);
        codeBlock();
      });
    }
    check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
      if (!this.$data)
        return;
      const { gen, schemaCode, schemaType, def } = this;
      gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
      if (valid !== codegen_1.nil)
        gen.assign(valid, true);
      if (schemaType.length || def.validateSchema) {
        gen.elseIf(this.invalid$data());
        this.$dataError();
        if (valid !== codegen_1.nil)
          gen.assign(valid, false);
      }
      gen.else();
    }
    invalid$data() {
      const { gen, schemaCode, schemaType, def, it: it2 } = this;
      return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
      function wrong$DataType() {
        if (schemaType.length) {
          if (!(schemaCode instanceof codegen_1.Name))
            throw new Error("ajv implementation error");
          const st2 = Array.isArray(schemaType) ? schemaType : [schemaType];
          return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st2, schemaCode, it2.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
        }
        return codegen_1.nil;
      }
      function invalid$DataSchema() {
        if (def.validateSchema) {
          const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema });
          return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
        }
        return codegen_1.nil;
      }
    }
    subschema(appl, valid) {
      const subschema2 = (0, subschema_1.getSubschema)(this.it, appl);
      (0, subschema_1.extendSubschemaData)(subschema2, this.it, appl);
      (0, subschema_1.extendSubschemaMode)(subschema2, appl);
      const nextContext = { ...this.it, ...subschema2, items: void 0, props: void 0 };
      subschemaCode(nextContext, valid);
      return nextContext;
    }
    mergeEvaluated(schemaCxt, toName) {
      const { it: it2, gen } = this;
      if (!it2.opts.unevaluated)
        return;
      if (it2.props !== true && schemaCxt.props !== void 0) {
        it2.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it2.props, toName);
      }
      if (it2.items !== true && schemaCxt.items !== void 0) {
        it2.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it2.items, toName);
      }
    }
    mergeValidEvaluated(schemaCxt, valid) {
      const { it: it2, gen } = this;
      if (it2.opts.unevaluated && (it2.props !== true || it2.items !== true)) {
        gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
        return true;
      }
    }
  }
  validate.KeywordCxt = KeywordCxt;
  function keywordCode(it2, keyword2, def, ruleType) {
    const cxt = new KeywordCxt(it2, def, keyword2);
    if ("code" in def) {
      def.code(cxt, ruleType);
    } else if (cxt.$data && def.validate) {
      (0, keyword_1.funcKeywordCode)(cxt, def);
    } else if ("macro" in def) {
      (0, keyword_1.macroKeywordCode)(cxt, def);
    } else if (def.compile || def.validate) {
      (0, keyword_1.funcKeywordCode)(cxt, def);
    }
  }
  const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
  const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
  function getData($data, { dataLevel, dataNames, dataPathArr }) {
    let jsonPointer;
    let data2;
    if ($data === "")
      return names_1.default.rootData;
    if ($data[0] === "/") {
      if (!JSON_POINTER.test($data))
        throw new Error(`Invalid JSON-pointer: ${$data}`);
      jsonPointer = $data;
      data2 = names_1.default.rootData;
    } else {
      const matches = RELATIVE_JSON_POINTER.exec($data);
      if (!matches)
        throw new Error(`Invalid JSON-pointer: ${$data}`);
      const up2 = +matches[1];
      jsonPointer = matches[2];
      if (jsonPointer === "#") {
        if (up2 >= dataLevel)
          throw new Error(errorMsg("property/index", up2));
        return dataPathArr[dataLevel - up2];
      }
      if (up2 > dataLevel)
        throw new Error(errorMsg("data", up2));
      data2 = dataNames[dataLevel - up2];
      if (!jsonPointer)
        return data2;
    }
    let expr = data2;
    const segments = jsonPointer.split("/");
    for (const segment of segments) {
      if (segment) {
        data2 = (0, codegen_1._)`${data2}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
        expr = (0, codegen_1._)`${expr} && ${data2}`;
      }
    }
    return expr;
    function errorMsg(pointerType, up2) {
      return `Cannot access ${pointerType} ${up2} levels up, current level is ${dataLevel}`;
    }
  }
  validate.getData = getData;
  return validate;
}
var validation_error = {};
var hasRequiredValidation_error;
function requireValidation_error() {
  if (hasRequiredValidation_error) return validation_error;
  hasRequiredValidation_error = 1;
  Object.defineProperty(validation_error, "__esModule", { value: true });
  class ValidationError extends Error {
    constructor(errors2) {
      super("validation failed");
      this.errors = errors2;
      this.ajv = this.validation = true;
    }
  }
  validation_error.default = ValidationError;
  return validation_error;
}
var ref_error = {};
var hasRequiredRef_error;
function requireRef_error() {
  if (hasRequiredRef_error) return ref_error;
  hasRequiredRef_error = 1;
  Object.defineProperty(ref_error, "__esModule", { value: true });
  const resolve_12 = /* @__PURE__ */ requireResolve();
  class MissingRefError extends Error {
    constructor(resolver, baseId, ref2, msg) {
      super(msg || `can't resolve reference ${ref2} from id ${baseId}`);
      this.missingRef = (0, resolve_12.resolveUrl)(resolver, baseId, ref2);
      this.missingSchema = (0, resolve_12.normalizeId)((0, resolve_12.getFullPath)(resolver, this.missingRef));
    }
  }
  ref_error.default = MissingRefError;
  return ref_error;
}
var compile = {};
var hasRequiredCompile;
function requireCompile() {
  if (hasRequiredCompile) return compile;
  hasRequiredCompile = 1;
  Object.defineProperty(compile, "__esModule", { value: true });
  compile.resolveSchema = compile.getCompilingSchema = compile.resolveRef = compile.compileSchema = compile.SchemaEnv = void 0;
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const validation_error_1 = /* @__PURE__ */ requireValidation_error();
  const names_1 = /* @__PURE__ */ requireNames();
  const resolve_12 = /* @__PURE__ */ requireResolve();
  const util_1 = /* @__PURE__ */ requireUtil();
  const validate_1 = /* @__PURE__ */ requireValidate();
  class SchemaEnv {
    constructor(env) {
      var _a2;
      this.refs = {};
      this.dynamicAnchors = {};
      let schema;
      if (typeof env.schema == "object")
        schema = env.schema;
      this.schema = env.schema;
      this.schemaId = env.schemaId;
      this.root = env.root || this;
      this.baseId = (_a2 = env.baseId) !== null && _a2 !== void 0 ? _a2 : (0, resolve_12.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
      this.schemaPath = env.schemaPath;
      this.localRefs = env.localRefs;
      this.meta = env.meta;
      this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
      this.refs = {};
    }
  }
  compile.SchemaEnv = SchemaEnv;
  function compileSchema(sch) {
    const _sch = getCompilingSchema.call(this, sch);
    if (_sch)
      return _sch;
    const rootId = (0, resolve_12.getFullPath)(this.opts.uriResolver, sch.root.baseId);
    const { es5, lines } = this.opts.code;
    const { ownProperties } = this.opts;
    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
    let _ValidationError;
    if (sch.$async) {
      _ValidationError = gen.scopeValue("Error", {
        ref: validation_error_1.default,
        code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
      });
    }
    const validateName = gen.scopeName("validate");
    sch.validateName = validateName;
    const schemaCxt = {
      gen,
      allErrors: this.opts.allErrors,
      data: names_1.default.data,
      parentData: names_1.default.parentData,
      parentDataProperty: names_1.default.parentDataProperty,
      dataNames: [names_1.default.data],
      dataPathArr: [codegen_1.nil],
      // TODO can its length be used as dataLevel if nil is removed?
      dataLevel: 0,
      dataTypes: [],
      definedProperties: /* @__PURE__ */ new Set(),
      topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
      validateName,
      ValidationError: _ValidationError,
      schema: sch.schema,
      schemaEnv: sch,
      rootId,
      baseId: sch.baseId || rootId,
      schemaPath: codegen_1.nil,
      errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
      errorPath: (0, codegen_1._)`""`,
      opts: this.opts,
      self: this
    };
    let sourceCode;
    try {
      this._compilations.add(sch);
      (0, validate_1.validateFunctionCode)(schemaCxt);
      gen.optimize(this.opts.code.optimize);
      const validateCode = gen.toString();
      sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
      if (this.opts.code.process)
        sourceCode = this.opts.code.process(sourceCode, sch);
      const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
      const validate2 = makeValidate(this, this.scope.get());
      this.scope.value(validateName, { ref: validate2 });
      validate2.errors = null;
      validate2.schema = sch.schema;
      validate2.schemaEnv = sch;
      if (sch.$async)
        validate2.$async = true;
      if (this.opts.code.source === true) {
        validate2.source = { validateName, validateCode, scopeValues: gen._values };
      }
      if (this.opts.unevaluated) {
        const { props, items: items2 } = schemaCxt;
        validate2.evaluated = {
          props: props instanceof codegen_1.Name ? void 0 : props,
          items: items2 instanceof codegen_1.Name ? void 0 : items2,
          dynamicProps: props instanceof codegen_1.Name,
          dynamicItems: items2 instanceof codegen_1.Name
        };
        if (validate2.source)
          validate2.source.evaluated = (0, codegen_1.stringify)(validate2.evaluated);
      }
      sch.validate = validate2;
      return sch;
    } catch (e) {
      delete sch.validate;
      delete sch.validateName;
      if (sourceCode)
        this.logger.error("Error compiling schema, function code:", sourceCode);
      throw e;
    } finally {
      this._compilations.delete(sch);
    }
  }
  compile.compileSchema = compileSchema;
  function resolveRef2(root, baseId, ref2) {
    var _a2;
    ref2 = (0, resolve_12.resolveUrl)(this.opts.uriResolver, baseId, ref2);
    const schOrFunc = root.refs[ref2];
    if (schOrFunc)
      return schOrFunc;
    let _sch = resolve2.call(this, root, ref2);
    if (_sch === void 0) {
      const schema = (_a2 = root.localRefs) === null || _a2 === void 0 ? void 0 : _a2[ref2];
      const { schemaId } = this.opts;
      if (schema)
        _sch = new SchemaEnv({ schema, schemaId, root, baseId });
    }
    if (_sch === void 0)
      return;
    return root.refs[ref2] = inlineOrCompile.call(this, _sch);
  }
  compile.resolveRef = resolveRef2;
  function inlineOrCompile(sch) {
    if ((0, resolve_12.inlineRef)(sch.schema, this.opts.inlineRefs))
      return sch.schema;
    return sch.validate ? sch : compileSchema.call(this, sch);
  }
  function getCompilingSchema(schEnv) {
    for (const sch of this._compilations) {
      if (sameSchemaEnv(sch, schEnv))
        return sch;
    }
  }
  compile.getCompilingSchema = getCompilingSchema;
  function sameSchemaEnv(s1, s2) {
    return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
  }
  function resolve2(root, ref2) {
    let sch;
    while (typeof (sch = this.refs[ref2]) == "string")
      ref2 = sch;
    return sch || this.schemas[ref2] || resolveSchema.call(this, root, ref2);
  }
  function resolveSchema(root, ref2) {
    const p2 = this.opts.uriResolver.parse(ref2);
    const refPath = (0, resolve_12._getFullPath)(this.opts.uriResolver, p2);
    let baseId = (0, resolve_12.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
    if (Object.keys(root.schema).length > 0 && refPath === baseId) {
      return getJsonPointer.call(this, p2, root);
    }
    const id2 = (0, resolve_12.normalizeId)(refPath);
    const schOrRef = this.refs[id2] || this.schemas[id2];
    if (typeof schOrRef == "string") {
      const sch = resolveSchema.call(this, root, schOrRef);
      if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
        return;
      return getJsonPointer.call(this, p2, sch);
    }
    if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
      return;
    if (!schOrRef.validate)
      compileSchema.call(this, schOrRef);
    if (id2 === (0, resolve_12.normalizeId)(ref2)) {
      const { schema } = schOrRef;
      const { schemaId } = this.opts;
      const schId = schema[schemaId];
      if (schId)
        baseId = (0, resolve_12.resolveUrl)(this.opts.uriResolver, baseId, schId);
      return new SchemaEnv({ schema, schemaId, root, baseId });
    }
    return getJsonPointer.call(this, p2, schOrRef);
  }
  compile.resolveSchema = resolveSchema;
  const PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
    "properties",
    "patternProperties",
    "enum",
    "dependencies",
    "definitions"
  ]);
  function getJsonPointer(parsedRef, { baseId, schema, root }) {
    var _a2;
    if (((_a2 = parsedRef.fragment) === null || _a2 === void 0 ? void 0 : _a2[0]) !== "/")
      return;
    for (const part of parsedRef.fragment.slice(1).split("/")) {
      if (typeof schema === "boolean")
        return;
      const partSchema = schema[(0, util_1.unescapeFragment)(part)];
      if (partSchema === void 0)
        return;
      schema = partSchema;
      const schId = typeof schema === "object" && schema[this.opts.schemaId];
      if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
        baseId = (0, resolve_12.resolveUrl)(this.opts.uriResolver, baseId, schId);
      }
    }
    let env;
    if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
      const $ref = (0, resolve_12.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
      env = resolveSchema.call(this, root, $ref);
    }
    const { schemaId } = this.opts;
    env = env || new SchemaEnv({ schema, schemaId, root, baseId });
    if (env.schema !== env.root.schema)
      return env;
    return void 0;
  }
  return compile;
}
const $id$1 = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
const description = "Meta-schema for $data reference (JSON AnySchema extension proposal)";
const type$1 = "object";
const required$1 = ["$data"];
const properties$2 = { "$data": { "type": "string", "anyOf": [{ "format": "relative-json-pointer" }, { "format": "json-pointer" }] } };
const additionalProperties$1 = false;
const require$$9 = {
  $id: $id$1,
  description,
  type: type$1,
  required: required$1,
  properties: properties$2,
  additionalProperties: additionalProperties$1
};
var uri = {};
var hasRequiredUri;
function requireUri() {
  if (hasRequiredUri) return uri;
  hasRequiredUri = 1;
  Object.defineProperty(uri, "__esModule", { value: true });
  const uri$12 = requireFastUri();
  uri$12.code = 'require("ajv/dist/runtime/uri").default';
  uri.default = uri$12;
  return uri;
}
var hasRequiredCore$1;
function requireCore$1() {
  if (hasRequiredCore$1) return core$1;
  hasRequiredCore$1 = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.CodeGen = exports$1.Name = exports$1.nil = exports$1.stringify = exports$1.str = exports$1._ = exports$1.KeywordCxt = void 0;
    var validate_1 = /* @__PURE__ */ requireValidate();
    Object.defineProperty(exports$1, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = /* @__PURE__ */ requireCodegen();
    Object.defineProperty(exports$1, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports$1, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports$1, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports$1, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports$1, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports$1, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    const validation_error_1 = /* @__PURE__ */ requireValidation_error();
    const ref_error_1 = /* @__PURE__ */ requireRef_error();
    const rules_1 = /* @__PURE__ */ requireRules();
    const compile_12 = /* @__PURE__ */ requireCompile();
    const codegen_2 = /* @__PURE__ */ requireCodegen();
    const resolve_12 = /* @__PURE__ */ requireResolve();
    const dataType_1 = /* @__PURE__ */ requireDataType();
    const util_1 = /* @__PURE__ */ requireUtil();
    const $dataRefSchema = require$$9;
    const uri_1 = /* @__PURE__ */ requireUri();
    const defaultRegExp = (str, flags) => new RegExp(str, flags);
    defaultRegExp.code = "new RegExp";
    const META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
    const EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]);
    const removedOptions = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    };
    const deprecatedOptions = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    };
    const MAX_EXPRESSION = 200;
    function requiredOptions(o) {
      var _a2, _b, _c2, _d2, _e2, _f, _g2, _h2, _j, _k, _l2, _m, _o2, _p2, _q, _r2, _s2, _t2, _u2, _v2, _w, _x, _y, _z, _0;
      const s2 = o.strict;
      const _optz = (_a2 = o.code) === null || _a2 === void 0 ? void 0 : _a2.optimize;
      const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
      const regExp = (_c2 = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c2 !== void 0 ? _c2 : defaultRegExp;
      const uriResolver = (_d2 = o.uriResolver) !== null && _d2 !== void 0 ? _d2 : uri_1.default;
      return {
        strictSchema: (_f = (_e2 = o.strictSchema) !== null && _e2 !== void 0 ? _e2 : s2) !== null && _f !== void 0 ? _f : true,
        strictNumbers: (_h2 = (_g2 = o.strictNumbers) !== null && _g2 !== void 0 ? _g2 : s2) !== null && _h2 !== void 0 ? _h2 : true,
        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s2) !== null && _k !== void 0 ? _k : "log",
        strictTuples: (_m = (_l2 = o.strictTuples) !== null && _l2 !== void 0 ? _l2 : s2) !== null && _m !== void 0 ? _m : "log",
        strictRequired: (_p2 = (_o2 = o.strictRequired) !== null && _o2 !== void 0 ? _o2 : s2) !== null && _p2 !== void 0 ? _p2 : false,
        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
        loopEnum: (_r2 = o.loopEnum) !== null && _r2 !== void 0 ? _r2 : MAX_EXPRESSION,
        meta: (_s2 = o.meta) !== null && _s2 !== void 0 ? _s2 : true,
        messages: (_t2 = o.messages) !== null && _t2 !== void 0 ? _t2 : true,
        inlineRefs: (_u2 = o.inlineRefs) !== null && _u2 !== void 0 ? _u2 : true,
        schemaId: (_v2 = o.schemaId) !== null && _v2 !== void 0 ? _v2 : "$id",
        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
        uriResolver
      };
    }
    class Ajv2 {
      constructor(opts = {}) {
        this.schemas = {};
        this.refs = {};
        this.formats = {};
        this._compilations = /* @__PURE__ */ new Set();
        this._loading = {};
        this._cache = /* @__PURE__ */ new Map();
        opts = this.opts = { ...opts, ...requiredOptions(opts) };
        const { es5, lines } = this.opts.code;
        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
        this.logger = getLogger(opts.logger);
        const formatOpt = opts.validateFormats;
        opts.validateFormats = false;
        this.RULES = (0, rules_1.getRules)();
        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
        this._metaOpts = getMetaSchemaOptions.call(this);
        if (opts.formats)
          addInitialFormats.call(this);
        this._addVocabularies();
        this._addDefaultMetaSchema();
        if (opts.keywords)
          addInitialKeywords.call(this, opts.keywords);
        if (typeof opts.meta == "object")
          this.addMetaSchema(opts.meta);
        addInitialSchemas.call(this);
        opts.validateFormats = formatOpt;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data, meta, schemaId } = this.opts;
        let _dataRefSchema = $dataRefSchema;
        if (schemaId === "id") {
          _dataRefSchema = { ...$dataRefSchema };
          _dataRefSchema.id = _dataRefSchema.$id;
          delete _dataRefSchema.$id;
        }
        if (meta && $data)
          this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
      }
      defaultMeta() {
        const { meta, schemaId } = this.opts;
        return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
      }
      validate(schemaKeyRef, data2) {
        let v;
        if (typeof schemaKeyRef == "string") {
          v = this.getSchema(schemaKeyRef);
          if (!v)
            throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
        } else {
          v = this.compile(schemaKeyRef);
        }
        const valid = v(data2);
        if (!("$async" in v))
          this.errors = v.errors;
        return valid;
      }
      compile(schema, _meta) {
        const sch = this._addSchema(schema, _meta);
        return sch.validate || this._compileSchemaEnv(sch);
      }
      compileAsync(schema, meta) {
        if (typeof this.opts.loadSchema != "function") {
          throw new Error("options.loadSchema should be a function");
        }
        const { loadSchema } = this.opts;
        return runCompileAsync.call(this, schema, meta);
        async function runCompileAsync(_schema, _meta) {
          await loadMetaSchema.call(this, _schema.$schema);
          const sch = this._addSchema(_schema, _meta);
          return sch.validate || _compileAsync.call(this, sch);
        }
        async function loadMetaSchema($ref) {
          if ($ref && !this.getSchema($ref)) {
            await runCompileAsync.call(this, { $ref }, true);
          }
        }
        async function _compileAsync(sch) {
          try {
            return this._compileSchemaEnv(sch);
          } catch (e) {
            if (!(e instanceof ref_error_1.default))
              throw e;
            checkLoaded.call(this, e);
            await loadMissingSchema.call(this, e.missingSchema);
            return _compileAsync.call(this, sch);
          }
        }
        function checkLoaded({ missingSchema: ref2, missingRef }) {
          if (this.refs[ref2]) {
            throw new Error(`AnySchema ${ref2} is loaded but ${missingRef} cannot be resolved`);
          }
        }
        async function loadMissingSchema(ref2) {
          const _schema = await _loadSchema.call(this, ref2);
          if (!this.refs[ref2])
            await loadMetaSchema.call(this, _schema.$schema);
          if (!this.refs[ref2])
            this.addSchema(_schema, ref2, meta);
        }
        async function _loadSchema(ref2) {
          const p2 = this._loading[ref2];
          if (p2)
            return p2;
          try {
            return await (this._loading[ref2] = loadSchema(ref2));
          } finally {
            delete this._loading[ref2];
          }
        }
      }
      // Adds schema to the instance
      addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
        if (Array.isArray(schema)) {
          for (const sch of schema)
            this.addSchema(sch, void 0, _meta, _validateSchema);
          return this;
        }
        let id2;
        if (typeof schema === "object") {
          const { schemaId } = this.opts;
          id2 = schema[schemaId];
          if (id2 !== void 0 && typeof id2 != "string") {
            throw new Error(`schema ${schemaId} must be string`);
          }
        }
        key = (0, resolve_12.normalizeId)(key || id2);
        this._checkUnique(key);
        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
        return this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
        this.addSchema(schema, key, true, _validateSchema);
        return this;
      }
      //  Validate schema against its meta-schema
      validateSchema(schema, throwOrLogError) {
        if (typeof schema == "boolean")
          return true;
        let $schema2;
        $schema2 = schema.$schema;
        if ($schema2 !== void 0 && typeof $schema2 != "string") {
          throw new Error("$schema must be a string");
        }
        $schema2 = $schema2 || this.opts.defaultMeta || this.defaultMeta();
        if (!$schema2) {
          this.logger.warn("meta-schema not available");
          this.errors = null;
          return true;
        }
        const valid = this.validate($schema2, schema);
        if (!valid && throwOrLogError) {
          const message = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(message);
          else
            throw new Error(message);
        }
        return valid;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(keyRef) {
        let sch;
        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
          keyRef = sch;
        if (sch === void 0) {
          const { schemaId } = this.opts;
          const root = new compile_12.SchemaEnv({ schema: {}, schemaId });
          sch = compile_12.resolveSchema.call(this, root, keyRef);
          if (!sch)
            return;
          this.refs[keyRef] = sch;
        }
        return sch.validate || this._compileSchemaEnv(sch);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp) {
          this._removeAllSchemas(this.schemas, schemaKeyRef);
          this._removeAllSchemas(this.refs, schemaKeyRef);
          return this;
        }
        switch (typeof schemaKeyRef) {
          case "undefined":
            this._removeAllSchemas(this.schemas);
            this._removeAllSchemas(this.refs);
            this._cache.clear();
            return this;
          case "string": {
            const sch = getSchEnv.call(this, schemaKeyRef);
            if (typeof sch == "object")
              this._cache.delete(sch.schema);
            delete this.schemas[schemaKeyRef];
            delete this.refs[schemaKeyRef];
            return this;
          }
          case "object": {
            const cacheKey = schemaKeyRef;
            this._cache.delete(cacheKey);
            let id2 = schemaKeyRef[this.opts.schemaId];
            if (id2) {
              id2 = (0, resolve_12.normalizeId)(id2);
              delete this.schemas[id2];
              delete this.refs[id2];
            }
            return this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(definitions2) {
        for (const def of definitions2)
          this.addKeyword(def);
        return this;
      }
      addKeyword(kwdOrDef, def) {
        let keyword2;
        if (typeof kwdOrDef == "string") {
          keyword2 = kwdOrDef;
          if (typeof def == "object") {
            this.logger.warn("these parameters are deprecated, see docs for addKeyword");
            def.keyword = keyword2;
          }
        } else if (typeof kwdOrDef == "object" && def === void 0) {
          def = kwdOrDef;
          keyword2 = def.keyword;
          if (Array.isArray(keyword2) && !keyword2.length) {
            throw new Error("addKeywords: keyword must be string or non-empty array");
          }
        } else {
          throw new Error("invalid addKeywords parameters");
        }
        checkKeyword.call(this, keyword2, def);
        if (!def) {
          (0, util_1.eachItem)(keyword2, (kwd) => addRule.call(this, kwd));
          return this;
        }
        keywordMetaschema.call(this, def);
        const definition = {
          ...def,
          type: (0, dataType_1.getJSONTypes)(def.type),
          schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
        };
        (0, util_1.eachItem)(keyword2, definition.type.length === 0 ? (k2) => addRule.call(this, k2, definition) : (k2) => definition.type.forEach((t) => addRule.call(this, k2, definition, t)));
        return this;
      }
      getKeyword(keyword2) {
        const rule = this.RULES.all[keyword2];
        return typeof rule == "object" ? rule.definition : !!rule;
      }
      // Remove keyword
      removeKeyword(keyword2) {
        const { RULES } = this;
        delete RULES.keywords[keyword2];
        delete RULES.all[keyword2];
        for (const group of RULES.rules) {
          const i = group.rules.findIndex((rule) => rule.keyword === keyword2);
          if (i >= 0)
            group.rules.splice(i, 1);
        }
        return this;
      }
      // Add format
      addFormat(name2, format2) {
        if (typeof format2 == "string")
          format2 = new RegExp(format2);
        this.formats[name2] = format2;
        return this;
      }
      errorsText(errors2 = this.errors, { separator = ", ", dataVar = "data" } = {}) {
        if (!errors2 || errors2.length === 0)
          return "No errors";
        return errors2.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
      }
      $dataMetaSchema(metaSchema, keywordsJsonPointers) {
        const rules2 = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (const jsonPointer of keywordsJsonPointers) {
          const segments = jsonPointer.split("/").slice(1);
          let keywords = metaSchema;
          for (const seg of segments)
            keywords = keywords[seg];
          for (const key in rules2) {
            const rule = rules2[key];
            if (typeof rule != "object")
              continue;
            const { $data } = rule.definition;
            const schema = keywords[key];
            if ($data && schema)
              keywords[key] = schemaOrData(schema);
          }
        }
        return metaSchema;
      }
      _removeAllSchemas(schemas, regex) {
        for (const keyRef in schemas) {
          const sch = schemas[keyRef];
          if (!regex || regex.test(keyRef)) {
            if (typeof sch == "string") {
              delete schemas[keyRef];
            } else if (sch && !sch.meta) {
              this._cache.delete(sch.schema);
              delete schemas[keyRef];
            }
          }
        }
      }
      _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
        let id2;
        const { schemaId } = this.opts;
        if (typeof schema == "object") {
          id2 = schema[schemaId];
        } else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          else if (typeof schema != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let sch = this._cache.get(schema);
        if (sch !== void 0)
          return sch;
        baseId = (0, resolve_12.normalizeId)(id2 || baseId);
        const localRefs = resolve_12.getSchemaRefs.call(this, schema, baseId);
        sch = new compile_12.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
        this._cache.set(sch.schema, sch);
        if (addSchema && !baseId.startsWith("#")) {
          if (baseId)
            this._checkUnique(baseId);
          this.refs[baseId] = sch;
        }
        if (validateSchema)
          this.validateSchema(schema, true);
        return sch;
      }
      _checkUnique(id2) {
        if (this.schemas[id2] || this.refs[id2]) {
          throw new Error(`schema with key or id "${id2}" already exists`);
        }
      }
      _compileSchemaEnv(sch) {
        if (sch.meta)
          this._compileMetaSchema(sch);
        else
          compile_12.compileSchema.call(this, sch);
        if (!sch.validate)
          throw new Error("ajv implementation error");
        return sch.validate;
      }
      _compileMetaSchema(sch) {
        const currentOpts = this.opts;
        this.opts = this._metaOpts;
        try {
          compile_12.compileSchema.call(this, sch);
        } finally {
          this.opts = currentOpts;
        }
      }
    }
    Ajv2.ValidationError = validation_error_1.default;
    Ajv2.MissingRefError = ref_error_1.default;
    exports$1.default = Ajv2;
    function checkOptions(checkOpts, options, msg, log = "error") {
      for (const key in checkOpts) {
        const opt = key;
        if (opt in options)
          this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
      }
    }
    function getSchEnv(keyRef) {
      keyRef = (0, resolve_12.normalizeId)(keyRef);
      return this.schemas[keyRef] || this.refs[keyRef];
    }
    function addInitialSchemas() {
      const optsSchemas = this.opts.schemas;
      if (!optsSchemas)
        return;
      if (Array.isArray(optsSchemas))
        this.addSchema(optsSchemas);
      else
        for (const key in optsSchemas)
          this.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats() {
      for (const name2 in this.opts.formats) {
        const format2 = this.opts.formats[name2];
        if (format2)
          this.addFormat(name2, format2);
      }
    }
    function addInitialKeywords(defs) {
      if (Array.isArray(defs)) {
        this.addVocabulary(defs);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const keyword2 in defs) {
        const def = defs[keyword2];
        if (!def.keyword)
          def.keyword = keyword2;
        this.addKeyword(def);
      }
    }
    function getMetaSchemaOptions() {
      const metaOpts = { ...this.opts };
      for (const opt of META_IGNORE_OPTIONS)
        delete metaOpts[opt];
      return metaOpts;
    }
    const noLogs = { log() {
    }, warn() {
    }, error() {
    } };
    function getLogger(logger) {
      if (logger === false)
        return noLogs;
      if (logger === void 0)
        return console;
      if (logger.log && logger.warn && logger.error)
        return logger;
      throw new Error("logger must implement log, warn and error methods");
    }
    const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
    function checkKeyword(keyword2, def) {
      const { RULES } = this;
      (0, util_1.eachItem)(keyword2, (kwd) => {
        if (RULES.keywords[kwd])
          throw new Error(`Keyword ${kwd} is already defined`);
        if (!KEYWORD_NAME.test(kwd))
          throw new Error(`Keyword ${kwd} has invalid name`);
      });
      if (!def)
        return;
      if (def.$data && !("code" in def || "validate" in def)) {
        throw new Error('$data keyword must have "code" or "validate" function');
      }
    }
    function addRule(keyword2, definition, dataType2) {
      var _a2;
      const post = definition === null || definition === void 0 ? void 0 : definition.post;
      if (dataType2 && post)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES } = this;
      let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType2);
      if (!ruleGroup) {
        ruleGroup = { type: dataType2, rules: [] };
        RULES.rules.push(ruleGroup);
      }
      RULES.keywords[keyword2] = true;
      if (!definition)
        return;
      const rule = {
        keyword: keyword2,
        definition: {
          ...definition,
          type: (0, dataType_1.getJSONTypes)(definition.type),
          schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
        }
      };
      if (definition.before)
        addBeforeRule.call(this, ruleGroup, rule, definition.before);
      else
        ruleGroup.rules.push(rule);
      RULES.all[keyword2] = rule;
      (_a2 = definition.implements) === null || _a2 === void 0 ? void 0 : _a2.forEach((kwd) => this.addKeyword(kwd));
    }
    function addBeforeRule(ruleGroup, rule, before) {
      const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
      if (i >= 0) {
        ruleGroup.rules.splice(i, 0, rule);
      } else {
        ruleGroup.rules.push(rule);
        this.logger.warn(`rule ${before} is not defined`);
      }
    }
    function keywordMetaschema(def) {
      let { metaSchema } = def;
      if (metaSchema === void 0)
        return;
      if (def.$data && this.opts.$data)
        metaSchema = schemaOrData(metaSchema);
      def.validateSchema = this.compile(metaSchema, true);
    }
    const $dataRef = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function schemaOrData(schema) {
      return { anyOf: [schema, $dataRef] };
    }
  })(core$1);
  return core$1;
}
var draft7 = {};
var core = {};
var id$1 = {};
var hasRequiredId;
function requireId() {
  if (hasRequiredId) return id$1;
  hasRequiredId = 1;
  Object.defineProperty(id$1, "__esModule", { value: true });
  const def = {
    keyword: "id",
    code() {
      throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
    }
  };
  id$1.default = def;
  return id$1;
}
var ref = {};
var hasRequiredRef;
function requireRef() {
  if (hasRequiredRef) return ref;
  hasRequiredRef = 1;
  Object.defineProperty(ref, "__esModule", { value: true });
  ref.callRef = ref.getValidate = void 0;
  const ref_error_1 = /* @__PURE__ */ requireRef_error();
  const code_1 = /* @__PURE__ */ requireCode();
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const names_1 = /* @__PURE__ */ requireNames();
  const compile_12 = /* @__PURE__ */ requireCompile();
  const util_1 = /* @__PURE__ */ requireUtil();
  const def = {
    keyword: "$ref",
    schemaType: "string",
    code(cxt) {
      const { gen, schema: $ref, it: it2 } = cxt;
      const { baseId, schemaEnv: env, validateName, opts, self: self2 } = it2;
      const { root } = env;
      if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
        return callRootRef();
      const schOrEnv = compile_12.resolveRef.call(self2, root, baseId, $ref);
      if (schOrEnv === void 0)
        throw new ref_error_1.default(it2.opts.uriResolver, baseId, $ref);
      if (schOrEnv instanceof compile_12.SchemaEnv)
        return callValidate(schOrEnv);
      return inlineRefSchema(schOrEnv);
      function callRootRef() {
        if (env === root)
          return callRef(cxt, validateName, env, env.$async);
        const rootName = gen.scopeValue("root", { ref: root });
        return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
      }
      function callValidate(sch) {
        const v = getValidate(cxt, sch);
        callRef(cxt, v, sch, sch.$async);
      }
      function inlineRefSchema(sch) {
        const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
        const valid = gen.name("valid");
        const schCxt = cxt.subschema({
          schema: sch,
          dataTypes: [],
          schemaPath: codegen_1.nil,
          topSchemaRef: schName,
          errSchemaPath: $ref
        }, valid);
        cxt.mergeEvaluated(schCxt);
        cxt.ok(valid);
      }
    }
  };
  function getValidate(cxt, sch) {
    const { gen } = cxt;
    return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
  }
  ref.getValidate = getValidate;
  function callRef(cxt, v, sch, $async) {
    const { gen, it: it2 } = cxt;
    const { allErrors, schemaEnv: env, opts } = it2;
    const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
    if ($async)
      callAsyncRef();
    else
      callSyncRef();
    function callAsyncRef() {
      if (!env.$async)
        throw new Error("async schema referenced by sync schema");
      const valid = gen.let("valid");
      gen.try(() => {
        gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
        addEvaluatedFrom(v);
        if (!allErrors)
          gen.assign(valid, true);
      }, (e) => {
        gen.if((0, codegen_1._)`!(${e} instanceof ${it2.ValidationError})`, () => gen.throw(e));
        addErrorsFrom(e);
        if (!allErrors)
          gen.assign(valid, false);
      });
      cxt.ok(valid);
    }
    function callSyncRef() {
      cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
    }
    function addErrorsFrom(source) {
      const errs = (0, codegen_1._)`${source}.errors`;
      gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
      gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
    }
    function addEvaluatedFrom(source) {
      var _a2;
      if (!it2.opts.unevaluated)
        return;
      const schEvaluated = (_a2 = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a2 === void 0 ? void 0 : _a2.evaluated;
      if (it2.props !== true) {
        if (schEvaluated && !schEvaluated.dynamicProps) {
          if (schEvaluated.props !== void 0) {
            it2.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it2.props);
          }
        } else {
          const props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
          it2.props = util_1.mergeEvaluated.props(gen, props, it2.props, codegen_1.Name);
        }
      }
      if (it2.items !== true) {
        if (schEvaluated && !schEvaluated.dynamicItems) {
          if (schEvaluated.items !== void 0) {
            it2.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it2.items);
          }
        } else {
          const items2 = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
          it2.items = util_1.mergeEvaluated.items(gen, items2, it2.items, codegen_1.Name);
        }
      }
    }
  }
  ref.callRef = callRef;
  ref.default = def;
  return ref;
}
var hasRequiredCore;
function requireCore() {
  if (hasRequiredCore) return core;
  hasRequiredCore = 1;
  Object.defineProperty(core, "__esModule", { value: true });
  const id_1 = /* @__PURE__ */ requireId();
  const ref_1 = /* @__PURE__ */ requireRef();
  const core$12 = [
    "$schema",
    "$id",
    "$defs",
    "$vocabulary",
    { keyword: "$comment" },
    "definitions",
    id_1.default,
    ref_1.default
  ];
  core.default = core$12;
  return core;
}
var validation = {};
var limitNumber = {};
var hasRequiredLimitNumber;
function requireLimitNumber() {
  if (hasRequiredLimitNumber) return limitNumber;
  hasRequiredLimitNumber = 1;
  Object.defineProperty(limitNumber, "__esModule", { value: true });
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const ops = codegen_1.operators;
  const KWDs = {
    maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
    minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
    exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
    exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
  };
  const error = {
    message: ({ keyword: keyword2, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword2].okStr} ${schemaCode}`,
    params: ({ keyword: keyword2, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword2].okStr}, limit: ${schemaCode}}`
  };
  const def = {
    keyword: Object.keys(KWDs),
    type: "number",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
      const { keyword: keyword2, data: data2, schemaCode } = cxt;
      cxt.fail$data((0, codegen_1._)`${data2} ${KWDs[keyword2].fail} ${schemaCode} || isNaN(${data2})`);
    }
  };
  limitNumber.default = def;
  return limitNumber;
}
var multipleOf = {};
var hasRequiredMultipleOf;
function requireMultipleOf() {
  if (hasRequiredMultipleOf) return multipleOf;
  hasRequiredMultipleOf = 1;
  Object.defineProperty(multipleOf, "__esModule", { value: true });
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const error = {
    message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
    params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
  };
  const def = {
    keyword: "multipleOf",
    type: "number",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
      const { gen, data: data2, schemaCode, it: it2 } = cxt;
      const prec = it2.opts.multipleOfPrecision;
      const res = gen.let("res");
      const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
      cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data2}/${schemaCode}, ${invalid}))`);
    }
  };
  multipleOf.default = def;
  return multipleOf;
}
var limitLength = {};
var ucs2length = {};
var hasRequiredUcs2length;
function requireUcs2length() {
  if (hasRequiredUcs2length) return ucs2length;
  hasRequiredUcs2length = 1;
  Object.defineProperty(ucs2length, "__esModule", { value: true });
  function ucs2length$12(str) {
    const len = str.length;
    let length = 0;
    let pos = 0;
    let value;
    while (pos < len) {
      length++;
      value = str.charCodeAt(pos++);
      if (value >= 55296 && value <= 56319 && pos < len) {
        value = str.charCodeAt(pos);
        if ((value & 64512) === 56320)
          pos++;
      }
    }
    return length;
  }
  ucs2length.default = ucs2length$12;
  ucs2length$12.code = 'require("ajv/dist/runtime/ucs2length").default';
  return ucs2length;
}
var hasRequiredLimitLength;
function requireLimitLength() {
  if (hasRequiredLimitLength) return limitLength;
  hasRequiredLimitLength = 1;
  Object.defineProperty(limitLength, "__esModule", { value: true });
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const util_1 = /* @__PURE__ */ requireUtil();
  const ucs2length_1 = /* @__PURE__ */ requireUcs2length();
  const error = {
    message({ keyword: keyword2, schemaCode }) {
      const comp = keyword2 === "maxLength" ? "more" : "fewer";
      return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
    },
    params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
  };
  const def = {
    keyword: ["maxLength", "minLength"],
    type: "string",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
      const { keyword: keyword2, data: data2, schemaCode, it: it2 } = cxt;
      const op2 = keyword2 === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
      const len = it2.opts.unicode === false ? (0, codegen_1._)`${data2}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data2})`;
      cxt.fail$data((0, codegen_1._)`${len} ${op2} ${schemaCode}`);
    }
  };
  limitLength.default = def;
  return limitLength;
}
var pattern = {};
var hasRequiredPattern;
function requirePattern() {
  if (hasRequiredPattern) return pattern;
  hasRequiredPattern = 1;
  Object.defineProperty(pattern, "__esModule", { value: true });
  const code_1 = /* @__PURE__ */ requireCode();
  const util_1 = /* @__PURE__ */ requireUtil();
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const error = {
    message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
    params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
  };
  const def = {
    keyword: "pattern",
    type: "string",
    schemaType: "string",
    $data: true,
    error,
    code(cxt) {
      const { gen, data: data2, $data, schema, schemaCode, it: it2 } = cxt;
      const u2 = it2.opts.unicodeRegExp ? "u" : "";
      if ($data) {
        const { regExp } = it2.opts.code;
        const regExpCode = regExp.code === "new RegExp" ? (0, codegen_1._)`new RegExp` : (0, util_1.useFunc)(gen, regExp);
        const valid = gen.let("valid");
        gen.try(() => gen.assign(valid, (0, codegen_1._)`${regExpCode}(${schemaCode}, ${u2}).test(${data2})`), () => gen.assign(valid, false));
        cxt.fail$data((0, codegen_1._)`!${valid}`);
      } else {
        const regExp = (0, code_1.usePattern)(cxt, schema);
        cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data2})`);
      }
    }
  };
  pattern.default = def;
  return pattern;
}
var limitProperties = {};
var hasRequiredLimitProperties;
function requireLimitProperties() {
  if (hasRequiredLimitProperties) return limitProperties;
  hasRequiredLimitProperties = 1;
  Object.defineProperty(limitProperties, "__esModule", { value: true });
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const error = {
    message({ keyword: keyword2, schemaCode }) {
      const comp = keyword2 === "maxProperties" ? "more" : "fewer";
      return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
    },
    params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
  };
  const def = {
    keyword: ["maxProperties", "minProperties"],
    type: "object",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
      const { keyword: keyword2, data: data2, schemaCode } = cxt;
      const op2 = keyword2 === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
      cxt.fail$data((0, codegen_1._)`Object.keys(${data2}).length ${op2} ${schemaCode}`);
    }
  };
  limitProperties.default = def;
  return limitProperties;
}
var required = {};
var hasRequiredRequired;
function requireRequired() {
  if (hasRequiredRequired) return required;
  hasRequiredRequired = 1;
  Object.defineProperty(required, "__esModule", { value: true });
  const code_1 = /* @__PURE__ */ requireCode();
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const util_1 = /* @__PURE__ */ requireUtil();
  const error = {
    message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
    params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
  };
  const def = {
    keyword: "required",
    type: "object",
    schemaType: "array",
    $data: true,
    error,
    code(cxt) {
      const { gen, schema, schemaCode, data: data2, $data, it: it2 } = cxt;
      const { opts } = it2;
      if (!$data && schema.length === 0)
        return;
      const useLoop = schema.length >= opts.loopRequired;
      if (it2.allErrors)
        allErrorsMode();
      else
        exitOnErrorMode();
      if (opts.strictRequired) {
        const props = cxt.parentSchema.properties;
        const { definedProperties } = cxt.it;
        for (const requiredKey of schema) {
          if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
            const schemaPath = it2.schemaEnv.baseId + it2.errSchemaPath;
            const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
            (0, util_1.checkStrictMode)(it2, msg, it2.opts.strictRequired);
          }
        }
      }
      function allErrorsMode() {
        if (useLoop || $data) {
          cxt.block$data(codegen_1.nil, loopAllRequired);
        } else {
          for (const prop of schema) {
            (0, code_1.checkReportMissingProp)(cxt, prop);
          }
        }
      }
      function exitOnErrorMode() {
        const missing = gen.let("missing");
        if (useLoop || $data) {
          const valid = gen.let("valid", true);
          cxt.block$data(valid, () => loopUntilMissing(missing, valid));
          cxt.ok(valid);
        } else {
          gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
          (0, code_1.reportMissingProp)(cxt, missing);
          gen.else();
        }
      }
      function loopAllRequired() {
        gen.forOf("prop", schemaCode, (prop) => {
          cxt.setParams({ missingProperty: prop });
          gen.if((0, code_1.noPropertyInData)(gen, data2, prop, opts.ownProperties), () => cxt.error());
        });
      }
      function loopUntilMissing(missing, valid) {
        cxt.setParams({ missingProperty: missing });
        gen.forOf(missing, schemaCode, () => {
          gen.assign(valid, (0, code_1.propertyInData)(gen, data2, missing, opts.ownProperties));
          gen.if((0, codegen_1.not)(valid), () => {
            cxt.error();
            gen.break();
          });
        }, codegen_1.nil);
      }
    }
  };
  required.default = def;
  return required;
}
var limitItems = {};
var hasRequiredLimitItems;
function requireLimitItems() {
  if (hasRequiredLimitItems) return limitItems;
  hasRequiredLimitItems = 1;
  Object.defineProperty(limitItems, "__esModule", { value: true });
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const error = {
    message({ keyword: keyword2, schemaCode }) {
      const comp = keyword2 === "maxItems" ? "more" : "fewer";
      return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
    },
    params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
  };
  const def = {
    keyword: ["maxItems", "minItems"],
    type: "array",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
      const { keyword: keyword2, data: data2, schemaCode } = cxt;
      const op2 = keyword2 === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
      cxt.fail$data((0, codegen_1._)`${data2}.length ${op2} ${schemaCode}`);
    }
  };
  limitItems.default = def;
  return limitItems;
}
var uniqueItems = {};
var equal = {};
var hasRequiredEqual;
function requireEqual() {
  if (hasRequiredEqual) return equal;
  hasRequiredEqual = 1;
  Object.defineProperty(equal, "__esModule", { value: true });
  const equal$12 = requireFastDeepEqual();
  equal$12.code = 'require("ajv/dist/runtime/equal").default';
  equal.default = equal$12;
  return equal;
}
var hasRequiredUniqueItems;
function requireUniqueItems() {
  if (hasRequiredUniqueItems) return uniqueItems;
  hasRequiredUniqueItems = 1;
  Object.defineProperty(uniqueItems, "__esModule", { value: true });
  const dataType_1 = /* @__PURE__ */ requireDataType();
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const util_1 = /* @__PURE__ */ requireUtil();
  const equal_1 = /* @__PURE__ */ requireEqual();
  const error = {
    message: ({ params: { i, j: j2 } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j2} and ${i} are identical)`,
    params: ({ params: { i, j: j2 } }) => (0, codegen_1._)`{i: ${i}, j: ${j2}}`
  };
  const def = {
    keyword: "uniqueItems",
    type: "array",
    schemaType: "boolean",
    $data: true,
    error,
    code(cxt) {
      const { gen, data: data2, $data, schema, parentSchema, schemaCode, it: it2 } = cxt;
      if (!$data && !schema)
        return;
      const valid = gen.let("valid");
      const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
      cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
      cxt.ok(valid);
      function validateUniqueItems() {
        const i = gen.let("i", (0, codegen_1._)`${data2}.length`);
        const j2 = gen.let("j");
        cxt.setParams({ i, j: j2 });
        gen.assign(valid, true);
        gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j2));
      }
      function canOptimize() {
        return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
      }
      function loopN(i, j2) {
        const item = gen.name("item");
        const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it2.opts.strictNumbers, dataType_1.DataType.Wrong);
        const indices = gen.const("indices", (0, codegen_1._)`{}`);
        gen.for((0, codegen_1._)`;${i}--;`, () => {
          gen.let(item, (0, codegen_1._)`${data2}[${i}]`);
          gen.if(wrongType, (0, codegen_1._)`continue`);
          if (itemTypes.length > 1)
            gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
          gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
            gen.assign(j2, (0, codegen_1._)`${indices}[${item}]`);
            cxt.error();
            gen.assign(valid, false).break();
          }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
        });
      }
      function loopN2(i, j2) {
        const eql = (0, util_1.useFunc)(gen, equal_1.default);
        const outer = gen.name("outer");
        gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j2} = ${i}; ${j2}--;`, () => gen.if((0, codegen_1._)`${eql}(${data2}[${i}], ${data2}[${j2}])`, () => {
          cxt.error();
          gen.assign(valid, false).break(outer);
        })));
      }
    }
  };
  uniqueItems.default = def;
  return uniqueItems;
}
var _const = {};
var hasRequired_const;
function require_const() {
  if (hasRequired_const) return _const;
  hasRequired_const = 1;
  Object.defineProperty(_const, "__esModule", { value: true });
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const util_1 = /* @__PURE__ */ requireUtil();
  const equal_1 = /* @__PURE__ */ requireEqual();
  const error = {
    message: "must be equal to constant",
    params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
  };
  const def = {
    keyword: "const",
    $data: true,
    error,
    code(cxt) {
      const { gen, data: data2, $data, schemaCode, schema } = cxt;
      if ($data || schema && typeof schema == "object") {
        cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data2}, ${schemaCode})`);
      } else {
        cxt.fail((0, codegen_1._)`${schema} !== ${data2}`);
      }
    }
  };
  _const.default = def;
  return _const;
}
var _enum = {};
var hasRequired_enum;
function require_enum() {
  if (hasRequired_enum) return _enum;
  hasRequired_enum = 1;
  Object.defineProperty(_enum, "__esModule", { value: true });
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const util_1 = /* @__PURE__ */ requireUtil();
  const equal_1 = /* @__PURE__ */ requireEqual();
  const error = {
    message: "must be equal to one of the allowed values",
    params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
  };
  const def = {
    keyword: "enum",
    schemaType: "array",
    $data: true,
    error,
    code(cxt) {
      const { gen, data: data2, $data, schema, schemaCode, it: it2 } = cxt;
      if (!$data && schema.length === 0)
        throw new Error("enum must have non-empty array");
      const useLoop = schema.length >= it2.opts.loopEnum;
      let eql;
      const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);
      let valid;
      if (useLoop || $data) {
        valid = gen.let("valid");
        cxt.block$data(valid, loopEnum);
      } else {
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        const vSchema = gen.const("vSchema", schemaCode);
        valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
      }
      cxt.pass(valid);
      function loopEnum() {
        gen.assign(valid, false);
        gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._)`${getEql()}(${data2}, ${v})`, () => gen.assign(valid, true).break()));
      }
      function equalCode(vSchema, i) {
        const sch = schema[i];
        return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data2}, ${vSchema}[${i}])` : (0, codegen_1._)`${data2} === ${sch}`;
      }
    }
  };
  _enum.default = def;
  return _enum;
}
var hasRequiredValidation;
function requireValidation() {
  if (hasRequiredValidation) return validation;
  hasRequiredValidation = 1;
  Object.defineProperty(validation, "__esModule", { value: true });
  const limitNumber_1 = /* @__PURE__ */ requireLimitNumber();
  const multipleOf_1 = /* @__PURE__ */ requireMultipleOf();
  const limitLength_1 = /* @__PURE__ */ requireLimitLength();
  const pattern_1 = /* @__PURE__ */ requirePattern();
  const limitProperties_1 = /* @__PURE__ */ requireLimitProperties();
  const required_1 = /* @__PURE__ */ requireRequired();
  const limitItems_1 = /* @__PURE__ */ requireLimitItems();
  const uniqueItems_1 = /* @__PURE__ */ requireUniqueItems();
  const const_1 = /* @__PURE__ */ require_const();
  const enum_1 = /* @__PURE__ */ require_enum();
  const validation$12 = [
    // number
    limitNumber_1.default,
    multipleOf_1.default,
    // string
    limitLength_1.default,
    pattern_1.default,
    // object
    limitProperties_1.default,
    required_1.default,
    // array
    limitItems_1.default,
    uniqueItems_1.default,
    // any
    { keyword: "type", schemaType: ["string", "array"] },
    { keyword: "nullable", schemaType: "boolean" },
    const_1.default,
    enum_1.default
  ];
  validation.default = validation$12;
  return validation;
}
var applicator = {};
var additionalItems = {};
var hasRequiredAdditionalItems;
function requireAdditionalItems() {
  if (hasRequiredAdditionalItems) return additionalItems;
  hasRequiredAdditionalItems = 1;
  Object.defineProperty(additionalItems, "__esModule", { value: true });
  additionalItems.validateAdditionalItems = void 0;
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const util_1 = /* @__PURE__ */ requireUtil();
  const error = {
    message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
    params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
  };
  const def = {
    keyword: "additionalItems",
    type: "array",
    schemaType: ["boolean", "object"],
    before: "uniqueItems",
    error,
    code(cxt) {
      const { parentSchema, it: it2 } = cxt;
      const { items: items2 } = parentSchema;
      if (!Array.isArray(items2)) {
        (0, util_1.checkStrictMode)(it2, '"additionalItems" is ignored when "items" is not an array of schemas');
        return;
      }
      validateAdditionalItems(cxt, items2);
    }
  };
  function validateAdditionalItems(cxt, items2) {
    const { gen, schema, data: data2, keyword: keyword2, it: it2 } = cxt;
    it2.items = true;
    const len = gen.const("len", (0, codegen_1._)`${data2}.length`);
    if (schema === false) {
      cxt.setParams({ len: items2.length });
      cxt.pass((0, codegen_1._)`${len} <= ${items2.length}`);
    } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it2, schema)) {
      const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items2.length}`);
      gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
      cxt.ok(valid);
    }
    function validateItems(valid) {
      gen.forRange("i", items2.length, len, (i) => {
        cxt.subschema({ keyword: keyword2, dataProp: i, dataPropType: util_1.Type.Num }, valid);
        if (!it2.allErrors)
          gen.if((0, codegen_1.not)(valid), () => gen.break());
      });
    }
  }
  additionalItems.validateAdditionalItems = validateAdditionalItems;
  additionalItems.default = def;
  return additionalItems;
}
var prefixItems = {};
var items = {};
var hasRequiredItems;
function requireItems() {
  if (hasRequiredItems) return items;
  hasRequiredItems = 1;
  Object.defineProperty(items, "__esModule", { value: true });
  items.validateTuple = void 0;
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const util_1 = /* @__PURE__ */ requireUtil();
  const code_1 = /* @__PURE__ */ requireCode();
  const def = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "array", "boolean"],
    before: "uniqueItems",
    code(cxt) {
      const { schema, it: it2 } = cxt;
      if (Array.isArray(schema))
        return validateTuple(cxt, "additionalItems", schema);
      it2.items = true;
      if ((0, util_1.alwaysValidSchema)(it2, schema))
        return;
      cxt.ok((0, code_1.validateArray)(cxt));
    }
  };
  function validateTuple(cxt, extraItems, schArr = cxt.schema) {
    const { gen, parentSchema, data: data2, keyword: keyword2, it: it2 } = cxt;
    checkStrictTuple(parentSchema);
    if (it2.opts.unevaluated && schArr.length && it2.items !== true) {
      it2.items = util_1.mergeEvaluated.items(gen, schArr.length, it2.items);
    }
    const valid = gen.name("valid");
    const len = gen.const("len", (0, codegen_1._)`${data2}.length`);
    schArr.forEach((sch, i) => {
      if ((0, util_1.alwaysValidSchema)(it2, sch))
        return;
      gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
        keyword: keyword2,
        schemaProp: i,
        dataProp: i
      }, valid));
      cxt.ok(valid);
    });
    function checkStrictTuple(sch) {
      const { opts, errSchemaPath } = it2;
      const l = schArr.length;
      const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
      if (opts.strictTuples && !fullTuple) {
        const msg = `"${keyword2}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
        (0, util_1.checkStrictMode)(it2, msg, opts.strictTuples);
      }
    }
  }
  items.validateTuple = validateTuple;
  items.default = def;
  return items;
}
var hasRequiredPrefixItems;
function requirePrefixItems() {
  if (hasRequiredPrefixItems) return prefixItems;
  hasRequiredPrefixItems = 1;
  Object.defineProperty(prefixItems, "__esModule", { value: true });
  const items_1 = /* @__PURE__ */ requireItems();
  const def = {
    keyword: "prefixItems",
    type: "array",
    schemaType: ["array"],
    before: "uniqueItems",
    code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
  };
  prefixItems.default = def;
  return prefixItems;
}
var items2020 = {};
var hasRequiredItems2020;
function requireItems2020() {
  if (hasRequiredItems2020) return items2020;
  hasRequiredItems2020 = 1;
  Object.defineProperty(items2020, "__esModule", { value: true });
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const util_1 = /* @__PURE__ */ requireUtil();
  const code_1 = /* @__PURE__ */ requireCode();
  const additionalItems_1 = /* @__PURE__ */ requireAdditionalItems();
  const error = {
    message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
    params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
  };
  const def = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    error,
    code(cxt) {
      const { schema, parentSchema, it: it2 } = cxt;
      const { prefixItems: prefixItems2 } = parentSchema;
      it2.items = true;
      if ((0, util_1.alwaysValidSchema)(it2, schema))
        return;
      if (prefixItems2)
        (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems2);
      else
        cxt.ok((0, code_1.validateArray)(cxt));
    }
  };
  items2020.default = def;
  return items2020;
}
var contains = {};
var hasRequiredContains;
function requireContains() {
  if (hasRequiredContains) return contains;
  hasRequiredContains = 1;
  Object.defineProperty(contains, "__esModule", { value: true });
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const util_1 = /* @__PURE__ */ requireUtil();
  const error = {
    message: ({ params: { min: min2, max: max2 } }) => max2 === void 0 ? (0, codegen_1.str)`must contain at least ${min2} valid item(s)` : (0, codegen_1.str)`must contain at least ${min2} and no more than ${max2} valid item(s)`,
    params: ({ params: { min: min2, max: max2 } }) => max2 === void 0 ? (0, codegen_1._)`{minContains: ${min2}}` : (0, codegen_1._)`{minContains: ${min2}, maxContains: ${max2}}`
  };
  const def = {
    keyword: "contains",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    trackErrors: true,
    error,
    code(cxt) {
      const { gen, schema, parentSchema, data: data2, it: it2 } = cxt;
      let min2;
      let max2;
      const { minContains, maxContains } = parentSchema;
      if (it2.opts.next) {
        min2 = minContains === void 0 ? 1 : minContains;
        max2 = maxContains;
      } else {
        min2 = 1;
      }
      const len = gen.const("len", (0, codegen_1._)`${data2}.length`);
      cxt.setParams({ min: min2, max: max2 });
      if (max2 === void 0 && min2 === 0) {
        (0, util_1.checkStrictMode)(it2, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
        return;
      }
      if (max2 !== void 0 && min2 > max2) {
        (0, util_1.checkStrictMode)(it2, `"minContains" > "maxContains" is always invalid`);
        cxt.fail();
        return;
      }
      if ((0, util_1.alwaysValidSchema)(it2, schema)) {
        let cond = (0, codegen_1._)`${len} >= ${min2}`;
        if (max2 !== void 0)
          cond = (0, codegen_1._)`${cond} && ${len} <= ${max2}`;
        cxt.pass(cond);
        return;
      }
      it2.items = true;
      const valid = gen.name("valid");
      if (max2 === void 0 && min2 === 1) {
        validateItems(valid, () => gen.if(valid, () => gen.break()));
      } else if (min2 === 0) {
        gen.let(valid, true);
        if (max2 !== void 0)
          gen.if((0, codegen_1._)`${data2}.length > 0`, validateItemsWithCount);
      } else {
        gen.let(valid, false);
        validateItemsWithCount();
      }
      cxt.result(valid, () => cxt.reset());
      function validateItemsWithCount() {
        const schValid = gen.name("_valid");
        const count2 = gen.let("count", 0);
        validateItems(schValid, () => gen.if(schValid, () => checkLimits(count2)));
      }
      function validateItems(_valid, block) {
        gen.forRange("i", 0, len, (i) => {
          cxt.subschema({
            keyword: "contains",
            dataProp: i,
            dataPropType: util_1.Type.Num,
            compositeRule: true
          }, _valid);
          block();
        });
      }
      function checkLimits(count2) {
        gen.code((0, codegen_1._)`${count2}++`);
        if (max2 === void 0) {
          gen.if((0, codegen_1._)`${count2} >= ${min2}`, () => gen.assign(valid, true).break());
        } else {
          gen.if((0, codegen_1._)`${count2} > ${max2}`, () => gen.assign(valid, false).break());
          if (min2 === 1)
            gen.assign(valid, true);
          else
            gen.if((0, codegen_1._)`${count2} >= ${min2}`, () => gen.assign(valid, true));
        }
      }
    }
  };
  contains.default = def;
  return contains;
}
var dependencies = {};
var hasRequiredDependencies;
function requireDependencies() {
  if (hasRequiredDependencies) return dependencies;
  hasRequiredDependencies = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.validateSchemaDeps = exports$1.validatePropertyDeps = exports$1.error = void 0;
    const codegen_1 = /* @__PURE__ */ requireCodegen();
    const util_1 = /* @__PURE__ */ requireUtil();
    const code_1 = /* @__PURE__ */ requireCode();
    exports$1.error = {
      message: ({ params: { property, depsCount, deps } }) => {
        const property_ies = depsCount === 1 ? "property" : "properties";
        return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
      },
      params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
      // TODO change to reference
    };
    const def = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: exports$1.error,
      code(cxt) {
        const [propDeps, schDeps] = splitDependencies(cxt);
        validatePropertyDeps(cxt, propDeps);
        validateSchemaDeps(cxt, schDeps);
      }
    };
    function splitDependencies({ schema }) {
      const propertyDeps = {};
      const schemaDeps = {};
      for (const key in schema) {
        if (key === "__proto__")
          continue;
        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
        deps[key] = schema[key];
      }
      return [propertyDeps, schemaDeps];
    }
    function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
      const { gen, data: data2, it: it2 } = cxt;
      if (Object.keys(propertyDeps).length === 0)
        return;
      const missing = gen.let("missing");
      for (const prop in propertyDeps) {
        const deps = propertyDeps[prop];
        if (deps.length === 0)
          continue;
        const hasProperty = (0, code_1.propertyInData)(gen, data2, prop, it2.opts.ownProperties);
        cxt.setParams({
          property: prop,
          depsCount: deps.length,
          deps: deps.join(", ")
        });
        if (it2.allErrors) {
          gen.if(hasProperty, () => {
            for (const depProp of deps) {
              (0, code_1.checkReportMissingProp)(cxt, depProp);
            }
          });
        } else {
          gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
          (0, code_1.reportMissingProp)(cxt, missing);
          gen.else();
        }
      }
    }
    exports$1.validatePropertyDeps = validatePropertyDeps;
    function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
      const { gen, data: data2, keyword: keyword2, it: it2 } = cxt;
      const valid = gen.name("valid");
      for (const prop in schemaDeps) {
        if ((0, util_1.alwaysValidSchema)(it2, schemaDeps[prop]))
          continue;
        gen.if(
          (0, code_1.propertyInData)(gen, data2, prop, it2.opts.ownProperties),
          () => {
            const schCxt = cxt.subschema({ keyword: keyword2, schemaProp: prop }, valid);
            cxt.mergeValidEvaluated(schCxt, valid);
          },
          () => gen.var(valid, true)
          // TODO var
        );
        cxt.ok(valid);
      }
    }
    exports$1.validateSchemaDeps = validateSchemaDeps;
    exports$1.default = def;
  })(dependencies);
  return dependencies;
}
var propertyNames = {};
var hasRequiredPropertyNames;
function requirePropertyNames() {
  if (hasRequiredPropertyNames) return propertyNames;
  hasRequiredPropertyNames = 1;
  Object.defineProperty(propertyNames, "__esModule", { value: true });
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const util_1 = /* @__PURE__ */ requireUtil();
  const error = {
    message: "property name must be valid",
    params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
  };
  const def = {
    keyword: "propertyNames",
    type: "object",
    schemaType: ["object", "boolean"],
    error,
    code(cxt) {
      const { gen, schema, data: data2, it: it2 } = cxt;
      if ((0, util_1.alwaysValidSchema)(it2, schema))
        return;
      const valid = gen.name("valid");
      gen.forIn("key", data2, (key) => {
        cxt.setParams({ propertyName: key });
        cxt.subschema({
          keyword: "propertyNames",
          data: key,
          dataTypes: ["string"],
          propertyName: key,
          compositeRule: true
        }, valid);
        gen.if((0, codegen_1.not)(valid), () => {
          cxt.error(true);
          if (!it2.allErrors)
            gen.break();
        });
      });
      cxt.ok(valid);
    }
  };
  propertyNames.default = def;
  return propertyNames;
}
var additionalProperties = {};
var hasRequiredAdditionalProperties;
function requireAdditionalProperties() {
  if (hasRequiredAdditionalProperties) return additionalProperties;
  hasRequiredAdditionalProperties = 1;
  Object.defineProperty(additionalProperties, "__esModule", { value: true });
  const code_1 = /* @__PURE__ */ requireCode();
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const names_1 = /* @__PURE__ */ requireNames();
  const util_1 = /* @__PURE__ */ requireUtil();
  const error = {
    message: "must NOT have additional properties",
    params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
  };
  const def = {
    keyword: "additionalProperties",
    type: ["object"],
    schemaType: ["boolean", "object"],
    allowUndefined: true,
    trackErrors: true,
    error,
    code(cxt) {
      const { gen, schema, parentSchema, data: data2, errsCount, it: it2 } = cxt;
      if (!errsCount)
        throw new Error("ajv implementation error");
      const { allErrors, opts } = it2;
      it2.props = true;
      if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it2, schema))
        return;
      const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
      const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
      checkAdditionalProperties();
      cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
      function checkAdditionalProperties() {
        gen.forIn("key", data2, (key) => {
          if (!props.length && !patProps.length)
            additionalPropertyCode(key);
          else
            gen.if(isAdditional(key), () => additionalPropertyCode(key));
        });
      }
      function isAdditional(key) {
        let definedProp;
        if (props.length > 8) {
          const propsSchema = (0, util_1.schemaRefOrVal)(it2, parentSchema.properties, "properties");
          definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
        } else if (props.length) {
          definedProp = (0, codegen_1.or)(...props.map((p2) => (0, codegen_1._)`${key} === ${p2}`));
        } else {
          definedProp = codegen_1.nil;
        }
        if (patProps.length) {
          definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p2) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p2)}.test(${key})`));
        }
        return (0, codegen_1.not)(definedProp);
      }
      function deleteAdditional(key) {
        gen.code((0, codegen_1._)`delete ${data2}[${key}]`);
      }
      function additionalPropertyCode(key) {
        if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
          deleteAdditional(key);
          return;
        }
        if (schema === false) {
          cxt.setParams({ additionalProperty: key });
          cxt.error();
          if (!allErrors)
            gen.break();
          return;
        }
        if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it2, schema)) {
          const valid = gen.name("valid");
          if (opts.removeAdditional === "failing") {
            applyAdditionalSchema(key, valid, false);
            gen.if((0, codegen_1.not)(valid), () => {
              cxt.reset();
              deleteAdditional(key);
            });
          } else {
            applyAdditionalSchema(key, valid);
            if (!allErrors)
              gen.if((0, codegen_1.not)(valid), () => gen.break());
          }
        }
      }
      function applyAdditionalSchema(key, valid, errors2) {
        const subschema2 = {
          keyword: "additionalProperties",
          dataProp: key,
          dataPropType: util_1.Type.Str
        };
        if (errors2 === false) {
          Object.assign(subschema2, {
            compositeRule: true,
            createErrors: false,
            allErrors: false
          });
        }
        cxt.subschema(subschema2, valid);
      }
    }
  };
  additionalProperties.default = def;
  return additionalProperties;
}
var properties$1 = {};
var hasRequiredProperties;
function requireProperties() {
  if (hasRequiredProperties) return properties$1;
  hasRequiredProperties = 1;
  Object.defineProperty(properties$1, "__esModule", { value: true });
  const validate_1 = /* @__PURE__ */ requireValidate();
  const code_1 = /* @__PURE__ */ requireCode();
  const util_1 = /* @__PURE__ */ requireUtil();
  const additionalProperties_1 = /* @__PURE__ */ requireAdditionalProperties();
  const def = {
    keyword: "properties",
    type: "object",
    schemaType: "object",
    code(cxt) {
      const { gen, schema, parentSchema, data: data2, it: it2 } = cxt;
      if (it2.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
        additionalProperties_1.default.code(new validate_1.KeywordCxt(it2, additionalProperties_1.default, "additionalProperties"));
      }
      const allProps = (0, code_1.allSchemaProperties)(schema);
      for (const prop of allProps) {
        it2.definedProperties.add(prop);
      }
      if (it2.opts.unevaluated && allProps.length && it2.props !== true) {
        it2.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it2.props);
      }
      const properties2 = allProps.filter((p2) => !(0, util_1.alwaysValidSchema)(it2, schema[p2]));
      if (properties2.length === 0)
        return;
      const valid = gen.name("valid");
      for (const prop of properties2) {
        if (hasDefault(prop)) {
          applyPropertySchema(prop);
        } else {
          gen.if((0, code_1.propertyInData)(gen, data2, prop, it2.opts.ownProperties));
          applyPropertySchema(prop);
          if (!it2.allErrors)
            gen.else().var(valid, true);
          gen.endIf();
        }
        cxt.it.definedProperties.add(prop);
        cxt.ok(valid);
      }
      function hasDefault(prop) {
        return it2.opts.useDefaults && !it2.compositeRule && schema[prop].default !== void 0;
      }
      function applyPropertySchema(prop) {
        cxt.subschema({
          keyword: "properties",
          schemaProp: prop,
          dataProp: prop
        }, valid);
      }
    }
  };
  properties$1.default = def;
  return properties$1;
}
var patternProperties = {};
var hasRequiredPatternProperties;
function requirePatternProperties() {
  if (hasRequiredPatternProperties) return patternProperties;
  hasRequiredPatternProperties = 1;
  Object.defineProperty(patternProperties, "__esModule", { value: true });
  const code_1 = /* @__PURE__ */ requireCode();
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const util_1 = /* @__PURE__ */ requireUtil();
  const util_2 = /* @__PURE__ */ requireUtil();
  const def = {
    keyword: "patternProperties",
    type: "object",
    schemaType: "object",
    code(cxt) {
      const { gen, schema, data: data2, parentSchema, it: it2 } = cxt;
      const { opts } = it2;
      const patterns = (0, code_1.allSchemaProperties)(schema);
      const alwaysValidPatterns = patterns.filter((p2) => (0, util_1.alwaysValidSchema)(it2, schema[p2]));
      if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it2.opts.unevaluated || it2.props === true)) {
        return;
      }
      const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
      const valid = gen.name("valid");
      if (it2.props !== true && !(it2.props instanceof codegen_1.Name)) {
        it2.props = (0, util_2.evaluatedPropsToName)(gen, it2.props);
      }
      const { props } = it2;
      validatePatternProperties();
      function validatePatternProperties() {
        for (const pat of patterns) {
          if (checkProperties)
            checkMatchingProperties(pat);
          if (it2.allErrors) {
            validateProperties(pat);
          } else {
            gen.var(valid, true);
            validateProperties(pat);
            gen.if(valid);
          }
        }
      }
      function checkMatchingProperties(pat) {
        for (const prop in checkProperties) {
          if (new RegExp(pat).test(prop)) {
            (0, util_1.checkStrictMode)(it2, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
          }
        }
      }
      function validateProperties(pat) {
        gen.forIn("key", data2, (key) => {
          gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
            const alwaysValid = alwaysValidPatterns.includes(pat);
            if (!alwaysValid) {
              cxt.subschema({
                keyword: "patternProperties",
                schemaProp: pat,
                dataProp: key,
                dataPropType: util_2.Type.Str
              }, valid);
            }
            if (it2.opts.unevaluated && props !== true) {
              gen.assign((0, codegen_1._)`${props}[${key}]`, true);
            } else if (!alwaysValid && !it2.allErrors) {
              gen.if((0, codegen_1.not)(valid), () => gen.break());
            }
          });
        });
      }
    }
  };
  patternProperties.default = def;
  return patternProperties;
}
var not = {};
var hasRequiredNot;
function requireNot() {
  if (hasRequiredNot) return not;
  hasRequiredNot = 1;
  Object.defineProperty(not, "__esModule", { value: true });
  const util_1 = /* @__PURE__ */ requireUtil();
  const def = {
    keyword: "not",
    schemaType: ["object", "boolean"],
    trackErrors: true,
    code(cxt) {
      const { gen, schema, it: it2 } = cxt;
      if ((0, util_1.alwaysValidSchema)(it2, schema)) {
        cxt.fail();
        return;
      }
      const valid = gen.name("valid");
      cxt.subschema({
        keyword: "not",
        compositeRule: true,
        createErrors: false,
        allErrors: false
      }, valid);
      cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
    },
    error: { message: "must NOT be valid" }
  };
  not.default = def;
  return not;
}
var anyOf = {};
var hasRequiredAnyOf;
function requireAnyOf() {
  if (hasRequiredAnyOf) return anyOf;
  hasRequiredAnyOf = 1;
  Object.defineProperty(anyOf, "__esModule", { value: true });
  const code_1 = /* @__PURE__ */ requireCode();
  const def = {
    keyword: "anyOf",
    schemaType: "array",
    trackErrors: true,
    code: code_1.validateUnion,
    error: { message: "must match a schema in anyOf" }
  };
  anyOf.default = def;
  return anyOf;
}
var oneOf = {};
var hasRequiredOneOf;
function requireOneOf() {
  if (hasRequiredOneOf) return oneOf;
  hasRequiredOneOf = 1;
  Object.defineProperty(oneOf, "__esModule", { value: true });
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const util_1 = /* @__PURE__ */ requireUtil();
  const error = {
    message: "must match exactly one schema in oneOf",
    params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
  };
  const def = {
    keyword: "oneOf",
    schemaType: "array",
    trackErrors: true,
    error,
    code(cxt) {
      const { gen, schema, parentSchema, it: it2 } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      if (it2.opts.discriminator && parentSchema.discriminator)
        return;
      const schArr = schema;
      const valid = gen.let("valid", false);
      const passing = gen.let("passing", null);
      const schValid = gen.name("_valid");
      cxt.setParams({ passing });
      gen.block(validateOneOf);
      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
      function validateOneOf() {
        schArr.forEach((sch, i) => {
          let schCxt;
          if ((0, util_1.alwaysValidSchema)(it2, sch)) {
            gen.var(schValid, true);
          } else {
            schCxt = cxt.subschema({
              keyword: "oneOf",
              schemaProp: i,
              compositeRule: true
            }, schValid);
          }
          if (i > 0) {
            gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();
          }
          gen.if(schValid, () => {
            gen.assign(valid, true);
            gen.assign(passing, i);
            if (schCxt)
              cxt.mergeEvaluated(schCxt, codegen_1.Name);
          });
        });
      }
    }
  };
  oneOf.default = def;
  return oneOf;
}
var allOf = {};
var hasRequiredAllOf;
function requireAllOf() {
  if (hasRequiredAllOf) return allOf;
  hasRequiredAllOf = 1;
  Object.defineProperty(allOf, "__esModule", { value: true });
  const util_1 = /* @__PURE__ */ requireUtil();
  const def = {
    keyword: "allOf",
    schemaType: "array",
    code(cxt) {
      const { gen, schema, it: it2 } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const valid = gen.name("valid");
      schema.forEach((sch, i) => {
        if ((0, util_1.alwaysValidSchema)(it2, sch))
          return;
        const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
        cxt.ok(valid);
        cxt.mergeEvaluated(schCxt);
      });
    }
  };
  allOf.default = def;
  return allOf;
}
var _if = {};
var hasRequired_if;
function require_if() {
  if (hasRequired_if) return _if;
  hasRequired_if = 1;
  Object.defineProperty(_if, "__esModule", { value: true });
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const util_1 = /* @__PURE__ */ requireUtil();
  const error = {
    message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
    params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
  };
  const def = {
    keyword: "if",
    schemaType: ["object", "boolean"],
    trackErrors: true,
    error,
    code(cxt) {
      const { gen, parentSchema, it: it2 } = cxt;
      if (parentSchema.then === void 0 && parentSchema.else === void 0) {
        (0, util_1.checkStrictMode)(it2, '"if" without "then" and "else" is ignored');
      }
      const hasThen = hasSchema(it2, "then");
      const hasElse = hasSchema(it2, "else");
      if (!hasThen && !hasElse)
        return;
      const valid = gen.let("valid", true);
      const schValid = gen.name("_valid");
      validateIf();
      cxt.reset();
      if (hasThen && hasElse) {
        const ifClause = gen.let("ifClause");
        cxt.setParams({ ifClause });
        gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
      } else if (hasThen) {
        gen.if(schValid, validateClause("then"));
      } else {
        gen.if((0, codegen_1.not)(schValid), validateClause("else"));
      }
      cxt.pass(valid, () => cxt.error(true));
      function validateIf() {
        const schCxt = cxt.subschema({
          keyword: "if",
          compositeRule: true,
          createErrors: false,
          allErrors: false
        }, schValid);
        cxt.mergeEvaluated(schCxt);
      }
      function validateClause(keyword2, ifClause) {
        return () => {
          const schCxt = cxt.subschema({ keyword: keyword2 }, schValid);
          gen.assign(valid, schValid);
          cxt.mergeValidEvaluated(schCxt, valid);
          if (ifClause)
            gen.assign(ifClause, (0, codegen_1._)`${keyword2}`);
          else
            cxt.setParams({ ifClause: keyword2 });
        };
      }
    }
  };
  function hasSchema(it2, keyword2) {
    const schema = it2.schema[keyword2];
    return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it2, schema);
  }
  _if.default = def;
  return _if;
}
var thenElse = {};
var hasRequiredThenElse;
function requireThenElse() {
  if (hasRequiredThenElse) return thenElse;
  hasRequiredThenElse = 1;
  Object.defineProperty(thenElse, "__esModule", { value: true });
  const util_1 = /* @__PURE__ */ requireUtil();
  const def = {
    keyword: ["then", "else"],
    schemaType: ["object", "boolean"],
    code({ keyword: keyword2, parentSchema, it: it2 }) {
      if (parentSchema.if === void 0)
        (0, util_1.checkStrictMode)(it2, `"${keyword2}" without "if" is ignored`);
    }
  };
  thenElse.default = def;
  return thenElse;
}
var hasRequiredApplicator;
function requireApplicator() {
  if (hasRequiredApplicator) return applicator;
  hasRequiredApplicator = 1;
  Object.defineProperty(applicator, "__esModule", { value: true });
  const additionalItems_1 = /* @__PURE__ */ requireAdditionalItems();
  const prefixItems_1 = /* @__PURE__ */ requirePrefixItems();
  const items_1 = /* @__PURE__ */ requireItems();
  const items2020_1 = /* @__PURE__ */ requireItems2020();
  const contains_1 = /* @__PURE__ */ requireContains();
  const dependencies_1 = /* @__PURE__ */ requireDependencies();
  const propertyNames_1 = /* @__PURE__ */ requirePropertyNames();
  const additionalProperties_1 = /* @__PURE__ */ requireAdditionalProperties();
  const properties_1 = /* @__PURE__ */ requireProperties();
  const patternProperties_1 = /* @__PURE__ */ requirePatternProperties();
  const not_1 = /* @__PURE__ */ requireNot();
  const anyOf_1 = /* @__PURE__ */ requireAnyOf();
  const oneOf_1 = /* @__PURE__ */ requireOneOf();
  const allOf_1 = /* @__PURE__ */ requireAllOf();
  const if_1 = /* @__PURE__ */ require_if();
  const thenElse_1 = /* @__PURE__ */ requireThenElse();
  function getApplicator(draft2020 = false) {
    const applicator2 = [
      // any
      not_1.default,
      anyOf_1.default,
      oneOf_1.default,
      allOf_1.default,
      if_1.default,
      thenElse_1.default,
      // object
      propertyNames_1.default,
      additionalProperties_1.default,
      dependencies_1.default,
      properties_1.default,
      patternProperties_1.default
    ];
    if (draft2020)
      applicator2.push(prefixItems_1.default, items2020_1.default);
    else
      applicator2.push(additionalItems_1.default, items_1.default);
    applicator2.push(contains_1.default);
    return applicator2;
  }
  applicator.default = getApplicator;
  return applicator;
}
var format$1 = {};
var format = {};
var hasRequiredFormat$1;
function requireFormat$1() {
  if (hasRequiredFormat$1) return format;
  hasRequiredFormat$1 = 1;
  Object.defineProperty(format, "__esModule", { value: true });
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const error = {
    message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
    params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
  };
  const def = {
    keyword: "format",
    type: ["number", "string"],
    schemaType: "string",
    $data: true,
    error,
    code(cxt, ruleType) {
      const { gen, data: data2, $data, schema, schemaCode, it: it2 } = cxt;
      const { opts, errSchemaPath, schemaEnv, self: self2 } = it2;
      if (!opts.validateFormats)
        return;
      if ($data)
        validate$DataFormat();
      else
        validateFormat();
      function validate$DataFormat() {
        const fmts = gen.scopeValue("formats", {
          ref: self2.formats,
          code: opts.code.formats
        });
        const fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
        const fType = gen.let("fType");
        const format2 = gen.let("format");
        gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format2, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format2, fDef));
        cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
        function unknownFmt() {
          if (opts.strictSchema === false)
            return codegen_1.nil;
          return (0, codegen_1._)`${schemaCode} && !${format2}`;
        }
        function invalidFmt() {
          const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format2}(${data2}) : ${format2}(${data2}))` : (0, codegen_1._)`${format2}(${data2})`;
          const validData = (0, codegen_1._)`(typeof ${format2} == "function" ? ${callFormat} : ${format2}.test(${data2}))`;
          return (0, codegen_1._)`${format2} && ${format2} !== true && ${fType} === ${ruleType} && !${validData}`;
        }
      }
      function validateFormat() {
        const formatDef = self2.formats[schema];
        if (!formatDef) {
          unknownFormat();
          return;
        }
        if (formatDef === true)
          return;
        const [fmtType, format2, fmtRef] = getFormat(formatDef);
        if (fmtType === ruleType)
          cxt.pass(validCondition());
        function unknownFormat() {
          if (opts.strictSchema === false) {
            self2.logger.warn(unknownMsg());
            return;
          }
          throw new Error(unknownMsg());
          function unknownMsg() {
            return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
          }
        }
        function getFormat(fmtDef) {
          const code2 = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : void 0;
          const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code: code2 });
          if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
            return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
          }
          return ["string", fmtDef, fmt];
        }
        function validCondition() {
          if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
            if (!schemaEnv.$async)
              throw new Error("async format in sync schema");
            return (0, codegen_1._)`await ${fmtRef}(${data2})`;
          }
          return typeof format2 == "function" ? (0, codegen_1._)`${fmtRef}(${data2})` : (0, codegen_1._)`${fmtRef}.test(${data2})`;
        }
      }
    }
  };
  format.default = def;
  return format;
}
var hasRequiredFormat;
function requireFormat() {
  if (hasRequiredFormat) return format$1;
  hasRequiredFormat = 1;
  Object.defineProperty(format$1, "__esModule", { value: true });
  const format_1 = /* @__PURE__ */ requireFormat$1();
  const format2 = [format_1.default];
  format$1.default = format2;
  return format$1;
}
var metadata = {};
var hasRequiredMetadata;
function requireMetadata() {
  if (hasRequiredMetadata) return metadata;
  hasRequiredMetadata = 1;
  Object.defineProperty(metadata, "__esModule", { value: true });
  metadata.contentVocabulary = metadata.metadataVocabulary = void 0;
  metadata.metadataVocabulary = [
    "title",
    "description",
    "default",
    "deprecated",
    "readOnly",
    "writeOnly",
    "examples"
  ];
  metadata.contentVocabulary = [
    "contentMediaType",
    "contentEncoding",
    "contentSchema"
  ];
  return metadata;
}
var hasRequiredDraft7;
function requireDraft7() {
  if (hasRequiredDraft7) return draft7;
  hasRequiredDraft7 = 1;
  Object.defineProperty(draft7, "__esModule", { value: true });
  const core_1 = /* @__PURE__ */ requireCore();
  const validation_1 = /* @__PURE__ */ requireValidation();
  const applicator_1 = /* @__PURE__ */ requireApplicator();
  const format_1 = /* @__PURE__ */ requireFormat();
  const metadata_1 = /* @__PURE__ */ requireMetadata();
  const draft7Vocabularies = [
    core_1.default,
    validation_1.default,
    (0, applicator_1.default)(),
    format_1.default,
    metadata_1.metadataVocabulary,
    metadata_1.contentVocabulary
  ];
  draft7.default = draft7Vocabularies;
  return draft7;
}
var discriminator = {};
var types = {};
var hasRequiredTypes;
function requireTypes() {
  if (hasRequiredTypes) return types;
  hasRequiredTypes = 1;
  Object.defineProperty(types, "__esModule", { value: true });
  types.DiscrError = void 0;
  var DiscrError;
  (function(DiscrError2) {
    DiscrError2["Tag"] = "tag";
    DiscrError2["Mapping"] = "mapping";
  })(DiscrError || (types.DiscrError = DiscrError = {}));
  return types;
}
var hasRequiredDiscriminator;
function requireDiscriminator() {
  if (hasRequiredDiscriminator) return discriminator;
  hasRequiredDiscriminator = 1;
  Object.defineProperty(discriminator, "__esModule", { value: true });
  const codegen_1 = /* @__PURE__ */ requireCodegen();
  const types_1 = /* @__PURE__ */ requireTypes();
  const compile_12 = /* @__PURE__ */ requireCompile();
  const ref_error_1 = /* @__PURE__ */ requireRef_error();
  const util_1 = /* @__PURE__ */ requireUtil();
  const error = {
    message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
    params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
  };
  const def = {
    keyword: "discriminator",
    type: "object",
    schemaType: "object",
    error,
    code(cxt) {
      const { gen, data: data2, schema, parentSchema, it: it2 } = cxt;
      const { oneOf: oneOf2 } = parentSchema;
      if (!it2.opts.discriminator) {
        throw new Error("discriminator: requires discriminator option");
      }
      const tagName = schema.propertyName;
      if (typeof tagName != "string")
        throw new Error("discriminator: requires propertyName");
      if (schema.mapping)
        throw new Error("discriminator: mapping is not supported");
      if (!oneOf2)
        throw new Error("discriminator: requires oneOf keyword");
      const valid = gen.let("valid", false);
      const tag = gen.const("tag", (0, codegen_1._)`${data2}${(0, codegen_1.getProperty)(tagName)}`);
      gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
      cxt.ok(valid);
      function validateMapping() {
        const mapping = getMapping();
        gen.if(false);
        for (const tagValue in mapping) {
          gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
          gen.assign(valid, applyTagSchema(mapping[tagValue]));
        }
        gen.else();
        cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
        gen.endIf();
      }
      function applyTagSchema(schemaProp) {
        const _valid = gen.name("valid");
        const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
        cxt.mergeEvaluated(schCxt, codegen_1.Name);
        return _valid;
      }
      function getMapping() {
        var _a2;
        const oneOfMapping = {};
        const topRequired = hasRequired(parentSchema);
        let tagRequired = true;
        for (let i = 0; i < oneOf2.length; i++) {
          let sch = oneOf2[i];
          if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it2.self.RULES)) {
            const ref2 = sch.$ref;
            sch = compile_12.resolveRef.call(it2.self, it2.schemaEnv.root, it2.baseId, ref2);
            if (sch instanceof compile_12.SchemaEnv)
              sch = sch.schema;
            if (sch === void 0)
              throw new ref_error_1.default(it2.opts.uriResolver, it2.baseId, ref2);
          }
          const propSch = (_a2 = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a2 === void 0 ? void 0 : _a2[tagName];
          if (typeof propSch != "object") {
            throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
          }
          tagRequired = tagRequired && (topRequired || hasRequired(sch));
          addMappings(propSch, i);
        }
        if (!tagRequired)
          throw new Error(`discriminator: "${tagName}" must be required`);
        return oneOfMapping;
        function hasRequired({ required: required2 }) {
          return Array.isArray(required2) && required2.includes(tagName);
        }
        function addMappings(sch, i) {
          if (sch.const) {
            addMapping(sch.const, i);
          } else if (sch.enum) {
            for (const tagValue of sch.enum) {
              addMapping(tagValue, i);
            }
          } else {
            throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
          }
        }
        function addMapping(tagValue, i) {
          if (typeof tagValue != "string" || tagValue in oneOfMapping) {
            throw new Error(`discriminator: "${tagName}" values must be unique strings`);
          }
          oneOfMapping[tagValue] = i;
        }
      }
    }
  };
  discriminator.default = def;
  return discriminator;
}
const $schema = "http://json-schema.org/draft-07/schema#";
const $id = "http://json-schema.org/draft-07/schema#";
const title = "Core schema meta-schema";
const definitions = { "schemaArray": { "type": "array", "minItems": 1, "items": { "$ref": "#" } }, "nonNegativeInteger": { "type": "integer", "minimum": 0 }, "nonNegativeIntegerDefault0": { "allOf": [{ "$ref": "#/definitions/nonNegativeInteger" }, { "default": 0 }] }, "simpleTypes": { "enum": ["array", "boolean", "integer", "null", "number", "object", "string"] }, "stringArray": { "type": "array", "items": { "type": "string" }, "uniqueItems": true, "default": [] } };
const type = ["object", "boolean"];
const properties = { "$id": { "type": "string", "format": "uri-reference" }, "$schema": { "type": "string", "format": "uri" }, "$ref": { "type": "string", "format": "uri-reference" }, "$comment": { "type": "string" }, "title": { "type": "string" }, "description": { "type": "string" }, "default": true, "readOnly": { "type": "boolean", "default": false }, "examples": { "type": "array", "items": true }, "multipleOf": { "type": "number", "exclusiveMinimum": 0 }, "maximum": { "type": "number" }, "exclusiveMaximum": { "type": "number" }, "minimum": { "type": "number" }, "exclusiveMinimum": { "type": "number" }, "maxLength": { "$ref": "#/definitions/nonNegativeInteger" }, "minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "pattern": { "type": "string", "format": "regex" }, "additionalItems": { "$ref": "#" }, "items": { "anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/schemaArray" }], "default": true }, "maxItems": { "$ref": "#/definitions/nonNegativeInteger" }, "minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "uniqueItems": { "type": "boolean", "default": false }, "contains": { "$ref": "#" }, "maxProperties": { "$ref": "#/definitions/nonNegativeInteger" }, "minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "required": { "$ref": "#/definitions/stringArray" }, "additionalProperties": { "$ref": "#" }, "definitions": { "type": "object", "additionalProperties": { "$ref": "#" }, "default": {} }, "properties": { "type": "object", "additionalProperties": { "$ref": "#" }, "default": {} }, "patternProperties": { "type": "object", "additionalProperties": { "$ref": "#" }, "propertyNames": { "format": "regex" }, "default": {} }, "dependencies": { "type": "object", "additionalProperties": { "anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/stringArray" }] } }, "propertyNames": { "$ref": "#" }, "const": true, "enum": { "type": "array", "items": true, "minItems": 1, "uniqueItems": true }, "type": { "anyOf": [{ "$ref": "#/definitions/simpleTypes" }, { "type": "array", "items": { "$ref": "#/definitions/simpleTypes" }, "minItems": 1, "uniqueItems": true }] }, "format": { "type": "string" }, "contentMediaType": { "type": "string" }, "contentEncoding": { "type": "string" }, "if": { "$ref": "#" }, "then": { "$ref": "#" }, "else": { "$ref": "#" }, "allOf": { "$ref": "#/definitions/schemaArray" }, "anyOf": { "$ref": "#/definitions/schemaArray" }, "oneOf": { "$ref": "#/definitions/schemaArray" }, "not": { "$ref": "#" } };
const require$$3 = {
  $schema,
  $id,
  title,
  definitions,
  type,
  properties,
  "default": true
};
var hasRequiredAjv;
function requireAjv() {
  if (hasRequiredAjv) return ajv.exports;
  hasRequiredAjv = 1;
  (function(module, exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.MissingRefError = exports$1.ValidationError = exports$1.CodeGen = exports$1.Name = exports$1.nil = exports$1.stringify = exports$1.str = exports$1._ = exports$1.KeywordCxt = exports$1.Ajv = void 0;
    const core_1 = /* @__PURE__ */ requireCore$1();
    const draft7_1 = /* @__PURE__ */ requireDraft7();
    const discriminator_1 = /* @__PURE__ */ requireDiscriminator();
    const draft7MetaSchema = require$$3;
    const META_SUPPORT_DATA = ["/properties"];
    const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
    class Ajv2 extends core_1.default {
      _addVocabularies() {
        super._addVocabularies();
        draft7_1.default.forEach((v) => this.addVocabulary(v));
        if (this.opts.discriminator)
          this.addKeyword(discriminator_1.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        if (!this.opts.meta)
          return;
        const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
    }
    exports$1.Ajv = Ajv2;
    module.exports = exports$1 = Ajv2;
    module.exports.Ajv = Ajv2;
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.default = Ajv2;
    var validate_1 = /* @__PURE__ */ requireValidate();
    Object.defineProperty(exports$1, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = /* @__PURE__ */ requireCodegen();
    Object.defineProperty(exports$1, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports$1, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports$1, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports$1, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports$1, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports$1, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = /* @__PURE__ */ requireValidation_error();
    Object.defineProperty(exports$1, "ValidationError", { enumerable: true, get: function() {
      return validation_error_1.default;
    } });
    var ref_error_1 = /* @__PURE__ */ requireRef_error();
    Object.defineProperty(exports$1, "MissingRefError", { enumerable: true, get: function() {
      return ref_error_1.default;
    } });
  })(ajv, ajv.exports);
  return ajv.exports;
}
var hasRequiredLimit;
function requireLimit() {
  if (hasRequiredLimit) return limit;
  hasRequiredLimit = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.formatLimitDefinition = void 0;
    const ajv_1 = /* @__PURE__ */ requireAjv();
    const codegen_1 = /* @__PURE__ */ requireCodegen();
    const ops = codegen_1.operators;
    const KWDs = {
      formatMaximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      formatMinimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      formatExclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      formatExclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    const error = {
      message: ({ keyword: keyword2, schemaCode }) => (0, codegen_1.str)`should be ${KWDs[keyword2].okStr} ${schemaCode}`,
      params: ({ keyword: keyword2, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword2].okStr}, limit: ${schemaCode}}`
    };
    exports$1.formatLimitDefinition = {
      keyword: Object.keys(KWDs),
      type: "string",
      schemaType: "string",
      $data: true,
      error,
      code(cxt) {
        const { gen, data: data2, schemaCode, keyword: keyword2, it: it2 } = cxt;
        const { opts, self: self2 } = it2;
        if (!opts.validateFormats)
          return;
        const fCxt = new ajv_1.KeywordCxt(it2, self2.RULES.all.format.definition, "format");
        if (fCxt.$data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self2.formats,
            code: opts.code.formats
          });
          const fmt = gen.const("fmt", (0, codegen_1._)`${fmts}[${fCxt.schemaCode}]`);
          cxt.fail$data((0, codegen_1.or)((0, codegen_1._)`typeof ${fmt} != "object"`, (0, codegen_1._)`${fmt} instanceof RegExp`, (0, codegen_1._)`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
        }
        function validateFormat() {
          const format2 = fCxt.schema;
          const fmtDef = self2.formats[format2];
          if (!fmtDef || fmtDef === true)
            return;
          if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function") {
            throw new Error(`"${keyword2}": format "${format2}" does not define "compare" function`);
          }
          const fmt = gen.scopeValue("formats", {
            key: format2,
            ref: fmtDef,
            code: opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(format2)}` : void 0
          });
          cxt.fail$data(compareCode(fmt));
        }
        function compareCode(fmt) {
          return (0, codegen_1._)`${fmt}.compare(${data2}, ${schemaCode}) ${KWDs[keyword2].fail} 0`;
        }
      },
      dependencies: ["format"]
    };
    const formatLimitPlugin = (ajv2) => {
      ajv2.addKeyword(exports$1.formatLimitDefinition);
      return ajv2;
    };
    exports$1.default = formatLimitPlugin;
  })(limit);
  return limit;
}
var hasRequiredDist;
function requireDist() {
  if (hasRequiredDist) return dist.exports;
  hasRequiredDist = 1;
  (function(module, exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    const formats_12 = requireFormats();
    const limit_1 = requireLimit();
    const codegen_1 = /* @__PURE__ */ requireCodegen();
    const fullName = new codegen_1.Name("fullFormats");
    const fastName = new codegen_1.Name("fastFormats");
    const formatsPlugin = (ajv2, opts = { keywords: true }) => {
      if (Array.isArray(opts)) {
        addFormats(ajv2, opts, formats_12.fullFormats, fullName);
        return ajv2;
      }
      const [formats2, exportName] = opts.mode === "fast" ? [formats_12.fastFormats, fastName] : [formats_12.fullFormats, fullName];
      const list = opts.formats || formats_12.formatNames;
      addFormats(ajv2, list, formats2, exportName);
      if (opts.keywords)
        (0, limit_1.default)(ajv2);
      return ajv2;
    };
    formatsPlugin.get = (name2, mode = "full") => {
      const formats2 = mode === "fast" ? formats_12.fastFormats : formats_12.fullFormats;
      const f2 = formats2[name2];
      if (!f2)
        throw new Error(`Unknown format "${name2}"`);
      return f2;
    };
    function addFormats(ajv2, list, fs2, exportName) {
      var _a2;
      var _b;
      (_a2 = (_b = ajv2.opts.code).formats) !== null && _a2 !== void 0 ? _a2 : _b.formats = (0, codegen_1._)`require("ajv-formats/dist/formats").${exportName}`;
      for (const f2 of list)
        ajv2.addFormat(f2, fs2[f2]);
    }
    module.exports = exports$1 = formatsPlugin;
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.default = formatsPlugin;
  })(dist, dist.exports);
  return dist.exports;
}
var distExports = requireDist();
const _addFormats = /* @__PURE__ */ getDefaultExportFromCjs(distExports);
function createDefaultAjvInstance() {
  const ajv2 = new Ajv({
    strict: false,
    validateFormats: true,
    validateSchema: false,
    allErrors: true
  });
  const addFormats = _addFormats;
  addFormats(ajv2);
  return ajv2;
}
class AjvJsonSchemaValidator {
  /**
   * Create an AJV validator
   *
   * @param ajv - Optional pre-configured AJV instance. If not provided, a default instance will be created.
   *
   * @example
   * ```typescript
   * // Use default configuration (recommended for most cases)
   * import { AjvJsonSchemaValidator } from '@modelcontextprotocol/sdk/validation/ajv';
   * const validator = new AjvJsonSchemaValidator();
   *
   * // Or provide custom AJV instance for advanced configuration
   * import { Ajv } from 'ajv';
   * import addFormats from 'ajv-formats';
   *
   * const ajv = new Ajv({ validateFormats: true });
   * addFormats(ajv);
   * const validator = new AjvJsonSchemaValidator(ajv);
   * ```
   */
  constructor(ajv2) {
    this._ajv = ajv2 ?? createDefaultAjvInstance();
  }
  /**
   * Create a validator for the given JSON Schema
   *
   * The validator is compiled once and can be reused multiple times.
   * If the schema has an $id, it will be cached by AJV automatically.
   *
   * @param schema - Standard JSON Schema object
   * @returns A validator function that validates input data
   */
  getValidator(schema) {
    const ajvValidator = "$id" in schema && typeof schema.$id === "string" ? this._ajv.getSchema(schema.$id) ?? this._ajv.compile(schema) : this._ajv.compile(schema);
    return (input) => {
      const valid = ajvValidator(input);
      if (valid) {
        return {
          valid: true,
          data: input,
          errorMessage: void 0
        };
      } else {
        return {
          valid: false,
          data: void 0,
          errorMessage: this._ajv.errorsText(ajvValidator.errors)
        };
      }
    };
  }
}
class ExperimentalClientTasks {
  constructor(_client) {
    this._client = _client;
  }
  /**
   * Calls a tool and returns an AsyncGenerator that yields response messages.
   * The generator is guaranteed to end with either a 'result' or 'error' message.
   *
   * This method provides streaming access to tool execution, allowing you to
   * observe intermediate task status updates for long-running tool calls.
   * Automatically validates structured output if the tool has an outputSchema.
   *
   * @example
   * ```typescript
   * const stream = client.experimental.tasks.callToolStream({ name: 'myTool', arguments: {} });
   * for await (const message of stream) {
   *   switch (message.type) {
   *     case 'taskCreated':
   *       console.log('Tool execution started:', message.task.taskId);
   *       break;
   *     case 'taskStatus':
   *       console.log('Tool status:', message.task.status);
   *       break;
   *     case 'result':
   *       console.log('Tool result:', message.result);
   *       break;
   *     case 'error':
   *       console.error('Tool error:', message.error);
   *       break;
   *   }
   * }
   * ```
   *
   * @param params - Tool call parameters (name and arguments)
   * @param resultSchema - Zod schema for validating the result (defaults to CallToolResultSchema)
   * @param options - Optional request options (timeout, signal, task creation params, etc.)
   * @returns AsyncGenerator that yields ResponseMessage objects
   *
   * @experimental
   */
  async *callToolStream(params, resultSchema = CallToolResultSchema, options) {
    const clientInternal = this._client;
    const optionsWithTask = {
      ...options,
      // We check if the tool is known to be a task during auto-configuration, but assume
      // the caller knows what they're doing if they pass this explicitly
      task: options?.task ?? (clientInternal.isToolTask(params.name) ? {} : void 0)
    };
    const stream = clientInternal.requestStream({ method: "tools/call", params }, resultSchema, optionsWithTask);
    const validator = clientInternal.getToolOutputValidator(params.name);
    for await (const message of stream) {
      if (message.type === "result" && validator) {
        const result = message.result;
        if (!result.structuredContent && !result.isError) {
          yield {
            type: "error",
            error: new McpError(ErrorCode.InvalidRequest, `Tool ${params.name} has an output schema but did not return structured content`)
          };
          return;
        }
        if (result.structuredContent) {
          try {
            const validationResult = validator(result.structuredContent);
            if (!validationResult.valid) {
              yield {
                type: "error",
                error: new McpError(ErrorCode.InvalidParams, `Structured content does not match the tool's output schema: ${validationResult.errorMessage}`)
              };
              return;
            }
          } catch (error) {
            if (error instanceof McpError) {
              yield { type: "error", error };
              return;
            }
            yield {
              type: "error",
              error: new McpError(ErrorCode.InvalidParams, `Failed to validate structured content: ${error instanceof Error ? error.message : String(error)}`)
            };
            return;
          }
        }
      }
      yield message;
    }
  }
  /**
   * Gets the current status of a task.
   *
   * @param taskId - The task identifier
   * @param options - Optional request options
   * @returns The task status
   *
   * @experimental
   */
  async getTask(taskId, options) {
    return this._client.getTask({ taskId }, options);
  }
  /**
   * Retrieves the result of a completed task.
   *
   * @param taskId - The task identifier
   * @param resultSchema - Zod schema for validating the result
   * @param options - Optional request options
   * @returns The task result
   *
   * @experimental
   */
  async getTaskResult(taskId, resultSchema, options) {
    return this._client.getTaskResult({ taskId }, resultSchema, options);
  }
  /**
   * Lists tasks with optional pagination.
   *
   * @param cursor - Optional pagination cursor
   * @param options - Optional request options
   * @returns List of tasks with optional next cursor
   *
   * @experimental
   */
  async listTasks(cursor, options) {
    return this._client.listTasks(cursor ? { cursor } : void 0, options);
  }
  /**
   * Cancels a running task.
   *
   * @param taskId - The task identifier
   * @param options - Optional request options
   *
   * @experimental
   */
  async cancelTask(taskId, options) {
    return this._client.cancelTask({ taskId }, options);
  }
  /**
   * Sends a request and returns an AsyncGenerator that yields response messages.
   * The generator is guaranteed to end with either a 'result' or 'error' message.
   *
   * This method provides streaming access to request processing, allowing you to
   * observe intermediate task status updates for task-augmented requests.
   *
   * @param request - The request to send
   * @param resultSchema - Zod schema for validating the result
   * @param options - Optional request options (timeout, signal, task creation params, etc.)
   * @returns AsyncGenerator that yields ResponseMessage objects
   *
   * @experimental
   */
  requestStream(request, resultSchema, options) {
    return this._client.requestStream(request, resultSchema, options);
  }
}
function assertToolsCallTaskCapability(requests, method, entityName) {
  if (!requests) {
    throw new Error(`${entityName} does not support task creation (required for ${method})`);
  }
  switch (method) {
    case "tools/call":
      if (!requests.tools?.call) {
        throw new Error(`${entityName} does not support task creation for tools/call (required for ${method})`);
      }
      break;
  }
}
function assertClientRequestTaskCapability(requests, method, entityName) {
  if (!requests) {
    throw new Error(`${entityName} does not support task creation (required for ${method})`);
  }
  switch (method) {
    case "sampling/createMessage":
      if (!requests.sampling?.createMessage) {
        throw new Error(`${entityName} does not support task creation for sampling/createMessage (required for ${method})`);
      }
      break;
    case "elicitation/create":
      if (!requests.elicitation?.create) {
        throw new Error(`${entityName} does not support task creation for elicitation/create (required for ${method})`);
      }
      break;
  }
}
function applyElicitationDefaults(schema, data2) {
  if (!schema || data2 === null || typeof data2 !== "object")
    return;
  if (schema.type === "object" && schema.properties && typeof schema.properties === "object") {
    const obj = data2;
    const props = schema.properties;
    for (const key of Object.keys(props)) {
      const propSchema = props[key];
      if (obj[key] === void 0 && Object.prototype.hasOwnProperty.call(propSchema, "default")) {
        obj[key] = propSchema.default;
      }
      if (obj[key] !== void 0) {
        applyElicitationDefaults(propSchema, obj[key]);
      }
    }
  }
  if (Array.isArray(schema.anyOf)) {
    for (const sub of schema.anyOf) {
      if (typeof sub !== "boolean") {
        applyElicitationDefaults(sub, data2);
      }
    }
  }
  if (Array.isArray(schema.oneOf)) {
    for (const sub of schema.oneOf) {
      if (typeof sub !== "boolean") {
        applyElicitationDefaults(sub, data2);
      }
    }
  }
}
function getSupportedElicitationModes(capabilities) {
  if (!capabilities) {
    return { supportsFormMode: false, supportsUrlMode: false };
  }
  const hasFormCapability = capabilities.form !== void 0;
  const hasUrlCapability = capabilities.url !== void 0;
  const supportsFormMode = hasFormCapability || !hasFormCapability && !hasUrlCapability;
  const supportsUrlMode = hasUrlCapability;
  return { supportsFormMode, supportsUrlMode };
}
class Client extends Protocol {
  /**
   * Initializes this client with the given name and version information.
   */
  constructor(_clientInfo, options) {
    super(options);
    this._clientInfo = _clientInfo;
    this._cachedToolOutputValidators = /* @__PURE__ */ new Map();
    this._cachedKnownTaskTools = /* @__PURE__ */ new Set();
    this._cachedRequiredTaskTools = /* @__PURE__ */ new Set();
    this._listChangedDebounceTimers = /* @__PURE__ */ new Map();
    this._capabilities = options?.capabilities ?? {};
    this._jsonSchemaValidator = options?.jsonSchemaValidator ?? new AjvJsonSchemaValidator();
    if (options?.listChanged) {
      this._pendingListChangedConfig = options.listChanged;
    }
  }
  /**
   * Set up handlers for list changed notifications based on config and server capabilities.
   * This should only be called after initialization when server capabilities are known.
   * Handlers are silently skipped if the server doesn't advertise the corresponding listChanged capability.
   * @internal
   */
  _setupListChangedHandlers(config2) {
    if (config2.tools && this._serverCapabilities?.tools?.listChanged) {
      this._setupListChangedHandler("tools", ToolListChangedNotificationSchema, config2.tools, async () => {
        const result = await this.listTools();
        return result.tools;
      });
    }
    if (config2.prompts && this._serverCapabilities?.prompts?.listChanged) {
      this._setupListChangedHandler("prompts", PromptListChangedNotificationSchema, config2.prompts, async () => {
        const result = await this.listPrompts();
        return result.prompts;
      });
    }
    if (config2.resources && this._serverCapabilities?.resources?.listChanged) {
      this._setupListChangedHandler("resources", ResourceListChangedNotificationSchema, config2.resources, async () => {
        const result = await this.listResources();
        return result.resources;
      });
    }
  }
  /**
   * Access experimental features.
   *
   * WARNING: These APIs are experimental and may change without notice.
   *
   * @experimental
   */
  get experimental() {
    if (!this._experimental) {
      this._experimental = {
        tasks: new ExperimentalClientTasks(this)
      };
    }
    return this._experimental;
  }
  /**
   * Registers new capabilities. This can only be called before connecting to a transport.
   *
   * The new capabilities will be merged with any existing capabilities previously given (e.g., at initialization).
   */
  registerCapabilities(capabilities) {
    if (this.transport) {
      throw new Error("Cannot register capabilities after connecting to transport");
    }
    this._capabilities = mergeCapabilities(this._capabilities, capabilities);
  }
  /**
   * Override request handler registration to enforce client-side validation for elicitation.
   */
  setRequestHandler(requestSchema, handler) {
    const shape = getObjectShape(requestSchema);
    const methodSchema = shape?.method;
    if (!methodSchema) {
      throw new Error("Schema is missing a method literal");
    }
    let methodValue;
    if (isZ4Schema(methodSchema)) {
      const v4Schema = methodSchema;
      const v4Def = v4Schema._zod?.def;
      methodValue = v4Def?.value ?? v4Schema.value;
    } else {
      const v3Schema = methodSchema;
      const legacyDef = v3Schema._def;
      methodValue = legacyDef?.value ?? v3Schema.value;
    }
    if (typeof methodValue !== "string") {
      throw new Error("Schema method literal must be a string");
    }
    const method = methodValue;
    if (method === "elicitation/create") {
      const wrappedHandler = async (request, extra) => {
        const validatedRequest = safeParse(ElicitRequestSchema, request);
        if (!validatedRequest.success) {
          const errorMessage = validatedRequest.error instanceof Error ? validatedRequest.error.message : String(validatedRequest.error);
          throw new McpError(ErrorCode.InvalidParams, `Invalid elicitation request: ${errorMessage}`);
        }
        const { params } = validatedRequest.data;
        params.mode = params.mode ?? "form";
        const { supportsFormMode, supportsUrlMode } = getSupportedElicitationModes(this._capabilities.elicitation);
        if (params.mode === "form" && !supportsFormMode) {
          throw new McpError(ErrorCode.InvalidParams, "Client does not support form-mode elicitation requests");
        }
        if (params.mode === "url" && !supportsUrlMode) {
          throw new McpError(ErrorCode.InvalidParams, "Client does not support URL-mode elicitation requests");
        }
        const result = await Promise.resolve(handler(request, extra));
        if (params.task) {
          const taskValidationResult = safeParse(CreateTaskResultSchema, result);
          if (!taskValidationResult.success) {
            const errorMessage = taskValidationResult.error instanceof Error ? taskValidationResult.error.message : String(taskValidationResult.error);
            throw new McpError(ErrorCode.InvalidParams, `Invalid task creation result: ${errorMessage}`);
          }
          return taskValidationResult.data;
        }
        const validationResult = safeParse(ElicitResultSchema, result);
        if (!validationResult.success) {
          const errorMessage = validationResult.error instanceof Error ? validationResult.error.message : String(validationResult.error);
          throw new McpError(ErrorCode.InvalidParams, `Invalid elicitation result: ${errorMessage}`);
        }
        const validatedResult = validationResult.data;
        const requestedSchema = params.mode === "form" ? params.requestedSchema : void 0;
        if (params.mode === "form" && validatedResult.action === "accept" && validatedResult.content && requestedSchema) {
          if (this._capabilities.elicitation?.form?.applyDefaults) {
            try {
              applyElicitationDefaults(requestedSchema, validatedResult.content);
            } catch {
            }
          }
        }
        return validatedResult;
      };
      return super.setRequestHandler(requestSchema, wrappedHandler);
    }
    if (method === "sampling/createMessage") {
      const wrappedHandler = async (request, extra) => {
        const validatedRequest = safeParse(CreateMessageRequestSchema, request);
        if (!validatedRequest.success) {
          const errorMessage = validatedRequest.error instanceof Error ? validatedRequest.error.message : String(validatedRequest.error);
          throw new McpError(ErrorCode.InvalidParams, `Invalid sampling request: ${errorMessage}`);
        }
        const { params } = validatedRequest.data;
        const result = await Promise.resolve(handler(request, extra));
        if (params.task) {
          const taskValidationResult = safeParse(CreateTaskResultSchema, result);
          if (!taskValidationResult.success) {
            const errorMessage = taskValidationResult.error instanceof Error ? taskValidationResult.error.message : String(taskValidationResult.error);
            throw new McpError(ErrorCode.InvalidParams, `Invalid task creation result: ${errorMessage}`);
          }
          return taskValidationResult.data;
        }
        const hasTools = params.tools || params.toolChoice;
        const resultSchema = hasTools ? CreateMessageResultWithToolsSchema : CreateMessageResultSchema;
        const validationResult = safeParse(resultSchema, result);
        if (!validationResult.success) {
          const errorMessage = validationResult.error instanceof Error ? validationResult.error.message : String(validationResult.error);
          throw new McpError(ErrorCode.InvalidParams, `Invalid sampling result: ${errorMessage}`);
        }
        return validationResult.data;
      };
      return super.setRequestHandler(requestSchema, wrappedHandler);
    }
    return super.setRequestHandler(requestSchema, handler);
  }
  assertCapability(capability, method) {
    if (!this._serverCapabilities?.[capability]) {
      throw new Error(`Server does not support ${capability} (required for ${method})`);
    }
  }
  async connect(transport, options) {
    await super.connect(transport);
    if (transport.sessionId !== void 0) {
      return;
    }
    try {
      const result = await this.request({
        method: "initialize",
        params: {
          protocolVersion: LATEST_PROTOCOL_VERSION,
          capabilities: this._capabilities,
          clientInfo: this._clientInfo
        }
      }, InitializeResultSchema, options);
      if (result === void 0) {
        throw new Error(`Server sent invalid initialize result: ${result}`);
      }
      if (!SUPPORTED_PROTOCOL_VERSIONS.includes(result.protocolVersion)) {
        throw new Error(`Server's protocol version is not supported: ${result.protocolVersion}`);
      }
      this._serverCapabilities = result.capabilities;
      this._serverVersion = result.serverInfo;
      if (transport.setProtocolVersion) {
        transport.setProtocolVersion(result.protocolVersion);
      }
      this._instructions = result.instructions;
      await this.notification({
        method: "notifications/initialized"
      });
      if (this._pendingListChangedConfig) {
        this._setupListChangedHandlers(this._pendingListChangedConfig);
        this._pendingListChangedConfig = void 0;
      }
    } catch (error) {
      void this.close();
      throw error;
    }
  }
  /**
   * After initialization has completed, this will be populated with the server's reported capabilities.
   */
  getServerCapabilities() {
    return this._serverCapabilities;
  }
  /**
   * After initialization has completed, this will be populated with information about the server's name and version.
   */
  getServerVersion() {
    return this._serverVersion;
  }
  /**
   * After initialization has completed, this may be populated with information about the server's instructions.
   */
  getInstructions() {
    return this._instructions;
  }
  assertCapabilityForMethod(method) {
    switch (method) {
      case "logging/setLevel":
        if (!this._serverCapabilities?.logging) {
          throw new Error(`Server does not support logging (required for ${method})`);
        }
        break;
      case "prompts/get":
      case "prompts/list":
        if (!this._serverCapabilities?.prompts) {
          throw new Error(`Server does not support prompts (required for ${method})`);
        }
        break;
      case "resources/list":
      case "resources/templates/list":
      case "resources/read":
      case "resources/subscribe":
      case "resources/unsubscribe":
        if (!this._serverCapabilities?.resources) {
          throw new Error(`Server does not support resources (required for ${method})`);
        }
        if (method === "resources/subscribe" && !this._serverCapabilities.resources.subscribe) {
          throw new Error(`Server does not support resource subscriptions (required for ${method})`);
        }
        break;
      case "tools/call":
      case "tools/list":
        if (!this._serverCapabilities?.tools) {
          throw new Error(`Server does not support tools (required for ${method})`);
        }
        break;
      case "completion/complete":
        if (!this._serverCapabilities?.completions) {
          throw new Error(`Server does not support completions (required for ${method})`);
        }
        break;
    }
  }
  assertNotificationCapability(method) {
    switch (method) {
      case "notifications/roots/list_changed":
        if (!this._capabilities.roots?.listChanged) {
          throw new Error(`Client does not support roots list changed notifications (required for ${method})`);
        }
        break;
    }
  }
  assertRequestHandlerCapability(method) {
    if (!this._capabilities) {
      return;
    }
    switch (method) {
      case "sampling/createMessage":
        if (!this._capabilities.sampling) {
          throw new Error(`Client does not support sampling capability (required for ${method})`);
        }
        break;
      case "elicitation/create":
        if (!this._capabilities.elicitation) {
          throw new Error(`Client does not support elicitation capability (required for ${method})`);
        }
        break;
      case "roots/list":
        if (!this._capabilities.roots) {
          throw new Error(`Client does not support roots capability (required for ${method})`);
        }
        break;
      case "tasks/get":
      case "tasks/list":
      case "tasks/result":
      case "tasks/cancel":
        if (!this._capabilities.tasks) {
          throw new Error(`Client does not support tasks capability (required for ${method})`);
        }
        break;
    }
  }
  assertTaskCapability(method) {
    assertToolsCallTaskCapability(this._serverCapabilities?.tasks?.requests, method, "Server");
  }
  assertTaskHandlerCapability(method) {
    if (!this._capabilities) {
      return;
    }
    assertClientRequestTaskCapability(this._capabilities.tasks?.requests, method, "Client");
  }
  async ping(options) {
    return this.request({ method: "ping" }, EmptyResultSchema, options);
  }
  async complete(params, options) {
    return this.request({ method: "completion/complete", params }, CompleteResultSchema, options);
  }
  async setLoggingLevel(level, options) {
    return this.request({ method: "logging/setLevel", params: { level } }, EmptyResultSchema, options);
  }
  async getPrompt(params, options) {
    return this.request({ method: "prompts/get", params }, GetPromptResultSchema, options);
  }
  async listPrompts(params, options) {
    return this.request({ method: "prompts/list", params }, ListPromptsResultSchema, options);
  }
  async listResources(params, options) {
    return this.request({ method: "resources/list", params }, ListResourcesResultSchema, options);
  }
  async listResourceTemplates(params, options) {
    return this.request({ method: "resources/templates/list", params }, ListResourceTemplatesResultSchema, options);
  }
  async readResource(params, options) {
    return this.request({ method: "resources/read", params }, ReadResourceResultSchema, options);
  }
  async subscribeResource(params, options) {
    return this.request({ method: "resources/subscribe", params }, EmptyResultSchema, options);
  }
  async unsubscribeResource(params, options) {
    return this.request({ method: "resources/unsubscribe", params }, EmptyResultSchema, options);
  }
  /**
   * Calls a tool and waits for the result. Automatically validates structured output if the tool has an outputSchema.
   *
   * For task-based execution with streaming behavior, use client.experimental.tasks.callToolStream() instead.
   */
  async callTool(params, resultSchema = CallToolResultSchema, options) {
    if (this.isToolTaskRequired(params.name)) {
      throw new McpError(ErrorCode.InvalidRequest, `Tool "${params.name}" requires task-based execution. Use client.experimental.tasks.callToolStream() instead.`);
    }
    const result = await this.request({ method: "tools/call", params }, resultSchema, options);
    const validator = this.getToolOutputValidator(params.name);
    if (validator) {
      if (!result.structuredContent && !result.isError) {
        throw new McpError(ErrorCode.InvalidRequest, `Tool ${params.name} has an output schema but did not return structured content`);
      }
      if (result.structuredContent) {
        try {
          const validationResult = validator(result.structuredContent);
          if (!validationResult.valid) {
            throw new McpError(ErrorCode.InvalidParams, `Structured content does not match the tool's output schema: ${validationResult.errorMessage}`);
          }
        } catch (error) {
          if (error instanceof McpError) {
            throw error;
          }
          throw new McpError(ErrorCode.InvalidParams, `Failed to validate structured content: ${error instanceof Error ? error.message : String(error)}`);
        }
      }
    }
    return result;
  }
  isToolTask(toolName) {
    if (!this._serverCapabilities?.tasks?.requests?.tools?.call) {
      return false;
    }
    return this._cachedKnownTaskTools.has(toolName);
  }
  /**
   * Check if a tool requires task-based execution.
   * Unlike isToolTask which includes 'optional' tools, this only checks for 'required'.
   */
  isToolTaskRequired(toolName) {
    return this._cachedRequiredTaskTools.has(toolName);
  }
  /**
   * Cache validators for tool output schemas.
   * Called after listTools() to pre-compile validators for better performance.
   */
  cacheToolMetadata(tools) {
    this._cachedToolOutputValidators.clear();
    this._cachedKnownTaskTools.clear();
    this._cachedRequiredTaskTools.clear();
    for (const tool of tools) {
      if (tool.outputSchema) {
        const toolValidator = this._jsonSchemaValidator.getValidator(tool.outputSchema);
        this._cachedToolOutputValidators.set(tool.name, toolValidator);
      }
      const taskSupport = tool.execution?.taskSupport;
      if (taskSupport === "required" || taskSupport === "optional") {
        this._cachedKnownTaskTools.add(tool.name);
      }
      if (taskSupport === "required") {
        this._cachedRequiredTaskTools.add(tool.name);
      }
    }
  }
  /**
   * Get cached validator for a tool
   */
  getToolOutputValidator(toolName) {
    return this._cachedToolOutputValidators.get(toolName);
  }
  async listTools(params, options) {
    const result = await this.request({ method: "tools/list", params }, ListToolsResultSchema, options);
    this.cacheToolMetadata(result.tools);
    return result;
  }
  /**
   * Set up a single list changed handler.
   * @internal
   */
  _setupListChangedHandler(listType, notificationSchema, options, fetcher) {
    const parseResult = ListChangedOptionsBaseSchema.safeParse(options);
    if (!parseResult.success) {
      throw new Error(`Invalid ${listType} listChanged options: ${parseResult.error.message}`);
    }
    if (typeof options.onChanged !== "function") {
      throw new Error(`Invalid ${listType} listChanged options: onChanged must be a function`);
    }
    const { autoRefresh, debounceMs } = parseResult.data;
    const { onChanged } = options;
    const refresh = async () => {
      if (!autoRefresh) {
        onChanged(null, null);
        return;
      }
      try {
        const items2 = await fetcher();
        onChanged(null, items2);
      } catch (e) {
        const error = e instanceof Error ? e : new Error(String(e));
        onChanged(error, null);
      }
    };
    const handler = () => {
      if (debounceMs) {
        const existingTimer = this._listChangedDebounceTimers.get(listType);
        if (existingTimer) {
          clearTimeout(existingTimer);
        }
        const timer = setTimeout(refresh, debounceMs);
        this._listChangedDebounceTimers.set(listType, timer);
      } else {
        refresh();
      }
    };
    this.setNotificationHandler(notificationSchema, handler);
  }
  async sendRootsListChanged() {
    return this.notification({ method: "notifications/roots/list_changed" });
  }
}
class ParseError extends Error {
  constructor(message, options) {
    super(message), this.name = "ParseError", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;
  }
}
function noop$1(_arg) {
}
function createParser(callbacks) {
  if (typeof callbacks == "function")
    throw new TypeError(
      "`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?"
    );
  const { onEvent = noop$1, onError = noop$1, onRetry = noop$1, onComment } = callbacks;
  let incompleteLine = "", isFirstChunk = true, id2, data2 = "", eventType = "";
  function feed(newChunk) {
    const chunk = isFirstChunk ? newChunk.replace(/^\xEF\xBB\xBF/, "") : newChunk, [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`);
    for (const line of complete)
      parseLine(line);
    incompleteLine = incomplete, isFirstChunk = false;
  }
  function parseLine(line) {
    if (line === "") {
      dispatchEvent();
      return;
    }
    if (line.startsWith(":")) {
      onComment && onComment(line.slice(line.startsWith(": ") ? 2 : 1));
      return;
    }
    const fieldSeparatorIndex = line.indexOf(":");
    if (fieldSeparatorIndex !== -1) {
      const field = line.slice(0, fieldSeparatorIndex), offset2 = line[fieldSeparatorIndex + 1] === " " ? 2 : 1, value = line.slice(fieldSeparatorIndex + offset2);
      processField(field, value, line);
      return;
    }
    processField(line, "", line);
  }
  function processField(field, value, line) {
    switch (field) {
      case "event":
        eventType = value;
        break;
      case "data":
        data2 = `${data2}${value}
`;
        break;
      case "id":
        id2 = value.includes("\0") ? void 0 : value;
        break;
      case "retry":
        /^\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(
          new ParseError(`Invalid \`retry\` value: "${value}"`, {
            type: "invalid-retry",
            value,
            line
          })
        );
        break;
      default:
        onError(
          new ParseError(
            `Unknown field "${field.length > 20 ? `${field.slice(0, 20)}` : field}"`,
            { type: "unknown-field", field, value, line }
          )
        );
        break;
    }
  }
  function dispatchEvent() {
    data2.length > 0 && onEvent({
      id: id2,
      event: eventType || void 0,
      // If the data buffer's last character is a U+000A LINE FEED (LF) character,
      // then remove the last character from the data buffer.
      data: data2.endsWith(`
`) ? data2.slice(0, -1) : data2
    }), id2 = void 0, data2 = "", eventType = "";
  }
  function reset(options = {}) {
    incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = true, id2 = void 0, data2 = "", eventType = "", incompleteLine = "";
  }
  return { feed, reset };
}
function splitLines(chunk) {
  const lines = [];
  let incompleteLine = "", searchIndex = 0;
  for (; searchIndex < chunk.length; ) {
    const crIndex = chunk.indexOf("\r", searchIndex), lfIndex = chunk.indexOf(`
`, searchIndex);
    let lineEnd = -1;
    if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? crIndex === chunk.length - 1 ? lineEnd = -1 : lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {
      incompleteLine = chunk.slice(searchIndex);
      break;
    } else {
      const line = chunk.slice(searchIndex, lineEnd);
      lines.push(line), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === "\r" && chunk[searchIndex] === `
` && searchIndex++;
    }
  }
  return [lines, incompleteLine];
}
class ErrorEvent extends Event {
  /**
   * Constructs a new `ErrorEvent` instance. This is typically not called directly,
   * but rather emitted by the `EventSource` object when an error occurs.
   *
   * @param type - The type of the event (should be "error")
   * @param errorEventInitDict - Optional properties to include in the error event
   */
  constructor(type2, errorEventInitDict) {
    var _a2, _b;
    super(type2), this.code = (_a2 = errorEventInitDict == null ? void 0 : errorEventInitDict.code) != null ? _a2 : void 0, this.message = (_b = errorEventInitDict == null ? void 0 : errorEventInitDict.message) != null ? _b : void 0;
  }
  /**
   * Node.js "hides" the `message` and `code` properties of the `ErrorEvent` instance,
   * when it is `console.log`'ed. This makes it harder to debug errors. To ease debugging,
   * we explicitly include the properties in the `inspect` method.
   *
   * This is automatically called by Node.js when you `console.log` an instance of this class.
   *
   * @param _depth - The current depth
   * @param options - The options passed to `util.inspect`
   * @param inspect - The inspect function to use (prevents having to import it from `util`)
   * @returns A string representation of the error
   */
  [/* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
    return inspect(inspectableError(this), options);
  }
  /**
   * Deno "hides" the `message` and `code` properties of the `ErrorEvent` instance,
   * when it is `console.log`'ed. This makes it harder to debug errors. To ease debugging,
   * we explicitly include the properties in the `inspect` method.
   *
   * This is automatically called by Deno when you `console.log` an instance of this class.
   *
   * @param inspect - The inspect function to use (prevents having to import it from `util`)
   * @param options - The options passed to `Deno.inspect`
   * @returns A string representation of the error
   */
  [/* @__PURE__ */ Symbol.for("Deno.customInspect")](inspect, options) {
    return inspect(inspectableError(this), options);
  }
}
function syntaxError(message) {
  const DomException = globalThis.DOMException;
  return typeof DomException == "function" ? new DomException(message, "SyntaxError") : new SyntaxError(message);
}
function flattenError(err) {
  return err instanceof Error ? "errors" in err && Array.isArray(err.errors) ? err.errors.map(flattenError).join(", ") : "cause" in err && err.cause instanceof Error ? `${err}: ${flattenError(err.cause)}` : err.message : `${err}`;
}
function inspectableError(err) {
  return {
    type: err.type,
    message: err.message,
    code: err.code,
    defaultPrevented: err.defaultPrevented,
    cancelable: err.cancelable,
    timeStamp: err.timeStamp
  };
}
var __typeError = (msg) => {
  throw TypeError(msg);
}, __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg), __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj)), __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value), __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), member.set(obj, value), value), __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method), _readyState, _url, _redirectUrl, _withCredentials, _fetch, _reconnectInterval, _reconnectTimer, _lastEventId, _controller, _parser, _onError, _onMessage, _onOpen, _EventSource_instances, connect_fn, _onFetchResponse, _onFetchError, getRequestOptions_fn, _onEvent, _onRetryChange, failConnection_fn, scheduleReconnect_fn, _reconnect;
class EventSource extends EventTarget {
  constructor(url2, eventSourceInitDict) {
    var _a2, _b;
    super(), __privateAdd(this, _EventSource_instances), this.CONNECTING = 0, this.OPEN = 1, this.CLOSED = 2, __privateAdd(this, _readyState), __privateAdd(this, _url), __privateAdd(this, _redirectUrl), __privateAdd(this, _withCredentials), __privateAdd(this, _fetch), __privateAdd(this, _reconnectInterval), __privateAdd(this, _reconnectTimer), __privateAdd(this, _lastEventId, null), __privateAdd(this, _controller), __privateAdd(this, _parser), __privateAdd(this, _onError, null), __privateAdd(this, _onMessage, null), __privateAdd(this, _onOpen, null), __privateAdd(this, _onFetchResponse, async (response) => {
      var _a22;
      __privateGet(this, _parser).reset();
      const { body, redirected, status, headers } = response;
      if (status === 204) {
        __privateMethod(this, _EventSource_instances, failConnection_fn).call(this, "Server sent HTTP 204, not reconnecting", 204), this.close();
        return;
      }
      if (redirected ? __privateSet(this, _redirectUrl, new URL(response.url)) : __privateSet(this, _redirectUrl, void 0), status !== 200) {
        __privateMethod(this, _EventSource_instances, failConnection_fn).call(this, `Non-200 status code (${status})`, status);
        return;
      }
      if (!(headers.get("content-type") || "").startsWith("text/event-stream")) {
        __privateMethod(this, _EventSource_instances, failConnection_fn).call(this, 'Invalid content type, expected "text/event-stream"', status);
        return;
      }
      if (__privateGet(this, _readyState) === this.CLOSED)
        return;
      __privateSet(this, _readyState, this.OPEN);
      const openEvent = new Event("open");
      if ((_a22 = __privateGet(this, _onOpen)) == null || _a22.call(this, openEvent), this.dispatchEvent(openEvent), typeof body != "object" || !body || !("getReader" in body)) {
        __privateMethod(this, _EventSource_instances, failConnection_fn).call(this, "Invalid response body, expected a web ReadableStream", status), this.close();
        return;
      }
      const decoder = new TextDecoder(), reader = body.getReader();
      let open = true;
      do {
        const { done, value } = await reader.read();
        value && __privateGet(this, _parser).feed(decoder.decode(value, { stream: !done })), done && (open = false, __privateGet(this, _parser).reset(), __privateMethod(this, _EventSource_instances, scheduleReconnect_fn).call(this));
      } while (open);
    }), __privateAdd(this, _onFetchError, (err) => {
      __privateSet(this, _controller, void 0), !(err.name === "AbortError" || err.type === "aborted") && __privateMethod(this, _EventSource_instances, scheduleReconnect_fn).call(this, flattenError(err));
    }), __privateAdd(this, _onEvent, (event) => {
      typeof event.id == "string" && __privateSet(this, _lastEventId, event.id);
      const messageEvent = new MessageEvent(event.event || "message", {
        data: event.data,
        origin: __privateGet(this, _redirectUrl) ? __privateGet(this, _redirectUrl).origin : __privateGet(this, _url).origin,
        lastEventId: event.id || ""
      });
      __privateGet(this, _onMessage) && (!event.event || event.event === "message") && __privateGet(this, _onMessage).call(this, messageEvent), this.dispatchEvent(messageEvent);
    }), __privateAdd(this, _onRetryChange, (value) => {
      __privateSet(this, _reconnectInterval, value);
    }), __privateAdd(this, _reconnect, () => {
      __privateSet(this, _reconnectTimer, void 0), __privateGet(this, _readyState) === this.CONNECTING && __privateMethod(this, _EventSource_instances, connect_fn).call(this);
    });
    try {
      if (url2 instanceof URL)
        __privateSet(this, _url, url2);
      else if (typeof url2 == "string")
        __privateSet(this, _url, new URL(url2, getBaseURL()));
      else
        throw new Error("Invalid URL");
    } catch {
      throw syntaxError("An invalid or illegal string was specified");
    }
    __privateSet(this, _parser, createParser({
      onEvent: __privateGet(this, _onEvent),
      onRetry: __privateGet(this, _onRetryChange)
    })), __privateSet(this, _readyState, this.CONNECTING), __privateSet(this, _reconnectInterval, 3e3), __privateSet(this, _fetch, (_a2 = eventSourceInitDict == null ? void 0 : eventSourceInitDict.fetch) != null ? _a2 : globalThis.fetch), __privateSet(this, _withCredentials, (_b = eventSourceInitDict == null ? void 0 : eventSourceInitDict.withCredentials) != null ? _b : false), __privateMethod(this, _EventSource_instances, connect_fn).call(this);
  }
  /**
   * Returns the state of this EventSource object's connection. It can have the values described below.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/readyState)
   *
   * Note: typed as `number` instead of `0 | 1 | 2` for compatibility with the `EventSource` interface,
   * defined in the TypeScript `dom` library.
   *
   * @public
   */
  get readyState() {
    return __privateGet(this, _readyState);
  }
  /**
   * Returns the URL providing the event stream.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/url)
   *
   * @public
   */
  get url() {
    return __privateGet(this, _url).href;
  }
  /**
   * Returns true if the credentials mode for connection requests to the URL providing the event stream is set to "include", and false otherwise.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/withCredentials)
   */
  get withCredentials() {
    return __privateGet(this, _withCredentials);
  }
  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/error_event) */
  get onerror() {
    return __privateGet(this, _onError);
  }
  set onerror(value) {
    __privateSet(this, _onError, value);
  }
  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/message_event) */
  get onmessage() {
    return __privateGet(this, _onMessage);
  }
  set onmessage(value) {
    __privateSet(this, _onMessage, value);
  }
  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/open_event) */
  get onopen() {
    return __privateGet(this, _onOpen);
  }
  set onopen(value) {
    __privateSet(this, _onOpen, value);
  }
  addEventListener(type2, listener, options) {
    const listen = listener;
    super.addEventListener(type2, listen, options);
  }
  removeEventListener(type2, listener, options) {
    const listen = listener;
    super.removeEventListener(type2, listen, options);
  }
  /**
   * Aborts any instances of the fetch algorithm started for this EventSource object, and sets the readyState attribute to CLOSED.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/close)
   *
   * @public
   */
  close() {
    __privateGet(this, _reconnectTimer) && clearTimeout(__privateGet(this, _reconnectTimer)), __privateGet(this, _readyState) !== this.CLOSED && (__privateGet(this, _controller) && __privateGet(this, _controller).abort(), __privateSet(this, _readyState, this.CLOSED), __privateSet(this, _controller, void 0));
  }
}
_readyState = /* @__PURE__ */ new WeakMap(), _url = /* @__PURE__ */ new WeakMap(), _redirectUrl = /* @__PURE__ */ new WeakMap(), _withCredentials = /* @__PURE__ */ new WeakMap(), _fetch = /* @__PURE__ */ new WeakMap(), _reconnectInterval = /* @__PURE__ */ new WeakMap(), _reconnectTimer = /* @__PURE__ */ new WeakMap(), _lastEventId = /* @__PURE__ */ new WeakMap(), _controller = /* @__PURE__ */ new WeakMap(), _parser = /* @__PURE__ */ new WeakMap(), _onError = /* @__PURE__ */ new WeakMap(), _onMessage = /* @__PURE__ */ new WeakMap(), _onOpen = /* @__PURE__ */ new WeakMap(), _EventSource_instances = /* @__PURE__ */ new WeakSet(), /**
* Connect to the given URL and start receiving events
*
* @internal
*/
connect_fn = function() {
  __privateSet(this, _readyState, this.CONNECTING), __privateSet(this, _controller, new AbortController()), __privateGet(this, _fetch)(__privateGet(this, _url), __privateMethod(this, _EventSource_instances, getRequestOptions_fn).call(this)).then(__privateGet(this, _onFetchResponse)).catch(__privateGet(this, _onFetchError));
}, _onFetchResponse = /* @__PURE__ */ new WeakMap(), _onFetchError = /* @__PURE__ */ new WeakMap(), /**
* Get request options for the `fetch()` request
*
* @returns The request options
* @internal
*/
getRequestOptions_fn = function() {
  var _a2;
  const init = {
    // [spec] Let `corsAttributeState` be `Anonymous`
    // [spec] will have their mode set to "cors"
    mode: "cors",
    redirect: "follow",
    headers: { Accept: "text/event-stream", ...__privateGet(this, _lastEventId) ? { "Last-Event-ID": __privateGet(this, _lastEventId) } : void 0 },
    cache: "no-store",
    signal: (_a2 = __privateGet(this, _controller)) == null ? void 0 : _a2.signal
  };
  return "window" in globalThis && (init.credentials = this.withCredentials ? "include" : "same-origin"), init;
}, _onEvent = /* @__PURE__ */ new WeakMap(), _onRetryChange = /* @__PURE__ */ new WeakMap(), /**
* Handles the process referred to in the EventSource specification as "failing a connection".
*
* @param error - The error causing the connection to fail
* @param code - The HTTP status code, if available
* @internal
*/
failConnection_fn = function(message, code2) {
  var _a2;
  __privateGet(this, _readyState) !== this.CLOSED && __privateSet(this, _readyState, this.CLOSED);
  const errorEvent = new ErrorEvent("error", { code: code2, message });
  (_a2 = __privateGet(this, _onError)) == null || _a2.call(this, errorEvent), this.dispatchEvent(errorEvent);
}, /**
* Schedules a reconnection attempt against the EventSource endpoint.
*
* @param message - The error causing the connection to fail
* @param code - The HTTP status code, if available
* @internal
*/
scheduleReconnect_fn = function(message, code2) {
  var _a2;
  if (__privateGet(this, _readyState) === this.CLOSED)
    return;
  __privateSet(this, _readyState, this.CONNECTING);
  const errorEvent = new ErrorEvent("error", { code: code2, message });
  (_a2 = __privateGet(this, _onError)) == null || _a2.call(this, errorEvent), this.dispatchEvent(errorEvent), __privateSet(this, _reconnectTimer, setTimeout(__privateGet(this, _reconnect), __privateGet(this, _reconnectInterval)));
}, _reconnect = /* @__PURE__ */ new WeakMap(), /**
* ReadyState representing an EventSource currently trying to connect
*
* @public
*/
EventSource.CONNECTING = 0, /**
* ReadyState representing an EventSource connection that is open (eg connected)
*
* @public
*/
EventSource.OPEN = 1, /**
* ReadyState representing an EventSource connection that is closed (eg disconnected)
*
* @public
*/
EventSource.CLOSED = 2;
function getBaseURL() {
  const doc = "document" in globalThis ? globalThis.document : void 0;
  return doc && typeof doc == "object" && "baseURI" in doc && typeof doc.baseURI == "string" ? doc.baseURI : void 0;
}
function normalizeHeaders(headers) {
  if (!headers)
    return {};
  if (headers instanceof Headers) {
    return Object.fromEntries(headers.entries());
  }
  if (Array.isArray(headers)) {
    return Object.fromEntries(headers);
  }
  return { ...headers };
}
function createFetchWithInit(baseFetch = fetch, baseInit) {
  if (!baseInit) {
    return baseFetch;
  }
  return async (url2, init) => {
    const mergedInit = {
      ...baseInit,
      ...init,
      // Headers need special handling - merge instead of replace
      headers: init?.headers ? { ...normalizeHeaders(baseInit.headers), ...normalizeHeaders(init.headers) } : baseInit.headers
    };
    return baseFetch(url2, mergedInit);
  };
}
class SseError extends Error {
  constructor(code2, message, event) {
    super(`SSE error: ${message}`);
    this.code = code2;
    this.event = event;
  }
}
class SSEClientTransport {
  constructor(url2, opts) {
    this._url = url2;
    this._resourceMetadataUrl = void 0;
    this._scope = void 0;
    this._eventSourceInit = opts?.eventSourceInit;
    this._requestInit = opts?.requestInit;
    this._authProvider = opts?.authProvider;
    this._fetch = opts?.fetch;
    this._fetchWithInit = createFetchWithInit(opts?.fetch, opts?.requestInit);
  }
  async _authThenStart() {
    if (!this._authProvider) {
      throw new UnauthorizedError("No auth provider");
    }
    let result;
    try {
      result = await auth(this._authProvider, {
        serverUrl: this._url,
        resourceMetadataUrl: this._resourceMetadataUrl,
        scope: this._scope,
        fetchFn: this._fetchWithInit
      });
    } catch (error) {
      this.onerror?.(error);
      throw error;
    }
    if (result !== "AUTHORIZED") {
      throw new UnauthorizedError();
    }
    return await this._startOrAuth();
  }
  async _commonHeaders() {
    const headers = {};
    if (this._authProvider) {
      const tokens = await this._authProvider.tokens();
      if (tokens) {
        headers["Authorization"] = `Bearer ${tokens.access_token}`;
      }
    }
    if (this._protocolVersion) {
      headers["mcp-protocol-version"] = this._protocolVersion;
    }
    const extraHeaders = normalizeHeaders(this._requestInit?.headers);
    return new Headers({
      ...headers,
      ...extraHeaders
    });
  }
  _startOrAuth() {
    const fetchImpl = this?._eventSourceInit?.fetch ?? this._fetch ?? fetch;
    return new Promise((resolve2, reject) => {
      this._eventSource = new EventSource(this._url.href, {
        ...this._eventSourceInit,
        fetch: async (url2, init) => {
          const headers = await this._commonHeaders();
          headers.set("Accept", "text/event-stream");
          const response = await fetchImpl(url2, {
            ...init,
            headers
          });
          if (response.status === 401 && response.headers.has("www-authenticate")) {
            const { resourceMetadataUrl, scope: scope2 } = extractWWWAuthenticateParams(response);
            this._resourceMetadataUrl = resourceMetadataUrl;
            this._scope = scope2;
          }
          return response;
        }
      });
      this._abortController = new AbortController();
      this._eventSource.onerror = (event) => {
        if (event.code === 401 && this._authProvider) {
          this._authThenStart().then(resolve2, reject);
          return;
        }
        const error = new SseError(event.code, event.message, event);
        reject(error);
        this.onerror?.(error);
      };
      this._eventSource.onopen = () => {
      };
      this._eventSource.addEventListener("endpoint", (event) => {
        const messageEvent = event;
        try {
          this._endpoint = new URL(messageEvent.data, this._url);
          if (this._endpoint.origin !== this._url.origin) {
            throw new Error(`Endpoint origin does not match connection origin: ${this._endpoint.origin}`);
          }
        } catch (error) {
          reject(error);
          this.onerror?.(error);
          void this.close();
          return;
        }
        resolve2();
      });
      this._eventSource.onmessage = (event) => {
        const messageEvent = event;
        let message;
        try {
          message = JSONRPCMessageSchema.parse(JSON.parse(messageEvent.data));
        } catch (error) {
          this.onerror?.(error);
          return;
        }
        this.onmessage?.(message);
      };
    });
  }
  async start() {
    if (this._eventSource) {
      throw new Error("SSEClientTransport already started! If using Client class, note that connect() calls start() automatically.");
    }
    return await this._startOrAuth();
  }
  /**
   * Call this method after the user has finished authorizing via their user agent and is redirected back to the MCP client application. This will exchange the authorization code for an access token, enabling the next connection attempt to successfully auth.
   */
  async finishAuth(authorizationCode) {
    if (!this._authProvider) {
      throw new UnauthorizedError("No auth provider");
    }
    const result = await auth(this._authProvider, {
      serverUrl: this._url,
      authorizationCode,
      resourceMetadataUrl: this._resourceMetadataUrl,
      scope: this._scope,
      fetchFn: this._fetchWithInit
    });
    if (result !== "AUTHORIZED") {
      throw new UnauthorizedError("Failed to authorize");
    }
  }
  async close() {
    this._abortController?.abort();
    this._eventSource?.close();
    this.onclose?.();
  }
  async send(message) {
    if (!this._endpoint) {
      throw new Error("Not connected");
    }
    try {
      const headers = await this._commonHeaders();
      headers.set("content-type", "application/json");
      const init = {
        ...this._requestInit,
        method: "POST",
        headers,
        body: JSON.stringify(message),
        signal: this._abortController?.signal
      };
      const response = await (this._fetch ?? fetch)(this._endpoint, init);
      if (!response.ok) {
        const text = await response.text().catch(() => null);
        if (response.status === 401 && this._authProvider) {
          const { resourceMetadataUrl, scope: scope2 } = extractWWWAuthenticateParams(response);
          this._resourceMetadataUrl = resourceMetadataUrl;
          this._scope = scope2;
          const result = await auth(this._authProvider, {
            serverUrl: this._url,
            resourceMetadataUrl: this._resourceMetadataUrl,
            scope: this._scope,
            fetchFn: this._fetchWithInit
          });
          if (result !== "AUTHORIZED") {
            throw new UnauthorizedError();
          }
          return this.send(message);
        }
        throw new Error(`Error POSTing to endpoint (HTTP ${response.status}): ${text}`);
      }
      await response.body?.cancel();
    } catch (error) {
      this.onerror?.(error);
      throw error;
    }
  }
  setProtocolVersion(version2) {
    this._protocolVersion = version2;
  }
}
class EventSourceParserStream extends TransformStream {
  constructor({ onError, onRetry, onComment } = {}) {
    let parser;
    super({
      start(controller) {
        parser = createParser({
          onEvent: (event) => {
            controller.enqueue(event);
          },
          onError(error) {
            onError === "terminate" ? controller.error(error) : typeof onError == "function" && onError(error);
          },
          onRetry,
          onComment
        });
      },
      transform(chunk) {
        parser.feed(chunk);
      }
    });
  }
}
const DEFAULT_STREAMABLE_HTTP_RECONNECTION_OPTIONS = {
  initialReconnectionDelay: 1e3,
  maxReconnectionDelay: 3e4,
  reconnectionDelayGrowFactor: 1.5,
  maxRetries: 2
};
class StreamableHTTPError extends Error {
  constructor(code2, message) {
    super(`Streamable HTTP error: ${message}`);
    this.code = code2;
  }
}
class StreamableHTTPClientTransport {
  constructor(url2, opts) {
    this._hasCompletedAuthFlow = false;
    this._url = url2;
    this._resourceMetadataUrl = void 0;
    this._scope = void 0;
    this._requestInit = opts?.requestInit;
    this._authProvider = opts?.authProvider;
    this._fetch = opts?.fetch;
    this._fetchWithInit = createFetchWithInit(opts?.fetch, opts?.requestInit);
    this._sessionId = opts?.sessionId;
    this._reconnectionOptions = opts?.reconnectionOptions ?? DEFAULT_STREAMABLE_HTTP_RECONNECTION_OPTIONS;
  }
  async _authThenStart() {
    if (!this._authProvider) {
      throw new UnauthorizedError("No auth provider");
    }
    let result;
    try {
      result = await auth(this._authProvider, {
        serverUrl: this._url,
        resourceMetadataUrl: this._resourceMetadataUrl,
        scope: this._scope,
        fetchFn: this._fetchWithInit
      });
    } catch (error) {
      this.onerror?.(error);
      throw error;
    }
    if (result !== "AUTHORIZED") {
      throw new UnauthorizedError();
    }
    return await this._startOrAuthSse({ resumptionToken: void 0 });
  }
  async _commonHeaders() {
    const headers = {};
    if (this._authProvider) {
      const tokens = await this._authProvider.tokens();
      if (tokens) {
        headers["Authorization"] = `Bearer ${tokens.access_token}`;
      }
    }
    if (this._sessionId) {
      headers["mcp-session-id"] = this._sessionId;
    }
    if (this._protocolVersion) {
      headers["mcp-protocol-version"] = this._protocolVersion;
    }
    const extraHeaders = normalizeHeaders(this._requestInit?.headers);
    return new Headers({
      ...headers,
      ...extraHeaders
    });
  }
  async _startOrAuthSse(options) {
    const { resumptionToken } = options;
    try {
      const headers = await this._commonHeaders();
      headers.set("Accept", "text/event-stream");
      if (resumptionToken) {
        headers.set("last-event-id", resumptionToken);
      }
      const response = await (this._fetch ?? fetch)(this._url, {
        method: "GET",
        headers,
        signal: this._abortController?.signal
      });
      if (!response.ok) {
        await response.body?.cancel();
        if (response.status === 401 && this._authProvider) {
          return await this._authThenStart();
        }
        if (response.status === 405) {
          return;
        }
        throw new StreamableHTTPError(response.status, `Failed to open SSE stream: ${response.statusText}`);
      }
      this._handleSseStream(response.body, options, true);
    } catch (error) {
      this.onerror?.(error);
      throw error;
    }
  }
  /**
   * Calculates the next reconnection delay using  backoff algorithm
   *
   * @param attempt Current reconnection attempt count for the specific stream
   * @returns Time to wait in milliseconds before next reconnection attempt
   */
  _getNextReconnectionDelay(attempt) {
    if (this._serverRetryMs !== void 0) {
      return this._serverRetryMs;
    }
    const initialDelay = this._reconnectionOptions.initialReconnectionDelay;
    const growFactor = this._reconnectionOptions.reconnectionDelayGrowFactor;
    const maxDelay = this._reconnectionOptions.maxReconnectionDelay;
    return Math.min(initialDelay * Math.pow(growFactor, attempt), maxDelay);
  }
  /**
   * Schedule a reconnection attempt using server-provided retry interval or backoff
   *
   * @param lastEventId The ID of the last received event for resumability
   * @param attemptCount Current reconnection attempt count for this specific stream
   */
  _scheduleReconnection(options, attemptCount = 0) {
    const maxRetries = this._reconnectionOptions.maxRetries;
    if (attemptCount >= maxRetries) {
      this.onerror?.(new Error(`Maximum reconnection attempts (${maxRetries}) exceeded.`));
      return;
    }
    const delay = this._getNextReconnectionDelay(attemptCount);
    this._reconnectionTimeout = setTimeout(() => {
      this._startOrAuthSse(options).catch((error) => {
        this.onerror?.(new Error(`Failed to reconnect SSE stream: ${error instanceof Error ? error.message : String(error)}`));
        this._scheduleReconnection(options, attemptCount + 1);
      });
    }, delay);
  }
  _handleSseStream(stream, options, isReconnectable) {
    if (!stream) {
      return;
    }
    const { onresumptiontoken, replayMessageId } = options;
    let lastEventId;
    let hasPrimingEvent = false;
    let receivedResponse = false;
    const processStream = async () => {
      try {
        const reader = stream.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream({
          onRetry: (retryMs) => {
            this._serverRetryMs = retryMs;
          }
        })).getReader();
        while (true) {
          const { value: event, done } = await reader.read();
          if (done) {
            break;
          }
          if (event.id) {
            lastEventId = event.id;
            hasPrimingEvent = true;
            onresumptiontoken?.(event.id);
          }
          if (!event.data) {
            continue;
          }
          if (!event.event || event.event === "message") {
            try {
              const message = JSONRPCMessageSchema.parse(JSON.parse(event.data));
              if (isJSONRPCResultResponse(message)) {
                receivedResponse = true;
                if (replayMessageId !== void 0) {
                  message.id = replayMessageId;
                }
              }
              this.onmessage?.(message);
            } catch (error) {
              this.onerror?.(error);
            }
          }
        }
        const canResume = isReconnectable || hasPrimingEvent;
        const needsReconnect = canResume && !receivedResponse;
        if (needsReconnect && this._abortController && !this._abortController.signal.aborted) {
          this._scheduleReconnection({
            resumptionToken: lastEventId,
            onresumptiontoken,
            replayMessageId
          }, 0);
        }
      } catch (error) {
        this.onerror?.(new Error(`SSE stream disconnected: ${error}`));
        const canResume = isReconnectable || hasPrimingEvent;
        const needsReconnect = canResume && !receivedResponse;
        if (needsReconnect && this._abortController && !this._abortController.signal.aborted) {
          try {
            this._scheduleReconnection({
              resumptionToken: lastEventId,
              onresumptiontoken,
              replayMessageId
            }, 0);
          } catch (error2) {
            this.onerror?.(new Error(`Failed to reconnect: ${error2 instanceof Error ? error2.message : String(error2)}`));
          }
        }
      }
    };
    processStream();
  }
  async start() {
    if (this._abortController) {
      throw new Error("StreamableHTTPClientTransport already started! If using Client class, note that connect() calls start() automatically.");
    }
    this._abortController = new AbortController();
  }
  /**
   * Call this method after the user has finished authorizing via their user agent and is redirected back to the MCP client application. This will exchange the authorization code for an access token, enabling the next connection attempt to successfully auth.
   */
  async finishAuth(authorizationCode) {
    if (!this._authProvider) {
      throw new UnauthorizedError("No auth provider");
    }
    const result = await auth(this._authProvider, {
      serverUrl: this._url,
      authorizationCode,
      resourceMetadataUrl: this._resourceMetadataUrl,
      scope: this._scope,
      fetchFn: this._fetchWithInit
    });
    if (result !== "AUTHORIZED") {
      throw new UnauthorizedError("Failed to authorize");
    }
  }
  async close() {
    if (this._reconnectionTimeout) {
      clearTimeout(this._reconnectionTimeout);
      this._reconnectionTimeout = void 0;
    }
    this._abortController?.abort();
    this.onclose?.();
  }
  async send(message, options) {
    try {
      const { resumptionToken, onresumptiontoken } = options || {};
      if (resumptionToken) {
        this._startOrAuthSse({ resumptionToken, replayMessageId: isJSONRPCRequest(message) ? message.id : void 0 }).catch((err) => this.onerror?.(err));
        return;
      }
      const headers = await this._commonHeaders();
      headers.set("content-type", "application/json");
      headers.set("accept", "application/json, text/event-stream");
      const init = {
        ...this._requestInit,
        method: "POST",
        headers,
        body: JSON.stringify(message),
        signal: this._abortController?.signal
      };
      const response = await (this._fetch ?? fetch)(this._url, init);
      const sessionId = response.headers.get("mcp-session-id");
      if (sessionId) {
        this._sessionId = sessionId;
      }
      if (!response.ok) {
        const text = await response.text().catch(() => null);
        if (response.status === 401 && this._authProvider) {
          if (this._hasCompletedAuthFlow) {
            throw new StreamableHTTPError(401, "Server returned 401 after successful authentication");
          }
          const { resourceMetadataUrl, scope: scope2 } = extractWWWAuthenticateParams(response);
          this._resourceMetadataUrl = resourceMetadataUrl;
          this._scope = scope2;
          const result = await auth(this._authProvider, {
            serverUrl: this._url,
            resourceMetadataUrl: this._resourceMetadataUrl,
            scope: this._scope,
            fetchFn: this._fetchWithInit
          });
          if (result !== "AUTHORIZED") {
            throw new UnauthorizedError();
          }
          this._hasCompletedAuthFlow = true;
          return this.send(message);
        }
        if (response.status === 403 && this._authProvider) {
          const { resourceMetadataUrl, scope: scope2, error } = extractWWWAuthenticateParams(response);
          if (error === "insufficient_scope") {
            const wwwAuthHeader = response.headers.get("WWW-Authenticate");
            if (this._lastUpscopingHeader === wwwAuthHeader) {
              throw new StreamableHTTPError(403, "Server returned 403 after trying upscoping");
            }
            if (scope2) {
              this._scope = scope2;
            }
            if (resourceMetadataUrl) {
              this._resourceMetadataUrl = resourceMetadataUrl;
            }
            this._lastUpscopingHeader = wwwAuthHeader ?? void 0;
            const result = await auth(this._authProvider, {
              serverUrl: this._url,
              resourceMetadataUrl: this._resourceMetadataUrl,
              scope: this._scope,
              fetchFn: this._fetch
            });
            if (result !== "AUTHORIZED") {
              throw new UnauthorizedError();
            }
            return this.send(message);
          }
        }
        throw new StreamableHTTPError(response.status, `Error POSTing to endpoint: ${text}`);
      }
      this._hasCompletedAuthFlow = false;
      this._lastUpscopingHeader = void 0;
      if (response.status === 202) {
        await response.body?.cancel();
        if (isInitializedNotification(message)) {
          this._startOrAuthSse({ resumptionToken: void 0 }).catch((err) => this.onerror?.(err));
        }
        return;
      }
      const messages = Array.isArray(message) ? message : [message];
      const hasRequests = messages.filter((msg) => "method" in msg && "id" in msg && msg.id !== void 0).length > 0;
      const contentType = response.headers.get("content-type");
      if (hasRequests) {
        if (contentType?.includes("text/event-stream")) {
          this._handleSseStream(response.body, { onresumptiontoken }, false);
        } else if (contentType?.includes("application/json")) {
          const data2 = await response.json();
          const responseMessages = Array.isArray(data2) ? data2.map((msg) => JSONRPCMessageSchema.parse(msg)) : [JSONRPCMessageSchema.parse(data2)];
          for (const msg of responseMessages) {
            this.onmessage?.(msg);
          }
        } else {
          await response.body?.cancel();
          throw new StreamableHTTPError(-1, `Unexpected content type: ${contentType}`);
        }
      } else {
        await response.body?.cancel();
      }
    } catch (error) {
      this.onerror?.(error);
      throw error;
    }
  }
  get sessionId() {
    return this._sessionId;
  }
  /**
   * Terminates the current session by sending a DELETE request to the server.
   *
   * Clients that no longer need a particular session
   * (e.g., because the user is leaving the client application) SHOULD send an
   * HTTP DELETE to the MCP endpoint with the Mcp-Session-Id header to explicitly
   * terminate the session.
   *
   * The server MAY respond with HTTP 405 Method Not Allowed, indicating that
   * the server does not allow clients to terminate sessions.
   */
  async terminateSession() {
    if (!this._sessionId) {
      return;
    }
    try {
      const headers = await this._commonHeaders();
      const init = {
        ...this._requestInit,
        method: "DELETE",
        headers,
        signal: this._abortController?.signal
      };
      const response = await (this._fetch ?? fetch)(this._url, init);
      await response.body?.cancel();
      if (!response.ok && response.status !== 405) {
        throw new StreamableHTTPError(response.status, `Failed to terminate session: ${response.statusText}`);
      }
      this._sessionId = void 0;
    } catch (error) {
      this.onerror?.(error);
      throw error;
    }
  }
  setProtocolVersion(version2) {
    this._protocolVersion = version2;
  }
  get protocolVersion() {
    return this._protocolVersion;
  }
  /**
   * Resume an SSE stream from a previous event ID.
   * Opens a GET SSE connection with Last-Event-ID header to replay missed events.
   *
   * @param lastEventId The event ID to resume from
   * @param options Optional callback to receive new resumption tokens
   */
  async resumeStream(lastEventId, options) {
    await this._startOrAuthSse({
      resumptionToken: lastEventId,
      onresumptiontoken: options?.onresumptiontoken
    });
  }
}
const getSearchParam = (key) => {
  try {
    const url2 = new URL(window.location.href);
    return url2.searchParams.get(key);
  } catch {
    return null;
  }
};
const getMCPProxyAddress = (config2) => {
  let proxyFullAddress = config2.MCP_PROXY_FULL_ADDRESS.value;
  if (proxyFullAddress) {
    proxyFullAddress = proxyFullAddress.replace(/\/+$/, "");
    return proxyFullAddress;
  }
  const proxyPort = getSearchParam("MCP_PROXY_PORT") || DEFAULT_MCP_PROXY_LISTEN_PORT;
  return `${window.location.protocol}//${window.location.hostname}:${proxyPort}`;
};
const getMCPServerRequestTimeout = (config2) => {
  return config2.MCP_SERVER_REQUEST_TIMEOUT.value;
};
const resetRequestTimeoutOnProgress = (config2) => {
  return config2.MCP_REQUEST_TIMEOUT_RESET_ON_PROGRESS.value;
};
const getMCPServerRequestMaxTotalTimeout = (config2) => {
  return config2.MCP_REQUEST_MAX_TOTAL_TIMEOUT.value;
};
const getMCPProxyAuthToken = (config2) => {
  return {
    token: config2.MCP_PROXY_AUTH_TOKEN.value,
    header: "X-MCP-Proxy-Auth"
  };
};
const getMCPTaskTtl = (config2) => {
  return config2.MCP_TASK_TTL.value;
};
const getInitialTransportType = () => {
  const param = getSearchParam("transport");
  if (param === "stdio" || param === "sse" || param === "streamable-http") {
    return param;
  }
  return localStorage.getItem("lastTransportType") || "stdio";
};
const getInitialSseUrl = () => {
  const param = getSearchParam("serverUrl");
  if (param) return param;
  return localStorage.getItem("lastSseUrl") || "http://localhost:3001/sse";
};
const getInitialCommand = () => {
  const param = getSearchParam("serverCommand");
  if (param) return param;
  return localStorage.getItem("lastCommand") || "mcp-server-everything";
};
const getInitialArgs = () => {
  const param = getSearchParam("serverArgs");
  if (param) return param;
  return localStorage.getItem("lastArgs") || "";
};
const getConfigOverridesFromQueryParams = (defaultConfig) => {
  const url2 = new URL(window.location.href);
  const overrides = {};
  for (const key of Object.keys(defaultConfig)) {
    const param = url2.searchParams.get(key);
    if (param !== null) {
      const defaultValue = defaultConfig[key].value;
      let value = param;
      if (typeof defaultValue === "number") {
        value = Number(param);
      } else if (typeof defaultValue === "boolean") {
        value = param === "true";
      }
      overrides[key] = {
        ...defaultConfig[key],
        value
      };
    }
  }
  return overrides;
};
const initializeInspectorConfig = (localStorageKey) => {
  const savedPersistentConfig = localStorage.getItem(localStorageKey);
  const savedEphemeralConfig = sessionStorage.getItem(
    `${localStorageKey}_ephemeral`
  );
  let baseConfig = { ...DEFAULT_INSPECTOR_CONFIG };
  if (savedPersistentConfig) {
    const parsedPersistentConfig = JSON.parse(savedPersistentConfig);
    baseConfig = { ...baseConfig, ...parsedPersistentConfig };
  }
  if (savedEphemeralConfig) {
    const parsedEphemeralConfig = JSON.parse(savedEphemeralConfig);
    baseConfig = { ...baseConfig, ...parsedEphemeralConfig };
  }
  for (const [key, value] of Object.entries(baseConfig)) {
    baseConfig[key] = {
      ...value,
      label: DEFAULT_INSPECTOR_CONFIG[key].label,
      description: DEFAULT_INSPECTOR_CONFIG[key].description,
      is_session_item: DEFAULT_INSPECTOR_CONFIG[key].is_session_item
    };
  }
  const overrides = getConfigOverridesFromQueryParams(DEFAULT_INSPECTOR_CONFIG);
  return { ...baseConfig, ...overrides };
};
const saveInspectorConfig = (localStorageKey, config2) => {
  const persistentConfig = {};
  const ephemeralConfig = {};
  for (const [key, value] of Object.entries(config2)) {
    if (value.is_session_item) {
      ephemeralConfig[key] = value;
    } else {
      persistentConfig[key] = value;
    }
  }
  localStorage.setItem(localStorageKey, JSON.stringify(persistentConfig));
  sessionStorage.setItem(
    `${localStorageKey}_ephemeral`,
    JSON.stringify(ephemeralConfig)
  );
};
function useConnection({
  transportType,
  command,
  args,
  sseUrl,
  env,
  customHeaders,
  oauthClientId,
  oauthClientSecret,
  oauthScope,
  config: config2,
  connectionType = "proxy",
  onNotification,
  onPendingRequest,
  onElicitationRequest,
  getRoots,
  defaultLoggingLevel,
  metadata: metadata2 = {}
}) {
  const [connectionStatus, setConnectionStatus] = reactExports.useState("disconnected");
  const { toast: toast2 } = useToast();
  const [serverCapabilities, setServerCapabilities] = reactExports.useState(null);
  const [mcpClient, setMcpClient] = reactExports.useState(null);
  const [clientTransport, setClientTransport] = reactExports.useState(
    null
  );
  const [requestHistory, setRequestHistory] = reactExports.useState([]);
  const [completionsSupported, setCompletionsSupported] = reactExports.useState(false);
  const [mcpSessionId, setMcpSessionId] = reactExports.useState(null);
  const [mcpProtocolVersion, setMcpProtocolVersion] = reactExports.useState(
    null
  );
  const [serverImplementation, setServerImplementation] = reactExports.useState(null);
  const receiverTasksRef = reactExports.useRef(/* @__PURE__ */ new Map());
  reactExports.useEffect(() => {
    if (!oauthClientId) {
      clearClientInformationFromSessionStorage({
        serverUrl: sseUrl,
        isPreregistered: true
      });
      return;
    }
    const clientInformation = {
      client_id: oauthClientId
    };
    if (oauthClientSecret) {
      clientInformation.client_secret = oauthClientSecret;
    }
    saveClientInformationToSessionStorage({
      serverUrl: sseUrl,
      clientInformation,
      isPreregistered: true
    });
  }, [oauthClientId, oauthClientSecret, sseUrl]);
  reactExports.useEffect(() => {
    if (!oauthScope) {
      clearScopeFromSessionStorage(sseUrl);
      return;
    }
    saveScopeToSessionStorage(sseUrl, oauthScope);
  }, [oauthScope, sseUrl]);
  const pushHistory = (request, response) => {
    setRequestHistory((prev) => [
      ...prev,
      {
        request: JSON.stringify(request),
        response: response !== void 0 ? JSON.stringify(response) : void 0
      }
    ]);
  };
  const makeRequest = async (request, schema, options) => {
    if (!mcpClient) {
      throw new Error("MCP client not connected");
    }
    try {
      const abortController = new AbortController();
      const shouldAddGeneralMetadata = request.method !== "tools/call" && Object.keys(metadata2).length > 0;
      const requestWithMetadata = shouldAddGeneralMetadata ? {
        ...request,
        params: {
          ...request.params,
          _meta: metadata2
        }
      } : request;
      const mcpRequestOptions = {
        signal: options?.signal ?? abortController.signal,
        resetTimeoutOnProgress: options?.resetTimeoutOnProgress ?? resetRequestTimeoutOnProgress(config2),
        timeout: options?.timeout ?? getMCPServerRequestTimeout(config2),
        maxTotalTimeout: options?.maxTotalTimeout ?? getMCPServerRequestMaxTotalTimeout(config2)
      };
      if (mcpRequestOptions.resetTimeoutOnProgress) {
        mcpRequestOptions.onprogress = (params) => {
          if (onNotification) {
            onNotification({
              method: "notifications/progress",
              params
            });
          }
        };
      }
      let response;
      try {
        response = await mcpClient.request(
          requestWithMetadata,
          schema,
          mcpRequestOptions
        );
        pushHistory(requestWithMetadata, response);
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        pushHistory(requestWithMetadata, { error: errorMessage });
        throw error;
      }
      return response;
    } catch (e) {
      if (!options?.suppressToast) {
        const errorString = e.message ?? String(e);
        toast2({
          title: "Error",
          description: errorString,
          variant: "destructive"
        });
      }
      throw e;
    }
  };
  const handleCompletion = async (ref2, argName, value, context, signal) => {
    if (!mcpClient || !completionsSupported) {
      return [];
    }
    const request = {
      method: "completion/complete",
      params: {
        argument: {
          name: argName,
          value
        },
        ref: ref2
      }
    };
    if (context) {
      request["params"]["context"] = {
        arguments: context
      };
    }
    try {
      const response = await makeRequest(request, CompleteResultSchema, {
        signal,
        suppressToast: true
      });
      return response?.completion.values || [];
    } catch (e) {
      if (e instanceof McpError && e.code === ErrorCode.MethodNotFound) {
        setCompletionsSupported(false);
        return [];
      }
      toast2({
        title: "Error",
        description: e instanceof Error ? e.message : String(e),
        variant: "destructive"
      });
      throw e;
    }
  };
  const sendNotification = async (notification) => {
    if (!mcpClient) {
      const error = new Error("MCP client not connected");
      toast2({
        title: "Error",
        description: error.message,
        variant: "destructive"
      });
      throw error;
    }
    try {
      await mcpClient.notification(notification);
      pushHistory(notification);
    } catch (e) {
      if (e instanceof McpError) {
        pushHistory(notification, { error: e.message });
      }
      toast2({
        title: "Error",
        description: e instanceof Error ? e.message : String(e),
        variant: "destructive"
      });
      throw e;
    }
  };
  const checkProxyHealth = async () => {
    try {
      const proxyHealthUrl = new URL(`${getMCPProxyAddress(config2)}/health`);
      const { token: proxyAuthToken, header: proxyAuthTokenHeader } = getMCPProxyAuthToken(config2);
      const headers = {};
      if (proxyAuthToken) {
        headers[proxyAuthTokenHeader] = `Bearer ${proxyAuthToken}`;
      }
      const proxyHealthResponse = await fetch(proxyHealthUrl, { headers });
      const proxyHealth = await proxyHealthResponse.json();
      if (proxyHealth?.status !== "ok") {
        throw new Error("MCP Proxy Server is not healthy");
      }
    } catch (e) {
      console.error("Couldn't connect to MCP Proxy Server", e);
      throw e;
    }
  };
  const is401Error = (error) => {
    return error instanceof SseError && error.code === 401 || error instanceof StreamableHTTPError && error.code === 401 || error instanceof Error && error.message.includes("401") || error instanceof Error && error.message.includes("Unauthorized") || error instanceof Error && error.message.includes("Missing Authorization header");
  };
  const isProxyAuthError = (error) => {
    return error instanceof Error && error.message.includes("Authentication required. Use the session token");
  };
  const handleAuthError = async (error) => {
    if (is401Error(error)) {
      let scope2 = oauthScope?.trim();
      if (!scope2) {
        let resourceMetadata;
        try {
          resourceMetadata = await discoverOAuthProtectedResourceMetadata(
            new URL("/", sseUrl)
          );
        } catch {
        }
        scope2 = await discoverScopes(sseUrl, resourceMetadata);
      }
      saveScopeToSessionStorage(sseUrl, scope2);
      const serverAuthProvider = new InspectorOAuthClientProvider(sseUrl);
      try {
        const result = await auth(serverAuthProvider, {
          serverUrl: sseUrl,
          scope: scope2
        });
        return result === "AUTHORIZED";
      } catch (authError) {
        toast2({
          title: "OAuth Authentication Failed",
          description: authError instanceof Error ? authError.message : String(authError),
          variant: "destructive"
        });
        return false;
      }
    }
    return false;
  };
  const captureResponseHeaders = (response) => {
    const sessionId = response.headers.get("mcp-session-id");
    const protocolVersion = response.headers.get("mcp-protocol-version");
    if (sessionId && sessionId !== mcpSessionId) {
      setMcpSessionId(sessionId);
    }
    if (protocolVersion && protocolVersion !== mcpProtocolVersion) {
      setMcpProtocolVersion(protocolVersion);
    }
  };
  const connect = async (_e2, retryCount = 0) => {
    const clientCapabilities = {
      capabilities: {
        sampling: {},
        elicitation: {},
        roots: {
          listChanged: true
        },
        tasks: {
          list: {},
          cancel: {},
          ...onPendingRequest || onElicitationRequest ? {
            requests: {
              ...onPendingRequest ? { sampling: { createMessage: {} } } : void 0,
              ...onElicitationRequest ? { elicitation: { create: {} } } : void 0
            }
          } : void 0
        }
      }
    };
    const client2 = new Client(
      CLIENT_IDENTITY,
      clientCapabilities
    );
    if (connectionType === "proxy") {
      try {
        await checkProxyHealth();
      } catch {
        setConnectionStatus("error-connecting-to-proxy");
        return;
      }
    }
    let lastRequest = "";
    try {
      const headers = {};
      const serverAuthProvider = new InspectorOAuthClientProvider(sseUrl);
      let finalHeaders = customHeaders || [];
      const isEmptyAuthHeader = (header) => header.name.trim().toLowerCase() === "authorization" && header.value.trim().toLowerCase() === "bearer";
      const hasEmptyAuthHeader = finalHeaders.some(
        (header) => header.enabled && isEmptyAuthHeader(header)
      );
      if (hasEmptyAuthHeader) {
        toast2({
          title: "Invalid Authorization Header",
          description: "Authorization header is enabled but empty. Please add a token or disable the header.",
          variant: "destructive"
        });
      }
      const needsOAuthToken = !finalHeaders.some(
        (header) => header.enabled && header.name.trim().toLowerCase() === "authorization"
      );
      if (needsOAuthToken) {
        const oauthToken = (await serverAuthProvider.tokens())?.access_token;
        if (oauthToken) {
          finalHeaders = [
            // Remove any existing Authorization headers with empty tokens
            ...finalHeaders.filter((header) => !isEmptyAuthHeader(header)),
            {
              name: "Authorization",
              value: `Bearer ${oauthToken}`,
              enabled: true
            }
          ];
        }
      }
      const customHeaderNames = [];
      finalHeaders.forEach((header) => {
        if (header.enabled && header.name.trim() && header.value.trim()) {
          const headerName = header.name.trim();
          const headerValue = header.value.trim();
          headers[headerName] = headerValue;
          if (headerName.toLowerCase() !== "authorization") {
            customHeaderNames.push(headerName);
          }
        }
      });
      if (customHeaderNames.length > 0) {
        headers["x-custom-auth-headers"] = JSON.stringify(customHeaderNames);
      }
      let transportOptions;
      let serverUrl;
      if (connectionType === "direct" && transportType !== "stdio") {
        serverUrl = new URL(sseUrl);
        const requestHeaders = { ...headers };
        if (mcpSessionId) {
          requestHeaders["mcp-session-id"] = mcpSessionId;
        }
        switch (transportType) {
          case "sse":
            requestHeaders["Accept"] = "text/event-stream";
            requestHeaders["content-type"] = "application/json";
            transportOptions = {
              authProvider: serverAuthProvider,
              fetch: async (url2, init) => {
                const response = await fetch(url2, {
                  ...init,
                  headers: requestHeaders
                });
                captureResponseHeaders(response);
                return response;
              },
              requestInit: {
                headers: requestHeaders
              }
            };
            break;
          case "streamable-http":
            transportOptions = {
              authProvider: serverAuthProvider,
              fetch: async (url2, init) => {
                requestHeaders["Accept"] = "text/event-stream, application/json";
                requestHeaders["Content-Type"] = "application/json";
                const response = await fetch(url2, {
                  headers: requestHeaders,
                  ...init
                });
                captureResponseHeaders(response);
                return response;
              },
              requestInit: {
                headers: requestHeaders
              },
              // TODO these should be configurable...
              reconnectionOptions: {
                maxReconnectionDelay: 3e4,
                initialReconnectionDelay: 1e3,
                reconnectionDelayGrowFactor: 1.5,
                maxRetries: 2
              }
            };
            break;
        }
      } else {
        const { token: proxyAuthToken, header: proxyAuthTokenHeader } = getMCPProxyAuthToken(config2);
        const proxyHeaders = {};
        if (proxyAuthToken) {
          proxyHeaders[proxyAuthTokenHeader] = `Bearer ${proxyAuthToken}`;
        }
        let mcpProxyServerUrl;
        switch (transportType) {
          case "stdio": {
            mcpProxyServerUrl = new URL(`${getMCPProxyAddress(config2)}/stdio`);
            mcpProxyServerUrl.searchParams.append("command", command);
            mcpProxyServerUrl.searchParams.append("args", args);
            mcpProxyServerUrl.searchParams.append("env", JSON.stringify(env));
            const proxyFullAddress = config2.MCP_PROXY_FULL_ADDRESS.value;
            if (proxyFullAddress) {
              mcpProxyServerUrl.searchParams.append(
                "proxyFullAddress",
                proxyFullAddress
              );
            }
            transportOptions = {
              authProvider: serverAuthProvider,
              eventSourceInit: {
                fetch: (url2, init) => fetch(url2, {
                  ...init,
                  headers: { ...headers, ...proxyHeaders }
                })
              },
              requestInit: {
                headers: { ...headers, ...proxyHeaders }
              }
            };
            break;
          }
          case "sse": {
            mcpProxyServerUrl = new URL(`${getMCPProxyAddress(config2)}/sse`);
            mcpProxyServerUrl.searchParams.append("url", sseUrl);
            const proxyFullAddressSSE = config2.MCP_PROXY_FULL_ADDRESS.value;
            if (proxyFullAddressSSE) {
              mcpProxyServerUrl.searchParams.append(
                "proxyFullAddress",
                proxyFullAddressSSE
              );
            }
            transportOptions = {
              authProvider: serverAuthProvider,
              eventSourceInit: {
                fetch: (url2, init) => fetch(url2, {
                  ...init,
                  headers: { ...headers, ...proxyHeaders }
                })
              },
              requestInit: {
                headers: { ...headers, ...proxyHeaders }
              }
            };
            break;
          }
          case "streamable-http":
            mcpProxyServerUrl = new URL(`${getMCPProxyAddress(config2)}/mcp`);
            mcpProxyServerUrl.searchParams.append("url", sseUrl);
            transportOptions = {
              authProvider: serverAuthProvider,
              eventSourceInit: {
                fetch: (url2, init) => fetch(url2, {
                  ...init,
                  headers: { ...headers, ...proxyHeaders }
                })
              },
              requestInit: {
                headers: { ...headers, ...proxyHeaders }
              },
              // TODO these should be configurable...
              reconnectionOptions: {
                maxReconnectionDelay: 3e4,
                initialReconnectionDelay: 1e3,
                reconnectionDelayGrowFactor: 1.5,
                maxRetries: 2
              }
            };
            break;
        }
        serverUrl = mcpProxyServerUrl;
        serverUrl.searchParams.append("transportType", transportType);
      }
      if (onNotification) {
        [
          CancelledNotificationSchema,
          LoggingMessageNotificationSchema,
          ResourceUpdatedNotificationSchema,
          ResourceListChangedNotificationSchema,
          ToolListChangedNotificationSchema,
          PromptListChangedNotificationSchema,
          TaskStatusNotificationSchema
        ].forEach((notificationSchema) => {
          client2.setNotificationHandler(notificationSchema, onNotification);
        });
        client2.fallbackNotificationHandler = (notification) => {
          onNotification(notification);
          return Promise.resolve();
        };
      }
      let capabilities;
      try {
        const transport = transportType === "streamable-http" ? new StreamableHTTPClientTransport(serverUrl, {
          sessionId: void 0,
          ...transportOptions
        }) : new SSEClientTransport(serverUrl, transportOptions);
        await client2.connect(transport);
        const protocolOnMessage = transport.onmessage;
        if (protocolOnMessage) {
          transport.onmessage = (message) => {
            const resolvedMessage = resolveRefsInMessage(message);
            protocolOnMessage(resolvedMessage);
          };
        }
        setClientTransport(transport);
        capabilities = client2.getServerCapabilities();
        const serverInfo = client2.getServerVersion();
        setServerImplementation(serverInfo || null);
        const initializeRequest = {
          method: "initialize"
        };
        pushHistory(initializeRequest, {
          capabilities,
          serverInfo: client2.getServerVersion(),
          instructions: client2.getInstructions()
        });
      } catch (error) {
        console.error(
          connectionType === "direct" ? `Failed to connect directly to MCP Server at: ${serverUrl}:` : `Failed to connect to MCP Server via the MCP Inspector Proxy: ${serverUrl}:`,
          error
        );
        if (isProxyAuthError(error)) {
          toast2({
            title: "Proxy Authentication Required",
            description: "Please enter the session token from the proxy server console in the Configuration settings.",
            variant: "destructive"
          });
          setConnectionStatus("error");
          return;
        }
        const shouldRetry = await handleAuthError(error);
        if (shouldRetry) {
          return connect(void 0, retryCount + 1);
        }
        if (is401Error(error)) {
          return;
        }
        throw error;
      }
      setServerCapabilities(capabilities ?? null);
      setCompletionsSupported(capabilities?.completions !== void 0);
      const nowIso = () => (/* @__PURE__ */ new Date()).toISOString();
      const makeTaskId = () => {
        const cryptoAny = globalThis.crypto;
        return cryptoAny?.randomUUID?.() ?? `task_${Date.now()}_${Math.random().toString(16).slice(2)}`;
      };
      const emitTaskStatus = async (task) => {
        try {
          const notification = {
            method: "notifications/tasks/status",
            params: task
          };
          await client2.notification(notification);
          pushHistory(notification);
        } catch (e) {
          console.warn("Failed to send notifications/tasks/status", e);
        }
      };
      const upsertReceiverTask = async (task) => {
        const record2 = receiverTasksRef.current.get(task.taskId);
        if (record2) {
          receiverTasksRef.current.set(task.taskId, { ...record2, task });
        }
        await emitTaskStatus(task);
      };
      const createReceiverTask = (opts) => {
        const taskId = makeTaskId();
        const createdAt = nowIso();
        const ttl = opts.ttl ?? getMCPTaskTtl(config2);
        let resolvePayload = () => void 0;
        let rejectPayload = () => void 0;
        const payloadPromise = new Promise((resolve2, reject) => {
          resolvePayload = resolve2;
          rejectPayload = reject;
        });
        const task = {
          taskId,
          status: opts.initialStatus,
          ttl,
          createdAt,
          lastUpdatedAt: createdAt,
          ...opts.pollInterval !== void 0 ? { pollInterval: opts.pollInterval } : void 0,
          ...opts.statusMessage ? { statusMessage: opts.statusMessage } : {}
        };
        const record2 = {
          task,
          payloadPromise,
          resolvePayload,
          rejectPayload
        };
        if (ttl !== null && ttl > 0) {
          record2.cleanupTimeoutId = setTimeout(() => {
            receiverTasksRef.current.delete(taskId);
          }, ttl);
        }
        receiverTasksRef.current.set(taskId, record2);
        void emitTaskStatus(task);
        return record2;
      };
      client2.setRequestHandler(ListTasksRequestSchema, async () => {
        return {
          tasks: Array.from(receiverTasksRef.current.values()).map(
            (r2) => r2.task
          )
        };
      });
      client2.setRequestHandler(GetTaskRequestSchema, async (request) => {
        const record2 = receiverTasksRef.current.get(request.params.taskId);
        if (!record2) {
          throw new McpError(
            ErrorCode.InvalidParams,
            `Unknown taskId: ${request.params.taskId}`
          );
        }
        return record2.task;
      });
      client2.setRequestHandler(GetTaskPayloadRequestSchema, async (request) => {
        const record2 = receiverTasksRef.current.get(request.params.taskId);
        if (!record2) {
          throw new McpError(
            ErrorCode.InvalidParams,
            `Unknown taskId: ${request.params.taskId}`
          );
        }
        return await record2.payloadPromise;
      });
      client2.setRequestHandler(CancelTaskRequestSchema, async (request) => {
        const record2 = receiverTasksRef.current.get(request.params.taskId);
        if (!record2) {
          throw new McpError(
            ErrorCode.InvalidParams,
            `Unknown taskId: ${request.params.taskId}`
          );
        }
        const terminalStatuses = [
          "completed",
          "failed",
          "cancelled"
        ];
        if (!terminalStatuses.includes(record2.task.status)) {
          const updated = {
            ...record2.task,
            status: "cancelled",
            lastUpdatedAt: nowIso(),
            statusMessage: "Cancelled"
          };
          receiverTasksRef.current.set(request.params.taskId, {
            ...record2,
            task: updated
          });
          record2.rejectPayload(
            new McpError(ErrorCode.InternalError, "Task was cancelled")
          );
          await emitTaskStatus(updated);
        }
        return receiverTasksRef.current.get(request.params.taskId).task;
      });
      if (onPendingRequest) {
        client2.setRequestHandler(CreateMessageRequestSchema, (request) => {
          const taskSpec = request.params?.task;
          if (!taskSpec) {
            return new Promise((resolve2, reject) => {
              onPendingRequest(request, resolve2, reject);
            });
          }
          const record2 = createReceiverTask({
            ttl: taskSpec.ttl,
            initialStatus: "input_required",
            statusMessage: "Awaiting user input"
          });
          void (async () => {
            try {
              const payload = await new Promise((resolve2, reject) => {
                onPendingRequest(request, resolve2, reject);
              });
              record2.resolvePayload(payload);
              const updated = {
                ...record2.task,
                status: "completed",
                lastUpdatedAt: nowIso()
              };
              receiverTasksRef.current.set(record2.task.taskId, {
                ...record2,
                task: updated
              });
              await upsertReceiverTask(updated);
            } catch (e) {
              record2.rejectPayload(e);
              const updated = {
                ...record2.task,
                status: "failed",
                lastUpdatedAt: nowIso(),
                statusMessage: e instanceof Error ? e.message : "Task failed"
              };
              receiverTasksRef.current.set(record2.task.taskId, {
                ...record2,
                task: updated
              });
              await upsertReceiverTask(updated);
            }
          })();
          const createTaskResult = {
            task: record2.task
          };
          return createTaskResult;
        });
      }
      if (getRoots) {
        client2.setRequestHandler(ListRootsRequestSchema, async () => {
          return { roots: getRoots() };
        });
      }
      if (onElicitationRequest) {
        client2.setRequestHandler(ElicitRequestSchema, (request) => {
          const taskSpec = request.params?.task;
          if (!taskSpec) {
            return new Promise((resolve2) => {
              onElicitationRequest(request, resolve2);
            });
          }
          const record2 = createReceiverTask({
            ttl: taskSpec.ttl,
            initialStatus: "input_required",
            statusMessage: "Awaiting user input"
          });
          void (async () => {
            try {
              const payload = await new Promise((resolve2) => {
                onElicitationRequest(request, resolve2);
              });
              record2.resolvePayload(payload);
              const updated = {
                ...record2.task,
                status: "completed",
                lastUpdatedAt: nowIso()
              };
              receiverTasksRef.current.set(record2.task.taskId, {
                ...record2,
                task: updated
              });
              await upsertReceiverTask(updated);
            } catch (e) {
              record2.rejectPayload(e);
              const updated = {
                ...record2.task,
                status: "failed",
                lastUpdatedAt: nowIso(),
                statusMessage: e instanceof Error ? e.message : "Task failed"
              };
              receiverTasksRef.current.set(record2.task.taskId, {
                ...record2,
                task: updated
              });
              await upsertReceiverTask(updated);
            }
          })();
          const createTaskResult = {
            task: record2.task
          };
          return createTaskResult;
        });
      }
      if (capabilities?.logging && defaultLoggingLevel) {
        lastRequest = "logging/setLevel";
        await client2.setLoggingLevel(defaultLoggingLevel);
        pushHistory(
          {
            method: "logging/setLevel",
            params: {
              level: defaultLoggingLevel
            }
          },
          {}
        );
        lastRequest = "";
      }
      setMcpClient(client2);
      setConnectionStatus("connected");
    } catch (e) {
      if (lastRequest === "logging/setLevel" && e instanceof McpError && e.code === ErrorCode.MethodNotFound) {
        toast2({
          title: "Error",
          description: `Server declares logging capability but doesn't implement method: "${lastRequest}"`,
          variant: "destructive"
        });
      } else {
        toast2({
          title: "Connection error",
          description: `Connection failed: "${e}"`,
          variant: "destructive"
        });
      }
      console.error(e);
      setConnectionStatus("error");
    }
  };
  const cancelTask = async (taskId) => {
    return makeRequest(
      {
        method: "tasks/cancel",
        params: { taskId }
      },
      CancelTaskResultSchema
    );
  };
  const listTasks = async (cursor) => {
    return makeRequest(
      {
        method: "tasks/list",
        params: { cursor }
      },
      ListTasksResultSchema
    );
  };
  const disconnect = async () => {
    receiverTasksRef.current.forEach((record2) => {
      if (record2.cleanupTimeoutId) {
        clearTimeout(record2.cleanupTimeoutId);
      }
    });
    receiverTasksRef.current.clear();
    if (transportType === "streamable-http")
      await clientTransport.terminateSession();
    await mcpClient?.close();
    const authProvider = new InspectorOAuthClientProvider(sseUrl);
    authProvider.clear();
    setMcpClient(null);
    setClientTransport(null);
    setConnectionStatus("disconnected");
    setCompletionsSupported(false);
    setServerCapabilities(null);
    setMcpSessionId(null);
    setMcpProtocolVersion(null);
  };
  const clearRequestHistory = () => {
    setRequestHistory([]);
    setServerImplementation(null);
  };
  return {
    connectionStatus,
    serverCapabilities,
    serverImplementation,
    mcpClient,
    requestHistory,
    clearRequestHistory,
    makeRequest,
    cancelTask,
    listTasks,
    sendNotification,
    handleCompletion,
    completionsSupported,
    connect,
    disconnect
  };
}
function useDraggablePane(initialHeight) {
  const [height, setHeight] = reactExports.useState(initialHeight);
  const [isDragging, setIsDragging] = reactExports.useState(false);
  const dragStartY = reactExports.useRef(0);
  const dragStartHeight = reactExports.useRef(0);
  const handleDragStart = reactExports.useCallback(
    (e) => {
      setIsDragging(true);
      dragStartY.current = e.clientY;
      dragStartHeight.current = height;
      document.body.style.userSelect = "none";
    },
    [height]
  );
  const handleDragMove = reactExports.useCallback(
    (e) => {
      if (!isDragging) return;
      const deltaY = dragStartY.current - e.clientY;
      const newHeight = Math.max(
        100,
        Math.min(800, dragStartHeight.current + deltaY)
      );
      setHeight(newHeight);
    },
    [isDragging]
  );
  const handleDragEnd = reactExports.useCallback(() => {
    setIsDragging(false);
    document.body.style.userSelect = "";
  }, []);
  reactExports.useEffect(() => {
    if (isDragging) {
      window.addEventListener("mousemove", handleDragMove);
      window.addEventListener("mouseup", handleDragEnd);
      return () => {
        window.removeEventListener("mousemove", handleDragMove);
        window.removeEventListener("mouseup", handleDragEnd);
      };
    }
  }, [isDragging, handleDragMove, handleDragEnd]);
  return {
    height,
    isDragging,
    handleDragStart
  };
}
function useDraggableSidebar(initialWidth) {
  const [width, setWidth] = reactExports.useState(initialWidth);
  const [isDragging, setIsDragging] = reactExports.useState(false);
  const dragStartX = reactExports.useRef(0);
  const dragStartWidth = reactExports.useRef(0);
  const handleDragStart = reactExports.useCallback(
    (e) => {
      setIsDragging(true);
      dragStartX.current = e.clientX;
      dragStartWidth.current = width;
      document.body.style.userSelect = "none";
    },
    [width]
  );
  const handleDragMove = reactExports.useCallback(
    (e) => {
      if (!isDragging) return;
      const deltaX = e.clientX - dragStartX.current;
      const newWidth = Math.max(
        200,
        Math.min(600, dragStartWidth.current + deltaX)
      );
      setWidth(newWidth);
    },
    [isDragging]
  );
  const handleDragEnd = reactExports.useCallback(() => {
    setIsDragging(false);
    document.body.style.userSelect = "";
  }, []);
  reactExports.useEffect(() => {
    if (isDragging) {
      window.addEventListener("mousemove", handleDragMove);
      window.addEventListener("mouseup", handleDragEnd);
      return () => {
        window.removeEventListener("mousemove", handleDragMove);
        window.removeEventListener("mouseup", handleDragEnd);
      };
    }
  }, [isDragging, handleDragMove, handleDragEnd]);
  return {
    width,
    isDragging,
    handleDragStart
  };
}
var useReactId = React$1[" useId ".trim().toString()] || (() => void 0);
var count$1 = 0;
function useId(deterministicId) {
  const [id2, setId] = reactExports.useState(useReactId());
  useLayoutEffect2(() => {
    setId((reactId) => reactId ?? String(count$1++));
  }, [deterministicId]);
  return id2 ? `radix-${id2}` : "";
}
var DirectionContext = reactExports.createContext(void 0);
function useDirection(localDir) {
  const globalDir = reactExports.useContext(DirectionContext);
  return localDir || globalDir || "ltr";
}
var ENTRY_FOCUS = "rovingFocusGroup.onEntryFocus";
var EVENT_OPTIONS$1 = { bubbles: false, cancelable: true };
var GROUP_NAME$1 = "RovingFocusGroup";
var [Collection$1, useCollection$1, createCollectionScope$1] = createCollection(GROUP_NAME$1);
var [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope(
  GROUP_NAME$1,
  [createCollectionScope$1]
);
var [RovingFocusProvider, useRovingFocusContext] = createRovingFocusGroupContext(GROUP_NAME$1);
var RovingFocusGroup = reactExports.forwardRef(
  (props, forwardedRef) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$1.Provider, { scope: props.__scopeRovingFocusGroup, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$1.Slot, { scope: props.__scopeRovingFocusGroup, children: /* @__PURE__ */ jsxRuntimeExports.jsx(RovingFocusGroupImpl, { ...props, ref: forwardedRef }) }) });
  }
);
RovingFocusGroup.displayName = GROUP_NAME$1;
var RovingFocusGroupImpl = reactExports.forwardRef((props, forwardedRef) => {
  const {
    __scopeRovingFocusGroup,
    orientation,
    loop = false,
    dir,
    currentTabStopId: currentTabStopIdProp,
    defaultCurrentTabStopId,
    onCurrentTabStopIdChange,
    onEntryFocus,
    preventScrollOnEntryFocus = false,
    ...groupProps
  } = props;
  const ref2 = reactExports.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref2);
  const direction = useDirection(dir);
  const [currentTabStopId, setCurrentTabStopId] = useControllableState({
    prop: currentTabStopIdProp,
    defaultProp: defaultCurrentTabStopId ?? null,
    onChange: onCurrentTabStopIdChange,
    caller: GROUP_NAME$1
  });
  const [isTabbingBackOut, setIsTabbingBackOut] = reactExports.useState(false);
  const handleEntryFocus = useCallbackRef$1(onEntryFocus);
  const getItems = useCollection$1(__scopeRovingFocusGroup);
  const isClickFocusRef = reactExports.useRef(false);
  const [focusableItemsCount, setFocusableItemsCount] = reactExports.useState(0);
  reactExports.useEffect(() => {
    const node = ref2.current;
    if (node) {
      node.addEventListener(ENTRY_FOCUS, handleEntryFocus);
      return () => node.removeEventListener(ENTRY_FOCUS, handleEntryFocus);
    }
  }, [handleEntryFocus]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    RovingFocusProvider,
    {
      scope: __scopeRovingFocusGroup,
      orientation,
      dir: direction,
      loop,
      currentTabStopId,
      onItemFocus: reactExports.useCallback(
        (tabStopId) => setCurrentTabStopId(tabStopId),
        [setCurrentTabStopId]
      ),
      onItemShiftTab: reactExports.useCallback(() => setIsTabbingBackOut(true), []),
      onFocusableItemAdd: reactExports.useCallback(
        () => setFocusableItemsCount((prevCount) => prevCount + 1),
        []
      ),
      onFocusableItemRemove: reactExports.useCallback(
        () => setFocusableItemsCount((prevCount) => prevCount - 1),
        []
      ),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive$1.div,
        {
          tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,
          "data-orientation": orientation,
          ...groupProps,
          ref: composedRefs,
          style: { outline: "none", ...props.style },
          onMouseDown: composeEventHandlers(props.onMouseDown, () => {
            isClickFocusRef.current = true;
          }),
          onFocus: composeEventHandlers(props.onFocus, (event) => {
            const isKeyboardFocus = !isClickFocusRef.current;
            if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {
              const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS$1);
              event.currentTarget.dispatchEvent(entryFocusEvent);
              if (!entryFocusEvent.defaultPrevented) {
                const items2 = getItems().filter((item) => item.focusable);
                const activeItem = items2.find((item) => item.active);
                const currentItem = items2.find((item) => item.id === currentTabStopId);
                const candidateItems = [activeItem, currentItem, ...items2].filter(
                  Boolean
                );
                const candidateNodes = candidateItems.map((item) => item.ref.current);
                focusFirst$1(candidateNodes, preventScrollOnEntryFocus);
              }
            }
            isClickFocusRef.current = false;
          }),
          onBlur: composeEventHandlers(props.onBlur, () => setIsTabbingBackOut(false))
        }
      )
    }
  );
});
var ITEM_NAME$1 = "RovingFocusGroupItem";
var RovingFocusGroupItem = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeRovingFocusGroup,
      focusable = true,
      active = false,
      tabStopId,
      children,
      ...itemProps
    } = props;
    const autoId = useId();
    const id2 = tabStopId || autoId;
    const context = useRovingFocusContext(ITEM_NAME$1, __scopeRovingFocusGroup);
    const isCurrentTabStop = context.currentTabStopId === id2;
    const getItems = useCollection$1(__scopeRovingFocusGroup);
    const { onFocusableItemAdd, onFocusableItemRemove, currentTabStopId } = context;
    reactExports.useEffect(() => {
      if (focusable) {
        onFocusableItemAdd();
        return () => onFocusableItemRemove();
      }
    }, [focusable, onFocusableItemAdd, onFocusableItemRemove]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Collection$1.ItemSlot,
      {
        scope: __scopeRovingFocusGroup,
        id: id2,
        focusable,
        active,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive$1.span,
          {
            tabIndex: isCurrentTabStop ? 0 : -1,
            "data-orientation": context.orientation,
            ...itemProps,
            ref: forwardedRef,
            onMouseDown: composeEventHandlers(props.onMouseDown, (event) => {
              if (!focusable) event.preventDefault();
              else context.onItemFocus(id2);
            }),
            onFocus: composeEventHandlers(props.onFocus, () => context.onItemFocus(id2)),
            onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
              if (event.key === "Tab" && event.shiftKey) {
                context.onItemShiftTab();
                return;
              }
              if (event.target !== event.currentTarget) return;
              const focusIntent = getFocusIntent(event, context.orientation, context.dir);
              if (focusIntent !== void 0) {
                if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey) return;
                event.preventDefault();
                const items2 = getItems().filter((item) => item.focusable);
                let candidateNodes = items2.map((item) => item.ref.current);
                if (focusIntent === "last") candidateNodes.reverse();
                else if (focusIntent === "prev" || focusIntent === "next") {
                  if (focusIntent === "prev") candidateNodes.reverse();
                  const currentIndex = candidateNodes.indexOf(event.currentTarget);
                  candidateNodes = context.loop ? wrapArray$1(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);
                }
                setTimeout(() => focusFirst$1(candidateNodes));
              }
            }),
            children: typeof children === "function" ? children({ isCurrentTabStop, hasTabStop: currentTabStopId != null }) : children
          }
        )
      }
    );
  }
);
RovingFocusGroupItem.displayName = ITEM_NAME$1;
var MAP_KEY_TO_FOCUS_INTENT = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function getDirectionAwareKey(key, dir) {
  if (dir !== "rtl") return key;
  return key === "ArrowLeft" ? "ArrowRight" : key === "ArrowRight" ? "ArrowLeft" : key;
}
function getFocusIntent(event, orientation, dir) {
  const key = getDirectionAwareKey(event.key, dir);
  if (orientation === "vertical" && ["ArrowLeft", "ArrowRight"].includes(key)) return void 0;
  if (orientation === "horizontal" && ["ArrowUp", "ArrowDown"].includes(key)) return void 0;
  return MAP_KEY_TO_FOCUS_INTENT[key];
}
function focusFirst$1(candidates, preventScroll = false) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
    candidate.focus({ preventScroll });
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
  }
}
function wrapArray$1(array2, startIndex) {
  return array2.map((_2, index2) => array2[(startIndex + index2) % array2.length]);
}
var Root$4 = RovingFocusGroup;
var Item$1 = RovingFocusGroupItem;
var TABS_NAME = "Tabs";
var [createTabsContext] = createContextScope(TABS_NAME, [
  createRovingFocusGroupScope
]);
var useRovingFocusGroupScope = createRovingFocusGroupScope();
var [TabsProvider, useTabsContext] = createTabsContext(TABS_NAME);
var Tabs$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeTabs,
      value: valueProp,
      onValueChange,
      defaultValue,
      orientation = "horizontal",
      dir,
      activationMode = "automatic",
      ...tabsProps
    } = props;
    const direction = useDirection(dir);
    const [value, setValue] = useControllableState({
      prop: valueProp,
      onChange: onValueChange,
      defaultProp: defaultValue ?? "",
      caller: TABS_NAME
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      TabsProvider,
      {
        scope: __scopeTabs,
        baseId: useId(),
        value,
        onValueChange: setValue,
        orientation,
        dir: direction,
        activationMode,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive$1.div,
          {
            dir: direction,
            "data-orientation": orientation,
            ...tabsProps,
            ref: forwardedRef
          }
        )
      }
    );
  }
);
Tabs$1.displayName = TABS_NAME;
var TAB_LIST_NAME = "TabsList";
var TabsList$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTabs, loop = true, ...listProps } = props;
    const context = useTabsContext(TAB_LIST_NAME, __scopeTabs);
    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeTabs);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Root$4,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        orientation: context.orientation,
        dir: context.dir,
        loop,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive$1.div,
          {
            role: "tablist",
            "aria-orientation": context.orientation,
            ...listProps,
            ref: forwardedRef
          }
        )
      }
    );
  }
);
TabsList$1.displayName = TAB_LIST_NAME;
var TRIGGER_NAME$5 = "TabsTrigger";
var TabsTrigger$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTabs, value, disabled = false, ...triggerProps } = props;
    const context = useTabsContext(TRIGGER_NAME$5, __scopeTabs);
    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeTabs);
    const triggerId = makeTriggerId(context.baseId, value);
    const contentId = makeContentId(context.baseId, value);
    const isSelected = value === context.value;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Item$1,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        focusable: !disabled,
        active: isSelected,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive$1.button,
          {
            type: "button",
            role: "tab",
            "aria-selected": isSelected,
            "aria-controls": contentId,
            "data-state": isSelected ? "active" : "inactive",
            "data-disabled": disabled ? "" : void 0,
            disabled,
            id: triggerId,
            ...triggerProps,
            ref: forwardedRef,
            onMouseDown: composeEventHandlers(props.onMouseDown, (event) => {
              if (!disabled && event.button === 0 && event.ctrlKey === false) {
                context.onValueChange(value);
              } else {
                event.preventDefault();
              }
            }),
            onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
              if ([" ", "Enter"].includes(event.key)) context.onValueChange(value);
            }),
            onFocus: composeEventHandlers(props.onFocus, () => {
              const isAutomaticActivation = context.activationMode !== "manual";
              if (!isSelected && !disabled && isAutomaticActivation) {
                context.onValueChange(value);
              }
            })
          }
        )
      }
    );
  }
);
TabsTrigger$1.displayName = TRIGGER_NAME$5;
var CONTENT_NAME$5 = "TabsContent";
var TabsContent$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTabs, value, forceMount, children, ...contentProps } = props;
    const context = useTabsContext(CONTENT_NAME$5, __scopeTabs);
    const triggerId = makeTriggerId(context.baseId, value);
    const contentId = makeContentId(context.baseId, value);
    const isSelected = value === context.value;
    const isMountAnimationPreventedRef = reactExports.useRef(isSelected);
    reactExports.useEffect(() => {
      const rAF = requestAnimationFrame(() => isMountAnimationPreventedRef.current = false);
      return () => cancelAnimationFrame(rAF);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || isSelected, children: ({ present }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive$1.div,
      {
        "data-state": isSelected ? "active" : "inactive",
        "data-orientation": context.orientation,
        role: "tabpanel",
        "aria-labelledby": triggerId,
        hidden: !present,
        id: contentId,
        tabIndex: 0,
        ...contentProps,
        ref: forwardedRef,
        style: {
          ...props.style,
          animationDuration: isMountAnimationPreventedRef.current ? "0s" : void 0
        },
        children: present && children
      }
    ) });
  }
);
TabsContent$1.displayName = CONTENT_NAME$5;
function makeTriggerId(baseId, value) {
  return `${baseId}-trigger-${value}`;
}
function makeContentId(baseId, value) {
  return `${baseId}-content-${value}`;
}
var Root2$3 = Tabs$1;
var List = TabsList$1;
var Trigger$3 = TabsTrigger$1;
var Content$2 = TabsContent$1;
const Tabs = Root2$3;
const TabsList = reactExports.forwardRef(({ className, ...props }, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  List,
  {
    ref: ref2,
    className: cn$2(
      "inline-flex h-9 items-center justify-center rounded-lg bg-muted p-1 text-muted-foreground",
      className
    ),
    ...props
  }
));
TabsList.displayName = List.displayName;
const TabsTrigger = reactExports.forwardRef(({ className, ...props }, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Trigger$3,
  {
    ref: ref2,
    className: cn$2(
      "inline-flex items-center justify-center whitespace-nowrap rounded-md px-3 py-1 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 bg-muted data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow",
      className
    ),
    ...props
  }
));
TabsTrigger.displayName = Trigger$3.displayName;
const TabsContent = reactExports.forwardRef(({ className, ...props }, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Content$2,
  {
    ref: ref2,
    className: cn$2(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    ),
    ...props
  }
));
TabsContent.displayName = Content$2.displayName;
var REACT_LAZY_TYPE = /* @__PURE__ */ Symbol.for("react.lazy");
var use = React$1[" use ".trim().toString()];
function isPromiseLike(value) {
  return typeof value === "object" && value !== null && "then" in value;
}
function isLazyComponent(element) {
  return element != null && typeof element === "object" && "$$typeof" in element && element.$$typeof === REACT_LAZY_TYPE && "_payload" in element && isPromiseLike(element._payload);
}
// @__NO_SIDE_EFFECTS__
function createSlot$3(ownerName) {
  const SlotClone = /* @__PURE__ */ createSlotClone$3(ownerName);
  const Slot2 = reactExports.forwardRef((props, forwardedRef) => {
    let { children, ...slotProps } = props;
    if (isLazyComponent(children) && typeof use === "function") {
      children = use(children._payload);
    }
    const childrenArray = reactExports.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable$3);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (reactExports.Children.count(newElement) > 1) return reactExports.Children.only(null);
          return reactExports.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children: reactExports.isValidElement(newElement) ? reactExports.cloneElement(newElement, void 0, newChildren) : null });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children });
  });
  Slot2.displayName = `${ownerName}.Slot`;
  return Slot2;
}
var Slot$3 = /* @__PURE__ */ createSlot$3("Slot");
// @__NO_SIDE_EFFECTS__
function createSlotClone$3(ownerName) {
  const SlotClone = reactExports.forwardRef((props, forwardedRef) => {
    let { children, ...slotProps } = props;
    if (isLazyComponent(children) && typeof use === "function") {
      children = use(children._payload);
    }
    if (reactExports.isValidElement(children)) {
      const childrenRef = getElementRef$3(children);
      const props2 = mergeProps$3(slotProps, children.props);
      if (children.type !== reactExports.Fragment) {
        props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
      }
      return reactExports.cloneElement(children, props2);
    }
    return reactExports.Children.count(children) > 1 ? reactExports.Children.only(null) : null;
  });
  SlotClone.displayName = `${ownerName}.SlotClone`;
  return SlotClone;
}
var SLOTTABLE_IDENTIFIER$4 = /* @__PURE__ */ Symbol("radix.slottable");
function isSlottable$3(child) {
  return reactExports.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER$4;
}
function mergeProps$3(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          const result = childPropValue(...args);
          slotPropValue(...args);
          return result;
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef$3(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground shadow hover:bg-primary/90 dark:bg-gray-800 dark:text-white dark:hover:bg-gray-700",
        destructive: "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline: "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
);
const Button = reactExports.forwardRef(
  ({ className, variant, size: size2, asChild = false, ...props }, ref2) => {
    const Comp = asChild ? Slot$3 : "button";
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Comp,
      {
        className: cn$2(buttonVariants({ variant, size: size2, className })),
        ref: ref2,
        ...props
      }
    );
  }
);
Button.displayName = "Button";
const toKebabCase = (string2) => string2.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
const toCamelCase = (string2) => string2.replace(
  /^([A-Z])|[\s-_]+(\w)/g,
  (match, p1, p2) => p2 ? p2.toUpperCase() : p1.toLowerCase()
);
const toPascalCase = (string2) => {
  const camelCase = toCamelCase(string2);
  return camelCase.charAt(0).toUpperCase() + camelCase.slice(1);
};
const mergeClasses = (...classes) => classes.filter((className, index2, array2) => {
  return Boolean(className) && className.trim() !== "" && array2.indexOf(className) === index2;
}).join(" ").trim();
const hasA11yProp = (props) => {
  for (const prop in props) {
    if (prop.startsWith("aria-") || prop === "role" || prop === "title") {
      return true;
    }
  }
};
var defaultAttributes = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
const Icon$1 = reactExports.forwardRef(
  ({
    color = "currentColor",
    size: size2 = 24,
    strokeWidth = 2,
    absoluteStrokeWidth,
    className = "",
    children,
    iconNode,
    ...rest
  }, ref2) => reactExports.createElement(
    "svg",
    {
      ref: ref2,
      ...defaultAttributes,
      width: size2,
      height: size2,
      stroke: color,
      strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size2) : strokeWidth,
      className: mergeClasses("lucide", className),
      ...!children && !hasA11yProp(rest) && { "aria-hidden": "true" },
      ...rest
    },
    [
      ...iconNode.map(([tag, attrs]) => reactExports.createElement(tag, attrs)),
      ...Array.isArray(children) ? children : [children]
    ]
  )
);
const createLucideIcon = (iconName, iconNode) => {
  const Component = reactExports.forwardRef(
    ({ className, ...props }, ref2) => reactExports.createElement(Icon$1, {
      ref: ref2,
      iconNode,
      className: mergeClasses(
        `lucide-${toKebabCase(toPascalCase(iconName))}`,
        `lucide-${iconName}`,
        className
      ),
      ...props
    })
  );
  Component.displayName = toPascalCase(iconName);
  return Component;
};
const __iconNode$J = [
  ["rect", { x: "2", y: "4", width: "20", height: "16", rx: "2", key: "izxlao" }],
  ["path", { d: "M10 4v4", key: "pp8u80" }],
  ["path", { d: "M2 8h20", key: "d11cs7" }],
  ["path", { d: "M6 4v4", key: "1svtjw" }]
];
const AppWindow = createLucideIcon("app-window", __iconNode$J);
const __iconNode$I = [
  ["path", { d: "M10.268 21a2 2 0 0 0 3.464 0", key: "vwvbt9" }],
  [
    "path",
    {
      d: "M3.262 15.326A1 1 0 0 0 4 17h16a1 1 0 0 0 .74-1.673C19.41 13.956 18 12.499 18 8A6 6 0 0 0 6 8c0 4.499-1.411 5.956-2.738 7.326",
      key: "11g9vi"
    }
  ]
];
const Bell = createLucideIcon("bell", __iconNode$I);
const __iconNode$H = [
  ["path", { d: "m8 2 1.88 1.88", key: "fmnt4t" }],
  ["path", { d: "M14.12 3.88 16 2", key: "qol33r" }],
  ["path", { d: "M9 7.13v-1a3.003 3.003 0 1 1 6 0v1", key: "d7y7pr" }],
  [
    "path",
    {
      d: "M12 20c-3.3 0-6-2.7-6-6v-3a4 4 0 0 1 4-4h4a4 4 0 0 1 4 4v3c0 3.3-2.7 6-6 6",
      key: "xs1cw7"
    }
  ],
  ["path", { d: "M12 20v-9", key: "1qisl0" }],
  ["path", { d: "M6.53 9C4.6 8.8 3 7.1 3 5", key: "32zzws" }],
  ["path", { d: "M6 13H2", key: "82j7cp" }],
  ["path", { d: "M3 21c0-2.1 1.7-3.9 3.8-4", key: "4p0ekp" }],
  ["path", { d: "M20.97 5c0 2.1-1.6 3.8-3.5 4", key: "18gb23" }],
  ["path", { d: "M22 13h-4", key: "1jl80f" }],
  ["path", { d: "M17.2 17c2.1.1 3.8 1.9 3.8 4", key: "k3fwyw" }]
];
const Bug = createLucideIcon("bug", __iconNode$H);
const __iconNode$G = [
  ["path", { d: "M18 6 7 17l-5-5", key: "116fxf" }],
  ["path", { d: "m22 10-7.5 7.5L13 16", key: "ke71qq" }]
];
const CheckCheck = createLucideIcon("check-check", __iconNode$G);
const __iconNode$F = [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]];
const Check = createLucideIcon("check", __iconNode$F);
const __iconNode$E = [["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]];
const ChevronDown = createLucideIcon("chevron-down", __iconNode$E);
const __iconNode$D = [["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]];
const ChevronRight = createLucideIcon("chevron-right", __iconNode$D);
const __iconNode$C = [["path", { d: "m18 15-6-6-6 6", key: "153udz" }]];
const ChevronUp = createLucideIcon("chevron-up", __iconNode$C);
const __iconNode$B = [
  ["path", { d: "m7 15 5 5 5-5", key: "1hf1tw" }],
  ["path", { d: "m7 9 5-5 5 5", key: "sgt6xg" }]
];
const ChevronsUpDown = createLucideIcon("chevrons-up-down", __iconNode$B);
const __iconNode$A = [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["line", { x1: "12", x2: "12", y1: "8", y2: "12", key: "1pkeuh" }],
  ["line", { x1: "12", x2: "12.01", y1: "16", y2: "16", key: "4dfq90" }]
];
const CircleAlert = createLucideIcon("circle-alert", __iconNode$A);
const __iconNode$z = [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "m9 12 2 2 4-4", key: "dzmm74" }]
];
const CircleCheck = createLucideIcon("circle-check", __iconNode$z);
const __iconNode$y = [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["polygon", { points: "10 8 16 12 10 16 10 8", key: "1cimsy" }]
];
const CirclePlay = createLucideIcon("circle-play", __iconNode$y);
const __iconNode$x = [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3", key: "1u773s" }],
  ["path", { d: "M12 17h.01", key: "p32p05" }]
];
const CircleQuestionMark = createLucideIcon("circle-question-mark", __iconNode$x);
const __iconNode$w = [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "m15 9-6 6", key: "1uzhvr" }],
  ["path", { d: "m9 9 6 6", key: "z0biqf" }]
];
const CircleX = createLucideIcon("circle-x", __iconNode$w);
const __iconNode$v = [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }]];
const Circle = createLucideIcon("circle", __iconNode$v);
const __iconNode$u = [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["polyline", { points: "12 6 12 12 16 14", key: "68esgv" }]
];
const Clock = createLucideIcon("clock", __iconNode$u);
const __iconNode$t = [
  ["rect", { width: "14", height: "14", x: "8", y: "8", rx: "2", ry: "2", key: "17jyea" }],
  ["path", { d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2", key: "zix9uf" }]
];
const Copy = createLucideIcon("copy", __iconNode$t);
const __iconNode$s = [
  ["path", { d: "M15 3h6v6", key: "1q9fwt" }],
  ["path", { d: "M10 14 21 3", key: "gplh6r" }],
  ["path", { d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6", key: "a6xqqp" }]
];
const ExternalLink = createLucideIcon("external-link", __iconNode$s);
const __iconNode$r = [
  [
    "path",
    {
      d: "M10.733 5.076a10.744 10.744 0 0 1 11.205 6.575 1 1 0 0 1 0 .696 10.747 10.747 0 0 1-1.444 2.49",
      key: "ct8e1f"
    }
  ],
  ["path", { d: "M14.084 14.158a3 3 0 0 1-4.242-4.242", key: "151rxh" }],
  [
    "path",
    {
      d: "M17.479 17.499a10.75 10.75 0 0 1-15.417-5.151 1 1 0 0 1 0-.696 10.75 10.75 0 0 1 4.446-5.143",
      key: "13bj9a"
    }
  ],
  ["path", { d: "m2 2 20 20", key: "1ooewy" }]
];
const EyeOff = createLucideIcon("eye-off", __iconNode$r);
const __iconNode$q = [
  [
    "path",
    {
      d: "M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0",
      key: "1nclc0"
    }
  ],
  ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]
];
const Eye = createLucideIcon("eye", __iconNode$q);
const __iconNode$p = [
  ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z", key: "1rqfz7" }],
  ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4", key: "tnqrlb" }],
  ["path", { d: "M10 9H8", key: "b1mrlr" }],
  ["path", { d: "M16 13H8", key: "t4e002" }],
  ["path", { d: "M16 17H8", key: "z1uh3a" }]
];
const FileText = createLucideIcon("file-text", __iconNode$p);
const __iconNode$o = [
  ["path", { d: "M20 7h-3a2 2 0 0 1-2-2V2", key: "x099mo" }],
  ["path", { d: "M9 18a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h7l4 4v10a2 2 0 0 1-2 2Z", key: "18t6ie" }],
  ["path", { d: "M3 7.6v12.8A1.6 1.6 0 0 0 4.6 22h9.8", key: "1nja0z" }]
];
const Files = createLucideIcon("files", __iconNode$o);
const __iconNode$n = [
  [
    "path",
    {
      d: "M20 10a1 1 0 0 0 1-1V6a1 1 0 0 0-1-1h-2.5a1 1 0 0 1-.8-.4l-.9-1.2A1 1 0 0 0 15 3h-2a1 1 0 0 0-1 1v5a1 1 0 0 0 1 1Z",
      key: "hod4my"
    }
  ],
  [
    "path",
    {
      d: "M20 21a1 1 0 0 0 1-1v-3a1 1 0 0 0-1-1h-2.9a1 1 0 0 1-.88-.55l-.42-.85a1 1 0 0 0-.92-.6H13a1 1 0 0 0-1 1v5a1 1 0 0 0 1 1Z",
      key: "w4yl2u"
    }
  ],
  ["path", { d: "M3 5a2 2 0 0 0 2 2h3", key: "f2jnh7" }],
  ["path", { d: "M3 3v13a2 2 0 0 0 2 2h3", key: "k8epm1" }]
];
const FolderTree = createLucideIcon("folder-tree", __iconNode$n);
const __iconNode$m = [
  [
    "path",
    {
      d: "M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4",
      key: "tonef"
    }
  ],
  ["path", { d: "M9 18c-4.51 2-5-2-7-2", key: "9comsn" }]
];
const Github = createLucideIcon("github", __iconNode$m);
const __iconNode$l = [
  ["path", { d: "m15 12-8.373 8.373a1 1 0 1 1-3-3L12 9", key: "eefl8a" }],
  ["path", { d: "m18 15 4-4", key: "16gjal" }],
  [
    "path",
    {
      d: "m21.5 11.5-1.914-1.914A2 2 0 0 1 19 8.172V7l-2.26-2.26a6 6 0 0 0-4.202-1.756L9 2.96l.92.82A6.18 6.18 0 0 1 12 8.4V10l2 2h1.172a2 2 0 0 1 1.414.586L18.5 14.5",
      key: "b7pghm"
    }
  ]
];
const Hammer = createLucideIcon("hammer", __iconNode$l);
const __iconNode$k = [
  ["line", { x1: "4", x2: "20", y1: "9", y2: "9", key: "4lhtct" }],
  ["line", { x1: "4", x2: "20", y1: "15", y2: "15", key: "vyu0kd" }],
  ["line", { x1: "10", x2: "8", y1: "3", y2: "21", key: "1ggp8o" }],
  ["line", { x1: "16", x2: "14", y1: "3", y2: "21", key: "weycgp" }]
];
const Hash = createLucideIcon("hash", __iconNode$k);
const __iconNode$j = [
  ["path", { d: "m15.5 7.5 2.3 2.3a1 1 0 0 0 1.4 0l2.1-2.1a1 1 0 0 0 0-1.4L19 4", key: "g0fldk" }],
  ["path", { d: "m21 2-9.6 9.6", key: "1j0ho8" }],
  ["circle", { cx: "7.5", cy: "15.5", r: "5.5", key: "yqb3hr" }]
];
const Key = createLucideIcon("key", __iconNode$j);
const __iconNode$i = [
  ["rect", { x: "3", y: "5", width: "6", height: "6", rx: "1", key: "1defrl" }],
  ["path", { d: "m3 17 2 2 4-4", key: "1jhpwq" }],
  ["path", { d: "M13 6h8", key: "15sg57" }],
  ["path", { d: "M13 12h8", key: "h98zly" }],
  ["path", { d: "M13 18h8", key: "oe0vm4" }]
];
const ListTodo = createLucideIcon("list-todo", __iconNode$i);
const __iconNode$h = [["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }]];
const LoaderCircle = createLucideIcon("loader-circle", __iconNode$h);
const __iconNode$g = [
  ["path", { d: "M15 3h6v6", key: "1q9fwt" }],
  ["path", { d: "m21 3-7 7", key: "1l2asr" }],
  ["path", { d: "m3 21 7-7", key: "tjx5ai" }],
  ["path", { d: "M9 21H3v-6", key: "wtvkvv" }]
];
const Maximize2 = createLucideIcon("maximize-2", __iconNode$g);
const __iconNode$f = [
  ["path", { d: "M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z", key: "1lielz" }]
];
const MessageSquare = createLucideIcon("message-square", __iconNode$f);
const __iconNode$e = [
  ["path", { d: "m14 10 7-7", key: "oa77jy" }],
  ["path", { d: "M20 10h-6V4", key: "mjg0md" }],
  ["path", { d: "m3 21 7-7", key: "tjx5ai" }],
  ["path", { d: "M4 14h6v6", key: "rmj7iw" }]
];
const Minimize2 = createLucideIcon("minimize-2", __iconNode$e);
const __iconNode$d = [["path", { d: "M5 12h14", key: "1ays0h" }]];
const Minus = createLucideIcon("minus", __iconNode$d);
const __iconNode$c = [["polygon", { points: "6 3 20 12 6 21 6 3", key: "1oa8hb" }]];
const Play = createLucideIcon("play", __iconNode$c);
const __iconNode$b = [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "M12 5v14", key: "s699le" }]
];
const Plus = createLucideIcon("plus", __iconNode$b);
const __iconNode$a = [
  ["path", { d: "M21 8L18.74 5.74A9.75 9.75 0 0 0 12 3C11 3 10.03 3.16 9.13 3.47", key: "1krf6h" }],
  ["path", { d: "M8 16H3v5", key: "1cv678" }],
  ["path", { d: "M3 12C3 9.51 4 7.26 5.64 5.64", key: "ruvoct" }],
  ["path", { d: "m3 16 2.26 2.26A9.75 9.75 0 0 0 12 21c2.49 0 4.74-1 6.36-2.64", key: "19q130" }],
  ["path", { d: "M21 12c0 1-.16 1.97-.47 2.87", key: "4w8emr" }],
  ["path", { d: "M21 3v5h-5", key: "1q7to0" }],
  ["path", { d: "M22 22 2 2", key: "1r8tn9" }]
];
const RefreshCwOff = createLucideIcon("refresh-cw-off", __iconNode$a);
const __iconNode$9 = [
  ["path", { d: "M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8", key: "v9h5vc" }],
  ["path", { d: "M21 3v5h-5", key: "1q7to0" }],
  ["path", { d: "M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16", key: "3uifl3" }],
  ["path", { d: "M8 16H3v5", key: "1cv678" }]
];
const RefreshCw = createLucideIcon("refresh-cw", __iconNode$9);
const __iconNode$8 = [
  ["path", { d: "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8", key: "1357e3" }],
  ["path", { d: "M3 3v5h5", key: "1xhq8a" }]
];
const RotateCcw = createLucideIcon("rotate-ccw", __iconNode$8);
const __iconNode$7 = [
  [
    "path",
    {
      d: "M15.2 3a2 2 0 0 1 1.4.6l3.8 3.8a2 2 0 0 1 .6 1.4V19a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2z",
      key: "1c8476"
    }
  ],
  ["path", { d: "M17 21v-7a1 1 0 0 0-1-1H8a1 1 0 0 0-1 1v7", key: "1ydtos" }],
  ["path", { d: "M7 3v4a1 1 0 0 0 1 1h7", key: "t51u73" }]
];
const Save = createLucideIcon("save", __iconNode$7);
const __iconNode$6 = [
  ["path", { d: "m21 21-4.34-4.34", key: "14j7rj" }],
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }]
];
const Search = createLucideIcon("search", __iconNode$6);
const __iconNode$5 = [
  [
    "path",
    {
      d: "M14.536 21.686a.5.5 0 0 0 .937-.024l6.5-19a.496.496 0 0 0-.635-.635l-19 6.5a.5.5 0 0 0-.024.937l7.93 3.18a2 2 0 0 1 1.112 1.11z",
      key: "1ffxy3"
    }
  ],
  ["path", { d: "m21.854 2.147-10.94 10.939", key: "12cjpa" }]
];
const Send = createLucideIcon("send", __iconNode$5);
const __iconNode$4 = [
  ["rect", { width: "20", height: "8", x: "2", y: "2", rx: "2", ry: "2", key: "ngkwjq" }],
  ["rect", { width: "20", height: "8", x: "2", y: "14", rx: "2", ry: "2", key: "iecqi9" }],
  ["line", { x1: "6", x2: "6.01", y1: "6", y2: "6", key: "16zg32" }],
  ["line", { x1: "6", x2: "6.01", y1: "18", y2: "18", key: "nzw8ys" }]
];
const Server = createLucideIcon("server", __iconNode$4);
const __iconNode$3 = [
  [
    "path",
    {
      d: "M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z",
      key: "1qme2f"
    }
  ],
  ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]
];
const Settings = createLucideIcon("settings", __iconNode$3);
const __iconNode$2 = [
  ["path", { d: "M3 6h18", key: "d0wm0j" }],
  ["path", { d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6", key: "4alrt4" }],
  ["path", { d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2", key: "v07s0e" }],
  ["line", { x1: "10", x2: "10", y1: "11", y2: "17", key: "1uufr5" }],
  ["line", { x1: "14", x2: "14", y1: "11", y2: "17", key: "xtxkd" }]
];
const Trash2 = createLucideIcon("trash-2", __iconNode$2);
const __iconNode$1 = [
  [
    "path",
    {
      d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3",
      key: "wmoenq"
    }
  ],
  ["path", { d: "M12 9v4", key: "juzpu7" }],
  ["path", { d: "M12 17h.01", key: "p32p05" }]
];
const TriangleAlert = createLucideIcon("triangle-alert", __iconNode$1);
const __iconNode = [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
];
const X$2 = createLucideIcon("x", __iconNode);
const OAuthStepDetails = ({
  label,
  isComplete,
  isCurrent,
  error,
  children
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: `flex items-center p-2 rounded-md ${isCurrent ? "bg-accent" : ""}`,
        children: [
          isComplete ? /* @__PURE__ */ jsxRuntimeExports.jsx(CircleCheck, { className: "h-5 w-5 text-green-500 mr-2" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Circle, { className: "h-5 w-5 text-muted-foreground mr-2" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `${isCurrent ? "font-medium" : ""}`, children: label })
        ]
      }
    ),
    (isCurrent || isComplete) && children && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ml-7 mt-1", children }),
    isCurrent && error && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ml-7 mt-2 p-3 border border-red-300 bg-red-50 rounded-md", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm font-medium text-red-700", children: "Error:" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-red-600 mt-1", children: error.message })
    ] })
  ] });
};
const steps = [
  "metadata_discovery",
  "client_registration",
  "authorization_redirect",
  "authorization_code",
  "token_request",
  "complete"
];
const OAuthFlowProgress = ({
  serverUrl,
  authState,
  updateAuthState,
  proceedToNextStep
}) => {
  const { toast: toast2 } = useToast();
  const provider = reactExports.useMemo(
    () => new DebugInspectorOAuthClientProvider(serverUrl),
    [serverUrl]
  );
  const [clientInfo, setClientInfo] = reactExports.useState(
    null
  );
  const authorizationServerMetadataDiscoveryUrl = reactExports.useMemo(() => {
    if (!authState.authServerUrl) {
      return null;
    }
    return getAuthorizationServerMetadataDiscoveryUrl(authState.authServerUrl);
  }, [authState.authServerUrl]);
  const currentStepIdx = steps.findIndex((s2) => s2 === authState.oauthStep);
  reactExports.useEffect(() => {
    const fetchClientInfo = async () => {
      if (authState.oauthClientInfo) {
        setClientInfo(authState.oauthClientInfo);
      } else {
        try {
          const info = await provider.clientInformation();
          if (info) {
            setClientInfo(info);
          }
        } catch (error) {
          console.error("Failed to fetch client information:", error);
        }
      }
    };
    if (currentStepIdx > steps.indexOf("client_registration")) {
      fetchClientInfo();
    }
  }, [
    provider,
    authState.oauthStep,
    authState.oauthClientInfo,
    currentStepIdx
  ]);
  const getStepProps = (stepName) => ({
    isComplete: currentStepIdx > steps.indexOf(stepName) || currentStepIdx === steps.length - 1,
    // last step is "complete"
    isCurrent: authState.oauthStep === stepName,
    error: authState.oauthStep === stepName ? authState.latestError : null
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rounded-md border p-6 space-y-4 mt-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-medium", children: "OAuth Flow Progress" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground", children: "Follow these steps to complete OAuth authentication with the server." }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-3", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        OAuthStepDetails,
        {
          label: "Metadata Discovery",
          ...getStepProps("metadata_discovery"),
          children: authState.oauthMetadata && /* @__PURE__ */ jsxRuntimeExports.jsxs("details", { className: "text-xs mt-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("summary", { className: "cursor-pointer text-muted-foreground font-medium", children: [
              "OAuth Metadata Sources",
              !authState.resourceMetadata && " "
            ] }),
            authState.resourceMetadata && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "font-medium", children: "Resource Metadata:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-xs text-muted-foreground", children: [
                "From",
                " ",
                new URL(
                  "/.well-known/oauth-protected-resource",
                  serverUrl
                ).href
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { className: "mt-2 p-2 bg-muted rounded-md overflow-auto max-h-[300px]", children: JSON.stringify(authState.resourceMetadata, null, 2) })
            ] }),
            authState.resourceMetadataError && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-2 p-3 border border-blue-300 bg-blue-50 rounded-md", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm font-medium text-blue-700", children: [
                " Problem with resource metadata from",
                " ",
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "a",
                  {
                    href: new URL(
                      "/.well-known/oauth-protected-resource",
                      serverUrl
                    ).href,
                    target: "_blank",
                    rel: "noopener noreferrer",
                    className: "text-blue-500 hover:text-blue-700",
                    children: new URL(
                      "/.well-known/oauth-protected-resource",
                      serverUrl
                    ).href
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-xs text-blue-600 mt-1", children: [
                "Resource metadata was added in the",
                " ",
                /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "https://modelcontextprotocol.io/specification/2025-06-18/basic/authorization#authorization-server-location", children: "2025-06-18 specification update" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                authState.resourceMetadataError.message,
                authState.resourceMetadataError instanceof TypeError && " (This could indicate the endpoint doesn't exist or does not have CORS configured)"
              ] })
            ] }),
            authState.oauthMetadata && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "font-medium", children: "Authorization Server Metadata:" }),
              authState.authServerUrl && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-xs text-muted-foreground", children: [
                "From ",
                authorizationServerMetadataDiscoveryUrl
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { className: "mt-2 p-2 bg-muted rounded-md overflow-auto max-h-[300px]", children: JSON.stringify(authState.oauthMetadata, null, 2) })
            ] })
          ] })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        OAuthStepDetails,
        {
          label: "Client Registration",
          ...getStepProps("client_registration"),
          children: clientInfo && /* @__PURE__ */ jsxRuntimeExports.jsxs("details", { className: "text-xs mt-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("summary", { className: "cursor-pointer text-muted-foreground font-medium", children: "Registered Client Information" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { className: "mt-2 p-2 bg-muted rounded-md overflow-auto max-h-[300px]", children: JSON.stringify(clientInfo, null, 2) })
          ] })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        OAuthStepDetails,
        {
          label: "Preparing Authorization",
          ...getStepProps("authorization_redirect"),
          children: authState.authorizationUrl && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-2 p-3 border rounded-md bg-muted", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "font-medium mb-2 text-sm", children: "Authorization URL:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs break-all", children: String(authState.authorizationUrl) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: () => {
                    try {
                      validateRedirectUrl(authState.authorizationUrl);
                      window.open(
                        authState.authorizationUrl,
                        "_blank",
                        "noopener noreferrer"
                      );
                    } catch (error) {
                      toast2({
                        title: "Invalid URL",
                        description: error instanceof Error ? error.message : "The authorization URL is not valid",
                        variant: "destructive"
                      });
                    }
                  },
                  className: "flex items-center text-blue-500 hover:text-blue-700",
                  "aria-label": "Open authorization URL in new tab",
                  title: "Open authorization URL",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(ExternalLink, { className: "h-4 w-4" })
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-muted-foreground mt-2", children: "Click the link to authorize in your browser. After authorization, you'll be redirected back to continue the flow." })
          ] })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        OAuthStepDetails,
        {
          label: "Request Authorization and acquire authorization code",
          ...getStepProps("authorization_code"),
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "label",
              {
                htmlFor: "authCode",
                className: "block text-sm font-medium mb-1",
                children: "Authorization Code"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex gap-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                id: "authCode",
                value: authState.authorizationCode,
                onChange: (e) => {
                  updateAuthState({
                    authorizationCode: e.target.value,
                    validationError: null
                  });
                },
                placeholder: "Enter the code from the authorization server",
                className: `flex h-9 w-full rounded-md border bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 ${authState.validationError ? "border-red-500" : "border-input"}`
              }
            ) }),
            authState.validationError && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-red-600 mt-1", children: authState.validationError }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-muted-foreground mt-1", children: "Once you've completed authorization in the link, paste the code here." })
          ] })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        OAuthStepDetails,
        {
          label: "Token Request",
          ...getStepProps("token_request"),
          children: authState.oauthMetadata && /* @__PURE__ */ jsxRuntimeExports.jsxs("details", { className: "text-xs mt-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("summary", { className: "cursor-pointer text-muted-foreground font-medium", children: "Token Request Details" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-2 p-2 bg-muted rounded-md", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "font-medium", children: "Token Endpoint:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("code", { className: "block mt-1 text-xs overflow-x-auto", children: authState.oauthMetadata.token_endpoint })
            ] })
          ] })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        OAuthStepDetails,
        {
          label: "Authentication Complete",
          ...getStepProps("complete"),
          children: authState.oauthTokens && /* @__PURE__ */ jsxRuntimeExports.jsxs("details", { className: "text-xs mt-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("summary", { className: "cursor-pointer text-muted-foreground font-medium", children: "Access Tokens" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-1 text-sm", children: "Authentication successful! You can now use the authenticated connection. These tokens will be used automatically for server requests." }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { className: "mt-2 p-2 bg-muted rounded-md overflow-auto max-h-[300px]", children: JSON.stringify(authState.oauthTokens, null, 2) })
          ] })
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-3 mt-4", children: [
      authState.oauthStep !== "complete" && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          onClick: proceedToNextStep,
          disabled: authState.isInitiatingAuth,
          children: authState.isInitiatingAuth ? "Processing..." : "Continue"
        }
      ) }),
      authState.oauthStep === "authorization_redirect" && authState.authorizationUrl && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          variant: "outline",
          onClick: () => {
            try {
              validateRedirectUrl(authState.authorizationUrl);
              window.open(authState.authorizationUrl, "_blank");
            } catch (error) {
              toast2({
                title: "Invalid URL",
                description: error instanceof Error ? error.message : "The authorization URL is not valid",
                variant: "destructive"
              });
            }
          },
          children: "Open in New Tab"
        }
      )
    ] })
  ] });
};
const StatusMessage = ({ message }) => {
  let bgColor;
  let textColor;
  let borderColor;
  switch (message.type) {
    case "error":
      bgColor = "bg-red-50";
      textColor = "text-red-700";
      borderColor = "border-red-200";
      break;
    case "success":
      bgColor = "bg-green-50";
      textColor = "text-green-700";
      borderColor = "border-green-200";
      break;
    case "info":
    default:
      bgColor = "bg-blue-50";
      textColor = "text-blue-700";
      borderColor = "border-blue-200";
      break;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: `p-3 rounded-md border ${bgColor} ${borderColor} ${textColor} mb-4`,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(CircleAlert, { className: "h-4 w-4" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm", children: message.message })
      ] })
    }
  );
};
const AuthDebugger = ({
  serverUrl,
  onBack,
  authState,
  updateAuthState
}) => {
  reactExports.useEffect(() => {
    if (serverUrl && !authState.oauthTokens) {
      const checkTokens = async () => {
        try {
          const provider = new DebugInspectorOAuthClientProvider(serverUrl);
          const existingTokens = await provider.tokens();
          if (existingTokens) {
            updateAuthState({
              oauthTokens: existingTokens,
              oauthStep: "complete"
            });
          }
        } catch (error) {
          console.error("Failed to load existing OAuth tokens:", error);
        }
      };
      checkTokens();
    }
  }, [serverUrl, updateAuthState, authState.oauthTokens]);
  const startOAuthFlow = reactExports.useCallback(() => {
    if (!serverUrl) {
      updateAuthState({
        statusMessage: {
          type: "error",
          message: "Please enter a server URL in the sidebar before authenticating"
        }
      });
      return;
    }
    updateAuthState({
      oauthStep: "metadata_discovery",
      authorizationUrl: null,
      statusMessage: null,
      latestError: null
    });
  }, [serverUrl, updateAuthState]);
  const stateMachine = reactExports.useMemo(
    () => new OAuthStateMachine(serverUrl, updateAuthState),
    [serverUrl, updateAuthState]
  );
  const proceedToNextStep = reactExports.useCallback(async () => {
    if (!serverUrl) return;
    try {
      updateAuthState({
        isInitiatingAuth: true,
        statusMessage: null,
        latestError: null
      });
      await stateMachine.executeStep(authState);
    } catch (error) {
      console.error("OAuth flow error:", error);
      updateAuthState({
        latestError: error instanceof Error ? error : new Error(String(error))
      });
    } finally {
      updateAuthState({ isInitiatingAuth: false });
    }
  }, [serverUrl, authState, updateAuthState, stateMachine]);
  const handleQuickOAuth = reactExports.useCallback(async () => {
    if (!serverUrl) {
      updateAuthState({
        statusMessage: {
          type: "error",
          message: "Please enter a server URL in the sidebar before authenticating"
        }
      });
      return;
    }
    updateAuthState({ isInitiatingAuth: true, statusMessage: null });
    try {
      let currentState = {
        ...authState,
        oauthStep: "metadata_discovery",
        authorizationUrl: null,
        latestError: null
      };
      const oauthMachine = new OAuthStateMachine(serverUrl, (updates) => {
        currentState = { ...currentState, ...updates };
      });
      while (currentState.oauthStep !== "complete") {
        await oauthMachine.executeStep(currentState);
        if (currentState.oauthStep === "authorization_code" && currentState.authorizationUrl) {
          try {
            validateRedirectUrl(currentState.authorizationUrl);
          } catch (error) {
            updateAuthState({
              ...currentState,
              isInitiatingAuth: false,
              latestError: error instanceof Error ? error : new Error(String(error)),
              statusMessage: {
                type: "error",
                message: `Invalid authorization URL: ${error instanceof Error ? error.message : String(error)}`
              }
            });
            return;
          }
          sessionStorage.setItem(
            SESSION_KEYS.AUTH_DEBUGGER_STATE,
            JSON.stringify(currentState)
          );
          window.location.href = currentState.authorizationUrl.toString();
          break;
        }
      }
      updateAuthState({
        ...currentState,
        statusMessage: {
          type: "info",
          message: currentState.oauthStep === "complete" ? "Authentication completed successfully" : "Please complete authentication in the opened window and enter the code"
        }
      });
    } catch (error) {
      console.error("OAuth initialization error:", error);
      updateAuthState({
        statusMessage: {
          type: "error",
          message: `Failed to start OAuth flow: ${error instanceof Error ? error.message : String(error)}`
        }
      });
    } finally {
      updateAuthState({ isInitiatingAuth: false });
    }
  }, [serverUrl, updateAuthState, authState]);
  const handleClearOAuth = reactExports.useCallback(() => {
    if (serverUrl) {
      const serverAuthProvider = new DebugInspectorOAuthClientProvider(
        serverUrl
      );
      serverAuthProvider.clear();
      updateAuthState({
        ...EMPTY_DEBUGGER_STATE,
        statusMessage: {
          type: "success",
          message: "OAuth tokens cleared successfully"
        }
      });
      setTimeout(() => {
        updateAuthState({ statusMessage: null });
      }, 3e3);
    }
  }, [serverUrl, updateAuthState]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full p-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center mb-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-bold", children: "Authentication Settings" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "outline", onClick: onBack, children: "Back to Connect" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full space-y-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col gap-6", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid w-full gap-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-muted-foreground mb-4", children: "Configure authentication settings for your MCP server connection." }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rounded-md border p-6 space-y-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-medium", children: "OAuth Authentication" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground mb-2", children: "Use OAuth to securely authenticate with the MCP server." }),
        authState.statusMessage && /* @__PURE__ */ jsxRuntimeExports.jsx(StatusMessage, { message: authState.statusMessage }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
          authState.oauthTokens && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm font-medium", children: "Access Token:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-muted p-2 rounded-md text-xs overflow-x-auto", children: [
              authState.oauthTokens.access_token.substring(0, 25),
              "..."
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                variant: "outline",
                onClick: startOAuthFlow,
                disabled: authState.isInitiatingAuth,
                children: authState.oauthTokens ? "Guided Token Refresh" : "Guided OAuth Flow"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                onClick: handleQuickOAuth,
                disabled: authState.isInitiatingAuth,
                children: authState.isInitiatingAuth ? "Initiating..." : authState.oauthTokens ? "Quick Refresh" : "Quick OAuth Flow"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "outline", onClick: handleClearOAuth, children: "Clear OAuth State" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-muted-foreground", children: 'Choose "Guided" for step-by-step instructions or "Quick" for the standard automatic flow.' })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        OAuthFlowProgress,
        {
          serverUrl,
          authState,
          updateAuthState,
          proceedToNextStep
        }
      )
    ] }) }) })
  ] });
};
const ConsoleTab = () => /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "console", className: "h-96", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-gray-900 text-gray-100 p-4 rounded-lg h-full font-mono text-sm overflow-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "opacity-50", children: "Welcome to MCP Client Console" }) }) });
function getDataType(value) {
  if (Array.isArray(value)) return "array";
  if (value === null) return "null";
  return typeof value;
}
function tryParseJson(str) {
  const trimmed = str?.trim();
  if (trimmed && !(trimmed.startsWith("{") && trimmed.endsWith("}")) && !(trimmed.startsWith("[") && trimmed.endsWith("]"))) {
    return { success: false, data: str };
  }
  try {
    return { success: true, data: JSON.parse(str) };
  } catch {
    return { success: false, data: str };
  }
}
function updateValueAtPath(obj, path, value) {
  if (path.length === 0) return value;
  if (obj === null || obj === void 0) {
    obj = !isNaN(Number(path[0])) ? [] : {};
  }
  if (Array.isArray(obj)) {
    return updateArray(obj, path, value);
  } else if (typeof obj === "object" && obj !== null) {
    return updateObject(obj, path, value);
  } else {
    console.error(
      `Cannot update path ${path.join(".")} in non-object/array value:`,
      obj
    );
    return obj;
  }
}
function updateArray(array2, path, value) {
  const [index2, ...restPath] = path;
  const arrayIndex = Number(index2);
  if (isNaN(arrayIndex)) {
    console.error(`Invalid array index: ${index2}`);
    return array2;
  }
  if (arrayIndex < 0) {
    console.error(`Array index out of bounds: ${arrayIndex} < 0`);
    return array2;
  }
  let newArray = [];
  for (let i = 0; i < array2.length; i++) {
    newArray[i] = i in array2 ? array2[i] : null;
  }
  if (arrayIndex >= newArray.length) {
    const extendedArray = new Array(arrayIndex).fill(null);
    for (let i = 0; i < newArray.length; i++) {
      extendedArray[i] = newArray[i];
    }
    newArray = extendedArray;
  }
  if (restPath.length === 0) {
    newArray[arrayIndex] = value;
  } else {
    newArray[arrayIndex] = updateValueAtPath(
      newArray[arrayIndex],
      restPath,
      value
    );
  }
  return newArray;
}
function updateObject(obj, path, value) {
  const [key, ...restPath] = path;
  if (typeof key !== "string") {
    console.error(`Invalid object key: ${key}`);
    return obj;
  }
  const newObj = { ...obj };
  if (restPath.length === 0) {
    newObj[key] = value;
  } else {
    if (!(key in newObj)) {
      newObj[key] = {};
    }
    newObj[key] = updateValueAtPath(newObj[key], restPath, value);
  }
  return newObj;
}
function useCopy({ timeout = 500 } = {}) {
  const [copied, setCopied] = reactExports.useState(false);
  reactExports.useEffect(() => {
    let timeoutId;
    if (copied) {
      timeoutId = setTimeout(() => {
        setCopied(false);
      }, timeout);
    }
    return () => {
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
    };
  }, [copied, timeout]);
  return { copied, setCopied };
}
const JsonView = reactExports.memo(
  ({
    data: data2,
    name: name2,
    initialExpandDepth = 3,
    className,
    withCopyButton = true,
    isError = false
  }) => {
    const { toast: toast2 } = useToast();
    const { copied, setCopied } = useCopy();
    const normalizedData = reactExports.useMemo(() => {
      return typeof data2 === "string" ? tryParseJson(data2).success ? tryParseJson(data2).data : data2 : data2;
    }, [data2]);
    const handleCopy = reactExports.useCallback(() => {
      try {
        navigator.clipboard.writeText(
          typeof normalizedData === "string" ? normalizedData : JSON.stringify(normalizedData, null, 2)
        );
        setCopied(true);
      } catch (error) {
        toast2({
          title: "Error",
          description: `There was an error coping result into the clipboard: ${error instanceof Error ? error.message : String(error)}`,
          variant: "destructive"
        });
      }
    }, [toast2, normalizedData, setCopied]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: clsx("p-4 border rounded relative", className), children: [
      withCopyButton && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          size: "icon",
          variant: "ghost",
          className: "absolute top-2 right-2",
          onClick: handleCopy,
          children: copied ? /* @__PURE__ */ jsxRuntimeExports.jsx(CheckCheck, { className: "size-4 dark:text-green-700 text-green-600" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Copy, { className: "size-4 text-foreground" })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "font-mono text-sm transition-all duration-300", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        JsonNode,
        {
          data: normalizedData,
          name: name2,
          depth: 0,
          initialExpandDepth,
          isError
        }
      ) })
    ] });
  }
);
JsonView.displayName = "JsonView";
const JsonNode = reactExports.memo(
  ({
    data: data2,
    name: name2,
    depth = 0,
    initialExpandDepth,
    isError = false
  }) => {
    const { toast: toast2 } = useToast();
    const [isExpanded, setIsExpanded] = reactExports.useState(depth < initialExpandDepth);
    const [typeStyleMap] = reactExports.useState({
      number: "text-blue-600",
      boolean: "text-amber-600",
      null: "text-purple-600",
      undefined: "text-gray-600",
      string: "text-green-600 group-hover:text-green-500",
      error: "text-red-600 group-hover:text-red-500",
      default: "text-gray-700"
    });
    const dataType2 = getDataType(data2);
    const [copied, setCopied] = reactExports.useState(false);
    reactExports.useEffect(() => {
      let timeoutId;
      if (copied) {
        timeoutId = setTimeout(() => setCopied(false), 500);
      }
      return () => {
        if (timeoutId) clearTimeout(timeoutId);
      };
    }, [copied]);
    const handleCopyValue = reactExports.useCallback(
      (value) => {
        try {
          let text;
          const valueType = getDataType(value);
          switch (valueType) {
            case "string":
              text = value;
              break;
            case "number":
            case "boolean":
              text = String(value);
              break;
            case "null":
              text = "null";
              break;
            case "undefined":
              text = "undefined";
              break;
            default:
              text = JSON.stringify(value);
          }
          navigator.clipboard.writeText(text);
          setCopied(true);
        } catch (error) {
          toast2({
            title: "Error",
            description: `There was an error coping result into the clipboard: ${error instanceof Error ? error.message : String(error)}`,
            variant: "destructive"
          });
        }
      },
      [toast2]
    );
    const renderCollapsible = (isArray) => {
      const items2 = isArray ? data2 : Object.entries(data2);
      const itemCount = items2.length;
      const isEmpty = itemCount === 0;
      const symbolMap = {
        open: isArray ? "[" : "{",
        close: isArray ? "]" : "}",
        collapsed: isArray ? "[ ... ]" : "{ ... }",
        empty: isArray ? "[]" : "{}"
      };
      if (isEmpty) {
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
          name2 && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "mr-1 text-gray-600 dark:text-gray-400", children: [
            name2,
            ":"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray-500", children: symbolMap.empty })
        ] });
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: "flex items-center mr-1 rounded cursor-pointer group hover:bg-gray-800/10 dark:hover:bg-gray-800/20",
            onClick: () => setIsExpanded(!isExpanded),
            children: [
              name2 && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "mr-1 text-gray-600 dark:text-gray-400 dark:group-hover:text-gray-100 group-hover:text-gray-400", children: [
                name2,
                ":"
              ] }),
              isExpanded ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray-600 dark:text-gray-400 dark:group-hover:text-gray-100 group-hover:text-gray-400", children: symbolMap.open }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray-600 dark:group-hover:text-gray-100 group-hover:text-gray-400", children: symbolMap.collapsed }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "ml-1 text-gray-700 dark:group-hover:text-gray-100 group-hover:text-gray-400", children: [
                  itemCount,
                  " ",
                  itemCount === 1 ? "item" : "items"
                ] })
              ] })
            ]
          }
        ),
        isExpanded && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "pl-2 ml-4 border-l border-gray-200 dark:border-gray-800", children: isArray ? items2.map((item, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "my-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            JsonNode,
            {
              data: item,
              name: `${index2}`,
              depth: depth + 1,
              initialExpandDepth
            }
          ) }, index2)) : items2.map(([key, value]) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "my-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            JsonNode,
            {
              data: value,
              name: key,
              depth: depth + 1,
              initialExpandDepth
            }
          ) }, key)) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-gray-600 dark:text-gray-400", children: symbolMap.close })
        ] })
      ] });
    };
    const renderString = (value) => {
      const maxLength = 100;
      const isTooLong = value.length > maxLength;
      if (!isTooLong) {
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex mr-1 rounded hover:bg-gray-800/20 group items-start", children: [
          name2 && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "mr-1 text-gray-600 dark:text-gray-400", children: [
            name2,
            ":"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "pre",
            {
              className: clsx(
                isError ? typeStyleMap.error : typeStyleMap.string,
                "break-all whitespace-pre-wrap"
              ),
              children: [
                '"',
                value,
                '"'
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              variant: "ghost",
              className: "ml-1 h-6 w-6 p-0 opacity-0 group-hover:opacity-100",
              onClick: (e) => {
                e.stopPropagation();
                handleCopyValue(value);
              },
              "aria-label": name2 ? `Copy value of ${name2}` : "Copy value",
              title: name2 ? `Copy value of ${name2}` : "Copy value",
              children: copied ? /* @__PURE__ */ jsxRuntimeExports.jsx(CheckCheck, { className: "size-4 dark:text-green-700 text-green-600" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Copy, { className: "size-4 text-foreground" })
            }
          )
        ] });
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex mr-1 rounded group hover:bg-gray-800/20 items-start", children: [
        name2 && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "mr-1 text-gray-600 dark:text-gray-400 dark:group-hover:text-gray-100 group-hover:text-gray-400", children: [
          name2,
          ":"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "pre",
          {
            className: clsx(
              isError ? typeStyleMap.error : typeStyleMap.string,
              "cursor-pointer break-all whitespace-pre-wrap"
            ),
            onClick: () => setIsExpanded(!isExpanded),
            title: isExpanded ? "Click to collapse" : "Click to expand",
            children: isExpanded ? `"${value}"` : `"${value.slice(0, maxLength)}..."`
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            variant: "ghost",
            className: "ml-1 h-6 w-6 p-0 opacity-0 group-hover:opacity-100",
            onClick: (e) => {
              e.stopPropagation();
              handleCopyValue(value);
            },
            "aria-label": name2 ? `Copy value of ${name2}` : "Copy value",
            title: name2 ? `Copy value of ${name2}` : "Copy value",
            children: copied ? /* @__PURE__ */ jsxRuntimeExports.jsx(CheckCheck, { className: "size-4 dark:text-green-700 text-green-600" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Copy, { className: "size-4 text-foreground" })
          }
        )
      ] });
    };
    switch (dataType2) {
      case "object":
      case "array":
        return renderCollapsible(dataType2 === "array");
      case "string":
        return renderString(data2);
      default:
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center mr-1 rounded hover:bg-gray-800/20 group", children: [
          name2 && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "mr-1 text-gray-600 dark:text-gray-400", children: [
            name2,
            ":"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: typeStyleMap[dataType2] || typeStyleMap.default, children: data2 === null ? "null" : String(data2) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              variant: "ghost",
              className: "ml-1 h-6 w-6 p-0 opacity-0 group-hover:opacity-100",
              onClick: (e) => {
                e.stopPropagation();
                handleCopyValue(data2);
              },
              "aria-label": name2 ? `Copy value of ${name2}` : "Copy value",
              title: name2 ? `Copy value of ${name2}` : "Copy value",
              children: copied ? /* @__PURE__ */ jsxRuntimeExports.jsx(CheckCheck, { className: "size-4 dark:text-green-700 text-green-600" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Copy, { className: "size-4 text-foreground" })
            }
          )
        ] });
    }
  }
);
JsonNode.displayName = "JsonNode";
const HistoryAndNotifications = ({
  requestHistory,
  serverNotifications,
  onClearHistory,
  onClearNotifications
}) => {
  const [expandedRequests, setExpandedRequests] = reactExports.useState({});
  const [expandedNotifications, setExpandedNotifications] = reactExports.useState({});
  const toggleRequestExpansion = (index2) => {
    setExpandedRequests((prev) => ({ ...prev, [index2]: !prev[index2] }));
  };
  const toggleNotificationExpansion = (index2) => {
    setExpandedNotifications((prev) => ({ ...prev, [index2]: !prev[index2] }));
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-card overflow-hidden flex h-full", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1 overflow-y-auto p-4 border-r", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-lg font-semibold", children: "History" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            variant: "outline",
            size: "sm",
            onClick: onClearHistory,
            disabled: requestHistory.length === 0,
            children: "Clear"
          }
        )
      ] }),
      requestHistory.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-500 dark:text-gray-400 italic", children: "No history yet" }) : /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: "space-y-3", children: requestHistory.slice().reverse().map((request, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "li",
        {
          className: "text-sm text-foreground bg-secondary py-2 px-3 rounded",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                className: "flex justify-between items-center cursor-pointer",
                onClick: () => toggleRequestExpansion(requestHistory.length - 1 - index2),
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-mono", children: [
                    requestHistory.length - index2,
                    ".",
                    " ",
                    JSON.parse(request.request).method
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: expandedRequests[requestHistory.length - 1 - index2] ? "" : "" })
                ]
              }
            ),
            expandedRequests[requestHistory.length - 1 - index2] && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-between items-center mb-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-semibold text-blue-600", children: "Request:" }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  JsonView,
                  {
                    data: request.request,
                    className: "bg-background"
                  }
                )
              ] }),
              request.response && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-between items-center mb-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-semibold text-green-600", children: "Response:" }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  JsonView,
                  {
                    data: request.response,
                    className: "bg-background"
                  }
                )
              ] })
            ] })
          ]
        },
        index2
      )) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1 overflow-y-auto p-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-lg font-semibold", children: "Server Notifications" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            variant: "outline",
            size: "sm",
            onClick: onClearNotifications,
            disabled: serverNotifications.length === 0,
            children: "Clear"
          }
        )
      ] }),
      serverNotifications.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-500 dark:text-gray-400 italic", children: "No notifications yet" }) : /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: "space-y-3", children: serverNotifications.slice().reverse().map((notification, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "li",
        {
          className: "text-sm text-foreground bg-secondary py-2 px-3 rounded",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                className: "flex justify-between items-center cursor-pointer",
                onClick: () => toggleNotificationExpansion(
                  serverNotifications.length - 1 - index2
                ),
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-mono", children: [
                    serverNotifications.length - index2,
                    ".",
                    " ",
                    notification.method
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: expandedNotifications[serverNotifications.length - 1 - index2] ? "" : "" })
                ]
              }
            ),
            expandedNotifications[serverNotifications.length - 1 - index2] && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-between items-center mb-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-semibold text-purple-600", children: "Details:" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                JsonView,
                {
                  data: JSON.stringify(notification, null, 2),
                  className: "bg-background"
                }
              )
            ] })
          ]
        },
        index2
      )) })
    ] })
  ] });
};
const PingTab = ({ onPingClick }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "ping", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-2 gap-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-2 flex justify-center items-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Button,
    {
      onClick: onPingClick,
      className: "font-bold py-6 px-12 rounded-full",
      children: "Ping Server"
    }
  ) }) }) });
};
const alertVariants = cva(
  "relative w-full rounded-lg border px-4 py-3 text-sm [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground [&>svg~*]:pl-7",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive: "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
);
const Alert = reactExports.forwardRef(({ className, variant, ...props }, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "div",
  {
    ref: ref2,
    role: "alert",
    className: cn$2(alertVariants({ variant }), className),
    ...props
  }
));
Alert.displayName = "Alert";
const AlertTitle = reactExports.forwardRef(({ className, ...props }, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "h5",
  {
    ref: ref2,
    className: cn$2("mb-1 font-medium leading-none tracking-tight", className),
    ...props
  }
));
AlertTitle.displayName = "AlertTitle";
const AlertDescription = reactExports.forwardRef(({ className, ...props }, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "div",
  {
    ref: ref2,
    className: cn$2("text-sm [&_p]:leading-relaxed", className),
    ...props
  }
));
AlertDescription.displayName = "AlertDescription";
var U = 1, Y$1 = 0.9, H$1 = 0.8, J = 0.17, p$1 = 0.1, u = 0.999, $ = 0.9999;
var k$2 = 0.99, m$1 = /[\\\/_+.#"@\[\(\{&]/, B$2 = /[\\\/_+.#"@\[\(\{&]/g, K$1 = /[\s-]/, X$1 = /[\s-]/g;
function G(_2, C, h2, P2, A2, f2, O) {
  if (f2 === C.length) return A2 === _2.length ? U : k$2;
  var T2 = `${A2},${f2}`;
  if (O[T2] !== void 0) return O[T2];
  for (var L2 = P2.charAt(f2), c = h2.indexOf(L2, A2), S2 = 0, E2, N2, R2, M2; c >= 0; ) E2 = G(_2, C, h2, P2, c + 1, f2 + 1, O), E2 > S2 && (c === A2 ? E2 *= U : m$1.test(_2.charAt(c - 1)) ? (E2 *= H$1, R2 = _2.slice(A2, c - 1).match(B$2), R2 && A2 > 0 && (E2 *= Math.pow(u, R2.length))) : K$1.test(_2.charAt(c - 1)) ? (E2 *= Y$1, M2 = _2.slice(A2, c - 1).match(X$1), M2 && A2 > 0 && (E2 *= Math.pow(u, M2.length))) : (E2 *= J, A2 > 0 && (E2 *= Math.pow(u, c - A2))), _2.charAt(c) !== C.charAt(f2) && (E2 *= $)), (E2 < p$1 && h2.charAt(c - 1) === P2.charAt(f2 + 1) || P2.charAt(f2 + 1) === P2.charAt(f2) && h2.charAt(c - 1) !== P2.charAt(f2)) && (N2 = G(_2, C, h2, P2, c + 1, f2 + 2, O), N2 * p$1 > E2 && (E2 = N2 * p$1)), E2 > S2 && (S2 = E2), c = h2.indexOf(L2, c + 1);
  return O[T2] = S2, S2;
}
function D$1(_2) {
  return _2.toLowerCase().replace(X$1, " ");
}
function W(_2, C, h2) {
  return _2 = h2 && h2.length > 0 ? `${_2 + " " + h2.join(" ")}` : _2, G(_2, C, D$1(_2), D$1(C), 0, 0, {});
}
var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
var AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
var EVENT_OPTIONS = { bubbles: false, cancelable: true };
var FOCUS_SCOPE_NAME = "FocusScope";
var FocusScope = reactExports.forwardRef((props, forwardedRef) => {
  const {
    loop = false,
    trapped = false,
    onMountAutoFocus: onMountAutoFocusProp,
    onUnmountAutoFocus: onUnmountAutoFocusProp,
    ...scopeProps
  } = props;
  const [container, setContainer] = reactExports.useState(null);
  const onMountAutoFocus = useCallbackRef$1(onMountAutoFocusProp);
  const onUnmountAutoFocus = useCallbackRef$1(onUnmountAutoFocusProp);
  const lastFocusedElementRef = reactExports.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));
  const focusScope = reactExports.useRef({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  reactExports.useEffect(() => {
    if (trapped) {
      let handleFocusIn2 = function(event) {
        if (focusScope.paused || !container) return;
        const target = event.target;
        if (container.contains(target)) {
          lastFocusedElementRef.current = target;
        } else {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleFocusOut2 = function(event) {
        if (focusScope.paused || !container) return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null) return;
        if (!container.contains(relatedTarget)) {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleMutations2 = function(mutations) {
        const focusedElement = document.activeElement;
        if (focusedElement !== document.body) return;
        for (const mutation of mutations) {
          if (mutation.removedNodes.length > 0) focus(container);
        }
      };
      document.addEventListener("focusin", handleFocusIn2);
      document.addEventListener("focusout", handleFocusOut2);
      const mutationObserver = new MutationObserver(handleMutations2);
      if (container) mutationObserver.observe(container, { childList: true, subtree: true });
      return () => {
        document.removeEventListener("focusin", handleFocusIn2);
        document.removeEventListener("focusout", handleFocusOut2);
        mutationObserver.disconnect();
      };
    }
  }, [trapped, container, focusScope.paused]);
  reactExports.useEffect(() => {
    if (container) {
      focusScopesStack.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);
        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        container.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });
          if (document.activeElement === previouslyFocusedElement) {
            focus(container);
          }
        }
      }
      return () => {
        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);
          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          container.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented) {
            focus(previouslyFocusedElement ?? document.body, { select: true });
          }
          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          focusScopesStack.remove(focusScope);
        }, 0);
      };
    }
  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
  const handleKeyDown = reactExports.useCallback(
    (event) => {
      if (!loop && !trapped) return;
      if (focusScope.paused) return;
      const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
      const focusedElement = document.activeElement;
      if (isTabKey && focusedElement) {
        const container2 = event.currentTarget;
        const [first, last] = getTabbableEdges(container2);
        const hasTabbableElementsInside = first && last;
        if (!hasTabbableElementsInside) {
          if (focusedElement === container2) event.preventDefault();
        } else {
          if (!event.shiftKey && focusedElement === last) {
            event.preventDefault();
            if (loop) focus(first, { select: true });
          } else if (event.shiftKey && focusedElement === first) {
            event.preventDefault();
            if (loop) focus(last, { select: true });
          }
        }
      }
    },
    [loop, trapped, focusScope.paused]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive$1.div, { tabIndex: -1, ...scopeProps, ref: composedRefs, onKeyDown: handleKeyDown });
});
FocusScope.displayName = FOCUS_SCOPE_NAME;
function focusFirst(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    focus(candidate, { select });
    if (document.activeElement !== previouslyFocusedElement) return;
  }
}
function getTabbableEdges(container) {
  const candidates = getTabbableCandidates(container);
  const first = findVisible(candidates, container);
  const last = findVisible(candidates.reverse(), container);
  return [first, last];
}
function getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function findVisible(elements, container) {
  for (const element of elements) {
    if (!isHidden(element, { upTo: container })) return element;
  }
}
function isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden") return true;
  while (node) {
    if (upTo !== void 0 && node === upTo) return false;
    if (getComputedStyle(node).display === "none") return true;
    node = node.parentElement;
  }
  return false;
}
function isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function focus(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = document.activeElement;
    element.focus({ preventScroll: true });
    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)
      element.select();
  }
}
var focusScopesStack = createFocusScopesStack();
function createFocusScopesStack() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope) {
        activeFocusScope?.pause();
      }
      stack = arrayRemove(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      stack = arrayRemove(stack, focusScope);
      stack[0]?.resume();
    }
  };
}
function arrayRemove(array2, item) {
  const updatedArray = [...array2];
  const index2 = updatedArray.indexOf(item);
  if (index2 !== -1) {
    updatedArray.splice(index2, 1);
  }
  return updatedArray;
}
function removeLinks(items2) {
  return items2.filter((item) => item.tagName !== "A");
}
var count = 0;
function useFocusGuards() {
  reactExports.useEffect(() => {
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", edgeGuards[0] ?? createFocusGuard());
    document.body.insertAdjacentElement("beforeend", edgeGuards[1] ?? createFocusGuard());
    count++;
    return () => {
      if (count === 1) {
        document.querySelectorAll("[data-radix-focus-guard]").forEach((node) => node.remove());
      }
      count--;
    };
  }, []);
}
function createFocusGuard() {
  const element = document.createElement("span");
  element.setAttribute("data-radix-focus-guard", "");
  element.tabIndex = 0;
  element.style.outline = "none";
  element.style.opacity = "0";
  element.style.position = "fixed";
  element.style.pointerEvents = "none";
  return element;
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t[p2] = s2[p2];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
}
function __spreadArray(to2, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar2; i < l; i++) {
    if (ar2 || !(i in from)) {
      if (!ar2) ar2 = Array.prototype.slice.call(from, 0, i);
      ar2[i] = from[i];
    }
  }
  return to2.concat(ar2 || Array.prototype.slice.call(from));
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";
function assignRef(ref2, value) {
  if (typeof ref2 === "function") {
    ref2(value);
  } else if (ref2) {
    ref2.current = value;
  }
  return ref2;
}
function useCallbackRef(initialValue, callback) {
  var ref2 = reactExports.useState(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref2.value;
        },
        set current(value) {
          var last = ref2.value;
          if (last !== value) {
            ref2.value = value;
            ref2.callback(value, last);
          }
        }
      }
    };
  })[0];
  ref2.callback = callback;
  return ref2.facade;
}
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
var currentValues = /* @__PURE__ */ new WeakMap();
function useMergeRefs(refs, defaultValue) {
  var callbackRef = useCallbackRef(null, function(newValue) {
    return refs.forEach(function(ref2) {
      return assignRef(ref2, newValue);
    });
  });
  useIsomorphicLayoutEffect(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue);
      var nextRefs_1 = new Set(refs);
      var current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref2) {
        if (!nextRefs_1.has(ref2)) {
          assignRef(ref2, null);
        }
      });
      nextRefs_1.forEach(function(ref2) {
        if (!prevRefs_1.has(ref2)) {
          assignRef(ref2, current_1);
        }
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]);
  return callbackRef;
}
function ItoI(a2) {
  return a2;
}
function innerCreateMedium(defaults2, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults2;
    },
    useMedium: function(data2) {
      var item = middleware(data2, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x2) {
          return x2 !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
      }
      buffer = {
        push: function(x2) {
          return cb(x2);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x2) {
          pendingQueue.push(x2);
          cycle();
        },
        filter: function(filter) {
          pendingQueue = pendingQueue.filter(filter);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign({ async: true, ssr: false }, options);
  return medium;
}
var SideCar$1 = function(_a2) {
  var sideCar = _a2.sideCar, rest = __rest(_a2, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return reactExports.createElement(Target, __assign({}, rest));
};
SideCar$1.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar$1;
}
var effectCar = createSidecarMedium();
var nothing = function() {
  return;
};
var RemoveScroll = reactExports.forwardRef(function(props, parentRef) {
  var ref2 = reactExports.useRef(null);
  var _a2 = reactExports.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a2[0], setCallbacks = _a2[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noRelative = props.noRelative, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? "div" : _b, gapMode = props.gapMode, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref2, parentRef]);
  var containerProps = __assign(__assign({}, rest), callbacks);
  return reactExports.createElement(
    reactExports.Fragment,
    null,
    enabled && reactExports.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noRelative, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref2, gapMode }),
    forwardProps ? reactExports.cloneElement(reactExports.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : reactExports.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};
var getNonce = function() {
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style);
          insertStyleTag(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic) {
    reactExports.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
};
var styleSingleton = function() {
  var useStyle = styleHookSingleton();
  var Sheet = function(_a2) {
    var styles = _a2.styles, dynamic = _a2.dynamic;
    useStyle(styles, dynamic);
    return null;
  };
  return Sheet;
};
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse = function(x2) {
  return parseInt(x2 || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs2 = window.getComputedStyle(document.body);
  var left = cs2[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top = cs2[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs2[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse(left), parse(top), parse(right)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};
var Style = styleSingleton();
var lockAttribute = "data-scroll-locked";
var getStyles = function(_a2, allowRelative, gapMode, important) {
  var left = _a2.left, top = _a2.top, right = _a2.right, gap = _a2.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute, "] {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
var getCurrentUseCounter = function() {
  var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
  return isFinite(counter) ? counter : 0;
};
var useLockAttribute = function() {
  reactExports.useEffect(function() {
    document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
    return function() {
      var newCounter = getCurrentUseCounter() - 1;
      if (newCounter <= 0) {
        document.body.removeAttribute(lockAttribute);
      } else {
        document.body.setAttribute(lockAttribute, newCounter.toString());
      }
    };
  }, []);
};
var RemoveScrollBar = function(_a2) {
  var noRelative = _a2.noRelative, noImportant = _a2.noImportant, _b = _a2.gapMode, gapMode = _b === void 0 ? "margin" : _b;
  useLockAttribute();
  var gap = reactExports.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return reactExports.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    var options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported = false;
  }
}
var nonPassive = passiveSupported ? { passive: false } : false;
var alwaysContainsScroll = function(node) {
  return node.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node, overflow) {
  if (!(node instanceof Element)) {
    return false;
  }
  var styles = window.getComputedStyle(node);
  return (
    // not-not-scrollable
    styles[overflow] !== "hidden" && // contains scroll inside self
    !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible")
  );
};
var elementCouldBeVScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowY");
};
var elementCouldBeHScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowX");
};
var locationCouldBeScrolled = function(axis, node) {
  var ownerDocument = node.ownerDocument;
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      var _a2 = getScrollVariables(axis, current), scrollHeight = _a2[1], clientHeight = _a2[2];
      if (scrollHeight > clientHeight) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== ownerDocument.body);
  return false;
};
var getVScrollVariables = function(_a2) {
  var scrollTop = _a2.scrollTop, scrollHeight = _a2.scrollHeight, clientHeight = _a2.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a2) {
  var scrollLeft = _a2.scrollLeft, scrollWidth = _a2.scrollWidth, clientWidth = _a2.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function(axis, node) {
  return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    if (!target) {
      break;
    }
    var _a2 = getScrollVariables(axis, target), position = _a2[0], scroll_1 = _a2[1], capacity = _a2[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    var parent_1 = target.parentNode;
    target = parent_1 && parent_1.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? parent_1.host : parent_1;
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (Math.abs(availableScroll) < 1 || false)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (Math.abs(availableScrollTop) < 1 || false)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref2) {
  return ref2 && "current" in ref2 ? ref2.current : ref2;
};
var deltaCompare = function(x2, y2) {
  return x2[0] === y2[0] && x2[1] === y2[1];
};
var generateStyle = function(id2) {
  return "\n  .block-interactivity-".concat(id2, " {pointer-events: none;}\n  .allow-interactivity-").concat(id2, " {pointer-events: all;}\n");
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = reactExports.useRef([]);
  var touchStartRef = reactExports.useRef([0, 0]);
  var activeAxis = reactExports.useRef();
  var id2 = reactExports.useState(idCounter++)[0];
  var Style2 = reactExports.useState(styleSingleton)[0];
  var lastProps = reactExports.useRef(props);
  reactExports.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  reactExports.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id2));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el2) {
        return el2.classList.add("allow-interactivity-".concat(id2));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id2));
        allow_1.forEach(function(el2) {
          return el2.classList.remove("allow-interactivity-".concat(id2));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = reactExports.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2 || event.type === "wheel" && event.ctrlKey) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var selection = window.getSelection();
    var anchorNode = selection && selection.anchorNode;
    var isTouchingSelection = anchorNode ? anchorNode === target || anchorNode.contains(target) : false;
    if (isTouchingSelection) {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY);
  }, []);
  var shouldPrevent = reactExports.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e) {
      return e.name === event.type && (e.target === event.target || event.target === e.shadowParent) && deltaCompare(e.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = reactExports.useCallback(function(name2, delta, target, should) {
    var event = { name: name2, delta, target, should, shadowParent: getOutermostShadowParent(target) };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e) {
        return e !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = reactExports.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = reactExports.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = reactExports.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  reactExports.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return reactExports.createElement(
    reactExports.Fragment,
    null,
    inert ? reactExports.createElement(Style2, { styles: generateStyle(id2) }) : null,
    removeScrollBar ? reactExports.createElement(RemoveScrollBar, { noRelative: props.noRelative, gapMode: props.gapMode }) : null
  );
}
function getOutermostShadowParent(node) {
  var shadowParent = null;
  while (node !== null) {
    if (node instanceof ShadowRoot) {
      shadowParent = node.host;
      node = node.host;
    }
    node = node.parentNode;
  }
  return shadowParent;
}
const SideCar = exportSidecar(effectCar, RemoveScrollSideCar);
var ReactRemoveScroll = reactExports.forwardRef(function(props, ref2) {
  return reactExports.createElement(RemoveScroll, __assign({}, props, { ref: ref2, sideCar: SideCar }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node) {
  return node && (node.host || unwrapHost(node.parentNode));
};
var correctTargets = function(parent, targets) {
  return targets.map(function(target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x2) {
    return Boolean(x2);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el2) {
    if (!el2 || elementsToKeep.has(el2)) {
      return;
    }
    elementsToKeep.add(el2);
    keep(el2.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        try {
          var attr = node.getAttribute(controlAttribute);
          var alreadyHidden = attr !== null && attr !== "false";
          var counterValue = (counterMap.get(node) || 0) + 1;
          var markerValue = (markerCounter.get(node) || 0) + 1;
          counterMap.set(node, counterValue);
          markerCounter.set(node, markerValue);
          hiddenNodes.push(node);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node, true);
          }
          if (markerValue === 1) {
            node.setAttribute(markerName, "true");
          }
          if (!alreadyHidden) {
            node.setAttribute(controlAttribute, "true");
          }
        } catch (e) {
          console.error("aria-hidden: cannot operate on ", node, e);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node) {
      var counterValue = counterMap.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live], script")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};
// @__NO_SIDE_EFFECTS__
function createSlot$2(ownerName) {
  const SlotClone = /* @__PURE__ */ createSlotClone$2(ownerName);
  const Slot2 = reactExports.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    const childrenArray = reactExports.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable$2);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (reactExports.Children.count(newElement) > 1) return reactExports.Children.only(null);
          return reactExports.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children: reactExports.isValidElement(newElement) ? reactExports.cloneElement(newElement, void 0, newChildren) : null });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children });
  });
  Slot2.displayName = `${ownerName}.Slot`;
  return Slot2;
}
// @__NO_SIDE_EFFECTS__
function createSlotClone$2(ownerName) {
  const SlotClone = reactExports.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    if (reactExports.isValidElement(children)) {
      const childrenRef = getElementRef$2(children);
      const props2 = mergeProps$2(slotProps, children.props);
      if (children.type !== reactExports.Fragment) {
        props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
      }
      return reactExports.cloneElement(children, props2);
    }
    return reactExports.Children.count(children) > 1 ? reactExports.Children.only(null) : null;
  });
  SlotClone.displayName = `${ownerName}.SlotClone`;
  return SlotClone;
}
var SLOTTABLE_IDENTIFIER$3 = /* @__PURE__ */ Symbol("radix.slottable");
function isSlottable$2(child) {
  return reactExports.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER$3;
}
function mergeProps$2(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          const result = childPropValue(...args);
          slotPropValue(...args);
          return result;
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef$2(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
var DIALOG_NAME = "Dialog";
var [createDialogContext] = createContextScope(DIALOG_NAME);
var [DialogProvider, useDialogContext] = createDialogContext(DIALOG_NAME);
var Dialog = (props) => {
  const {
    __scopeDialog,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props;
  const triggerRef = reactExports.useRef(null);
  const contentRef = reactExports.useRef(null);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: DIALOG_NAME
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    DialogProvider,
    {
      scope: __scopeDialog,
      triggerRef,
      contentRef,
      contentId: useId(),
      titleId: useId(),
      descriptionId: useId(),
      open,
      onOpenChange: setOpen,
      onOpenToggle: reactExports.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      modal,
      children
    }
  );
};
Dialog.displayName = DIALOG_NAME;
var TRIGGER_NAME$4 = "DialogTrigger";
var DialogTrigger = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...triggerProps } = props;
    const context = useDialogContext(TRIGGER_NAME$4, __scopeDialog);
    const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive$1.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context.open,
        "aria-controls": context.contentId,
        "data-state": getState$3(context.open),
        ...triggerProps,
        ref: composedTriggerRef,
        onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
      }
    );
  }
);
DialogTrigger.displayName = TRIGGER_NAME$4;
var PORTAL_NAME$3 = "DialogPortal";
var [PortalProvider$2, usePortalContext$2] = createDialogContext(PORTAL_NAME$3, {
  forceMount: void 0
});
var DialogPortal$1 = (props) => {
  const { __scopeDialog, forceMount, children, container } = props;
  const context = useDialogContext(PORTAL_NAME$3, __scopeDialog);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PortalProvider$2, { scope: __scopeDialog, forceMount, children: reactExports.Children.map(children, (child) => /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$3, { asChild: true, container, children: child }) })) });
};
DialogPortal$1.displayName = PORTAL_NAME$3;
var OVERLAY_NAME = "DialogOverlay";
var DialogOverlay$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext$2(OVERLAY_NAME, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...overlayProps } = props;
    const context = useDialogContext(OVERLAY_NAME, props.__scopeDialog);
    return context.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogOverlayImpl, { ...overlayProps, ref: forwardedRef }) }) : null;
  }
);
DialogOverlay$1.displayName = OVERLAY_NAME;
var Slot$2 = /* @__PURE__ */ createSlot$2("DialogOverlay.RemoveScroll");
var DialogOverlayImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...overlayProps } = props;
    const context = useDialogContext(OVERLAY_NAME, __scopeDialog);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ jsxRuntimeExports.jsx(ReactRemoveScroll, { as: Slot$2, allowPinchZoom: true, shards: [context.contentRef], children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive$1.div,
        {
          "data-state": getState$3(context.open),
          ...overlayProps,
          ref: forwardedRef,
          style: { pointerEvents: "auto", ...overlayProps.style }
        }
      ) })
    );
  }
);
var CONTENT_NAME$4 = "DialogContent";
var DialogContent$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext$2(CONTENT_NAME$4, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = useDialogContext(CONTENT_NAME$4, props.__scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: context.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentModal, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentNonModal, { ...contentProps, ref: forwardedRef }) });
  }
);
DialogContent$1.displayName = CONTENT_NAME$4;
var DialogContentModal = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME$4, props.__scopeDialog);
    const contentRef = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, context.contentRef, contentRef);
    reactExports.useEffect(() => {
      const content = contentRef.current;
      if (content) return hideOthers(content);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      DialogContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          event.preventDefault();
          context.triggerRef.current?.focus();
        }),
        onPointerDownOutside: composeEventHandlers(props.onPointerDownOutside, (event) => {
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (isRightClick) event.preventDefault();
        }),
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault()
        )
      }
    );
  }
);
var DialogContentNonModal = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME$4, props.__scopeDialog);
    const hasInteractedOutsideRef = reactExports.useRef(false);
    const hasPointerDownOutsideRef = reactExports.useRef(false);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      DialogContentImpl,
      {
        ...props,
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (event) => {
          props.onCloseAutoFocus?.(event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.current) context.triggerRef.current?.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
          hasPointerDownOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          props.onInteractOutside?.(event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.current = true;
            if (event.detail.originalEvent.type === "pointerdown") {
              hasPointerDownOutsideRef.current = true;
            }
          }
          const target = event.target;
          const targetIsTrigger = context.triggerRef.current?.contains(target);
          if (targetIsTrigger) event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
            event.preventDefault();
          }
        }
      }
    );
  }
);
var DialogContentImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, ...contentProps } = props;
    const context = useDialogContext(CONTENT_NAME$4, __scopeDialog);
    const contentRef = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef);
    useFocusGuards();
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FocusScope,
        {
          asChild: true,
          loop: true,
          trapped: trapFocus,
          onMountAutoFocus: onOpenAutoFocus,
          onUnmountAutoFocus: onCloseAutoFocus,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            DismissableLayer,
            {
              role: "dialog",
              id: context.contentId,
              "aria-describedby": context.descriptionId,
              "aria-labelledby": context.titleId,
              "data-state": getState$3(context.open),
              ...contentProps,
              ref: composedRefs,
              onDismiss: () => context.onOpenChange(false)
            }
          )
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TitleWarning, { titleId: context.titleId }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DescriptionWarning, { contentRef, descriptionId: context.descriptionId })
      ] })
    ] });
  }
);
var TITLE_NAME = "DialogTitle";
var DialogTitle$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...titleProps } = props;
    const context = useDialogContext(TITLE_NAME, __scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive$1.h2, { id: context.titleId, ...titleProps, ref: forwardedRef });
  }
);
DialogTitle$1.displayName = TITLE_NAME;
var DESCRIPTION_NAME = "DialogDescription";
var DialogDescription$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...descriptionProps } = props;
    const context = useDialogContext(DESCRIPTION_NAME, __scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive$1.p, { id: context.descriptionId, ...descriptionProps, ref: forwardedRef });
  }
);
DialogDescription$1.displayName = DESCRIPTION_NAME;
var CLOSE_NAME$1 = "DialogClose";
var DialogClose = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...closeProps } = props;
    const context = useDialogContext(CLOSE_NAME$1, __scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive$1.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, () => context.onOpenChange(false))
      }
    );
  }
);
DialogClose.displayName = CLOSE_NAME$1;
function getState$3(open) {
  return open ? "open" : "closed";
}
var TITLE_WARNING_NAME = "DialogTitleWarning";
var [WarningProvider, useWarningContext] = createContext2(TITLE_WARNING_NAME, {
  contentName: CONTENT_NAME$4,
  titleName: TITLE_NAME,
  docsSlug: "dialog"
});
var TitleWarning = ({ titleId }) => {
  const titleWarningContext = useWarningContext(TITLE_WARNING_NAME);
  const MESSAGE = `\`${titleWarningContext.contentName}\` requires a \`${titleWarningContext.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${titleWarningContext.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${titleWarningContext.docsSlug}`;
  reactExports.useEffect(() => {
    if (titleId) {
      const hasTitle = document.getElementById(titleId);
      if (!hasTitle) console.error(MESSAGE);
    }
  }, [MESSAGE, titleId]);
  return null;
};
var DESCRIPTION_WARNING_NAME = "DialogDescriptionWarning";
var DescriptionWarning = ({ contentRef, descriptionId }) => {
  const descriptionWarningContext = useWarningContext(DESCRIPTION_WARNING_NAME);
  const MESSAGE = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${descriptionWarningContext.contentName}}.`;
  reactExports.useEffect(() => {
    const describedById = contentRef.current?.getAttribute("aria-describedby");
    if (descriptionId && describedById) {
      const hasDescription = document.getElementById(descriptionId);
      if (!hasDescription) console.warn(MESSAGE);
    }
  }, [MESSAGE, contentRef, descriptionId]);
  return null;
};
var Root$3 = Dialog;
var Portal$2 = DialogPortal$1;
var Overlay = DialogOverlay$1;
var Content$1 = DialogContent$1;
var Title = DialogTitle$1;
var Description = DialogDescription$1;
var Close = DialogClose;
var N = '[cmdk-group=""]', Y = '[cmdk-group-items=""]', be$1 = '[cmdk-group-heading=""]', le$1 = '[cmdk-item=""]', ce = `${le$1}:not([aria-disabled="true"])`, Z$1 = "cmdk-item-select", T$1 = "data-value", Re = (r2, o, n) => W(r2, o, n), ue$1 = reactExports.createContext(void 0), K = () => reactExports.useContext(ue$1), de$1 = reactExports.createContext(void 0), ee$1 = () => reactExports.useContext(de$1), fe = reactExports.createContext(void 0), me$1 = reactExports.forwardRef((r2, o) => {
  let n = L(() => {
    var e, a2;
    return { search: "", value: (a2 = (e = r2.value) != null ? e : r2.defaultValue) != null ? a2 : "", selectedItemId: void 0, filtered: { count: 0, items: /* @__PURE__ */ new Map(), groups: /* @__PURE__ */ new Set() } };
  }), u2 = L(() => /* @__PURE__ */ new Set()), c = L(() => /* @__PURE__ */ new Map()), d2 = L(() => /* @__PURE__ */ new Map()), f2 = L(() => /* @__PURE__ */ new Set()), p2 = pe$1(r2), { label: b, children: m2, value: R2, onValueChange: x2, filter: C, shouldFilter: S2, loop: A2, disablePointerSelection: ge2 = false, vimBindings: j2 = true, ...O } = r2, $2 = useId(), q2 = useId(), _2 = useId(), I2 = reactExports.useRef(null), v = ke();
  k$1(() => {
    if (R2 !== void 0) {
      let e = R2.trim();
      n.current.value = e, E2.emit();
    }
  }, [R2]), k$1(() => {
    v(6, ne2);
  }, []);
  let E2 = reactExports.useMemo(() => ({ subscribe: (e) => (f2.current.add(e), () => f2.current.delete(e)), snapshot: () => n.current, setState: (e, a2, s2) => {
    var i, l, g2, y2;
    if (!Object.is(n.current[e], a2)) {
      if (n.current[e] = a2, e === "search") J2(), z2(), v(1, W2);
      else if (e === "value") {
        if (document.activeElement.hasAttribute("cmdk-input") || document.activeElement.hasAttribute("cmdk-root")) {
          let h2 = document.getElementById(_2);
          h2 ? h2.focus() : (i = document.getElementById($2)) == null || i.focus();
        }
        if (v(7, () => {
          var h2;
          n.current.selectedItemId = (h2 = M2()) == null ? void 0 : h2.id, E2.emit();
        }), s2 || v(5, ne2), ((l = p2.current) == null ? void 0 : l.value) !== void 0) {
          let h2 = a2 != null ? a2 : "";
          (y2 = (g2 = p2.current).onValueChange) == null || y2.call(g2, h2);
          return;
        }
      }
      E2.emit();
    }
  }, emit: () => {
    f2.current.forEach((e) => e());
  } }), []), U2 = reactExports.useMemo(() => ({ value: (e, a2, s2) => {
    var i;
    a2 !== ((i = d2.current.get(e)) == null ? void 0 : i.value) && (d2.current.set(e, { value: a2, keywords: s2 }), n.current.filtered.items.set(e, te2(a2, s2)), v(2, () => {
      z2(), E2.emit();
    }));
  }, item: (e, a2) => (u2.current.add(e), a2 && (c.current.has(a2) ? c.current.get(a2).add(e) : c.current.set(a2, /* @__PURE__ */ new Set([e]))), v(3, () => {
    J2(), z2(), n.current.value || W2(), E2.emit();
  }), () => {
    d2.current.delete(e), u2.current.delete(e), n.current.filtered.items.delete(e);
    let s2 = M2();
    v(4, () => {
      J2(), (s2 == null ? void 0 : s2.getAttribute("id")) === e && W2(), E2.emit();
    });
  }), group: (e) => (c.current.has(e) || c.current.set(e, /* @__PURE__ */ new Set()), () => {
    d2.current.delete(e), c.current.delete(e);
  }), filter: () => p2.current.shouldFilter, label: b || r2["aria-label"], getDisablePointerSelection: () => p2.current.disablePointerSelection, listId: $2, inputId: _2, labelId: q2, listInnerRef: I2 }), []);
  function te2(e, a2) {
    var i, l;
    let s2 = (l = (i = p2.current) == null ? void 0 : i.filter) != null ? l : Re;
    return e ? s2(e, n.current.search, a2) : 0;
  }
  function z2() {
    if (!n.current.search || p2.current.shouldFilter === false) return;
    let e = n.current.filtered.items, a2 = [];
    n.current.filtered.groups.forEach((i) => {
      let l = c.current.get(i), g2 = 0;
      l.forEach((y2) => {
        let h2 = e.get(y2);
        g2 = Math.max(h2, g2);
      }), a2.push([i, g2]);
    });
    let s2 = I2.current;
    V2().sort((i, l) => {
      var h2, F2;
      let g2 = i.getAttribute("id"), y2 = l.getAttribute("id");
      return ((h2 = e.get(y2)) != null ? h2 : 0) - ((F2 = e.get(g2)) != null ? F2 : 0);
    }).forEach((i) => {
      let l = i.closest(Y);
      l ? l.appendChild(i.parentElement === l ? i : i.closest(`${Y} > *`)) : s2.appendChild(i.parentElement === s2 ? i : i.closest(`${Y} > *`));
    }), a2.sort((i, l) => l[1] - i[1]).forEach((i) => {
      var g2;
      let l = (g2 = I2.current) == null ? void 0 : g2.querySelector(`${N}[${T$1}="${encodeURIComponent(i[0])}"]`);
      l == null || l.parentElement.appendChild(l);
    });
  }
  function W2() {
    let e = V2().find((s2) => s2.getAttribute("aria-disabled") !== "true"), a2 = e == null ? void 0 : e.getAttribute(T$1);
    E2.setState("value", a2 || void 0);
  }
  function J2() {
    var a2, s2, i, l;
    if (!n.current.search || p2.current.shouldFilter === false) {
      n.current.filtered.count = u2.current.size;
      return;
    }
    n.current.filtered.groups = /* @__PURE__ */ new Set();
    let e = 0;
    for (let g2 of u2.current) {
      let y2 = (s2 = (a2 = d2.current.get(g2)) == null ? void 0 : a2.value) != null ? s2 : "", h2 = (l = (i = d2.current.get(g2)) == null ? void 0 : i.keywords) != null ? l : [], F2 = te2(y2, h2);
      n.current.filtered.items.set(g2, F2), F2 > 0 && e++;
    }
    for (let [g2, y2] of c.current) for (let h2 of y2) if (n.current.filtered.items.get(h2) > 0) {
      n.current.filtered.groups.add(g2);
      break;
    }
    n.current.filtered.count = e;
  }
  function ne2() {
    var a2, s2, i;
    let e = M2();
    e && (((a2 = e.parentElement) == null ? void 0 : a2.firstChild) === e && ((i = (s2 = e.closest(N)) == null ? void 0 : s2.querySelector(be$1)) == null || i.scrollIntoView({ block: "nearest" })), e.scrollIntoView({ block: "nearest" }));
  }
  function M2() {
    var e;
    return (e = I2.current) == null ? void 0 : e.querySelector(`${le$1}[aria-selected="true"]`);
  }
  function V2() {
    var e;
    return Array.from(((e = I2.current) == null ? void 0 : e.querySelectorAll(ce)) || []);
  }
  function X2(e) {
    let s2 = V2()[e];
    s2 && E2.setState("value", s2.getAttribute(T$1));
  }
  function Q2(e) {
    var g2;
    let a2 = M2(), s2 = V2(), i = s2.findIndex((y2) => y2 === a2), l = s2[i + e];
    (g2 = p2.current) != null && g2.loop && (l = i + e < 0 ? s2[s2.length - 1] : i + e === s2.length ? s2[0] : s2[i + e]), l && E2.setState("value", l.getAttribute(T$1));
  }
  function re2(e) {
    let a2 = M2(), s2 = a2 == null ? void 0 : a2.closest(N), i;
    for (; s2 && !i; ) s2 = e > 0 ? we(s2, N) : De(s2, N), i = s2 == null ? void 0 : s2.querySelector(ce);
    i ? E2.setState("value", i.getAttribute(T$1)) : Q2(e);
  }
  let oe2 = () => X2(V2().length - 1), ie2 = (e) => {
    e.preventDefault(), e.metaKey ? oe2() : e.altKey ? re2(1) : Q2(1);
  }, se2 = (e) => {
    e.preventDefault(), e.metaKey ? X2(0) : e.altKey ? re2(-1) : Q2(-1);
  };
  return reactExports.createElement(Primitive$1.div, { ref: o, tabIndex: -1, ...O, "cmdk-root": "", onKeyDown: (e) => {
    var s2;
    (s2 = O.onKeyDown) == null || s2.call(O, e);
    let a2 = e.nativeEvent.isComposing || e.keyCode === 229;
    if (!(e.defaultPrevented || a2)) switch (e.key) {
      case "n":
      case "j": {
        j2 && e.ctrlKey && ie2(e);
        break;
      }
      case "ArrowDown": {
        ie2(e);
        break;
      }
      case "p":
      case "k": {
        j2 && e.ctrlKey && se2(e);
        break;
      }
      case "ArrowUp": {
        se2(e);
        break;
      }
      case "Home": {
        e.preventDefault(), X2(0);
        break;
      }
      case "End": {
        e.preventDefault(), oe2();
        break;
      }
      case "Enter": {
        e.preventDefault();
        let i = M2();
        if (i) {
          let l = new Event(Z$1);
          i.dispatchEvent(l);
        }
      }
    }
  } }, reactExports.createElement("label", { "cmdk-label": "", htmlFor: U2.inputId, id: U2.labelId, style: Te$1 }, b), B$1(r2, (e) => reactExports.createElement(de$1.Provider, { value: E2 }, reactExports.createElement(ue$1.Provider, { value: U2 }, e))));
}), he$1 = reactExports.forwardRef((r2, o) => {
  var _2, I2;
  let n = useId(), u2 = reactExports.useRef(null), c = reactExports.useContext(fe), d2 = K(), f2 = pe$1(r2), p2 = (I2 = (_2 = f2.current) == null ? void 0 : _2.forceMount) != null ? I2 : c == null ? void 0 : c.forceMount;
  k$1(() => {
    if (!p2) return d2.item(n, c == null ? void 0 : c.id);
  }, [p2]);
  let b = ve(n, u2, [r2.value, r2.children, u2], r2.keywords), m2 = ee$1(), R2 = P((v) => v.value && v.value === b.current), x2 = P((v) => p2 || d2.filter() === false ? true : v.search ? v.filtered.items.get(n) > 0 : true);
  reactExports.useEffect(() => {
    let v = u2.current;
    if (!(!v || r2.disabled)) return v.addEventListener(Z$1, C), () => v.removeEventListener(Z$1, C);
  }, [x2, r2.onSelect, r2.disabled]);
  function C() {
    var v, E2;
    S2(), (E2 = (v = f2.current).onSelect) == null || E2.call(v, b.current);
  }
  function S2() {
    m2.setState("value", b.current, true);
  }
  if (!x2) return null;
  let { disabled: A2, value: ge2, onSelect: j2, forceMount: O, keywords: $2, ...q2 } = r2;
  return reactExports.createElement(Primitive$1.div, { ref: composeRefs(u2, o), ...q2, id: n, "cmdk-item": "", role: "option", "aria-disabled": !!A2, "aria-selected": !!R2, "data-disabled": !!A2, "data-selected": !!R2, onPointerMove: A2 || d2.getDisablePointerSelection() ? void 0 : S2, onClick: A2 ? void 0 : C }, r2.children);
}), Ee$1 = reactExports.forwardRef((r2, o) => {
  let { heading: n, children: u2, forceMount: c, ...d2 } = r2, f2 = useId(), p2 = reactExports.useRef(null), b = reactExports.useRef(null), m2 = useId(), R2 = K(), x2 = P((S2) => c || R2.filter() === false ? true : S2.search ? S2.filtered.groups.has(f2) : true);
  k$1(() => R2.group(f2), []), ve(f2, p2, [r2.value, r2.heading, b]);
  let C = reactExports.useMemo(() => ({ id: f2, forceMount: c }), [c]);
  return reactExports.createElement(Primitive$1.div, { ref: composeRefs(p2, o), ...d2, "cmdk-group": "", role: "presentation", hidden: x2 ? void 0 : true }, n && reactExports.createElement("div", { ref: b, "cmdk-group-heading": "", "aria-hidden": true, id: m2 }, n), B$1(r2, (S2) => reactExports.createElement("div", { "cmdk-group-items": "", role: "group", "aria-labelledby": n ? m2 : void 0 }, reactExports.createElement(fe.Provider, { value: C }, S2))));
}), ye$1 = reactExports.forwardRef((r2, o) => {
  let { alwaysRender: n, ...u2 } = r2, c = reactExports.useRef(null), d2 = P((f2) => !f2.search);
  return !n && !d2 ? null : reactExports.createElement(Primitive$1.div, { ref: composeRefs(c, o), ...u2, "cmdk-separator": "", role: "separator" });
}), Se = reactExports.forwardRef((r2, o) => {
  let { onValueChange: n, ...u2 } = r2, c = r2.value != null, d2 = ee$1(), f2 = P((m2) => m2.search), p2 = P((m2) => m2.selectedItemId), b = K();
  return reactExports.useEffect(() => {
    r2.value != null && d2.setState("search", r2.value);
  }, [r2.value]), reactExports.createElement(Primitive$1.input, { ref: o, ...u2, "cmdk-input": "", autoComplete: "off", autoCorrect: "off", spellCheck: false, "aria-autocomplete": "list", role: "combobox", "aria-expanded": true, "aria-controls": b.listId, "aria-labelledby": b.labelId, "aria-activedescendant": p2, id: b.inputId, type: "text", value: c ? r2.value : f2, onChange: (m2) => {
    c || d2.setState("search", m2.target.value), n == null || n(m2.target.value);
  } });
}), Ce$1 = reactExports.forwardRef((r2, o) => {
  let { children: n, label: u2 = "Suggestions", ...c } = r2, d2 = reactExports.useRef(null), f2 = reactExports.useRef(null), p2 = P((m2) => m2.selectedItemId), b = K();
  return reactExports.useEffect(() => {
    if (f2.current && d2.current) {
      let m2 = f2.current, R2 = d2.current, x2, C = new ResizeObserver(() => {
        x2 = requestAnimationFrame(() => {
          let S2 = m2.offsetHeight;
          R2.style.setProperty("--cmdk-list-height", S2.toFixed(1) + "px");
        });
      });
      return C.observe(m2), () => {
        cancelAnimationFrame(x2), C.unobserve(m2);
      };
    }
  }, []), reactExports.createElement(Primitive$1.div, { ref: composeRefs(d2, o), ...c, "cmdk-list": "", role: "listbox", tabIndex: -1, "aria-activedescendant": p2, "aria-label": u2, id: b.listId }, B$1(r2, (m2) => reactExports.createElement("div", { ref: composeRefs(f2, b.listInnerRef), "cmdk-list-sizer": "" }, m2)));
}), xe$1 = reactExports.forwardRef((r2, o) => {
  let { open: n, onOpenChange: u2, overlayClassName: c, contentClassName: d2, container: f2, ...p2 } = r2;
  return reactExports.createElement(Root$3, { open: n, onOpenChange: u2 }, reactExports.createElement(Portal$2, { container: f2 }, reactExports.createElement(Overlay, { "cmdk-overlay": "", className: c }), reactExports.createElement(Content$1, { "aria-label": r2.label, "cmdk-dialog": "", className: d2 }, reactExports.createElement(me$1, { ref: o, ...p2 }))));
}), Ie$1 = reactExports.forwardRef((r2, o) => P((u2) => u2.filtered.count === 0) ? reactExports.createElement(Primitive$1.div, { ref: o, ...r2, "cmdk-empty": "", role: "presentation" }) : null), Pe = reactExports.forwardRef((r2, o) => {
  let { progress: n, children: u2, label: c = "Loading...", ...d2 } = r2;
  return reactExports.createElement(Primitive$1.div, { ref: o, ...d2, "cmdk-loading": "", role: "progressbar", "aria-valuenow": n, "aria-valuemin": 0, "aria-valuemax": 100, "aria-label": c }, B$1(r2, (f2) => reactExports.createElement("div", { "aria-hidden": true }, f2)));
}), _e = Object.assign(me$1, { List: Ce$1, Item: he$1, Input: Se, Group: Ee$1, Separator: ye$1, Dialog: xe$1, Empty: Ie$1, Loading: Pe });
function we(r2, o) {
  let n = r2.nextElementSibling;
  for (; n; ) {
    if (n.matches(o)) return n;
    n = n.nextElementSibling;
  }
}
function De(r2, o) {
  let n = r2.previousElementSibling;
  for (; n; ) {
    if (n.matches(o)) return n;
    n = n.previousElementSibling;
  }
}
function pe$1(r2) {
  let o = reactExports.useRef(r2);
  return k$1(() => {
    o.current = r2;
  }), o;
}
var k$1 = typeof window == "undefined" ? reactExports.useEffect : reactExports.useLayoutEffect;
function L(r2) {
  let o = reactExports.useRef();
  return o.current === void 0 && (o.current = r2()), o;
}
function P(r2) {
  let o = ee$1(), n = () => r2(o.snapshot());
  return reactExports.useSyncExternalStore(o.subscribe, n, n);
}
function ve(r2, o, n, u2 = []) {
  let c = reactExports.useRef(), d2 = K();
  return k$1(() => {
    var b;
    let f2 = (() => {
      var m2;
      for (let R2 of n) {
        if (typeof R2 == "string") return R2.trim();
        if (typeof R2 == "object" && "current" in R2) return R2.current ? (m2 = R2.current.textContent) == null ? void 0 : m2.trim() : c.current;
      }
    })(), p2 = u2.map((m2) => m2.trim());
    d2.value(r2, f2, p2), (b = o.current) == null || b.setAttribute(T$1, f2), c.current = f2;
  }), c;
}
var ke = () => {
  let [r2, o] = reactExports.useState(), n = L(() => /* @__PURE__ */ new Map());
  return k$1(() => {
    n.current.forEach((u2) => u2()), n.current = /* @__PURE__ */ new Map();
  }, [r2]), (u2, c) => {
    n.current.set(u2, c), o({});
  };
};
function Me$1(r2) {
  let o = r2.type;
  return typeof o == "function" ? o(r2.props) : "render" in o ? o.render(r2.props) : r2;
}
function B$1({ asChild: r2, children: o }, n) {
  return r2 && reactExports.isValidElement(o) ? reactExports.cloneElement(Me$1(o), { ref: o.ref }, n(o.props.children)) : n(o);
}
var Te$1 = { position: "absolute", width: "1px", height: "1px", padding: "0", margin: "-1px", overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0" };
const DialogPortal = Portal$2;
const DialogOverlay = reactExports.forwardRef(({ className, ...props }, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Overlay,
  {
    ref: ref2,
    className: cn$2(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    ),
    ...props
  }
));
DialogOverlay.displayName = Overlay.displayName;
const DialogContent = reactExports.forwardRef(({ className, children, ...props }, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogPortal, { children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx(DialogOverlay, {}),
  /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Content$1,
    {
      ref: ref2,
      className: cn$2(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      ),
      ...props,
      children: [
        children,
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Close, { className: "absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Cross2Icon, { className: "h-4 w-4" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "sr-only", children: "Close" })
        ] })
      ]
    }
  )
] }));
DialogContent.displayName = Content$1.displayName;
const DialogTitle = reactExports.forwardRef(({ className, ...props }, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Title,
  {
    ref: ref2,
    className: cn$2(
      "text-lg font-semibold leading-none tracking-tight",
      className
    ),
    ...props
  }
));
DialogTitle.displayName = Title.displayName;
const DialogDescription = reactExports.forwardRef(({ className, ...props }, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Description,
  {
    ref: ref2,
    className: cn$2("text-sm text-muted-foreground", className),
    ...props
  }
));
DialogDescription.displayName = Description.displayName;
const Command = reactExports.forwardRef(({ className, ...props }, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  _e,
  {
    ref: ref2,
    className: cn$2(
      "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
      className
    ),
    ...props
  }
));
Command.displayName = _e.displayName;
const CommandInput = reactExports.forwardRef(({ className, ...props }, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center border-b px-3", "cmdk-input-wrapper": "", children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx(MagnifyingGlassIcon, { className: "mr-2 h-4 w-4 shrink-0 opacity-50" }),
  /* @__PURE__ */ jsxRuntimeExports.jsx(
    _e.Input,
    {
      ref: ref2,
      className: cn$2(
        "flex h-10 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
        className
      ),
      ...props
    }
  )
] }));
CommandInput.displayName = _e.Input.displayName;
const CommandList = reactExports.forwardRef(({ className, ...props }, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  _e.List,
  {
    ref: ref2,
    className: cn$2("max-h-[300px] overflow-y-auto overflow-x-hidden", className),
    ...props
  }
));
CommandList.displayName = _e.List.displayName;
const CommandEmpty = reactExports.forwardRef((props, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  _e.Empty,
  {
    ref: ref2,
    className: "py-6 text-center text-sm",
    ...props
  }
));
CommandEmpty.displayName = _e.Empty.displayName;
const CommandGroup = reactExports.forwardRef(({ className, ...props }, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  _e.Group,
  {
    ref: ref2,
    className: cn$2(
      "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
      className
    ),
    ...props
  }
));
CommandGroup.displayName = _e.Group.displayName;
const CommandSeparator = reactExports.forwardRef(({ className, ...props }, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  _e.Separator,
  {
    ref: ref2,
    className: cn$2("-mx-1 h-px bg-border", className),
    ...props
  }
));
CommandSeparator.displayName = _e.Separator.displayName;
const CommandItem = reactExports.forwardRef(({ className, ...props }, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  _e.Item,
  {
    ref: ref2,
    className: cn$2(
      "relative flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected=true]:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      className
    ),
    ...props
  }
));
CommandItem.displayName = _e.Item.displayName;
const sides = ["top", "right", "bottom", "left"];
const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = (v) => ({
  x: v,
  y: v
});
const oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
const oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp$1(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
const yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
function getSideAxis(placement) {
  return yAxisSides.has(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
const lrPlacement = ["left", "right"];
const rlPlacement = ["right", "left"];
const tbPlacement = ["top", "bottom"];
const btPlacement = ["bottom", "top"];
function getSideList(side, isStart, rtl) {
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rlPlacement : lrPlacement;
      return isStart ? lrPlacement : rlPlacement;
    case "left":
    case "right":
      return isStart ? tbPlacement : btPlacement;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x: x2,
    y: y2,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y2,
    left: x2,
    right: x2 + width,
    bottom: y2 + height,
    x: x2,
    y: y2
  };
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x2,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x: x2,
    y: y2,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const computePosition$1 = async (reference, floating, config2) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config2;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x2,
    y: y2
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    var _platform$detectOverf;
    const {
      name: name2,
      fn: fn2
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data: data2,
      reset
    } = await fn2({
      x: x2,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: {
        ...platform2,
        detectOverflow: (_platform$detectOverf = platform2.detectOverflow) != null ? _platform$detectOverf : detectOverflow
      },
      elements: {
        reference,
        floating
      }
    });
    x2 = nextX != null ? nextX : x2;
    y2 = nextY != null ? nextY : y2;
    middlewareData = {
      ...middlewareData,
      [name2]: {
        ...middlewareData[name2],
        ...data2
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x2,
          y: y2
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x: x2,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
const arrow$3 = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x: x2,
      y: y2,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x: x2,
      y: y2
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = clamp$1(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
const flip$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await platform2.detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
          if (!ignoreCrossAxisOverflow || // We leave the current main axis only if every placement on that axis
          // overflows the main axis.
          overflowsData.every((d2) => getSideAxis(d2.placement) === initialSideAxis ? d2.overflows[0] > 0 : true)) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d2) => d2.overflows[0] <= 0).sort((a2, b) => a2.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d2) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d2.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d2) => [d2.placement, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b) => a2[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
const hide$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects,
        platform: platform2
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await platform2.detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await platform2.detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
const originSides = /* @__PURE__ */ new Set(["left", "top"]);
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = originSides.has(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset$2 = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x: x2,
        y: y2,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x2 + diffCoords.x,
        y: y2 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
const shift$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x: x2,
        y: y2,
        placement,
        platform: platform2
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x3,
              y: y3
            } = _ref;
            return {
              x: x3,
              y: y3
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x: x2,
        y: y2
      };
      const overflow = await platform2.detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp$1(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp$1(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y2,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
const limitShift$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x: x2,
        y: y2,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset2 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x: x2,
        y: y2
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset2, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = originSides.has(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
const size$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await platform2.detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
const invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
}
const tableElements = /* @__PURE__ */ new Set(["table", "td", "th"]);
function isTableElement(element) {
  return tableElements.has(getNodeName(element));
}
const topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(element) {
  return topLayerSelectors.some((selector) => {
    try {
      return element.matches(selector);
    } catch (_e2) {
      return false;
    }
  });
}
const transformProperties = ["transform", "translate", "scale", "rotate", "perspective"];
const willChangeValues = ["transform", "translate", "scale", "rotate", "perspective", "filter"];
const containValues = ["paint", "layout", "strict", "content"];
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;
  return transformProperties.some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || willChangeValues.some((value) => (css.willChange || "").includes(value)) || containValues.some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
const lastTraversableNodeNames = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function isLastTraversableNode(node) {
  return lastTraversableNodeNames.has(getNodeName(node));
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}
function getCssDimensions(element) {
  const css = getComputedStyle$1(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $2
  } = getCssDimensions(domElement);
  let x2 = ($2 ? round(rect.width) : rect.width) / width;
  let y2 = ($2 ? round(rect.height) : rect.height) / height;
  if (!x2 || !Number.isFinite(x2)) {
    x2 = 1;
  }
  if (!y2 || !Number.isFinite(y2)) {
    y2 = 1;
  }
  return {
    x: x2,
    y: y2
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale.x;
  let y2 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle$1(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x;
      y2 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x2 += left;
      y2 += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x2,
    y: y2
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll) {
  const htmlRect = documentElement.getBoundingClientRect();
  const x2 = htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect);
  const y2 = htmlRect.top + scroll.scrollTop;
  return {
    x: x2,
    y: y2
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y2 = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === "rtl") {
    x2 += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
const SCROLLBAR_MAX = 25;
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x2 = 0;
  let y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  const windowScrollbarX = getWindowScrollBarX(html);
  if (windowScrollbarX <= 0) {
    const doc = html.ownerDocument;
    const body = doc.body;
    const bodyStyles = getComputedStyle(body);
    const bodyMarginInline = doc.compatMode === "CSS1Compat" ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0 : 0;
    const clippingStableScrollbarWidth = Math.abs(html.clientWidth - body.clientWidth - bodyMarginInline);
    if (clippingStableScrollbarWidth <= SCROLLBAR_MAX) {
      width -= clippingStableScrollbarWidth;
    }
  } else if (windowScrollbarX <= SCROLLBAR_MAX) {
    width += windowScrollbarX;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
const absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x2 = left * scale.x;
  const y2 = top * scale.y;
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache2) {
  const cachedResult = cache2.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el2) => isElement(el2) && getNodeName(el2) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache2.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x2 = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y2 = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x: x2,
    y: y2,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle$1(element).position === "static";
}
function getTrueOffsetParent(element, polyfill2) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  if (polyfill2) {
    return polyfill2(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill2) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill2);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill2);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
const getElementRects = async function(data2) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data2.floating);
  return {
    reference: getRectRelativeToOffsetParent(data2.reference, await getOffsetParentFn(data2.floating), data2.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle$1(element).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a2, b) {
  return a2.x === b.x && a2.y === b.y && a2.width === b.width && a2.height === b.height;
}
function observeMove(element, onMove) {
  let io2 = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io2) == null || _io.disconnect();
    io2 = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io2 = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (_e2) {
      io2 = new IntersectionObserver(handleObserve, options);
    }
    io2.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
const offset$1 = offset$2;
const shift$1 = shift$2;
const flip$1 = flip$2;
const size$1 = size$2;
const hide$1 = hide$2;
const arrow$2 = arrow$3;
const limitShift$1 = limitShift$2;
const computePosition = (reference, floating, options) => {
  const cache2 = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache2
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
var isClient = typeof document !== "undefined";
var noop = function noop2() {
};
var index = isClient ? reactExports.useLayoutEffect : noop;
function deepEqual(a2, b) {
  if (a2 === b) {
    return true;
  }
  if (typeof a2 !== typeof b) {
    return false;
  }
  if (typeof a2 === "function" && a2.toString() === b.toString()) {
    return true;
  }
  let length;
  let i;
  let keys;
  if (a2 && b && typeof a2 === "object") {
    if (Array.isArray(a2)) {
      length = a2.length;
      if (length !== b.length) return false;
      for (i = length; i-- !== 0; ) {
        if (!deepEqual(a2[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a2);
    length = keys.length;
    if (length !== Object.keys(b).length) {
      return false;
    }
    for (i = length; i-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b, keys[i])) {
        return false;
      }
    }
    for (i = length; i-- !== 0; ) {
      const key = keys[i];
      if (key === "_owner" && a2.$$typeof) {
        continue;
      }
      if (!deepEqual(a2[key], b[key])) {
        return false;
      }
    }
    return true;
  }
  return a2 !== a2 && b !== b;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref2 = reactExports.useRef(value);
  index(() => {
    ref2.current = value;
  });
  return ref2;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform: transform2 = true,
    whileElementsMounted,
    open
  } = options;
  const [data2, setData] = reactExports.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = reactExports.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = reactExports.useState(null);
  const [_floating, _setFloating] = reactExports.useState(null);
  const setReference = reactExports.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = reactExports.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = reactExports.useRef(null);
  const floatingRef = reactExports.useRef(null);
  const dataRef = reactExports.useRef(data2);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const openRef = useLatestRef(open);
  const update = reactExports.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config2 = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config2.platform = platformRef.current;
    }
    computePosition(referenceRef.current, floatingRef.current, config2).then((data3) => {
      const fullData = {
        ...data3,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== false
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        reactDomExports.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data3) => ({
        ...data3,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = reactExports.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (referenceEl) referenceRef.current = referenceEl;
    if (floatingEl) floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = reactExports.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = reactExports.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = reactExports.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x2 = roundByDPR(elements.floating, data2.x);
    const y2 = roundByDPR(elements.floating, data2.y);
    if (transform2) {
      return {
        ...initialStyles,
        transform: "translate(" + x2 + "px, " + y2 + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x2,
      top: y2
    };
  }, [strategy, transform2, elements.floating, data2.x, data2.y]);
  return reactExports.useMemo(() => ({
    ...data2,
    update,
    refs,
    elements,
    floatingStyles
  }), [data2, update, refs, elements, floatingStyles]);
}
const arrow$1 = (options) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding
      } = typeof options === "function" ? options(state) : options;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow$2({
            element: element.current,
            padding
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow$2({
          element,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
const offset = (options, deps) => ({
  ...offset$1(options),
  options: [options, deps]
});
const shift = (options, deps) => ({
  ...shift$1(options),
  options: [options, deps]
});
const limitShift = (options, deps) => ({
  ...limitShift$1(options),
  options: [options, deps]
});
const flip = (options, deps) => ({
  ...flip$1(options),
  options: [options, deps]
});
const size = (options, deps) => ({
  ...size$1(options),
  options: [options, deps]
});
const hide = (options, deps) => ({
  ...hide$1(options),
  options: [options, deps]
});
const arrow = (options, deps) => ({
  ...arrow$1(options),
  options: [options, deps]
});
var NAME$1 = "Arrow";
var Arrow$1 = reactExports.forwardRef((props, forwardedRef) => {
  const { children, width = 10, height = 5, ...arrowProps } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive$1.svg,
    {
      ...arrowProps,
      ref: forwardedRef,
      width,
      height,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: props.asChild ? children : /* @__PURE__ */ jsxRuntimeExports.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
Arrow$1.displayName = NAME$1;
var Root$2 = Arrow$1;
function useSize(element) {
  const [size2, setSize] = reactExports.useState(void 0);
  useLayoutEffect2(() => {
    if (element) {
      setSize({ width: element.offsetWidth, height: element.offsetHeight });
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries)) {
          return;
        }
        if (!entries.length) {
          return;
        }
        const entry = entries[0];
        let width;
        let height;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry["borderBoxSize"];
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width = borderSize["inlineSize"];
          height = borderSize["blockSize"];
        } else {
          width = element.offsetWidth;
          height = element.offsetHeight;
        }
        setSize({ width, height });
      });
      resizeObserver.observe(element, { box: "border-box" });
      return () => resizeObserver.unobserve(element);
    } else {
      setSize(void 0);
    }
  }, [element]);
  return size2;
}
var POPPER_NAME = "Popper";
var [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);
var [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME);
var Popper = (props) => {
  const { __scopePopper, children } = props;
  const [anchor, setAnchor] = reactExports.useState(null);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PopperProvider, { scope: __scopePopper, anchor, onAnchorChange: setAnchor, children });
};
Popper.displayName = POPPER_NAME;
var ANCHOR_NAME$1 = "PopperAnchor";
var PopperAnchor = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopper, virtualRef, ...anchorProps } = props;
    const context = usePopperContext(ANCHOR_NAME$1, __scopePopper);
    const ref2 = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref2);
    const anchorRef = reactExports.useRef(null);
    reactExports.useEffect(() => {
      const previousAnchor = anchorRef.current;
      anchorRef.current = virtualRef?.current || ref2.current;
      if (previousAnchor !== anchorRef.current) {
        context.onAnchorChange(anchorRef.current);
      }
    });
    return virtualRef ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive$1.div, { ...anchorProps, ref: composedRefs });
  }
);
PopperAnchor.displayName = ANCHOR_NAME$1;
var CONTENT_NAME$3 = "PopperContent";
var [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME$3);
var PopperContent = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopePopper,
      side = "bottom",
      sideOffset = 0,
      align = "center",
      alignOffset = 0,
      arrowPadding = 0,
      avoidCollisions = true,
      collisionBoundary = [],
      collisionPadding: collisionPaddingProp = 0,
      sticky = "partial",
      hideWhenDetached = false,
      updatePositionStrategy = "optimized",
      onPlaced,
      ...contentProps
    } = props;
    const context = usePopperContext(CONTENT_NAME$3, __scopePopper);
    const [content, setContent] = reactExports.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
    const [arrow$12, setArrow] = reactExports.useState(null);
    const arrowSize = useSize(arrow$12);
    const arrowWidth = arrowSize?.width ?? 0;
    const arrowHeight = arrowSize?.height ?? 0;
    const desiredPlacement = side + (align !== "center" ? "-" + align : "");
    const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };
    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];
    const hasExplicitBoundaries = boundary.length > 0;
    const detectOverflowOptions = {
      padding: collisionPadding,
      boundary: boundary.filter(isNotNull),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: hasExplicitBoundaries
    };
    const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: desiredPlacement,
      whileElementsMounted: (...args) => {
        const cleanup = autoUpdate(...args, {
          animationFrame: updatePositionStrategy === "always"
        });
        return cleanup;
      },
      elements: {
        reference: context.anchor
      },
      middleware: [
        offset({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),
        avoidCollisions && shift({
          mainAxis: true,
          crossAxis: false,
          limiter: sticky === "partial" ? limitShift() : void 0,
          ...detectOverflowOptions
        }),
        avoidCollisions && flip({ ...detectOverflowOptions }),
        size({
          ...detectOverflowOptions,
          apply: ({ elements, rects, availableWidth, availableHeight }) => {
            const { width: anchorWidth, height: anchorHeight } = rects.reference;
            const contentStyle = elements.floating.style;
            contentStyle.setProperty("--radix-popper-available-width", `${availableWidth}px`);
            contentStyle.setProperty("--radix-popper-available-height", `${availableHeight}px`);
            contentStyle.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
            contentStyle.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
          }
        }),
        arrow$12 && arrow({ element: arrow$12, padding: arrowPadding }),
        transformOrigin({ arrowWidth, arrowHeight }),
        hideWhenDetached && hide({ strategy: "referenceHidden", ...detectOverflowOptions })
      ]
    });
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const handlePlaced = useCallbackRef$1(onPlaced);
    useLayoutEffect2(() => {
      if (isPositioned) {
        handlePlaced?.();
      }
    }, [isPositioned, handlePlaced]);
    const arrowX = middlewareData.arrow?.x;
    const arrowY = middlewareData.arrow?.y;
    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;
    const [contentZIndex, setContentZIndex] = reactExports.useState();
    useLayoutEffect2(() => {
      if (content) setContentZIndex(window.getComputedStyle(content).zIndex);
    }, [content]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        ref: refs.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...floatingStyles,
          transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: contentZIndex,
          ["--radix-popper-transform-origin"]: [
            middlewareData.transformOrigin?.x,
            middlewareData.transformOrigin?.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...middlewareData.hide?.referenceHidden && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: props.dir,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          PopperContentProvider,
          {
            scope: __scopePopper,
            placedSide,
            onArrowChange: setArrow,
            arrowX,
            arrowY,
            shouldHideArrow: cannotCenterArrow,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Primitive$1.div,
              {
                "data-side": placedSide,
                "data-align": placedAlign,
                ...contentProps,
                ref: composedRefs,
                style: {
                  ...contentProps.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: !isPositioned ? "none" : void 0
                }
              }
            )
          }
        )
      }
    );
  }
);
PopperContent.displayName = CONTENT_NAME$3;
var ARROW_NAME$3 = "PopperArrow";
var OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var PopperArrow = reactExports.forwardRef(function PopperArrow2(props, forwardedRef) {
  const { __scopePopper, ...arrowProps } = props;
  const contentContext = useContentContext(ARROW_NAME$3, __scopePopper);
  const baseSide = OPPOSITE_SIDE[contentContext.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "span",
      {
        ref: contentContext.onArrowChange,
        style: {
          position: "absolute",
          left: contentContext.arrowX,
          top: contentContext.arrowY,
          [baseSide]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[contentContext.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: `rotate(180deg)`,
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[contentContext.placedSide],
          visibility: contentContext.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Root$2,
          {
            ...arrowProps,
            ref: forwardedRef,
            style: {
              ...arrowProps.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
PopperArrow.displayName = ARROW_NAME$3;
function isNotNull(value) {
  return value !== null;
}
var transformOrigin = (options) => ({
  name: "transformOrigin",
  options,
  fn(data2) {
    const { placement, rects, middlewareData } = data2;
    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;
    const isArrowHidden = cannotCenterArrow;
    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
    const arrowXCenter = (middlewareData.arrow?.x ?? 0) + arrowWidth / 2;
    const arrowYCenter = (middlewareData.arrow?.y ?? 0) + arrowHeight / 2;
    let x2 = "";
    let y2 = "";
    if (placedSide === "bottom") {
      x2 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y2 = `${-arrowHeight}px`;
    } else if (placedSide === "top") {
      x2 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y2 = `${rects.floating.height + arrowHeight}px`;
    } else if (placedSide === "right") {
      x2 = `${-arrowHeight}px`;
      y2 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    } else if (placedSide === "left") {
      x2 = `${rects.floating.width + arrowHeight}px`;
      y2 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    }
    return { data: { x: x2, y: y2 } };
  }
});
function getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}
var Root2$2 = Popper;
var Anchor = PopperAnchor;
var Content = PopperContent;
var Arrow = PopperArrow;
// @__NO_SIDE_EFFECTS__
function createSlot$1(ownerName) {
  const SlotClone = /* @__PURE__ */ createSlotClone$1(ownerName);
  const Slot2 = reactExports.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    const childrenArray = reactExports.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable$1);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (reactExports.Children.count(newElement) > 1) return reactExports.Children.only(null);
          return reactExports.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children: reactExports.isValidElement(newElement) ? reactExports.cloneElement(newElement, void 0, newChildren) : null });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children });
  });
  Slot2.displayName = `${ownerName}.Slot`;
  return Slot2;
}
// @__NO_SIDE_EFFECTS__
function createSlotClone$1(ownerName) {
  const SlotClone = reactExports.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    if (reactExports.isValidElement(children)) {
      const childrenRef = getElementRef$1(children);
      const props2 = mergeProps$1(slotProps, children.props);
      if (children.type !== reactExports.Fragment) {
        props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
      }
      return reactExports.cloneElement(children, props2);
    }
    return reactExports.Children.count(children) > 1 ? reactExports.Children.only(null) : null;
  });
  SlotClone.displayName = `${ownerName}.SlotClone`;
  return SlotClone;
}
var SLOTTABLE_IDENTIFIER$2 = /* @__PURE__ */ Symbol("radix.slottable");
function isSlottable$1(child) {
  return reactExports.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER$2;
}
function mergeProps$1(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          const result = childPropValue(...args);
          slotPropValue(...args);
          return result;
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef$1(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
var POPOVER_NAME = "Popover";
var [createPopoverContext] = createContextScope(POPOVER_NAME, [
  createPopperScope
]);
var usePopperScope$2 = createPopperScope();
var [PopoverProvider, usePopoverContext] = createPopoverContext(POPOVER_NAME);
var Popover$1 = (props) => {
  const {
    __scopePopover,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = false
  } = props;
  const popperScope = usePopperScope$2(__scopePopover);
  const triggerRef = reactExports.useRef(null);
  const [hasCustomAnchor, setHasCustomAnchor] = reactExports.useState(false);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: POPOVER_NAME
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$2, { ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    PopoverProvider,
    {
      scope: __scopePopover,
      contentId: useId(),
      triggerRef,
      open,
      onOpenChange: setOpen,
      onOpenToggle: reactExports.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      hasCustomAnchor,
      onCustomAnchorAdd: reactExports.useCallback(() => setHasCustomAnchor(true), []),
      onCustomAnchorRemove: reactExports.useCallback(() => setHasCustomAnchor(false), []),
      modal,
      children
    }
  ) });
};
Popover$1.displayName = POPOVER_NAME;
var ANCHOR_NAME = "PopoverAnchor";
var PopoverAnchor = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...anchorProps } = props;
    const context = usePopoverContext(ANCHOR_NAME, __scopePopover);
    const popperScope = usePopperScope$2(__scopePopover);
    const { onCustomAnchorAdd, onCustomAnchorRemove } = context;
    reactExports.useEffect(() => {
      onCustomAnchorAdd();
      return () => onCustomAnchorRemove();
    }, [onCustomAnchorAdd, onCustomAnchorRemove]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor, { ...popperScope, ...anchorProps, ref: forwardedRef });
  }
);
PopoverAnchor.displayName = ANCHOR_NAME;
var TRIGGER_NAME$3 = "PopoverTrigger";
var PopoverTrigger$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...triggerProps } = props;
    const context = usePopoverContext(TRIGGER_NAME$3, __scopePopover);
    const popperScope = usePopperScope$2(__scopePopover);
    const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
    const trigger = /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive$1.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context.open,
        "aria-controls": context.contentId,
        "data-state": getState$2(context.open),
        ...triggerProps,
        ref: composedTriggerRef,
        onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
      }
    );
    return context.hasCustomAnchor ? trigger : /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor, { asChild: true, ...popperScope, children: trigger });
  }
);
PopoverTrigger$1.displayName = TRIGGER_NAME$3;
var PORTAL_NAME$2 = "PopoverPortal";
var [PortalProvider$1, usePortalContext$1] = createPopoverContext(PORTAL_NAME$2, {
  forceMount: void 0
});
var PopoverPortal = (props) => {
  const { __scopePopover, forceMount, children, container } = props;
  const context = usePopoverContext(PORTAL_NAME$2, __scopePopover);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PortalProvider$1, { scope: __scopePopover, forceMount, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$3, { asChild: true, container, children }) }) });
};
PopoverPortal.displayName = PORTAL_NAME$2;
var CONTENT_NAME$2 = "PopoverContent";
var PopoverContent$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext$1(CONTENT_NAME$2, props.__scopePopover);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = usePopoverContext(CONTENT_NAME$2, props.__scopePopover);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: context.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverContentModal, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverContentNonModal, { ...contentProps, ref: forwardedRef }) });
  }
);
PopoverContent$1.displayName = CONTENT_NAME$2;
var Slot$1 = /* @__PURE__ */ createSlot$1("PopoverContent.RemoveScroll");
var PopoverContentModal = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context = usePopoverContext(CONTENT_NAME$2, props.__scopePopover);
    const contentRef = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef);
    const isRightClickOutsideRef = reactExports.useRef(false);
    reactExports.useEffect(() => {
      const content = contentRef.current;
      if (content) return hideOthers(content);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ReactRemoveScroll, { as: Slot$1, allowPinchZoom: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      PopoverContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          event.preventDefault();
          if (!isRightClickOutsideRef.current) context.triggerRef.current?.focus();
        }),
        onPointerDownOutside: composeEventHandlers(
          props.onPointerDownOutside,
          (event) => {
            const originalEvent = event.detail.originalEvent;
            const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
            const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
            isRightClickOutsideRef.current = isRightClick;
          },
          { checkForDefaultPrevented: false }
        ),
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault(),
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
var PopoverContentNonModal = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context = usePopoverContext(CONTENT_NAME$2, props.__scopePopover);
    const hasInteractedOutsideRef = reactExports.useRef(false);
    const hasPointerDownOutsideRef = reactExports.useRef(false);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      PopoverContentImpl,
      {
        ...props,
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (event) => {
          props.onCloseAutoFocus?.(event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.current) context.triggerRef.current?.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
          hasPointerDownOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          props.onInteractOutside?.(event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.current = true;
            if (event.detail.originalEvent.type === "pointerdown") {
              hasPointerDownOutsideRef.current = true;
            }
          }
          const target = event.target;
          const targetIsTrigger = context.triggerRef.current?.contains(target);
          if (targetIsTrigger) event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
            event.preventDefault();
          }
        }
      }
    );
  }
);
var PopoverContentImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopePopover,
      trapFocus,
      onOpenAutoFocus,
      onCloseAutoFocus,
      disableOutsidePointerEvents,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      ...contentProps
    } = props;
    const context = usePopoverContext(CONTENT_NAME$2, __scopePopover);
    const popperScope = usePopperScope$2(__scopePopover);
    useFocusGuards();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      FocusScope,
      {
        asChild: true,
        loop: true,
        trapped: trapFocus,
        onMountAutoFocus: onOpenAutoFocus,
        onUnmountAutoFocus: onCloseAutoFocus,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          DismissableLayer,
          {
            asChild: true,
            disableOutsidePointerEvents,
            onInteractOutside,
            onEscapeKeyDown,
            onPointerDownOutside,
            onFocusOutside,
            onDismiss: () => context.onOpenChange(false),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Content,
              {
                "data-state": getState$2(context.open),
                role: "dialog",
                id: context.contentId,
                ...popperScope,
                ...contentProps,
                ref: forwardedRef,
                style: {
                  ...contentProps.style,
                  // re-namespace exposed content custom properties
                  ...{
                    "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
                    "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
                    "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
                    "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
                    "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
                  }
                }
              }
            )
          }
        )
      }
    );
  }
);
var CLOSE_NAME = "PopoverClose";
var PopoverClose = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...closeProps } = props;
    const context = usePopoverContext(CLOSE_NAME, __scopePopover);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive$1.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, () => context.onOpenChange(false))
      }
    );
  }
);
PopoverClose.displayName = CLOSE_NAME;
var ARROW_NAME$2 = "PopoverArrow";
var PopoverArrow = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...arrowProps } = props;
    const popperScope = usePopperScope$2(__scopePopover);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
PopoverArrow.displayName = ARROW_NAME$2;
function getState$2(open) {
  return open ? "open" : "closed";
}
var Root2$1 = Popover$1;
var Trigger$2 = PopoverTrigger$1;
var Portal$1 = PopoverPortal;
var Content2$2 = PopoverContent$1;
const Popover = Root2$1;
const PopoverTrigger = Trigger$2;
const PopoverContent = reactExports.forwardRef(({ className, align = "center", sideOffset = 4, ...props }, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
  Content2$2,
  {
    ref: ref2,
    align,
    sideOffset,
    className: cn$2(
      "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    ),
    ...props
  }
) }));
PopoverContent.displayName = Content2$2.displayName;
function Combobox({
  value,
  onChange,
  onInputChange,
  onFocus,
  options = [],
  placeholder = "Select...",
  emptyMessage = "No results found.",
  id: id2
}) {
  const [open, setOpen] = React.useState(false);
  const handleOpenChange = React.useCallback(
    (newOpen) => {
      setOpen(newOpen);
      if (newOpen && onFocus) {
        onFocus();
      }
    },
    [onFocus]
  );
  const handleSelect = React.useCallback(
    (option) => {
      onChange(option);
      setOpen(false);
    },
    [onChange]
  );
  const handleInputChange = React.useCallback(
    (value2) => {
      onInputChange(value2);
    },
    [onInputChange]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Popover, { open, onOpenChange: handleOpenChange, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Button,
      {
        variant: "outline",
        role: "combobox",
        "aria-expanded": open,
        "aria-controls": id2,
        className: "w-full justify-between",
        children: [
          value || placeholder,
          /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronsUpDown, { className: "ml-2 h-4 w-4 shrink-0 opacity-50" })
        ]
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverContent, { className: "w-full p-0", align: "start", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Command, { shouldFilter: false, id: id2, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        CommandInput,
        {
          placeholder,
          value,
          onValueChange: handleInputChange
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(CommandEmpty, { children: emptyMessage }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(CommandGroup, { children: options.map((option) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
        CommandItem,
        {
          value: option,
          onSelect: () => handleSelect(option),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Check,
              {
                className: cn$2(
                  "mr-2 h-4 w-4",
                  value === option ? "opacity-100" : "opacity-0"
                )
              }
            ),
            option
          ]
        },
        option
      )) })
    ] }) })
  ] });
}
var NODES = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
];
var Primitive = NODES.reduce((primitive, node) => {
  const Slot2 = /* @__PURE__ */ createSlot$3(`Primitive.${node}`);
  const Node2 = reactExports.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot2 : node;
    if (typeof window !== "undefined") {
      window[/* @__PURE__ */ Symbol.for("radix-ui")] = true;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node2.displayName = `Primitive.${node}`;
  return { ...primitive, [node]: Node2 };
}, {});
var NAME = "Label";
var Label$2 = reactExports.forwardRef((props, forwardedRef) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.label,
    {
      ...props,
      ref: forwardedRef,
      onMouseDown: (event) => {
        const target = event.target;
        if (target.closest("button, input, select, textarea")) return;
        props.onMouseDown?.(event);
        if (!event.defaultPrevented && event.detail > 1) event.preventDefault();
      }
    }
  );
});
Label$2.displayName = NAME;
var Root$1 = Label$2;
const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
);
const Label$1 = reactExports.forwardRef(({ className, ...props }, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Root$1,
  {
    ref: ref2,
    className: cn$2(labelVariants(), className),
    ...props
  }
));
Label$1.displayName = Root$1.displayName;
const Input = reactExports.forwardRef(
  ({ className, type: type2, ...props }, ref2) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "input",
      {
        type: type2,
        className: cn$2(
          "flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-sm shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50",
          className
        ),
        ref: ref2,
        ...props
      }
    );
  }
);
Input.displayName = "Input";
const ListPane = ({
  items: items2,
  listItems,
  clearItems,
  setSelectedItem,
  renderItem,
  title: title2,
  buttonText,
  isButtonDisabled
}) => {
  const [searchQuery, setSearchQuery] = reactExports.useState("");
  const [isSearchExpanded, setIsSearchExpanded] = reactExports.useState(false);
  const searchInputRef = reactExports.useRef(null);
  const filteredItems = reactExports.useMemo(() => {
    if (!searchQuery.trim()) return items2;
    return items2.filter((item) => {
      const searchableText = [
        item.name || "",
        item.description || ""
      ].join(" ").toLowerCase();
      return searchableText.includes(searchQuery.toLowerCase());
    });
  }, [items2, searchQuery]);
  const handleSearchClick = () => {
    setIsSearchExpanded(true);
    setTimeout(() => {
      searchInputRef.current?.focus();
    }, 100);
  };
  const handleSearchBlur = () => {
    if (!searchQuery.trim()) {
      setIsSearchExpanded(false);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-card border border-border rounded-lg shadow", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-4 border-b border-gray-200 dark:border-border", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between gap-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold dark:text-white flex-shrink-0", children: title2 }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-end min-w-0 flex-1", children: !isSearchExpanded ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          name: "search",
          "aria-label": "Search",
          onClick: handleSearchClick,
          className: "p-2 hover:bg-gray-100 dark:hover:bg-secondary rounded-md transition-all duration-300 ease-in-out",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Search, { className: "w-4 h-4 text-muted-foreground" })
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center w-full max-w-xs", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative w-full", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Search, { className: "absolute left-3 top-1/2 transform -translate-y-1/2 w-4 h-4 text-muted-foreground pointer-events-none z-10" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Input,
          {
            ref: searchInputRef,
            name: "search",
            type: "text",
            placeholder: "Search...",
            value: searchQuery,
            onChange: (e) => setSearchQuery(e.target.value),
            onBlur: handleSearchBlur,
            className: "pl-10 w-full transition-all duration-300 ease-in-out"
          }
        )
      ] }) }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          variant: "outline",
          className: "w-full mb-4",
          onClick: listItems,
          disabled: isButtonDisabled,
          children: buttonText
        }
      ),
      clearItems && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          variant: "outline",
          className: "w-full mb-4",
          onClick: clearItems,
          disabled: items2.length === 0,
          children: "Clear"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2 overflow-y-auto max-h-96", children: [
        filteredItems.map((item, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "flex items-center py-2 px-4 rounded hover:bg-gray-50 dark:hover:bg-secondary cursor-pointer",
            onClick: () => setSelectedItem(item),
            children: renderItem(item)
          },
          index2
        )),
        filteredItems.length === 0 && searchQuery && items2.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center py-4 text-muted-foreground", children: [
          'No items found matching "',
          searchQuery,
          '"'
        ] })
      ] })
    ] })
  ] });
};
function debounce(func, wait) {
  let timeout;
  return (...args) => {
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      void func(...args);
    }, wait);
  };
}
function useCompletionState(handleCompletion, completionsSupported = true, debounceMs = 300) {
  const [state, setState] = reactExports.useState({
    completions: {},
    loading: {}
  });
  const abortControllerRef = reactExports.useRef(null);
  const cleanup = reactExports.useCallback(() => {
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
      abortControllerRef.current = null;
    }
  }, []);
  reactExports.useEffect(() => {
    return cleanup;
  }, [cleanup]);
  const clearCompletions = reactExports.useCallback(() => {
    cleanup();
    setState({
      completions: {},
      loading: {}
    });
  }, [cleanup]);
  const requestCompletions = reactExports.useMemo(() => {
    return debounce(
      async (ref2, argName, value, context) => {
        if (!completionsSupported) {
          return;
        }
        cleanup();
        const abortController = new AbortController();
        abortControllerRef.current = abortController;
        setState((prev) => ({
          ...prev,
          loading: { ...prev.loading, [argName]: true }
        }));
        try {
          if (context !== void 0) {
            delete context[argName];
          }
          const values = await handleCompletion(
            ref2,
            argName,
            value,
            context,
            abortController.signal
          );
          if (!abortController.signal.aborted) {
            setState((prev) => ({
              ...prev,
              completions: { ...prev.completions, [argName]: values },
              loading: { ...prev.loading, [argName]: false }
            }));
          }
        } catch {
          console.error("completion failed");
          if (!abortController.signal.aborted) {
            setState((prev) => ({
              ...prev,
              loading: { ...prev.loading, [argName]: false }
            }));
          }
        } finally {
          if (abortControllerRef.current === abortController) {
            abortControllerRef.current = null;
          }
        }
      },
      debounceMs
    );
  }, [handleCompletion, completionsSupported, cleanup, debounceMs]);
  reactExports.useEffect(() => {
    if (!completionsSupported) {
      clearCompletions();
    }
  }, [completionsSupported, clearCompletions]);
  return {
    ...state,
    clearCompletions,
    requestCompletions,
    completionsSupported
  };
}
const IconDisplay = ({
  icons,
  className = "",
  size: size2 = "md"
}) => {
  if (!icons || icons.length === 0) {
    return null;
  }
  const sizeClasses = {
    sm: "w-4 h-4",
    md: "w-6 h-6",
    lg: "w-8 h-8"
  };
  const sizeClass = sizeClasses[size2];
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `flex gap-1 ${className}`, children: icons.map((icon, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "img",
    {
      src: icon.src,
      alt: "",
      className: `${sizeClass} object-contain flex-shrink-0`,
      style: {
        imageRendering: "auto"
      },
      onError: (e) => {
        e.currentTarget.style.display = "none";
      }
    },
    index2
  )) });
};
const PromptsTab = ({
  prompts,
  listPrompts,
  clearPrompts,
  getPrompt,
  selectedPrompt,
  setSelectedPrompt,
  handleCompletion,
  completionsSupported,
  promptContent,
  nextCursor,
  error
}) => {
  const [promptArgs, setPromptArgs] = reactExports.useState({});
  const { completions, clearCompletions, requestCompletions } = useCompletionState(handleCompletion, completionsSupported);
  reactExports.useEffect(() => {
    clearCompletions();
  }, [clearCompletions, selectedPrompt]);
  const triggerCompletions = (argName, value) => {
    if (selectedPrompt) {
      requestCompletions(
        {
          type: "ref/prompt",
          name: selectedPrompt.name
        },
        argName,
        value,
        promptArgs
      );
    }
  };
  const handleInputChange = async (argName, value) => {
    setPromptArgs((prev) => ({ ...prev, [argName]: value }));
    triggerCompletions(argName, value);
  };
  const handleFocus = async (argName) => {
    const currentValue = promptArgs[argName] || "";
    triggerCompletions(argName, currentValue);
  };
  const handleGetPrompt = () => {
    if (selectedPrompt) {
      getPrompt(selectedPrompt.name, promptArgs);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "prompts", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ListPane,
      {
        items: prompts,
        listItems: listPrompts,
        clearItems: () => {
          clearPrompts();
          setSelectedPrompt(null);
        },
        setSelectedItem: (prompt) => {
          setSelectedPrompt(prompt);
          setPromptArgs({});
        },
        renderItem: (prompt) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start w-full gap-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-shrink-0 mt-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconDisplay, { icons: prompt.icons, size: "sm" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col flex-1 min-w-0", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "truncate", children: prompt.name }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm text-gray-500 text-left line-clamp-2", children: prompt.description })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRight, { className: "w-4 h-4 flex-shrink-0 text-gray-400 mt-1" })
        ] }),
        title: "Prompts",
        buttonText: nextCursor ? "List More Prompts" : "List Prompts",
        isButtonDisabled: !nextCursor && prompts.length > 0
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-card border border-border rounded-lg shadow", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-4 border-b border-gray-200 dark:border-border", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
        selectedPrompt && /* @__PURE__ */ jsxRuntimeExports.jsx(
          IconDisplay,
          {
            icons: selectedPrompt.icons,
            size: "md"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold", children: selectedPrompt ? selectedPrompt.name : "Select a prompt" })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-4", children: error ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Alert, { variant: "destructive", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(CircleAlert, { className: "h-4 w-4" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(AlertTitle, { children: "Error" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(AlertDescription, { className: "break-all", children: error })
      ] }) : selectedPrompt ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
        selectedPrompt.description && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-600 dark:text-gray-400", children: selectedPrompt.description }),
        selectedPrompt.arguments?.map((arg) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { htmlFor: arg.name, children: arg.name }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Combobox,
            {
              id: arg.name,
              placeholder: `Enter ${arg.name}`,
              value: promptArgs[arg.name] || "",
              onChange: (value) => handleInputChange(arg.name, value),
              onInputChange: (value) => handleInputChange(arg.name, value),
              onFocus: () => handleFocus(arg.name),
              options: completions[arg.name] || []
            }
          ),
          arg.description && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-xs text-gray-500 mt-1", children: [
            arg.description,
            arg.required && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs mt-1 ml-1", children: "(Required)" })
          ] })
        ] }, arg.name)),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: handleGetPrompt, className: "w-full", children: "Get Prompt" }),
        promptContent && /* @__PURE__ */ jsxRuntimeExports.jsx(JsonView, { data: promptContent, withCopyButton: false })
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(AlertDescription, { children: "Select a prompt from the list to view and use it" }) }) })
    ] })
  ] }) });
};
const MAX_TEMPLATE_LENGTH = 1e6;
const MAX_VARIABLE_LENGTH = 1e6;
const MAX_TEMPLATE_EXPRESSIONS = 1e4;
const MAX_REGEX_LENGTH = 1e6;
class UriTemplate {
  /**
   * Returns true if the given string contains any URI template expressions.
   * A template expression is a sequence of characters enclosed in curly braces,
   * like {foo} or {?bar}.
   */
  static isTemplate(str) {
    return /\{[^}\s]+\}/.test(str);
  }
  static validateLength(str, max2, context) {
    if (str.length > max2) {
      throw new Error(`${context} exceeds maximum length of ${max2} characters (got ${str.length})`);
    }
  }
  get variableNames() {
    return this.parts.flatMap((part) => typeof part === "string" ? [] : part.names);
  }
  constructor(template) {
    UriTemplate.validateLength(template, MAX_TEMPLATE_LENGTH, "Template");
    this.template = template;
    this.parts = this.parse(template);
  }
  toString() {
    return this.template;
  }
  parse(template) {
    const parts = [];
    let currentText = "";
    let i = 0;
    let expressionCount = 0;
    while (i < template.length) {
      if (template[i] === "{") {
        if (currentText) {
          parts.push(currentText);
          currentText = "";
        }
        const end = template.indexOf("}", i);
        if (end === -1)
          throw new Error("Unclosed template expression");
        expressionCount++;
        if (expressionCount > MAX_TEMPLATE_EXPRESSIONS) {
          throw new Error(`Template contains too many expressions (max ${MAX_TEMPLATE_EXPRESSIONS})`);
        }
        const expr = template.slice(i + 1, end);
        const operator = this.getOperator(expr);
        const exploded = expr.includes("*");
        const names2 = this.getNames(expr);
        const name2 = names2[0];
        for (const name3 of names2) {
          UriTemplate.validateLength(name3, MAX_VARIABLE_LENGTH, "Variable name");
        }
        parts.push({ name: name2, operator, names: names2, exploded });
        i = end + 1;
      } else {
        currentText += template[i];
        i++;
      }
    }
    if (currentText) {
      parts.push(currentText);
    }
    return parts;
  }
  getOperator(expr) {
    const operators = ["+", "#", ".", "/", "?", "&"];
    return operators.find((op2) => expr.startsWith(op2)) || "";
  }
  getNames(expr) {
    const operator = this.getOperator(expr);
    return expr.slice(operator.length).split(",").map((name2) => name2.replace("*", "").trim()).filter((name2) => name2.length > 0);
  }
  encodeValue(value, operator) {
    UriTemplate.validateLength(value, MAX_VARIABLE_LENGTH, "Variable value");
    if (operator === "+" || operator === "#") {
      return encodeURI(value);
    }
    return encodeURIComponent(value);
  }
  expandPart(part, variables) {
    if (part.operator === "?" || part.operator === "&") {
      const pairs = part.names.map((name2) => {
        const value2 = variables[name2];
        if (value2 === void 0)
          return "";
        const encoded2 = Array.isArray(value2) ? value2.map((v) => this.encodeValue(v, part.operator)).join(",") : this.encodeValue(value2.toString(), part.operator);
        return `${name2}=${encoded2}`;
      }).filter((pair) => pair.length > 0);
      if (pairs.length === 0)
        return "";
      const separator = part.operator === "?" ? "?" : "&";
      return separator + pairs.join("&");
    }
    if (part.names.length > 1) {
      const values2 = part.names.map((name2) => variables[name2]).filter((v) => v !== void 0);
      if (values2.length === 0)
        return "";
      return values2.map((v) => Array.isArray(v) ? v[0] : v).join(",");
    }
    const value = variables[part.name];
    if (value === void 0)
      return "";
    const values = Array.isArray(value) ? value : [value];
    const encoded = values.map((v) => this.encodeValue(v, part.operator));
    switch (part.operator) {
      case "":
        return encoded.join(",");
      case "+":
        return encoded.join(",");
      case "#":
        return "#" + encoded.join(",");
      case ".":
        return "." + encoded.join(".");
      case "/":
        return "/" + encoded.join("/");
      default:
        return encoded.join(",");
    }
  }
  expand(variables) {
    let result = "";
    let hasQueryParam = false;
    for (const part of this.parts) {
      if (typeof part === "string") {
        result += part;
        continue;
      }
      const expanded = this.expandPart(part, variables);
      if (!expanded)
        continue;
      if ((part.operator === "?" || part.operator === "&") && hasQueryParam) {
        result += expanded.replace("?", "&");
      } else {
        result += expanded;
      }
      if (part.operator === "?" || part.operator === "&") {
        hasQueryParam = true;
      }
    }
    return result;
  }
  escapeRegExp(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  partToRegExp(part) {
    const patterns = [];
    for (const name3 of part.names) {
      UriTemplate.validateLength(name3, MAX_VARIABLE_LENGTH, "Variable name");
    }
    if (part.operator === "?" || part.operator === "&") {
      for (let i = 0; i < part.names.length; i++) {
        const name3 = part.names[i];
        const prefix = i === 0 ? "\\" + part.operator : "&";
        patterns.push({
          pattern: prefix + this.escapeRegExp(name3) + "=([^&]+)",
          name: name3
        });
      }
      return patterns;
    }
    let pattern2;
    const name2 = part.name;
    switch (part.operator) {
      case "":
        pattern2 = part.exploded ? "([^/,]+(?:,[^/,]+)*)" : "([^/,]+)";
        break;
      case "+":
      case "#":
        pattern2 = "(.+)";
        break;
      case ".":
        pattern2 = "\\.([^/,]+)";
        break;
      case "/":
        pattern2 = "/" + (part.exploded ? "([^/,]+(?:,[^/,]+)*)" : "([^/,]+)");
        break;
      default:
        pattern2 = "([^/]+)";
    }
    patterns.push({ pattern: pattern2, name: name2 });
    return patterns;
  }
  match(uri2) {
    UriTemplate.validateLength(uri2, MAX_TEMPLATE_LENGTH, "URI");
    let pattern2 = "^";
    const names2 = [];
    for (const part of this.parts) {
      if (typeof part === "string") {
        pattern2 += this.escapeRegExp(part);
      } else {
        const patterns = this.partToRegExp(part);
        for (const { pattern: partPattern, name: name2 } of patterns) {
          pattern2 += partPattern;
          names2.push({ name: name2, exploded: part.exploded });
        }
      }
    }
    pattern2 += "$";
    UriTemplate.validateLength(pattern2, MAX_REGEX_LENGTH, "Generated regex pattern");
    const regex = new RegExp(pattern2);
    const match = uri2.match(regex);
    if (!match)
      return null;
    const result = {};
    for (let i = 0; i < names2.length; i++) {
      const { name: name2, exploded } = names2[i];
      const value = match[i + 1];
      const cleanName = name2.replace("*", "");
      if (exploded && value.includes(",")) {
        result[cleanName] = value.split(",");
      } else {
        result[cleanName] = value;
      }
    }
    return result;
  }
}
const ResourcesTab = ({
  resources,
  resourceTemplates,
  listResources,
  clearResources,
  listResourceTemplates,
  clearResourceTemplates,
  readResource,
  selectedResource,
  setSelectedResource,
  resourceSubscriptionsSupported,
  resourceSubscriptions,
  subscribeToResource,
  unsubscribeFromResource,
  handleCompletion,
  completionsSupported,
  resourceContent,
  nextCursor,
  nextTemplateCursor,
  error
}) => {
  const [selectedTemplate, setSelectedTemplate] = reactExports.useState(null);
  const [templateValues, setTemplateValues] = reactExports.useState(
    {}
  );
  const { completions, clearCompletions, requestCompletions } = useCompletionState(handleCompletion, completionsSupported);
  reactExports.useEffect(() => {
    clearCompletions();
  }, [clearCompletions]);
  const fillTemplate = (template, values) => {
    return new UriTemplate(template).expand(values);
  };
  const handleTemplateValueChange = async (key, value) => {
    setTemplateValues((prev) => ({ ...prev, [key]: value }));
    if (selectedTemplate?.uriTemplate) {
      requestCompletions(
        {
          type: "ref/resource",
          uri: selectedTemplate.uriTemplate
        },
        key,
        value,
        templateValues
      );
    }
  };
  const handleReadTemplateResource = () => {
    if (selectedTemplate) {
      const uri2 = fillTemplate(selectedTemplate.uriTemplate, templateValues);
      readResource(uri2);
      setSelectedResource({ uri: uri2, name: uri2 });
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "resources", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-3 gap-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ListPane,
      {
        items: resources,
        listItems: listResources,
        clearItems: () => {
          clearResources();
          if (!selectedTemplate) {
            setSelectedResource(null);
          }
        },
        setSelectedItem: (resource) => {
          setSelectedResource(resource);
          readResource(resource.uri);
          setSelectedTemplate(null);
        },
        renderItem: (resource) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center w-full", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IconDisplay, { icons: resource.icons, size: "sm" }),
          !resource.icons && /* @__PURE__ */ jsxRuntimeExports.jsx(FileText, { className: "w-4 h-4 mr-2 flex-shrink-0 text-gray-500" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "flex-1 truncate", title: resource.uri.toString(), children: resource.name }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRight, { className: "w-4 h-4 flex-shrink-0 text-gray-400" })
        ] }),
        title: "Resources",
        buttonText: nextCursor ? "List More Resources" : "List Resources",
        isButtonDisabled: !nextCursor && resources.length > 0
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ListPane,
      {
        items: resourceTemplates,
        listItems: listResourceTemplates,
        clearItems: () => {
          clearResourceTemplates();
          if (selectedTemplate) {
            setSelectedResource(null);
          }
          setSelectedTemplate(null);
        },
        setSelectedItem: (template) => {
          setSelectedTemplate(template);
          setSelectedResource(null);
          setTemplateValues({});
        },
        renderItem: (template) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center w-full", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IconDisplay, { icons: template.icons, size: "sm" }),
          !template.icons && /* @__PURE__ */ jsxRuntimeExports.jsx(FileText, { className: "w-4 h-4 mr-2 flex-shrink-0 text-gray-500" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "flex-1 truncate", title: template.uriTemplate, children: template.name }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRight, { className: "w-4 h-4 flex-shrink-0 text-gray-400" })
        ] }),
        title: "Resource Templates",
        buttonText: nextTemplateCursor ? "List More Templates" : "List Templates",
        isButtonDisabled: !nextTemplateCursor && resourceTemplates.length > 0
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-card border border-border rounded-lg shadow", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 border-b border-gray-200 dark:border-border flex justify-between items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 truncate", children: [
          (selectedResource || selectedTemplate) && /* @__PURE__ */ jsxRuntimeExports.jsx(
            IconDisplay,
            {
              icons: (selectedResource || selectedTemplate).icons,
              size: "md"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "h3",
            {
              className: "font-semibold truncate",
              title: selectedResource?.name || selectedTemplate?.name,
              children: selectedResource ? selectedResource.name : selectedTemplate ? selectedTemplate.name : "Select a resource or template"
            }
          )
        ] }),
        selectedResource && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex row-auto gap-1 justify-end w-2/5", children: [
          resourceSubscriptionsSupported && !resourceSubscriptions.has(selectedResource.uri) && /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              variant: "outline",
              size: "sm",
              onClick: () => subscribeToResource(selectedResource.uri),
              children: "Subscribe"
            }
          ),
          resourceSubscriptionsSupported && resourceSubscriptions.has(selectedResource.uri) && /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              variant: "outline",
              size: "sm",
              onClick: () => unsubscribeFromResource(selectedResource.uri),
              children: "Unsubscribe"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Button,
            {
              variant: "outline",
              size: "sm",
              onClick: () => readResource(selectedResource.uri),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(RefreshCw, { className: "w-4 h-4 mr-2" }),
                "Refresh"
              ]
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-4", children: error ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Alert, { variant: "destructive", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(CircleAlert, { className: "h-4 w-4" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(AlertTitle, { children: "Error" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(AlertDescription, { className: "break-all", children: error })
      ] }) : selectedResource ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        JsonView,
        {
          data: resourceContent,
          className: "bg-gray-50 dark:bg-gray-800 p-4 rounded text-sm overflow-auto max-h-96 text-gray-900 dark:text-gray-100"
        }
      ) : selectedTemplate ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-600 dark:text-gray-400", children: selectedTemplate.description }),
        new UriTemplate(
          selectedTemplate.uriTemplate
        ).variableNames?.map((key) => {
          return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { htmlFor: key, children: key }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Combobox,
              {
                id: key,
                placeholder: `Enter ${key}`,
                value: templateValues[key] || "",
                onChange: (value) => handleTemplateValueChange(key, value),
                onInputChange: (value) => handleTemplateValueChange(key, value),
                options: completions[key] || []
              }
            )
          ] }, key);
        }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            onClick: handleReadTemplateResource,
            disabled: Object.keys(templateValues).length === 0,
            children: "Read Resource"
          }
        )
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(AlertDescription, { children: "Select a resource or template from the list to view its contents" }) }) })
    ] })
  ] }) });
};
const RootsTab = ({
  roots,
  setRoots,
  onRootsChange
}) => {
  const addRoot = () => {
    setRoots((currentRoots) => [...currentRoots, { uri: "file://", name: "" }]);
  };
  const removeRoot = (index2) => {
    setRoots((currentRoots) => currentRoots.filter((_2, i) => i !== index2));
  };
  const updateRoot = (index2, field, value) => {
    setRoots(
      (currentRoots) => currentRoots.map(
        (root, i) => i === index2 ? { ...root, [field]: value } : root
      )
    );
  };
  const handleSave = () => {
    onRootsChange();
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "roots", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(AlertDescription, { children: "Configure the root directories that the server can access" }) }),
    roots.map((root, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2 items-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Input,
        {
          placeholder: "file:// URI",
          value: root.uri,
          onChange: (e) => updateRoot(index2, "uri", e.target.value),
          className: "flex-1"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          variant: "destructive",
          size: "sm",
          onClick: () => removeRoot(index2),
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Minus, { className: "h-4 w-4" })
        }
      )
    ] }, index2)),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { variant: "outline", onClick: addRoot, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Plus, { className: "h-4 w-4 mr-2" }),
        "Add Root"
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { onClick: handleSave, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Save, { className: "h-4 w-4 mr-2" }),
        "Save Changes"
      ] })
    ] })
  ] }) });
};
var lib = {};
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib;
  hasRequiredLib = 1;
  var __assign2 = lib && lib.__assign || function() {
    __assign2 = Object.assign || function(t) {
      for (var s2, i = 1, n = arguments.length; i < n; i++) {
        s2 = arguments[i];
        for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
      }
      return t;
    };
    return __assign2.apply(this, arguments);
  };
  var __createBinding = lib && lib.__createBinding || (Object.create ? (function(o, m2, k2, k22) {
    if (k22 === void 0) k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o, k22, desc);
  }) : (function(o, m2, k2, k22) {
    if (k22 === void 0) k22 = k2;
    o[k22] = m2[k2];
  }));
  var __setModuleDefault = lib && lib.__setModuleDefault || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
    o["default"] = v;
  });
  var __importStar = lib && lib.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __rest2 = lib && lib.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  Object.defineProperty(lib, "__esModule", { value: true });
  var React2 = __importStar(requireReact());
  var KEYCODE_Y = 89;
  var KEYCODE_Z = 90;
  var KEYCODE_M = 77;
  var KEYCODE_PARENS = 57;
  var KEYCODE_BRACKETS = 219;
  var KEYCODE_QUOTE = 222;
  var KEYCODE_BACK_QUOTE = 192;
  var HISTORY_LIMIT = 100;
  var HISTORY_TIME_GAP = 3e3;
  var isWindows = typeof window !== "undefined" && "navigator" in window && /Win/i.test(navigator.platform);
  var isMacLike = typeof window !== "undefined" && "navigator" in window && /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform);
  var className = "npm__react-simple-code-editor__textarea";
  var cssText = (
    /* CSS */
    "\n/**\n * Reset the text fill color so that placeholder is visible\n */\n.".concat(className, ":empty {\n  -webkit-text-fill-color: inherit !important;\n}\n\n/**\n * Hack to apply on some CSS on IE10 and IE11\n */\n@media all and (-ms-high-contrast: none), (-ms-high-contrast: active) {\n  /**\n    * IE doesn't support '-webkit-text-fill-color'\n    * So we use 'color: transparent' to make the text transparent on IE\n    * Unlike other browsers, it doesn't affect caret color in IE\n    */\n  .").concat(className, " {\n    color: transparent !important;\n  }\n\n  .").concat(className, "::selection {\n    background-color: #accef7 !important;\n    color: transparent !important;\n  }\n}\n")
  );
  var Editor2 = React2.forwardRef(function Editor3(props, ref2) {
    var autoFocus = props.autoFocus, disabled = props.disabled, form = props.form, highlight = props.highlight, _a2 = props.ignoreTabKey, ignoreTabKey = _a2 === void 0 ? false : _a2, _b = props.insertSpaces, insertSpaces = _b === void 0 ? true : _b, maxLength = props.maxLength, minLength = props.minLength, name2 = props.name, onBlur = props.onBlur, onClick = props.onClick, onFocus = props.onFocus, onKeyDown = props.onKeyDown, onKeyUp = props.onKeyUp, onValueChange = props.onValueChange, _c2 = props.padding, padding = _c2 === void 0 ? 0 : _c2, placeholder = props.placeholder, preClassName = props.preClassName, readOnly = props.readOnly, required2 = props.required, style = props.style, _d2 = props.tabSize, tabSize = _d2 === void 0 ? 2 : _d2, textareaClassName = props.textareaClassName, textareaId = props.textareaId, value = props.value, rest = __rest2(props, ["autoFocus", "disabled", "form", "highlight", "ignoreTabKey", "insertSpaces", "maxLength", "minLength", "name", "onBlur", "onClick", "onFocus", "onKeyDown", "onKeyUp", "onValueChange", "padding", "placeholder", "preClassName", "readOnly", "required", "style", "tabSize", "textareaClassName", "textareaId", "value"]);
    var historyRef = React2.useRef({
      stack: [],
      offset: -1
    });
    var inputRef = React2.useRef(null);
    var _e2 = React2.useState(true), capture = _e2[0], setCapture = _e2[1];
    var contentStyle = {
      paddingTop: typeof padding === "object" ? padding.top : padding,
      paddingRight: typeof padding === "object" ? padding.right : padding,
      paddingBottom: typeof padding === "object" ? padding.bottom : padding,
      paddingLeft: typeof padding === "object" ? padding.left : padding
    };
    var highlighted = highlight(value);
    var getLines = function(text, position) {
      return text.substring(0, position).split("\n");
    };
    var recordChange = React2.useCallback(function(record2, overwrite) {
      var _a3, _b2, _c3;
      if (overwrite === void 0) {
        overwrite = false;
      }
      var _d3 = historyRef.current, stack = _d3.stack, offset2 = _d3.offset;
      if (stack.length && offset2 > -1) {
        historyRef.current.stack = stack.slice(0, offset2 + 1);
        var count2 = historyRef.current.stack.length;
        if (count2 > HISTORY_LIMIT) {
          var extras = count2 - HISTORY_LIMIT;
          historyRef.current.stack = stack.slice(extras, count2);
          historyRef.current.offset = Math.max(historyRef.current.offset - extras, 0);
        }
      }
      var timestamp = Date.now();
      if (overwrite) {
        var last = historyRef.current.stack[historyRef.current.offset];
        if (last && timestamp - last.timestamp < HISTORY_TIME_GAP) {
          var re2 = /[^a-z0-9]([a-z0-9]+)$/i;
          var previous = (_a3 = getLines(last.value, last.selectionStart).pop()) === null || _a3 === void 0 ? void 0 : _a3.match(re2);
          var current = (_b2 = getLines(record2.value, record2.selectionStart).pop()) === null || _b2 === void 0 ? void 0 : _b2.match(re2);
          if ((previous === null || previous === void 0 ? void 0 : previous[1]) && ((_c3 = current === null || current === void 0 ? void 0 : current[1]) === null || _c3 === void 0 ? void 0 : _c3.startsWith(previous[1]))) {
            historyRef.current.stack[historyRef.current.offset] = __assign2(__assign2({}, record2), { timestamp });
            return;
          }
        }
      }
      historyRef.current.stack.push(__assign2(__assign2({}, record2), { timestamp }));
      historyRef.current.offset++;
    }, []);
    var recordCurrentState = React2.useCallback(function() {
      var input = inputRef.current;
      if (!input)
        return;
      var value2 = input.value, selectionStart = input.selectionStart, selectionEnd = input.selectionEnd;
      recordChange({
        value: value2,
        selectionStart,
        selectionEnd
      });
    }, [recordChange]);
    var updateInput = function(record2) {
      var input = inputRef.current;
      if (!input)
        return;
      input.value = record2.value;
      input.selectionStart = record2.selectionStart;
      input.selectionEnd = record2.selectionEnd;
      onValueChange === null || onValueChange === void 0 ? void 0 : onValueChange(record2.value);
    };
    var applyEdits = function(record2) {
      var input = inputRef.current;
      var last = historyRef.current.stack[historyRef.current.offset];
      if (last && input) {
        historyRef.current.stack[historyRef.current.offset] = __assign2(__assign2({}, last), { selectionStart: input.selectionStart, selectionEnd: input.selectionEnd });
      }
      recordChange(record2);
      updateInput(record2);
    };
    var undoEdit = function() {
      var _a3 = historyRef.current, stack = _a3.stack, offset2 = _a3.offset;
      var record2 = stack[offset2 - 1];
      if (record2) {
        updateInput(record2);
        historyRef.current.offset = Math.max(offset2 - 1, 0);
      }
    };
    var redoEdit = function() {
      var _a3 = historyRef.current, stack = _a3.stack, offset2 = _a3.offset;
      var record2 = stack[offset2 + 1];
      if (record2) {
        updateInput(record2);
        historyRef.current.offset = Math.min(offset2 + 1, stack.length - 1);
      }
    };
    var handleKeyDown = function(e) {
      if (onKeyDown) {
        onKeyDown(e);
        if (e.defaultPrevented) {
          return;
        }
      }
      if (e.key === "Escape") {
        e.currentTarget.blur();
      }
      var _a3 = e.currentTarget, value2 = _a3.value, selectionStart = _a3.selectionStart, selectionEnd = _a3.selectionEnd;
      var tabCharacter = (insertSpaces ? " " : "	").repeat(tabSize);
      if (e.key === "Tab" && !ignoreTabKey && capture) {
        e.preventDefault();
        if (e.shiftKey) {
          var linesBeforeCaret = getLines(value2, selectionStart);
          var startLine_1 = linesBeforeCaret.length - 1;
          var endLine_1 = getLines(value2, selectionEnd).length - 1;
          var nextValue = value2.split("\n").map(function(line2, i) {
            if (i >= startLine_1 && i <= endLine_1 && line2.startsWith(tabCharacter)) {
              return line2.substring(tabCharacter.length);
            }
            return line2;
          }).join("\n");
          if (value2 !== nextValue) {
            var startLineText = linesBeforeCaret[startLine_1];
            applyEdits({
              value: nextValue,
              // Move the start cursor if first line in selection was modified
              // It was modified only if it started with a tab
              selectionStart: (startLineText === null || startLineText === void 0 ? void 0 : startLineText.startsWith(tabCharacter)) ? selectionStart - tabCharacter.length : selectionStart,
              // Move the end cursor by total number of characters removed
              selectionEnd: selectionEnd - (value2.length - nextValue.length)
            });
          }
        } else if (selectionStart !== selectionEnd) {
          var linesBeforeCaret = getLines(value2, selectionStart);
          var startLine_2 = linesBeforeCaret.length - 1;
          var endLine_2 = getLines(value2, selectionEnd).length - 1;
          var startLineText = linesBeforeCaret[startLine_2];
          applyEdits({
            value: value2.split("\n").map(function(line2, i) {
              if (i >= startLine_2 && i <= endLine_2) {
                return tabCharacter + line2;
              }
              return line2;
            }).join("\n"),
            // Move the start cursor by number of characters added in first line of selection
            // Don't move it if it there was no text before cursor
            selectionStart: startLineText && /\S/.test(startLineText) ? selectionStart + tabCharacter.length : selectionStart,
            // Move the end cursor by total number of characters added
            selectionEnd: selectionEnd + tabCharacter.length * (endLine_2 - startLine_2 + 1)
          });
        } else {
          var updatedSelection = selectionStart + tabCharacter.length;
          applyEdits({
            // Insert tab character at caret
            value: value2.substring(0, selectionStart) + tabCharacter + value2.substring(selectionEnd),
            // Update caret position
            selectionStart: updatedSelection,
            selectionEnd: updatedSelection
          });
        }
      } else if (e.key === "Backspace") {
        var hasSelection = selectionStart !== selectionEnd;
        var textBeforeCaret = value2.substring(0, selectionStart);
        if (textBeforeCaret.endsWith(tabCharacter) && !hasSelection) {
          e.preventDefault();
          var updatedSelection = selectionStart - tabCharacter.length;
          applyEdits({
            // Remove tab character at caret
            value: value2.substring(0, selectionStart - tabCharacter.length) + value2.substring(selectionEnd),
            // Update caret position
            selectionStart: updatedSelection,
            selectionEnd: updatedSelection
          });
        }
      } else if (e.key === "Enter") {
        if (selectionStart === selectionEnd) {
          var line = getLines(value2, selectionStart).pop();
          var matches = line === null || line === void 0 ? void 0 : line.match(/^\s+/);
          if (matches === null || matches === void 0 ? void 0 : matches[0]) {
            e.preventDefault();
            var indent = "\n" + matches[0];
            var updatedSelection = selectionStart + indent.length;
            applyEdits({
              // Insert indentation character at caret
              value: value2.substring(0, selectionStart) + indent + value2.substring(selectionEnd),
              // Update caret position
              selectionStart: updatedSelection,
              selectionEnd: updatedSelection
            });
          }
        }
      } else if (e.keyCode === KEYCODE_PARENS || e.keyCode === KEYCODE_BRACKETS || e.keyCode === KEYCODE_QUOTE || e.keyCode === KEYCODE_BACK_QUOTE) {
        var chars = void 0;
        if (e.keyCode === KEYCODE_PARENS && e.shiftKey) {
          chars = ["(", ")"];
        } else if (e.keyCode === KEYCODE_BRACKETS) {
          if (e.shiftKey) {
            chars = ["{", "}"];
          } else {
            chars = ["[", "]"];
          }
        } else if (e.keyCode === KEYCODE_QUOTE) {
          if (e.shiftKey) {
            chars = ['"', '"'];
          } else {
            chars = ["'", "'"];
          }
        } else if (e.keyCode === KEYCODE_BACK_QUOTE && !e.shiftKey) {
          chars = ["`", "`"];
        }
        if (selectionStart !== selectionEnd && chars) {
          e.preventDefault();
          applyEdits({
            value: value2.substring(0, selectionStart) + chars[0] + value2.substring(selectionStart, selectionEnd) + chars[1] + value2.substring(selectionEnd),
            // Update caret position
            selectionStart,
            selectionEnd: selectionEnd + 2
          });
        }
      } else if ((isMacLike ? (
        // Trigger undo with +Z on Mac
        e.metaKey && e.keyCode === KEYCODE_Z
      ) : (
        // Trigger undo with Ctrl+Z on other platforms
        e.ctrlKey && e.keyCode === KEYCODE_Z
      )) && !e.shiftKey && !e.altKey) {
        e.preventDefault();
        undoEdit();
      } else if ((isMacLike ? (
        // Trigger redo with +Shift+Z on Mac
        e.metaKey && e.keyCode === KEYCODE_Z && e.shiftKey
      ) : isWindows ? (
        // Trigger redo with Ctrl+Y on Windows
        e.ctrlKey && e.keyCode === KEYCODE_Y
      ) : (
        // Trigger redo with Ctrl+Shift+Z on other platforms
        e.ctrlKey && e.keyCode === KEYCODE_Z && e.shiftKey
      )) && !e.altKey) {
        e.preventDefault();
        redoEdit();
      } else if (e.keyCode === KEYCODE_M && e.ctrlKey && (isMacLike ? e.shiftKey : true)) {
        e.preventDefault();
        setCapture(function(prev) {
          return !prev;
        });
      }
    };
    var handleChange = function(e) {
      var _a3 = e.currentTarget, value2 = _a3.value, selectionStart = _a3.selectionStart, selectionEnd = _a3.selectionEnd;
      recordChange({
        value: value2,
        selectionStart,
        selectionEnd
      }, true);
      onValueChange(value2);
    };
    React2.useEffect(function() {
      recordCurrentState();
    }, [recordCurrentState]);
    React2.useImperativeHandle(ref2, function() {
      return {
        get session() {
          return {
            history: historyRef.current
          };
        },
        set session(session) {
          historyRef.current = session.history;
        }
      };
    }, []);
    return React2.createElement(
      "div",
      __assign2({}, rest, { style: __assign2(__assign2({}, styles.container), style) }),
      React2.createElement("pre", __assign2({ className: preClassName, "aria-hidden": "true", style: __assign2(__assign2(__assign2({}, styles.editor), styles.highlight), contentStyle) }, typeof highlighted === "string" ? { dangerouslySetInnerHTML: { __html: highlighted + "<br />" } } : { children: highlighted })),
      React2.createElement("textarea", { ref: function(c) {
        return inputRef.current = c;
      }, style: __assign2(__assign2(__assign2({}, styles.editor), styles.textarea), contentStyle), className: className + (textareaClassName ? " ".concat(textareaClassName) : ""), id: textareaId, value, onChange: handleChange, onKeyDown: handleKeyDown, onClick, onKeyUp, onFocus, onBlur, disabled, form, maxLength, minLength, name: name2, placeholder, readOnly, required: required2, autoFocus, autoCapitalize: "off", autoComplete: "off", autoCorrect: "off", spellCheck: false, "data-gramm": false }),
      React2.createElement("style", { dangerouslySetInnerHTML: { __html: cssText } })
    );
  });
  var styles = {
    container: {
      position: "relative",
      textAlign: "left",
      boxSizing: "border-box",
      padding: 0,
      overflow: "hidden"
    },
    textarea: {
      position: "absolute",
      top: 0,
      left: 0,
      height: "100%",
      width: "100%",
      resize: "none",
      color: "inherit",
      overflow: "hidden",
      MozOsxFontSmoothing: "grayscale",
      WebkitFontSmoothing: "antialiased",
      WebkitTextFillColor: "transparent"
    },
    highlight: {
      position: "relative",
      pointerEvents: "none"
    },
    editor: {
      margin: 0,
      border: 0,
      background: "none",
      boxSizing: "inherit",
      display: "inherit",
      fontFamily: "inherit",
      fontSize: "inherit",
      fontStyle: "inherit",
      fontVariantLigatures: "inherit",
      fontWeight: "inherit",
      letterSpacing: "inherit",
      lineHeight: "inherit",
      tabSize: "inherit",
      textIndent: "inherit",
      textRendering: "inherit",
      textTransform: "inherit",
      whiteSpace: "pre-wrap",
      wordBreak: "keep-all",
      overflowWrap: "break-word"
    }
  };
  lib.default = Editor2;
  return lib;
}
var libExports = requireLib();
const Editor = /* @__PURE__ */ getDefaultExportFromCjs(libExports);
var prism = { exports: {} };
var hasRequiredPrism;
function requirePrism() {
  if (hasRequiredPrism) return prism.exports;
  hasRequiredPrism = 1;
  (function(module) {
    var _self = typeof window !== "undefined" ? window : typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope ? self : {};
    var Prism2 = (function(_self2) {
      var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
      var uniqueId = 0;
      var plainTextGrammar = {};
      var _2 = {
        /**
         * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
         * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
         * additional languages or plugins yourself.
         *
         * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
         *
         * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
         * empty Prism object into the global scope before loading the Prism script like this:
         *
         * ```js
         * window.Prism = window.Prism || {};
         * Prism.manual = true;
         * // add a new <script> to load Prism's script
         * ```
         *
         * @default false
         * @type {boolean}
         * @memberof Prism
         * @public
         */
        manual: _self2.Prism && _self2.Prism.manual,
        /**
         * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
         * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
         * own worker, you don't want it to do this.
         *
         * By setting this value to `true`, Prism will not add its own listeners to the worker.
         *
         * You obviously have to change this value before Prism executes. To do this, you can add an
         * empty Prism object into the global scope before loading the Prism script like this:
         *
         * ```js
         * window.Prism = window.Prism || {};
         * Prism.disableWorkerMessageHandler = true;
         * // Load Prism's script
         * ```
         *
         * @default false
         * @type {boolean}
         * @memberof Prism
         * @public
         */
        disableWorkerMessageHandler: _self2.Prism && _self2.Prism.disableWorkerMessageHandler,
        /**
         * A namespace for utility methods.
         *
         * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
         * change or disappear at any time.
         *
         * @namespace
         * @memberof Prism
         */
        util: {
          encode: function encode(tokens) {
            if (tokens instanceof Token) {
              return new Token(tokens.type, encode(tokens.content), tokens.alias);
            } else if (Array.isArray(tokens)) {
              return tokens.map(encode);
            } else {
              return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
            }
          },
          /**
           * Returns the name of the type of the given value.
           *
           * @param {any} o
           * @returns {string}
           * @example
           * type(null)      === 'Null'
           * type(undefined) === 'Undefined'
           * type(123)       === 'Number'
           * type('foo')     === 'String'
           * type(true)      === 'Boolean'
           * type([1, 2])    === 'Array'
           * type({})        === 'Object'
           * type(String)    === 'Function'
           * type(/abc+/)    === 'RegExp'
           */
          type: function(o) {
            return Object.prototype.toString.call(o).slice(8, -1);
          },
          /**
           * Returns a unique number for the given object. Later calls will still return the same number.
           *
           * @param {Object} obj
           * @returns {number}
           */
          objId: function(obj) {
            if (!obj["__id"]) {
              Object.defineProperty(obj, "__id", { value: ++uniqueId });
            }
            return obj["__id"];
          },
          /**
           * Creates a deep clone of the given object.
           *
           * The main intended use of this function is to clone language definitions.
           *
           * @param {T} o
           * @param {Record<number, any>} [visited]
           * @returns {T}
           * @template T
           */
          clone: function deepClone(o, visited) {
            visited = visited || {};
            var clone2;
            var id2;
            switch (_2.util.type(o)) {
              case "Object":
                id2 = _2.util.objId(o);
                if (visited[id2]) {
                  return visited[id2];
                }
                clone2 = /** @type {Record<string, any>} */
                {};
                visited[id2] = clone2;
                for (var key in o) {
                  if (o.hasOwnProperty(key)) {
                    clone2[key] = deepClone(o[key], visited);
                  }
                }
                return (
                  /** @type {any} */
                  clone2
                );
              case "Array":
                id2 = _2.util.objId(o);
                if (visited[id2]) {
                  return visited[id2];
                }
                clone2 = [];
                visited[id2] = clone2;
                /** @type {Array} */
                /** @type {any} */
                o.forEach(function(v, i) {
                  clone2[i] = deepClone(v, visited);
                });
                return (
                  /** @type {any} */
                  clone2
                );
              default:
                return o;
            }
          },
          /**
           * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
           *
           * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
           *
           * @param {Element} element
           * @returns {string}
           */
          getLanguage: function(element) {
            while (element) {
              var m2 = lang.exec(element.className);
              if (m2) {
                return m2[1].toLowerCase();
              }
              element = element.parentElement;
            }
            return "none";
          },
          /**
           * Sets the Prism `language-xxxx` class of the given element.
           *
           * @param {Element} element
           * @param {string} language
           * @returns {void}
           */
          setLanguage: function(element, language) {
            element.className = element.className.replace(RegExp(lang, "gi"), "");
            element.classList.add("language-" + language);
          },
          /**
           * Returns the script element that is currently executing.
           *
           * This does __not__ work for line script element.
           *
           * @returns {HTMLScriptElement | null}
           */
          currentScript: function() {
            if (typeof document === "undefined") {
              return null;
            }
            if (document.currentScript && document.currentScript.tagName === "SCRIPT" && 1 < 2) {
              return (
                /** @type {any} */
                document.currentScript
              );
            }
            try {
              throw new Error();
            } catch (err) {
              var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
              if (src) {
                var scripts = document.getElementsByTagName("script");
                for (var i in scripts) {
                  if (scripts[i].src == src) {
                    return scripts[i];
                  }
                }
              }
              return null;
            }
          },
          /**
           * Returns whether a given class is active for `element`.
           *
           * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
           * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
           * given class is just the given class with a `no-` prefix.
           *
           * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
           * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
           * ancestors have the given class or the negated version of it, then the default activation will be returned.
           *
           * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
           * version of it, the class is considered active.
           *
           * @param {Element} element
           * @param {string} className
           * @param {boolean} [defaultActivation=false]
           * @returns {boolean}
           */
          isActive: function(element, className, defaultActivation) {
            var no2 = "no-" + className;
            while (element) {
              var classList = element.classList;
              if (classList.contains(className)) {
                return true;
              }
              if (classList.contains(no2)) {
                return false;
              }
              element = element.parentElement;
            }
            return !!defaultActivation;
          }
        },
        /**
         * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
         *
         * @namespace
         * @memberof Prism
         * @public
         */
        languages: {
          /**
           * The grammar for plain, unformatted text.
           */
          plain: plainTextGrammar,
          plaintext: plainTextGrammar,
          text: plainTextGrammar,
          txt: plainTextGrammar,
          /**
           * Creates a deep copy of the language with the given id and appends the given tokens.
           *
           * If a token in `redef` also appears in the copied language, then the existing token in the copied language
           * will be overwritten at its original position.
           *
           * ## Best practices
           *
           * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
           * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
           * understand the language definition because, normally, the order of tokens matters in Prism grammars.
           *
           * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
           * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
           *
           * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
           * @param {Grammar} redef The new tokens to append.
           * @returns {Grammar} The new language created.
           * @public
           * @example
           * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
           *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
           *     // at its original position
           *     'comment': { ... },
           *     // CSS doesn't have a 'color' token, so this token will be appended
           *     'color': /\b(?:red|green|blue)\b/
           * });
           */
          extend: function(id2, redef) {
            var lang2 = _2.util.clone(_2.languages[id2]);
            for (var key in redef) {
              lang2[key] = redef[key];
            }
            return lang2;
          },
          /**
           * Inserts tokens _before_ another token in a language definition or any other grammar.
           *
           * ## Usage
           *
           * This helper method makes it easy to modify existing languages. For example, the CSS language definition
           * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
           * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
           * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
           * this:
           *
           * ```js
           * Prism.languages.markup.style = {
           *     // token
           * };
           * ```
           *
           * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
           * before existing tokens. For the CSS example above, you would use it like this:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'cdata', {
           *     'style': {
           *         // token
           *     }
           * });
           * ```
           *
           * ## Special cases
           *
           * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
           * will be ignored.
           *
           * This behavior can be used to insert tokens after `before`:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'comment', {
           *     'comment': Prism.languages.markup.comment,
           *     // tokens after 'comment'
           * });
           * ```
           *
           * ## Limitations
           *
           * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
           * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
           * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
           * deleting properties which is necessary to insert at arbitrary positions.
           *
           * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
           * Instead, it will create a new object and replace all references to the target object with the new one. This
           * can be done without temporarily deleting properties, so the iteration order is well-defined.
           *
           * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
           * you hold the target object in a variable, then the value of the variable will not change.
           *
           * ```js
           * var oldMarkup = Prism.languages.markup;
           * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
           *
           * assert(oldMarkup !== Prism.languages.markup);
           * assert(newMarkup === Prism.languages.markup);
           * ```
           *
           * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
           * object to be modified.
           * @param {string} before The key to insert before.
           * @param {Grammar} insert An object containing the key-value pairs to be inserted.
           * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
           * object to be modified.
           *
           * Defaults to `Prism.languages`.
           * @returns {Grammar} The new grammar object.
           * @public
           */
          insertBefore: function(inside, before, insert, root) {
            root = root || /** @type {any} */
            _2.languages;
            var grammar = root[inside];
            var ret = {};
            for (var token in grammar) {
              if (grammar.hasOwnProperty(token)) {
                if (token == before) {
                  for (var newToken in insert) {
                    if (insert.hasOwnProperty(newToken)) {
                      ret[newToken] = insert[newToken];
                    }
                  }
                }
                if (!insert.hasOwnProperty(token)) {
                  ret[token] = grammar[token];
                }
              }
            }
            var old = root[inside];
            root[inside] = ret;
            _2.languages.DFS(_2.languages, function(key, value) {
              if (value === old && key != inside) {
                this[key] = ret;
              }
            });
            return ret;
          },
          // Traverse a language definition with Depth First Search
          DFS: function DFS(o, callback, type2, visited) {
            visited = visited || {};
            var objId = _2.util.objId;
            for (var i in o) {
              if (o.hasOwnProperty(i)) {
                callback.call(o, i, o[i], type2 || i);
                var property = o[i];
                var propertyType = _2.util.type(property);
                if (propertyType === "Object" && !visited[objId(property)]) {
                  visited[objId(property)] = true;
                  DFS(property, callback, null, visited);
                } else if (propertyType === "Array" && !visited[objId(property)]) {
                  visited[objId(property)] = true;
                  DFS(property, callback, i, visited);
                }
              }
            }
          }
        },
        plugins: {},
        /**
         * This is the most high-level function in Prisms API.
         * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
         * each one of them.
         *
         * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
         *
         * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
         * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
         * @memberof Prism
         * @public
         */
        highlightAll: function(async2, callback) {
          _2.highlightAllUnder(document, async2, callback);
        },
        /**
         * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
         * {@link Prism.highlightElement} on each one of them.
         *
         * The following hooks will be run:
         * 1. `before-highlightall`
         * 2. `before-all-elements-highlight`
         * 3. All hooks of {@link Prism.highlightElement} for each element.
         *
         * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
         * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
         * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
         * @memberof Prism
         * @public
         */
        highlightAllUnder: function(container, async2, callback) {
          var env = {
            callback,
            container,
            selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
          };
          _2.hooks.run("before-highlightall", env);
          env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));
          _2.hooks.run("before-all-elements-highlight", env);
          for (var i = 0, element; element = env.elements[i++]; ) {
            _2.highlightElement(element, async2 === true, env.callback);
          }
        },
        /**
         * Highlights the code inside a single element.
         *
         * The following hooks will be run:
         * 1. `before-sanity-check`
         * 2. `before-highlight`
         * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
         * 4. `before-insert`
         * 5. `after-highlight`
         * 6. `complete`
         *
         * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
         * the element's language.
         *
         * @param {Element} element The element containing the code.
         * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
         * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
         * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
         * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
         *
         * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
         * asynchronous highlighting to work. You can build your own bundle on the
         * [Download page](https://prismjs.com/download.html).
         * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
         * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
         * @memberof Prism
         * @public
         */
        highlightElement: function(element, async2, callback) {
          var language = _2.util.getLanguage(element);
          var grammar = _2.languages[language];
          _2.util.setLanguage(element, language);
          var parent = element.parentElement;
          if (parent && parent.nodeName.toLowerCase() === "pre") {
            _2.util.setLanguage(parent, language);
          }
          var code2 = element.textContent;
          var env = {
            element,
            language,
            grammar,
            code: code2
          };
          function insertHighlightedCode(highlightedCode) {
            env.highlightedCode = highlightedCode;
            _2.hooks.run("before-insert", env);
            env.element.innerHTML = env.highlightedCode;
            _2.hooks.run("after-highlight", env);
            _2.hooks.run("complete", env);
            callback && callback.call(env.element);
          }
          _2.hooks.run("before-sanity-check", env);
          parent = env.element.parentElement;
          if (parent && parent.nodeName.toLowerCase() === "pre" && !parent.hasAttribute("tabindex")) {
            parent.setAttribute("tabindex", "0");
          }
          if (!env.code) {
            _2.hooks.run("complete", env);
            callback && callback.call(env.element);
            return;
          }
          _2.hooks.run("before-highlight", env);
          if (!env.grammar) {
            insertHighlightedCode(_2.util.encode(env.code));
            return;
          }
          if (async2 && _self2.Worker) {
            var worker = new Worker(_2.filename);
            worker.onmessage = function(evt) {
              insertHighlightedCode(evt.data);
            };
            worker.postMessage(JSON.stringify({
              language: env.language,
              code: env.code,
              immediateClose: true
            }));
          } else {
            insertHighlightedCode(_2.highlight(env.code, env.grammar, env.language));
          }
        },
        /**
         * Low-level function, only use if you know what youre doing. It accepts a string of text as input
         * and the language definitions to use, and returns a string with the HTML produced.
         *
         * The following hooks will be run:
         * 1. `before-tokenize`
         * 2. `after-tokenize`
         * 3. `wrap`: On each {@link Token}.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @param {string} language The name of the language definition passed to `grammar`.
         * @returns {string} The highlighted HTML.
         * @memberof Prism
         * @public
         * @example
         * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
         */
        highlight: function(text, grammar, language) {
          var env = {
            code: text,
            grammar,
            language
          };
          _2.hooks.run("before-tokenize", env);
          if (!env.grammar) {
            throw new Error('The language "' + env.language + '" has no grammar.');
          }
          env.tokens = _2.tokenize(env.code, env.grammar);
          _2.hooks.run("after-tokenize", env);
          return Token.stringify(_2.util.encode(env.tokens), env.language);
        },
        /**
         * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
         * and the language definitions to use, and returns an array with the tokenized code.
         *
         * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
         *
         * This method could be useful in other contexts as well, as a very crude parser.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @returns {TokenStream} An array of strings and tokens, a token stream.
         * @memberof Prism
         * @public
         * @example
         * let code = `var foo = 0;`;
         * let tokens = Prism.tokenize(code, Prism.languages.javascript);
         * tokens.forEach(token => {
         *     if (token instanceof Prism.Token && token.type === 'number') {
         *         console.log(`Found numeric literal: ${token.content}`);
         *     }
         * });
         */
        tokenize: function(text, grammar) {
          var rest = grammar.rest;
          if (rest) {
            for (var token in rest) {
              grammar[token] = rest[token];
            }
            delete grammar.rest;
          }
          var tokenList = new LinkedList();
          addAfter(tokenList, tokenList.head, text);
          matchGrammar(text, tokenList, grammar, tokenList.head, 0);
          return toArray(tokenList);
        },
        /**
         * @namespace
         * @memberof Prism
         * @public
         */
        hooks: {
          all: {},
          /**
           * Adds the given callback to the list of callbacks for the given hook.
           *
           * The callback will be invoked when the hook it is registered for is run.
           * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
           *
           * One callback function can be registered to multiple hooks and the same hook multiple times.
           *
           * @param {string} name The name of the hook.
           * @param {HookCallback} callback The callback function which is given environment variables.
           * @public
           */
          add: function(name2, callback) {
            var hooks = _2.hooks.all;
            hooks[name2] = hooks[name2] || [];
            hooks[name2].push(callback);
          },
          /**
           * Runs a hook invoking all registered callbacks with the given environment variables.
           *
           * Callbacks will be invoked synchronously and in the order in which they were registered.
           *
           * @param {string} name The name of the hook.
           * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
           * @public
           */
          run: function(name2, env) {
            var callbacks = _2.hooks.all[name2];
            if (!callbacks || !callbacks.length) {
              return;
            }
            for (var i = 0, callback; callback = callbacks[i++]; ) {
              callback(env);
            }
          }
        },
        Token
      };
      _self2.Prism = _2;
      function Token(type2, content, alias, matchedStr) {
        this.type = type2;
        this.content = content;
        this.alias = alias;
        this.length = (matchedStr || "").length | 0;
      }
      Token.stringify = function stringify(o, language) {
        if (typeof o == "string") {
          return o;
        }
        if (Array.isArray(o)) {
          var s2 = "";
          o.forEach(function(e) {
            s2 += stringify(e, language);
          });
          return s2;
        }
        var env = {
          type: o.type,
          content: stringify(o.content, language),
          tag: "span",
          classes: ["token", o.type],
          attributes: {},
          language
        };
        var aliases = o.alias;
        if (aliases) {
          if (Array.isArray(aliases)) {
            Array.prototype.push.apply(env.classes, aliases);
          } else {
            env.classes.push(aliases);
          }
        }
        _2.hooks.run("wrap", env);
        var attributes = "";
        for (var name2 in env.attributes) {
          attributes += " " + name2 + '="' + (env.attributes[name2] || "").replace(/"/g, "&quot;") + '"';
        }
        return "<" + env.tag + ' class="' + env.classes.join(" ") + '"' + attributes + ">" + env.content + "</" + env.tag + ">";
      };
      function matchPattern(pattern2, pos, text, lookbehind) {
        pattern2.lastIndex = pos;
        var match = pattern2.exec(text);
        if (match && lookbehind && match[1]) {
          var lookbehindLength = match[1].length;
          match.index += lookbehindLength;
          match[0] = match[0].slice(lookbehindLength);
        }
        return match;
      }
      function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
        for (var token in grammar) {
          if (!grammar.hasOwnProperty(token) || !grammar[token]) {
            continue;
          }
          var patterns = grammar[token];
          patterns = Array.isArray(patterns) ? patterns : [patterns];
          for (var j2 = 0; j2 < patterns.length; ++j2) {
            if (rematch && rematch.cause == token + "," + j2) {
              return;
            }
            var patternObj = patterns[j2];
            var inside = patternObj.inside;
            var lookbehind = !!patternObj.lookbehind;
            var greedy = !!patternObj.greedy;
            var alias = patternObj.alias;
            if (greedy && !patternObj.pattern.global) {
              var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
              patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
            }
            var pattern2 = patternObj.pattern || patternObj;
            for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
              if (rematch && pos >= rematch.reach) {
                break;
              }
              var str = currentNode.value;
              if (tokenList.length > text.length) {
                return;
              }
              if (str instanceof Token) {
                continue;
              }
              var removeCount = 1;
              var match;
              if (greedy) {
                match = matchPattern(pattern2, pos, text, lookbehind);
                if (!match || match.index >= text.length) {
                  break;
                }
                var from = match.index;
                var to2 = match.index + match[0].length;
                var p2 = pos;
                p2 += currentNode.value.length;
                while (from >= p2) {
                  currentNode = currentNode.next;
                  p2 += currentNode.value.length;
                }
                p2 -= currentNode.value.length;
                pos = p2;
                if (currentNode.value instanceof Token) {
                  continue;
                }
                for (var k2 = currentNode; k2 !== tokenList.tail && (p2 < to2 || typeof k2.value === "string"); k2 = k2.next) {
                  removeCount++;
                  p2 += k2.value.length;
                }
                removeCount--;
                str = text.slice(pos, p2);
                match.index -= pos;
              } else {
                match = matchPattern(pattern2, 0, str, lookbehind);
                if (!match) {
                  continue;
                }
              }
              var from = match.index;
              var matchStr = match[0];
              var before = str.slice(0, from);
              var after = str.slice(from + matchStr.length);
              var reach = pos + str.length;
              if (rematch && reach > rematch.reach) {
                rematch.reach = reach;
              }
              var removeFrom = currentNode.prev;
              if (before) {
                removeFrom = addAfter(tokenList, removeFrom, before);
                pos += before.length;
              }
              removeRange(tokenList, removeFrom, removeCount);
              var wrapped = new Token(token, inside ? _2.tokenize(matchStr, inside) : matchStr, alias, matchStr);
              currentNode = addAfter(tokenList, removeFrom, wrapped);
              if (after) {
                addAfter(tokenList, currentNode, after);
              }
              if (removeCount > 1) {
                var nestedRematch = {
                  cause: token + "," + j2,
                  reach
                };
                matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);
                if (rematch && nestedRematch.reach > rematch.reach) {
                  rematch.reach = nestedRematch.reach;
                }
              }
            }
          }
        }
      }
      function LinkedList() {
        var head = { value: null, prev: null, next: null };
        var tail = { value: null, prev: head, next: null };
        head.next = tail;
        this.head = head;
        this.tail = tail;
        this.length = 0;
      }
      function addAfter(list, node, value) {
        var next = node.next;
        var newNode = { value, prev: node, next };
        node.next = newNode;
        next.prev = newNode;
        list.length++;
        return newNode;
      }
      function removeRange(list, node, count2) {
        var next = node.next;
        for (var i = 0; i < count2 && next !== list.tail; i++) {
          next = next.next;
        }
        node.next = next;
        next.prev = node;
        list.length -= i;
      }
      function toArray(list) {
        var array2 = [];
        var node = list.head.next;
        while (node !== list.tail) {
          array2.push(node.value);
          node = node.next;
        }
        return array2;
      }
      if (!_self2.document) {
        if (!_self2.addEventListener) {
          return _2;
        }
        if (!_2.disableWorkerMessageHandler) {
          _self2.addEventListener("message", function(evt) {
            var message = JSON.parse(evt.data);
            var lang2 = message.language;
            var code2 = message.code;
            var immediateClose = message.immediateClose;
            _self2.postMessage(_2.highlight(code2, _2.languages[lang2], lang2));
            if (immediateClose) {
              _self2.close();
            }
          }, false);
        }
        return _2;
      }
      var script = _2.util.currentScript();
      if (script) {
        _2.filename = script.src;
        if (script.hasAttribute("data-manual")) {
          _2.manual = true;
        }
      }
      function highlightAutomaticallyCallback() {
        if (!_2.manual) {
          _2.highlightAll();
        }
      }
      if (!_2.manual) {
        var readyState = document.readyState;
        if (readyState === "loading" || readyState === "interactive" && script && script.defer) {
          document.addEventListener("DOMContentLoaded", highlightAutomaticallyCallback);
        } else {
          if (window.requestAnimationFrame) {
            window.requestAnimationFrame(highlightAutomaticallyCallback);
          } else {
            window.setTimeout(highlightAutomaticallyCallback, 16);
          }
        }
      }
      return _2;
    })(_self);
    if (module.exports) {
      module.exports = Prism2;
    }
    if (typeof commonjsGlobal !== "undefined") {
      commonjsGlobal.Prism = Prism2;
    }
    Prism2.languages.markup = {
      "comment": {
        pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
        greedy: true
      },
      "prolog": {
        pattern: /<\?[\s\S]+?\?>/,
        greedy: true
      },
      "doctype": {
        // https://www.w3.org/TR/xml/#NT-doctypedecl
        pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
        greedy: true,
        inside: {
          "internal-subset": {
            pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
            lookbehind: true,
            greedy: true,
            inside: null
            // see below
          },
          "string": {
            pattern: /"[^"]*"|'[^']*'/,
            greedy: true
          },
          "punctuation": /^<!|>$|[[\]]/,
          "doctype-tag": /^DOCTYPE/i,
          "name": /[^\s<>'"]+/
        }
      },
      "cdata": {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        greedy: true
      },
      "tag": {
        pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
        greedy: true,
        inside: {
          "tag": {
            pattern: /^<\/?[^\s>\/]+/,
            inside: {
              "punctuation": /^<\/?/,
              "namespace": /^[^\s>\/:]+:/
            }
          },
          "special-attr": [],
          "attr-value": {
            pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
            inside: {
              "punctuation": [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                {
                  pattern: /^(\s*)["']|["']$/,
                  lookbehind: true
                }
              ]
            }
          },
          "punctuation": /\/?>/,
          "attr-name": {
            pattern: /[^\s>\/]+/,
            inside: {
              "namespace": /^[^\s>\/:]+:/
            }
          }
        }
      },
      "entity": [
        {
          pattern: /&[\da-z]{1,8};/i,
          alias: "named-entity"
        },
        /&#x?[\da-f]{1,8};/i
      ]
    };
    Prism2.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism2.languages.markup["entity"];
    Prism2.languages.markup["doctype"].inside["internal-subset"].inside = Prism2.languages.markup;
    Prism2.hooks.add("wrap", function(env) {
      if (env.type === "entity") {
        env.attributes["title"] = env.content.replace(/&amp;/, "&");
      }
    });
    Object.defineProperty(Prism2.languages.markup.tag, "addInlined", {
      /**
       * Adds an inlined language to markup.
       *
       * An example of an inlined language is CSS with `<style>` tags.
       *
       * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
       * case insensitive.
       * @param {string} lang The language key.
       * @example
       * addInlined('style', 'css');
       */
      value: function addInlined(tagName, lang) {
        var includedCdataInside = {};
        includedCdataInside["language-" + lang] = {
          pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
          lookbehind: true,
          inside: Prism2.languages[lang]
        };
        includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
        var inside = {
          "included-cdata": {
            pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
            inside: includedCdataInside
          }
        };
        inside["language-" + lang] = {
          pattern: /[\s\S]+/,
          inside: Prism2.languages[lang]
        };
        var def = {};
        def[tagName] = {
          pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
            return tagName;
          }), "i"),
          lookbehind: true,
          greedy: true,
          inside
        };
        Prism2.languages.insertBefore("markup", "cdata", def);
      }
    });
    Object.defineProperty(Prism2.languages.markup.tag, "addAttribute", {
      /**
       * Adds an pattern to highlight languages embedded in HTML attributes.
       *
       * An example of an inlined language is CSS with `style` attributes.
       *
       * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
       * case insensitive.
       * @param {string} lang The language key.
       * @example
       * addAttribute('style', 'css');
       */
      value: function(attrName, lang) {
        Prism2.languages.markup.tag.inside["special-attr"].push({
          pattern: RegExp(
            /(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
            "i"
          ),
          lookbehind: true,
          inside: {
            "attr-name": /^[^\s=]+/,
            "attr-value": {
              pattern: /=[\s\S]+/,
              inside: {
                "value": {
                  pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                  lookbehind: true,
                  alias: [lang, "language-" + lang],
                  inside: Prism2.languages[lang]
                },
                "punctuation": [
                  {
                    pattern: /^=/,
                    alias: "attr-equals"
                  },
                  /"|'/
                ]
              }
            }
          }
        });
      }
    });
    Prism2.languages.html = Prism2.languages.markup;
    Prism2.languages.mathml = Prism2.languages.markup;
    Prism2.languages.svg = Prism2.languages.markup;
    Prism2.languages.xml = Prism2.languages.extend("markup", {});
    Prism2.languages.ssml = Prism2.languages.xml;
    Prism2.languages.atom = Prism2.languages.xml;
    Prism2.languages.rss = Prism2.languages.xml;
    (function(Prism3) {
      var string2 = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
      Prism3.languages.css = {
        "comment": /\/\*[\s\S]*?\*\//,
        "atrule": {
          pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + string2.source + ")*?" + /(?:;|(?=\s*\{))/.source),
          inside: {
            "rule": /^@[\w-]+/,
            "selector-function-argument": {
              pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
              lookbehind: true,
              alias: "selector"
            },
            "keyword": {
              pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
              lookbehind: true
            }
            // See rest below
          }
        },
        "url": {
          // https://drafts.csswg.org/css-values-3/#urls
          pattern: RegExp("\\burl\\((?:" + string2.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
          greedy: true,
          inside: {
            "function": /^url/i,
            "punctuation": /^\(|\)$/,
            "string": {
              pattern: RegExp("^" + string2.source + "$"),
              alias: "url"
            }
          }
        },
        "selector": {
          pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string2.source + ")*(?=\\s*\\{)"),
          lookbehind: true
        },
        "string": {
          pattern: string2,
          greedy: true
        },
        "property": {
          pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
          lookbehind: true
        },
        "important": /!important\b/i,
        "function": {
          pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
          lookbehind: true
        },
        "punctuation": /[(){};:,]/
      };
      Prism3.languages.css["atrule"].inside.rest = Prism3.languages.css;
      var markup = Prism3.languages.markup;
      if (markup) {
        markup.tag.addInlined("style", "css");
        markup.tag.addAttribute("style", "css");
      }
    })(Prism2);
    Prism2.languages.clike = {
      "comment": [
        {
          pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
          lookbehind: true,
          greedy: true
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: true,
          greedy: true
        }
      ],
      "string": {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: true
      },
      "class-name": {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
        lookbehind: true,
        inside: {
          "punctuation": /[.\\]/
        }
      },
      "keyword": /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
      "boolean": /\b(?:false|true)\b/,
      "function": /\b\w+(?=\()/,
      "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
      "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
      "punctuation": /[{}[\];(),.:]/
    };
    Prism2.languages.javascript = Prism2.languages.extend("clike", {
      "class-name": [
        Prism2.languages.clike["class-name"],
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
          lookbehind: true
        }
      ],
      "keyword": [
        {
          pattern: /((?:^|\})\s*)catch\b/,
          lookbehind: true
        },
        {
          pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
          lookbehind: true
        }
      ],
      // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
      "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
      "number": {
        pattern: RegExp(
          /(^|[^\w$])/.source + "(?:" + // constant
          (/NaN|Infinity/.source + "|" + // binary integer
          /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
          /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
          /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
          /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
          /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
        ),
        lookbehind: true
      },
      "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
    });
    Prism2.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
    Prism2.languages.insertBefore("javascript", "keyword", {
      "regex": {
        pattern: RegExp(
          // lookbehind
          // eslint-disable-next-line regexp/no-dupe-characters-character-class
          /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
          // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
          // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
          // with the only syntax, so we have to define 2 different regex patterns.
          /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
          /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
          /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
        ),
        lookbehind: true,
        greedy: true,
        inside: {
          "regex-source": {
            pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
            lookbehind: true,
            alias: "language-regex",
            inside: Prism2.languages.regex
          },
          "regex-delimiter": /^\/|\/$/,
          "regex-flags": /^[a-z]+$/
        }
      },
      // This must be declared before keyword because we use "function" inside the look-forward
      "function-variable": {
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
        alias: "function"
      },
      "parameter": [
        {
          pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
          lookbehind: true,
          inside: Prism2.languages.javascript
        },
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
          lookbehind: true,
          inside: Prism2.languages.javascript
        },
        {
          pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
          lookbehind: true,
          inside: Prism2.languages.javascript
        },
        {
          pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
          lookbehind: true,
          inside: Prism2.languages.javascript
        }
      ],
      "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
    });
    Prism2.languages.insertBefore("javascript", "string", {
      "hashbang": {
        pattern: /^#!.*/,
        greedy: true,
        alias: "comment"
      },
      "template-string": {
        pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
        greedy: true,
        inside: {
          "template-punctuation": {
            pattern: /^`|`$/,
            alias: "string"
          },
          "interpolation": {
            pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
            lookbehind: true,
            inside: {
              "interpolation-punctuation": {
                pattern: /^\$\{|\}$/,
                alias: "punctuation"
              },
              rest: Prism2.languages.javascript
            }
          },
          "string": /[\s\S]+/
        }
      },
      "string-property": {
        pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
        lookbehind: true,
        greedy: true,
        alias: "property"
      }
    });
    Prism2.languages.insertBefore("javascript", "operator", {
      "literal-property": {
        pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
        lookbehind: true,
        alias: "property"
      }
    });
    if (Prism2.languages.markup) {
      Prism2.languages.markup.tag.addInlined("script", "javascript");
      Prism2.languages.markup.tag.addAttribute(
        /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
        "javascript"
      );
    }
    Prism2.languages.js = Prism2.languages.javascript;
    (function() {
      if (typeof Prism2 === "undefined" || typeof document === "undefined") {
        return;
      }
      if (!Element.prototype.matches) {
        Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
      }
      var LOADING_MESSAGE = "Loading";
      var FAILURE_MESSAGE = function(status, message) {
        return " Error " + status + " while fetching file: " + message;
      };
      var FAILURE_EMPTY_MESSAGE = " Error: File does not exist or is empty";
      var EXTENSIONS = {
        "js": "javascript",
        "py": "python",
        "rb": "ruby",
        "ps1": "powershell",
        "psm1": "powershell",
        "sh": "bash",
        "bat": "batch",
        "h": "c",
        "tex": "latex"
      };
      var STATUS_ATTR = "data-src-status";
      var STATUS_LOADING = "loading";
      var STATUS_LOADED = "loaded";
      var STATUS_FAILED = "failed";
      var SELECTOR = "pre[data-src]:not([" + STATUS_ATTR + '="' + STATUS_LOADED + '"]):not([' + STATUS_ATTR + '="' + STATUS_LOADING + '"])';
      function loadFile(src, success, error) {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", src, true);
        xhr.onreadystatechange = function() {
          if (xhr.readyState == 4) {
            if (xhr.status < 400 && xhr.responseText) {
              success(xhr.responseText);
            } else {
              if (xhr.status >= 400) {
                error(FAILURE_MESSAGE(xhr.status, xhr.statusText));
              } else {
                error(FAILURE_EMPTY_MESSAGE);
              }
            }
          }
        };
        xhr.send(null);
      }
      function parseRange(range) {
        var m2 = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(range || "");
        if (m2) {
          var start = Number(m2[1]);
          var comma = m2[2];
          var end = m2[3];
          if (!comma) {
            return [start, start];
          }
          if (!end) {
            return [start, void 0];
          }
          return [start, Number(end)];
        }
        return void 0;
      }
      Prism2.hooks.add("before-highlightall", function(env) {
        env.selector += ", " + SELECTOR;
      });
      Prism2.hooks.add("before-sanity-check", function(env) {
        var pre = (
          /** @type {HTMLPreElement} */
          env.element
        );
        if (pre.matches(SELECTOR)) {
          env.code = "";
          pre.setAttribute(STATUS_ATTR, STATUS_LOADING);
          var code2 = pre.appendChild(document.createElement("CODE"));
          code2.textContent = LOADING_MESSAGE;
          var src = pre.getAttribute("data-src");
          var language = env.language;
          if (language === "none") {
            var extension = (/\.(\w+)$/.exec(src) || [, "none"])[1];
            language = EXTENSIONS[extension] || extension;
          }
          Prism2.util.setLanguage(code2, language);
          Prism2.util.setLanguage(pre, language);
          var autoloader = Prism2.plugins.autoloader;
          if (autoloader) {
            autoloader.loadLanguages(language);
          }
          loadFile(
            src,
            function(text) {
              pre.setAttribute(STATUS_ATTR, STATUS_LOADED);
              var range = parseRange(pre.getAttribute("data-range"));
              if (range) {
                var lines = text.split(/\r\n?|\n/g);
                var start = range[0];
                var end = range[1] == null ? lines.length : range[1];
                if (start < 0) {
                  start += lines.length;
                }
                start = Math.max(0, Math.min(start - 1, lines.length));
                if (end < 0) {
                  end += lines.length;
                }
                end = Math.max(0, Math.min(end, lines.length));
                text = lines.slice(start, end).join("\n");
                if (!pre.hasAttribute("data-start")) {
                  pre.setAttribute("data-start", String(start + 1));
                }
              }
              code2.textContent = text;
              Prism2.highlightElement(code2);
            },
            function(error) {
              pre.setAttribute(STATUS_ATTR, STATUS_FAILED);
              code2.textContent = error;
            }
          );
        }
      });
      Prism2.plugins.fileHighlight = {
        /**
         * Executes the File Highlight plugin for all matching `pre` elements under the given container.
         *
         * Note: Elements which are already loaded or currently loading will not be touched by this method.
         *
         * @param {ParentNode} [container=document]
         */
        highlight: function highlight(container) {
          var elements = (container || document).querySelectorAll(SELECTOR);
          for (var i = 0, element; element = elements[i++]; ) {
            Prism2.highlightElement(element);
          }
        }
      };
      var logged = false;
      Prism2.fileHighlight = function() {
        if (!logged) {
          console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.");
          logged = true;
        }
        Prism2.plugins.fileHighlight.highlight.apply(this, arguments);
      };
    })();
  })(prism);
  return prism.exports;
}
var prismExports = requirePrism();
const Prism$1 = /* @__PURE__ */ getDefaultExportFromCjs(prismExports);
Prism.languages.json = {
  "property": {
    pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
    lookbehind: true,
    greedy: true
  },
  "string": {
    pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
    lookbehind: true,
    greedy: true
  },
  "comment": {
    pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
    greedy: true
  },
  "number": /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
  "punctuation": /[{}[\],]/,
  "operator": /:/,
  "boolean": /\b(?:false|true)\b/,
  "null": {
    pattern: /\bnull\b/,
    alias: "keyword"
  }
};
Prism.languages.webmanifest = Prism.languages.json;
const JsonEditor = ({
  value,
  onChange,
  error: externalError,
  placeholder
}) => {
  const [editorContent, setEditorContent] = reactExports.useState(value || "");
  const [internalError, setInternalError] = reactExports.useState(
    void 0
  );
  reactExports.useEffect(() => {
    setEditorContent(value || "");
  }, [value]);
  const handleEditorChange = (newContent) => {
    setEditorContent(newContent);
    setInternalError(void 0);
    onChange(newContent);
  };
  const displayError = internalError || externalError;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: `border rounded-md ${displayError ? "border-red-500" : "border-gray-200 dark:border-gray-800"}`,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Editor,
          {
            value: editorContent,
            onValueChange: handleEditorChange,
            highlight: (code2) => Prism$1.highlight(code2, Prism$1.languages.json, "json"),
            padding: 10,
            placeholder,
            style: {
              fontFamily: '"Fira code", "Fira Mono", monospace',
              fontSize: 14,
              backgroundColor: "transparent",
              minHeight: "100px"
            },
            className: "w-full"
          }
        )
      }
    ),
    displayError && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-red-500 mt-1", children: displayError })
  ] });
};
const isTypeSupported = (type2, supportedTypes) => {
  if (Array.isArray(type2)) {
    return type2.every((t) => supportedTypes.includes(t));
  }
  return typeof type2 === "string" && supportedTypes.includes(type2);
};
const isSimpleObject = (schema) => {
  const supportedTypes = ["string", "number", "integer", "boolean", "null"];
  if (schema.type && isTypeSupported(schema.type, supportedTypes)) return true;
  if (schema.type === "object") {
    return Object.values(schema.properties ?? {}).every(
      (prop) => prop.type && isTypeSupported(prop.type, supportedTypes)
    );
  }
  if (schema.type === "array") {
    return !!schema.items && isSimpleObject(schema.items);
  }
  return false;
};
const getArrayItemDefault = (schema) => {
  if ("default" in schema && schema.default !== void 0) {
    return schema.default;
  }
  switch (schema.type) {
    case "string":
      return "";
    case "number":
    case "integer":
      return 0;
    case "boolean":
      return false;
    case "array":
      return [];
    case "object":
      return {};
    case "null":
      return null;
    default:
      return null;
  }
};
const DynamicJsonForm = reactExports.forwardRef(
  ({ schema, value, onChange, maxDepth = 3 }, ref2) => {
    const canRenderTopLevelForm = (s2) => {
      const primitiveTypes = ["string", "number", "integer", "boolean", "null"];
      const hasType = Array.isArray(s2.type) ? s2.type.length > 0 : !!s2.type;
      if (!hasType) return false;
      const includesType = (t) => Array.isArray(s2.type) ? s2.type.includes(t) : s2.type === t;
      if (primitiveTypes.some(includesType)) return true;
      if (includesType("object")) {
        const keys = Object.keys(s2.properties ?? {});
        return keys.length > 0;
      }
      if (includesType("array")) {
        return !!s2.items;
      }
      return false;
    };
    const isOnlyJSON = !canRenderTopLevelForm(schema);
    const [isJsonMode, setIsJsonMode] = reactExports.useState(isOnlyJSON);
    const [jsonError, setJsonError] = reactExports.useState();
    const [copiedJson, setCopiedJson] = reactExports.useState(false);
    const { toast: toast2 } = useToast();
    const [rawJsonValue, setRawJsonValue] = reactExports.useState(
      JSON.stringify(value ?? generateDefaultValue(schema), null, 2)
    );
    const timeoutRef = reactExports.useRef();
    const hasJsonError = () => {
      return !!jsonError;
    };
    const debouncedUpdateParent = reactExports.useCallback(
      (jsonString) => {
        if (timeoutRef.current) {
          clearTimeout(timeoutRef.current);
        }
        timeoutRef.current = setTimeout(() => {
          try {
            const parsed = JSON.parse(jsonString);
            onChange(parsed);
            setJsonError(void 0);
          } catch (err) {
            const errorMessage = err instanceof Error ? err.message : "Invalid JSON";
            setJsonError(errorMessage);
            const trimmed = jsonString?.trim();
            if (trimmed && trimmed.length > 5 && !trimmed.match(/^[\s[{]/)) {
              onChange(generateDefaultValue(schema));
            }
          }
        }, 300);
      },
      [onChange, setJsonError, schema]
    );
    reactExports.useEffect(() => {
      if (!isJsonMode) {
        setRawJsonValue(
          JSON.stringify(value ?? generateDefaultValue(schema), null, 2)
        );
      }
    }, [value, schema, isJsonMode]);
    const handleSwitchToFormMode = () => {
      if (isJsonMode) {
        try {
          const parsed = JSON.parse(rawJsonValue);
          onChange(parsed);
          setIsJsonMode(false);
        } catch (err) {
          setJsonError(err instanceof Error ? err.message : "Invalid JSON");
        }
      } else {
        setRawJsonValue(
          JSON.stringify(value ?? generateDefaultValue(schema), null, 2)
        );
        setIsJsonMode(true);
      }
    };
    const formatJson = () => {
      try {
        const jsonStr = rawJsonValue?.trim();
        if (!jsonStr) {
          return;
        }
        const formatted = JSON.stringify(JSON.parse(jsonStr), null, 2);
        setRawJsonValue(formatted);
        debouncedUpdateParent(formatted);
        setJsonError(void 0);
      } catch (err) {
        setJsonError(err instanceof Error ? err.message : "Invalid JSON");
      }
    };
    const validateJson = () => {
      if (!isJsonMode) return { isValid: true, error: null };
      try {
        const jsonStr = rawJsonValue?.trim();
        if (!jsonStr) return { isValid: true, error: null };
        const parsed = JSON.parse(jsonStr);
        if (timeoutRef.current) {
          clearTimeout(timeoutRef.current);
        }
        onChange(parsed);
        setJsonError(void 0);
        return { isValid: true, error: null };
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : "Invalid JSON";
        setJsonError(errorMessage);
        return { isValid: false, error: errorMessage };
      }
    };
    const handleCopyJson = reactExports.useCallback(async () => {
      try {
        await navigator.clipboard.writeText(
          JSON.stringify(value, null, 2) ?? "[]"
        );
        setCopiedJson(true);
        toast2({
          title: "JSON copied",
          description: "The JSON data has been successfully copied to your clipboard."
        });
        setTimeout(() => {
          setCopiedJson(false);
        }, 2e3);
      } catch (error) {
        toast2({
          title: "Error",
          description: `Failed to copy JSON: ${error instanceof Error ? error.message : String(error)}`,
          variant: "destructive"
        });
      }
    }, [toast2, value]);
    reactExports.useImperativeHandle(ref2, () => ({
      validateJson,
      hasJsonError
    }));
    const renderFormFields = (propSchema, currentValue, path = [], depth = 0, parentSchema, propertyName) => {
      if (depth >= maxDepth && (propSchema.type === "object" || propSchema.type === "array")) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          JsonEditor,
          {
            value: JSON.stringify(
              currentValue ?? generateDefaultValue(propSchema, propertyName, parentSchema),
              null,
              2
            ),
            onChange: (newValue) => {
              try {
                const parsed = JSON.parse(newValue);
                handleFieldChange(path, parsed);
                setJsonError(void 0);
              } catch (err) {
                setJsonError(
                  err instanceof Error ? err.message : "Invalid JSON"
                );
              }
            },
            error: jsonError
          }
        );
      }
      const isRequired = parentSchema?.required?.includes(propertyName || "") ?? false;
      let fieldType = propSchema.type;
      if (Array.isArray(fieldType)) {
        fieldType = fieldType.find((t) => t !== "null") ?? fieldType[0];
      }
      switch (fieldType) {
        case "string": {
          const titledOptions = (propSchema.oneOf ?? propSchema.anyOf)?.filter((opt) => "const" in opt);
          if (titledOptions && titledOptions.length > 0) {
            return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
              propSchema.description && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-600", children: propSchema.description }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "select",
                {
                  value: currentValue ?? "",
                  onChange: (e) => {
                    const val = e.target.value;
                    if (!val && !isRequired) {
                      handleFieldChange(path, void 0);
                    } else {
                      handleFieldChange(path, val);
                    }
                  },
                  required: isRequired,
                  className: "w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-800",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "", children: "Select an option..." }),
                    titledOptions.map((option) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "option",
                      {
                        value: String(option.const),
                        children: option.title ?? String(option.const)
                      },
                      String(option.const)
                    ))
                  ]
                }
              )
            ] });
          }
          if (propSchema.enum) {
            const names2 = Array.isArray(propSchema.enumNames) ? propSchema.enumNames : void 0;
            return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
              propSchema.description && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-600", children: propSchema.description }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "select",
                {
                  value: currentValue ?? "",
                  onChange: (e) => {
                    const val = e.target.value;
                    if (!val && !isRequired) {
                      handleFieldChange(path, void 0);
                    } else {
                      handleFieldChange(path, val);
                    }
                  },
                  required: isRequired,
                  className: "w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-800",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "", children: "Select an option..." }),
                    propSchema.enum.map((option, idx) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: option, children: names2?.[idx] ?? option }, option))
                  ]
                }
              )
            ] });
          }
          let inputType = "text";
          switch (propSchema.format) {
            case "email":
              inputType = "email";
              break;
            case "uri":
              inputType = "url";
              break;
            case "date":
              inputType = "date";
              break;
            case "date-time":
              inputType = "datetime-local";
              break;
            default:
              inputType = "text";
              break;
          }
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            Input,
            {
              type: inputType,
              value: currentValue ?? "",
              onChange: (e) => {
                const val = e.target.value;
                handleFieldChange(path, val);
              },
              placeholder: propSchema.description,
              required: isRequired,
              minLength: propSchema.minLength,
              maxLength: propSchema.maxLength,
              pattern: propSchema.pattern
            }
          );
        }
        case "number":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            Input,
            {
              type: "number",
              value: currentValue?.toString() ?? "",
              onChange: (e) => {
                const val = e.target.value;
                if (!val && !isRequired) {
                  handleFieldChange(path, void 0);
                } else {
                  const num = Number(val);
                  if (!isNaN(num)) {
                    handleFieldChange(path, num);
                  }
                }
              },
              placeholder: propSchema.description,
              required: isRequired,
              min: propSchema.minimum,
              max: propSchema.maximum
            }
          );
        case "integer":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            Input,
            {
              type: "number",
              step: "1",
              value: currentValue?.toString() ?? "",
              onChange: (e) => {
                const val = e.target.value;
                if (!val && !isRequired) {
                  handleFieldChange(path, void 0);
                } else {
                  const num = Number(val);
                  if (!isNaN(num) && Number.isInteger(num)) {
                    handleFieldChange(path, num);
                  }
                }
              },
              placeholder: propSchema.description,
              required: isRequired,
              min: propSchema.minimum,
              max: propSchema.maximum
            }
          );
        case "boolean":
          return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
            propSchema.description && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-600", children: propSchema.description }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input,
              {
                type: "checkbox",
                checked: currentValue ?? false,
                onChange: (e) => handleFieldChange(path, e.target.checked),
                className: "w-4 h-4",
                required: isRequired
              }
            )
          ] });
        case "null":
          return null;
        case "object":
          if (!propSchema.properties) {
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              JsonEditor,
              {
                value: JSON.stringify(currentValue ?? {}, null, 2),
                onChange: (newValue) => {
                  try {
                    const parsed = JSON.parse(newValue);
                    handleFieldChange(path, parsed);
                    setJsonError(void 0);
                  } catch (err) {
                    setJsonError(
                      err instanceof Error ? err.message : "Invalid JSON"
                    );
                  }
                },
                error: jsonError
              }
            );
          }
          return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-2 border rounded p-3", children: Object.entries(propSchema.properties).map(([key, subSchema]) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "block text-sm font-medium mb-1", children: [
              subSchema.title ?? key,
              propSchema.required?.includes(key) && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-red-500 ml-1", children: "*" })
            ] }),
            renderFormFields(
              subSchema,
              currentValue?.[key],
              [...path, key],
              depth + 1,
              propSchema,
              key
            )
          ] }, key)) });
        case "array": {
          const arrayValue = Array.isArray(currentValue) ? currentValue : [];
          if (!propSchema.items) return null;
          const itemSchema = propSchema.items;
          let multiOptions = null;
          const titledMulti = (itemSchema.anyOf ?? itemSchema.oneOf)?.filter((opt) => "const" in opt);
          if (titledMulti && titledMulti.length > 0) {
            multiOptions = titledMulti.map((o) => ({
              value: String(o.const),
              label: o.title ?? String(o.const)
            }));
          } else if (itemSchema.enum) {
            const names2 = Array.isArray(itemSchema.enumNames) ? itemSchema.enumNames : void 0;
            multiOptions = itemSchema.enum.map((v, i) => ({
              value: v,
              label: names2?.[i] ?? v
            }));
          }
          if (multiOptions) {
            const selectSize = Math.min(Math.max(multiOptions.length, 3), 8);
            return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
              propSchema.description && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-600", children: propSchema.description }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "select",
                {
                  multiple: true,
                  size: selectSize,
                  value: arrayValue,
                  onChange: (e) => {
                    const selected = Array.from(
                      e.target.selectedOptions
                    ).map((o) => o.value);
                    handleFieldChange(path, selected);
                  },
                  className: "w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-800",
                  children: multiOptions.map((opt) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: opt.value, children: opt.label }, opt.value))
                }
              ),
              (propSchema.minItems || propSchema.maxItems) && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-xs text-gray-500", children: [
                propSchema.minItems ? `Select at least ${propSchema.minItems}. ` : "",
                propSchema.maxItems ? `Select at most ${propSchema.maxItems}.` : ""
              ] })
            ] });
          }
          if (isSimpleObject(propSchema.items)) {
            return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
              propSchema.description && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-600", children: propSchema.description }),
              propSchema.items?.description && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm text-gray-500", children: [
                "Items: ",
                propSchema.items.description
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
                arrayValue.map((item, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
                  renderFormFields(
                    propSchema.items,
                    item,
                    [...path, index2.toString()],
                    depth + 1
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Button,
                    {
                      variant: "outline",
                      size: "sm",
                      onClick: () => {
                        const newArray = [...arrayValue];
                        newArray.splice(index2, 1);
                        handleFieldChange(path, newArray);
                      },
                      children: "Remove"
                    }
                  )
                ] }, index2)),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    variant: "outline",
                    size: "sm",
                    onClick: () => {
                      const defaultValue = getArrayItemDefault(
                        propSchema.items
                      );
                      handleFieldChange(path, [...arrayValue, defaultValue]);
                    },
                    title: propSchema.items?.description ? `Add new ${propSchema.items.description}` : "Add new item",
                    children: "Add Item"
                  }
                )
              ] })
            ] });
          }
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            JsonEditor,
            {
              value: JSON.stringify(currentValue ?? [], null, 2),
              onChange: (newValue) => {
                try {
                  const parsed = JSON.parse(newValue);
                  handleFieldChange(path, parsed);
                  setJsonError(void 0);
                } catch (err) {
                  setJsonError(
                    err instanceof Error ? err.message : "Invalid JSON"
                  );
                }
              },
              error: jsonError
            }
          );
        }
        default:
          return null;
      }
    };
    const handleFieldChange = (path, fieldValue) => {
      if (path.length === 0) {
        onChange(fieldValue);
        return;
      }
      try {
        const newValue = updateValueAtPath(value, path, fieldValue);
        onChange(newValue);
      } catch (error) {
        console.error("Failed to update form value:", error);
        onChange(value);
      }
    };
    const shouldUseJsonMode = schema.type === "object" && (!schema.properties || Object.keys(schema.properties).length === 0);
    reactExports.useEffect(() => {
      if (shouldUseJsonMode && !isJsonMode) {
        setIsJsonMode(true);
      }
    }, [shouldUseJsonMode, isJsonMode]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-end space-x-2", children: [
        isJsonMode && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Button,
            {
              type: "button",
              variant: "outline",
              size: "sm",
              onClick: handleCopyJson,
              children: [
                copiedJson ? /* @__PURE__ */ jsxRuntimeExports.jsx(CheckCheck, { className: "h-4 w-4 mr-2" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Copy, { className: "h-4 w-4 mr-2" }),
                "Copy JSON"
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              type: "button",
              variant: "outline",
              size: "sm",
              onClick: formatJson,
              children: "Format JSON"
            }
          )
        ] }),
        !isOnlyJSON && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            variant: "outline",
            size: "sm",
            onClick: handleSwitchToFormMode,
            children: isJsonMode ? "Switch to Form" : "Switch to JSON"
          }
        )
      ] }),
      isJsonMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        JsonEditor,
        {
          value: rawJsonValue,
          onChange: (newValue) => {
            setRawJsonValue(newValue);
            debouncedUpdateParent(newValue);
          },
          error: jsonError,
          placeholder: schema.description
        }
      ) : (
        // If schema type is object but value is not an object or is empty, and we have actual JSON data,
        // render a simple representation of the JSON data
        schema.type === "object" && (typeof value !== "object" || value === null || Object.keys(value).length === 0) && rawJsonValue && rawJsonValue !== "{}" ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4 border rounded-md p-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-500", children: "Form view not available for this JSON structure. Using simplified view:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { className: "bg-gray-50 dark:bg-gray-800 dark:text-gray-100 p-4 rounded text-sm overflow-auto", children: rawJsonValue }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-500", children: "Use JSON mode for full editing capabilities." })
        ] }) : renderFormFields(schema, value)
      )
    ] });
  }
);
const SamplingRequest = ({
  onApprove,
  request,
  onReject
}) => {
  const { toast: toast2 } = useToast();
  const [messageResult, setMessageResult] = reactExports.useState({
    model: "stub-model",
    stopReason: "endTurn",
    role: "assistant",
    content: {
      type: "text",
      text: ""
    }
  });
  const contentType = messageResult?.content?.type;
  const schema = reactExports.useMemo(() => {
    const s2 = {
      type: "object",
      description: "Message result",
      properties: {
        model: {
          type: "string",
          default: "stub-model",
          description: "model name"
        },
        stopReason: {
          type: "string",
          default: "endTurn",
          description: "Stop reason"
        },
        role: {
          type: "string",
          default: "assistant",
          description: "Role of the model"
        },
        content: {
          type: "object",
          properties: {
            type: {
              type: "string",
              default: "text",
              description: "Type of content"
            }
          }
        }
      }
    };
    if (contentType === "text" && s2.properties) {
      s2.properties.content.properties = {
        ...s2.properties.content.properties,
        text: {
          type: "string",
          default: "",
          description: "text content"
        }
      };
      setMessageResult((prev) => ({
        ...prev,
        content: {
          type: contentType,
          text: ""
        }
      }));
    } else if (contentType === "image" && s2.properties) {
      s2.properties.content.properties = {
        ...s2.properties.content.properties,
        data: {
          type: "string",
          default: "",
          description: "Base64 encoded image data"
        },
        mimeType: {
          type: "string",
          default: "",
          description: "Mime type of the image"
        }
      };
      setMessageResult((prev) => ({
        ...prev,
        content: {
          type: contentType,
          data: "",
          mimeType: ""
        }
      }));
    }
    return s2;
  }, [contentType]);
  const handleApprove = (id2) => {
    const validationResult = CreateMessageResultSchema.safeParse(messageResult);
    if (!validationResult.success) {
      toast2({
        title: "Error",
        description: `There was an error validating the message result: ${validationResult.error.message}`,
        variant: "destructive"
      });
      return;
    }
    onApprove(id2, validationResult.data);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      "data-testid": "sampling-request",
      className: "flex gap-4 p-4 border rounded-lg space-y-4",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1 bg-gray-50 dark:bg-gray-800 dark:text-gray-100 p-2 rounded", children: /* @__PURE__ */ jsxRuntimeExports.jsx(JsonView, { data: JSON.stringify(request.request) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { className: "flex-1 space-y-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            DynamicJsonForm,
            {
              schema,
              value: messageResult,
              onChange: (newValue) => {
                setMessageResult(newValue);
              }
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex space-x-2 mt-1", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { type: "button", onClick: () => handleApprove(request.id), children: "Approve" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                type: "button",
                variant: "outline",
                onClick: () => onReject(request.id),
                children: "Reject"
              }
            )
          ] })
        ] })
      ]
    }
  );
};
const SamplingTab = ({ pendingRequests, onApprove, onReject }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "sampling", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "h-96", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(AlertDescription, { children: "When the server requests LLM sampling, requests will appear here for approval." }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-4 space-y-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold", children: "Recent Requests" }),
      pendingRequests.map((request) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        SamplingRequest,
        {
          request,
          onApprove,
          onReject
        },
        request.id
      )),
      pendingRequests.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-500", children: "No pending requests" })
    ] })
  ] }) });
};
function clamp(value, [min2, max2]) {
  return Math.min(max2, Math.max(min2, value));
}
// @__NO_SIDE_EFFECTS__
function createSlot(ownerName) {
  const SlotClone = /* @__PURE__ */ createSlotClone(ownerName);
  const Slot2 = reactExports.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    const childrenArray = reactExports.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (reactExports.Children.count(newElement) > 1) return reactExports.Children.only(null);
          return reactExports.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children: reactExports.isValidElement(newElement) ? reactExports.cloneElement(newElement, void 0, newChildren) : null });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children });
  });
  Slot2.displayName = `${ownerName}.Slot`;
  return Slot2;
}
// @__NO_SIDE_EFFECTS__
function createSlotClone(ownerName) {
  const SlotClone = reactExports.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    if (reactExports.isValidElement(children)) {
      const childrenRef = getElementRef(children);
      const props2 = mergeProps(slotProps, children.props);
      if (children.type !== reactExports.Fragment) {
        props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
      }
      return reactExports.cloneElement(children, props2);
    }
    return reactExports.Children.count(children) > 1 ? reactExports.Children.only(null) : null;
  });
  SlotClone.displayName = `${ownerName}.SlotClone`;
  return SlotClone;
}
var SLOTTABLE_IDENTIFIER$1 = /* @__PURE__ */ Symbol("radix.slottable");
function isSlottable(child) {
  return reactExports.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER$1;
}
function mergeProps(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          const result = childPropValue(...args);
          slotPropValue(...args);
          return result;
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
function usePrevious(value) {
  const ref2 = reactExports.useRef({ value, previous: value });
  return reactExports.useMemo(() => {
    if (ref2.current.value !== value) {
      ref2.current.previous = ref2.current.value;
      ref2.current.value = value;
    }
    return ref2.current.previous;
  }, [value]);
}
var OPEN_KEYS = [" ", "Enter", "ArrowUp", "ArrowDown"];
var SELECTION_KEYS = [" ", "Enter"];
var SELECT_NAME = "Select";
var [Collection, useCollection, createCollectionScope] = createCollection(SELECT_NAME);
var [createSelectContext] = createContextScope(SELECT_NAME, [
  createCollectionScope,
  createPopperScope
]);
var usePopperScope$1 = createPopperScope();
var [SelectProvider, useSelectContext] = createSelectContext(SELECT_NAME);
var [SelectNativeOptionsProvider, useSelectNativeOptionsContext] = createSelectContext(SELECT_NAME);
var Select$1 = (props) => {
  const {
    __scopeSelect,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    value: valueProp,
    defaultValue,
    onValueChange,
    dir,
    name: name2,
    autoComplete,
    disabled,
    required: required2,
    form
  } = props;
  const popperScope = usePopperScope$1(__scopeSelect);
  const [trigger, setTrigger] = reactExports.useState(null);
  const [valueNode, setValueNode] = reactExports.useState(null);
  const [valueNodeHasChildren, setValueNodeHasChildren] = reactExports.useState(false);
  const direction = useDirection(dir);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: SELECT_NAME
  });
  const [value, setValue] = useControllableState({
    prop: valueProp,
    defaultProp: defaultValue,
    onChange: onValueChange,
    caller: SELECT_NAME
  });
  const triggerPointerDownPosRef = reactExports.useRef(null);
  const isFormControl = trigger ? form || !!trigger.closest("form") : true;
  const [nativeOptionsSet, setNativeOptionsSet] = reactExports.useState(/* @__PURE__ */ new Set());
  const nativeSelectKey = Array.from(nativeOptionsSet).map((option) => option.props.value).join(";");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$2, { ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    SelectProvider,
    {
      required: required2,
      scope: __scopeSelect,
      trigger,
      onTriggerChange: setTrigger,
      valueNode,
      onValueNodeChange: setValueNode,
      valueNodeHasChildren,
      onValueNodeHasChildrenChange: setValueNodeHasChildren,
      contentId: useId(),
      value,
      onValueChange: setValue,
      open,
      onOpenChange: setOpen,
      dir: direction,
      triggerPointerDownPosRef,
      disabled,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.Provider, { scope: __scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          SelectNativeOptionsProvider,
          {
            scope: props.__scopeSelect,
            onNativeOptionAdd: reactExports.useCallback((option) => {
              setNativeOptionsSet((prev) => new Set(prev).add(option));
            }, []),
            onNativeOptionRemove: reactExports.useCallback((option) => {
              setNativeOptionsSet((prev) => {
                const optionsSet = new Set(prev);
                optionsSet.delete(option);
                return optionsSet;
              });
            }, []),
            children
          }
        ) }),
        isFormControl ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
          SelectBubbleInput,
          {
            "aria-hidden": true,
            required: required2,
            tabIndex: -1,
            name: name2,
            autoComplete,
            value,
            onChange: (event) => setValue(event.target.value),
            disabled,
            form,
            children: [
              value === void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "" }) : null,
              Array.from(nativeOptionsSet)
            ]
          },
          nativeSelectKey
        ) : null
      ]
    }
  ) });
};
Select$1.displayName = SELECT_NAME;
var TRIGGER_NAME$2 = "SelectTrigger";
var SelectTrigger$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, disabled = false, ...triggerProps } = props;
    const popperScope = usePopperScope$1(__scopeSelect);
    const context = useSelectContext(TRIGGER_NAME$2, __scopeSelect);
    const isDisabled = context.disabled || disabled;
    const composedRefs = useComposedRefs(forwardedRef, context.onTriggerChange);
    const getItems = useCollection(__scopeSelect);
    const pointerTypeRef = reactExports.useRef("touch");
    const [searchRef, handleTypeaheadSearch, resetTypeahead] = useTypeaheadSearch((search) => {
      const enabledItems = getItems().filter((item) => !item.disabled);
      const currentItem = enabledItems.find((item) => item.value === context.value);
      const nextItem = findNextItem(enabledItems, search, currentItem);
      if (nextItem !== void 0) {
        context.onValueChange(nextItem.value);
      }
    });
    const handleOpen = (pointerEvent) => {
      if (!isDisabled) {
        context.onOpenChange(true);
        resetTypeahead();
      }
      if (pointerEvent) {
        context.triggerPointerDownPosRef.current = {
          x: Math.round(pointerEvent.pageX),
          y: Math.round(pointerEvent.pageY)
        };
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor, { asChild: true, ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive$1.button,
      {
        type: "button",
        role: "combobox",
        "aria-controls": context.contentId,
        "aria-expanded": context.open,
        "aria-required": context.required,
        "aria-autocomplete": "none",
        dir: context.dir,
        "data-state": context.open ? "open" : "closed",
        disabled: isDisabled,
        "data-disabled": isDisabled ? "" : void 0,
        "data-placeholder": shouldShowPlaceholder(context.value) ? "" : void 0,
        ...triggerProps,
        ref: composedRefs,
        onClick: composeEventHandlers(triggerProps.onClick, (event) => {
          event.currentTarget.focus();
          if (pointerTypeRef.current !== "mouse") {
            handleOpen(event);
          }
        }),
        onPointerDown: composeEventHandlers(triggerProps.onPointerDown, (event) => {
          pointerTypeRef.current = event.pointerType;
          const target = event.target;
          if (target.hasPointerCapture(event.pointerId)) {
            target.releasePointerCapture(event.pointerId);
          }
          if (event.button === 0 && event.ctrlKey === false && event.pointerType === "mouse") {
            handleOpen(event);
            event.preventDefault();
          }
        }),
        onKeyDown: composeEventHandlers(triggerProps.onKeyDown, (event) => {
          const isTypingAhead = searchRef.current !== "";
          const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
          if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);
          if (isTypingAhead && event.key === " ") return;
          if (OPEN_KEYS.includes(event.key)) {
            handleOpen();
            event.preventDefault();
          }
        })
      }
    ) });
  }
);
SelectTrigger$1.displayName = TRIGGER_NAME$2;
var VALUE_NAME = "SelectValue";
var SelectValue$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, className, style, children, placeholder = "", ...valueProps } = props;
    const context = useSelectContext(VALUE_NAME, __scopeSelect);
    const { onValueNodeHasChildrenChange } = context;
    const hasChildren = children !== void 0;
    const composedRefs = useComposedRefs(forwardedRef, context.onValueNodeChange);
    useLayoutEffect2(() => {
      onValueNodeHasChildrenChange(hasChildren);
    }, [onValueNodeHasChildrenChange, hasChildren]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive$1.span,
      {
        ...valueProps,
        ref: composedRefs,
        style: { pointerEvents: "none" },
        children: shouldShowPlaceholder(context.value) ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: placeholder }) : children
      }
    );
  }
);
SelectValue$1.displayName = VALUE_NAME;
var ICON_NAME = "SelectIcon";
var SelectIcon = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, children, ...iconProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive$1.span, { "aria-hidden": true, ...iconProps, ref: forwardedRef, children: children || "" });
  }
);
SelectIcon.displayName = ICON_NAME;
var PORTAL_NAME$1 = "SelectPortal";
var SelectPortal = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$3, { asChild: true, ...props });
};
SelectPortal.displayName = PORTAL_NAME$1;
var CONTENT_NAME$1 = "SelectContent";
var SelectContent$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context = useSelectContext(CONTENT_NAME$1, props.__scopeSelect);
    const [fragment, setFragment] = reactExports.useState();
    useLayoutEffect2(() => {
      setFragment(new DocumentFragment());
    }, []);
    if (!context.open) {
      const frag = fragment;
      return frag ? reactDomExports.createPortal(
        /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContentProvider, { scope: props.__scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.Slot, { scope: props.__scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: props.children }) }) }),
        frag
      ) : null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContentImpl, { ...props, ref: forwardedRef });
  }
);
SelectContent$1.displayName = CONTENT_NAME$1;
var CONTENT_MARGIN = 10;
var [SelectContentProvider, useSelectContentContext] = createSelectContext(CONTENT_NAME$1);
var CONTENT_IMPL_NAME = "SelectContentImpl";
var Slot = /* @__PURE__ */ createSlot("SelectContent.RemoveScroll");
var SelectContentImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSelect,
      position = "item-aligned",
      onCloseAutoFocus,
      onEscapeKeyDown,
      onPointerDownOutside,
      //
      // PopperContent props
      side,
      sideOffset,
      align,
      alignOffset,
      arrowPadding,
      collisionBoundary,
      collisionPadding,
      sticky,
      hideWhenDetached,
      avoidCollisions,
      //
      ...contentProps
    } = props;
    const context = useSelectContext(CONTENT_NAME$1, __scopeSelect);
    const [content, setContent] = reactExports.useState(null);
    const [viewport, setViewport] = reactExports.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
    const [selectedItem, setSelectedItem] = reactExports.useState(null);
    const [selectedItemText, setSelectedItemText] = reactExports.useState(
      null
    );
    const getItems = useCollection(__scopeSelect);
    const [isPositioned, setIsPositioned] = reactExports.useState(false);
    const firstValidItemFoundRef = reactExports.useRef(false);
    reactExports.useEffect(() => {
      if (content) return hideOthers(content);
    }, [content]);
    useFocusGuards();
    const focusFirst2 = reactExports.useCallback(
      (candidates) => {
        const [firstItem, ...restItems] = getItems().map((item) => item.ref.current);
        const [lastItem] = restItems.slice(-1);
        const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
        for (const candidate of candidates) {
          if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
          candidate?.scrollIntoView({ block: "nearest" });
          if (candidate === firstItem && viewport) viewport.scrollTop = 0;
          if (candidate === lastItem && viewport) viewport.scrollTop = viewport.scrollHeight;
          candidate?.focus();
          if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
        }
      },
      [getItems, viewport]
    );
    const focusSelectedItem = reactExports.useCallback(
      () => focusFirst2([selectedItem, content]),
      [focusFirst2, selectedItem, content]
    );
    reactExports.useEffect(() => {
      if (isPositioned) {
        focusSelectedItem();
      }
    }, [isPositioned, focusSelectedItem]);
    const { onOpenChange, triggerPointerDownPosRef } = context;
    reactExports.useEffect(() => {
      if (content) {
        let pointerMoveDelta = { x: 0, y: 0 };
        const handlePointerMove = (event) => {
          pointerMoveDelta = {
            x: Math.abs(Math.round(event.pageX) - (triggerPointerDownPosRef.current?.x ?? 0)),
            y: Math.abs(Math.round(event.pageY) - (triggerPointerDownPosRef.current?.y ?? 0))
          };
        };
        const handlePointerUp = (event) => {
          if (pointerMoveDelta.x <= 10 && pointerMoveDelta.y <= 10) {
            event.preventDefault();
          } else {
            if (!content.contains(event.target)) {
              onOpenChange(false);
            }
          }
          document.removeEventListener("pointermove", handlePointerMove);
          triggerPointerDownPosRef.current = null;
        };
        if (triggerPointerDownPosRef.current !== null) {
          document.addEventListener("pointermove", handlePointerMove);
          document.addEventListener("pointerup", handlePointerUp, { capture: true, once: true });
        }
        return () => {
          document.removeEventListener("pointermove", handlePointerMove);
          document.removeEventListener("pointerup", handlePointerUp, { capture: true });
        };
      }
    }, [content, onOpenChange, triggerPointerDownPosRef]);
    reactExports.useEffect(() => {
      const close = () => onOpenChange(false);
      window.addEventListener("blur", close);
      window.addEventListener("resize", close);
      return () => {
        window.removeEventListener("blur", close);
        window.removeEventListener("resize", close);
      };
    }, [onOpenChange]);
    const [searchRef, handleTypeaheadSearch] = useTypeaheadSearch((search) => {
      const enabledItems = getItems().filter((item) => !item.disabled);
      const currentItem = enabledItems.find((item) => item.ref.current === document.activeElement);
      const nextItem = findNextItem(enabledItems, search, currentItem);
      if (nextItem) {
        setTimeout(() => nextItem.ref.current.focus());
      }
    });
    const itemRefCallback = reactExports.useCallback(
      (node, value, disabled) => {
        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
        const isSelectedItem = context.value !== void 0 && context.value === value;
        if (isSelectedItem || isFirstValidItem) {
          setSelectedItem(node);
          if (isFirstValidItem) firstValidItemFoundRef.current = true;
        }
      },
      [context.value]
    );
    const handleItemLeave = reactExports.useCallback(() => content?.focus(), [content]);
    const itemTextRefCallback = reactExports.useCallback(
      (node, value, disabled) => {
        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
        const isSelectedItem = context.value !== void 0 && context.value === value;
        if (isSelectedItem || isFirstValidItem) {
          setSelectedItemText(node);
        }
      },
      [context.value]
    );
    const SelectPosition = position === "popper" ? SelectPopperPosition : SelectItemAlignedPosition;
    const popperContentProps = SelectPosition === SelectPopperPosition ? {
      side,
      sideOffset,
      align,
      alignOffset,
      arrowPadding,
      collisionBoundary,
      collisionPadding,
      sticky,
      hideWhenDetached,
      avoidCollisions
    } : {};
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SelectContentProvider,
      {
        scope: __scopeSelect,
        content,
        viewport,
        onViewportChange: setViewport,
        itemRefCallback,
        selectedItem,
        onItemLeave: handleItemLeave,
        itemTextRefCallback,
        focusSelectedItem,
        selectedItemText,
        position,
        isPositioned,
        searchRef,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(ReactRemoveScroll, { as: Slot, allowPinchZoom: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          FocusScope,
          {
            asChild: true,
            trapped: context.open,
            onMountAutoFocus: (event) => {
              event.preventDefault();
            },
            onUnmountAutoFocus: composeEventHandlers(onCloseAutoFocus, (event) => {
              context.trigger?.focus({ preventScroll: true });
              event.preventDefault();
            }),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              DismissableLayer,
              {
                asChild: true,
                disableOutsidePointerEvents: true,
                onEscapeKeyDown,
                onPointerDownOutside,
                onFocusOutside: (event) => event.preventDefault(),
                onDismiss: () => context.onOpenChange(false),
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  SelectPosition,
                  {
                    role: "listbox",
                    id: context.contentId,
                    "data-state": context.open ? "open" : "closed",
                    dir: context.dir,
                    onContextMenu: (event) => event.preventDefault(),
                    ...contentProps,
                    ...popperContentProps,
                    onPlaced: () => setIsPositioned(true),
                    ref: composedRefs,
                    style: {
                      // flex layout so we can place the scroll buttons properly
                      display: "flex",
                      flexDirection: "column",
                      // reset the outline by default as the content MAY get focused
                      outline: "none",
                      ...contentProps.style
                    },
                    onKeyDown: composeEventHandlers(contentProps.onKeyDown, (event) => {
                      const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
                      if (event.key === "Tab") event.preventDefault();
                      if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);
                      if (["ArrowUp", "ArrowDown", "Home", "End"].includes(event.key)) {
                        const items2 = getItems().filter((item) => !item.disabled);
                        let candidateNodes = items2.map((item) => item.ref.current);
                        if (["ArrowUp", "End"].includes(event.key)) {
                          candidateNodes = candidateNodes.slice().reverse();
                        }
                        if (["ArrowUp", "ArrowDown"].includes(event.key)) {
                          const currentElement = event.target;
                          const currentIndex = candidateNodes.indexOf(currentElement);
                          candidateNodes = candidateNodes.slice(currentIndex + 1);
                        }
                        setTimeout(() => focusFirst2(candidateNodes));
                        event.preventDefault();
                      }
                    })
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
SelectContentImpl.displayName = CONTENT_IMPL_NAME;
var ITEM_ALIGNED_POSITION_NAME = "SelectItemAlignedPosition";
var SelectItemAlignedPosition = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeSelect, onPlaced, ...popperProps } = props;
  const context = useSelectContext(CONTENT_NAME$1, __scopeSelect);
  const contentContext = useSelectContentContext(CONTENT_NAME$1, __scopeSelect);
  const [contentWrapper, setContentWrapper] = reactExports.useState(null);
  const [content, setContent] = reactExports.useState(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
  const getItems = useCollection(__scopeSelect);
  const shouldExpandOnScrollRef = reactExports.useRef(false);
  const shouldRepositionRef = reactExports.useRef(true);
  const { viewport, selectedItem, selectedItemText, focusSelectedItem } = contentContext;
  const position = reactExports.useCallback(() => {
    if (context.trigger && context.valueNode && contentWrapper && content && viewport && selectedItem && selectedItemText) {
      const triggerRect = context.trigger.getBoundingClientRect();
      const contentRect = content.getBoundingClientRect();
      const valueNodeRect = context.valueNode.getBoundingClientRect();
      const itemTextRect = selectedItemText.getBoundingClientRect();
      if (context.dir !== "rtl") {
        const itemTextOffset = itemTextRect.left - contentRect.left;
        const left = valueNodeRect.left - itemTextOffset;
        const leftDelta = triggerRect.left - left;
        const minContentWidth = triggerRect.width + leftDelta;
        const contentWidth = Math.max(minContentWidth, contentRect.width);
        const rightEdge = window.innerWidth - CONTENT_MARGIN;
        const clampedLeft = clamp(left, [
          CONTENT_MARGIN,
          // Prevents the content from going off the starting edge of the
          // viewport. It may still go off the ending edge, but this can be
          // controlled by the user since they may want to manage overflow in a
          // specific way.
          // https://github.com/radix-ui/primitives/issues/2049
          Math.max(CONTENT_MARGIN, rightEdge - contentWidth)
        ]);
        contentWrapper.style.minWidth = minContentWidth + "px";
        contentWrapper.style.left = clampedLeft + "px";
      } else {
        const itemTextOffset = contentRect.right - itemTextRect.right;
        const right = window.innerWidth - valueNodeRect.right - itemTextOffset;
        const rightDelta = window.innerWidth - triggerRect.right - right;
        const minContentWidth = triggerRect.width + rightDelta;
        const contentWidth = Math.max(minContentWidth, contentRect.width);
        const leftEdge = window.innerWidth - CONTENT_MARGIN;
        const clampedRight = clamp(right, [
          CONTENT_MARGIN,
          Math.max(CONTENT_MARGIN, leftEdge - contentWidth)
        ]);
        contentWrapper.style.minWidth = minContentWidth + "px";
        contentWrapper.style.right = clampedRight + "px";
      }
      const items2 = getItems();
      const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
      const itemsHeight = viewport.scrollHeight;
      const contentStyles = window.getComputedStyle(content);
      const contentBorderTopWidth = parseInt(contentStyles.borderTopWidth, 10);
      const contentPaddingTop = parseInt(contentStyles.paddingTop, 10);
      const contentBorderBottomWidth = parseInt(contentStyles.borderBottomWidth, 10);
      const contentPaddingBottom = parseInt(contentStyles.paddingBottom, 10);
      const fullContentHeight = contentBorderTopWidth + contentPaddingTop + itemsHeight + contentPaddingBottom + contentBorderBottomWidth;
      const minContentHeight = Math.min(selectedItem.offsetHeight * 5, fullContentHeight);
      const viewportStyles = window.getComputedStyle(viewport);
      const viewportPaddingTop = parseInt(viewportStyles.paddingTop, 10);
      const viewportPaddingBottom = parseInt(viewportStyles.paddingBottom, 10);
      const topEdgeToTriggerMiddle = triggerRect.top + triggerRect.height / 2 - CONTENT_MARGIN;
      const triggerMiddleToBottomEdge = availableHeight - topEdgeToTriggerMiddle;
      const selectedItemHalfHeight = selectedItem.offsetHeight / 2;
      const itemOffsetMiddle = selectedItem.offsetTop + selectedItemHalfHeight;
      const contentTopToItemMiddle = contentBorderTopWidth + contentPaddingTop + itemOffsetMiddle;
      const itemMiddleToContentBottom = fullContentHeight - contentTopToItemMiddle;
      const willAlignWithoutTopOverflow = contentTopToItemMiddle <= topEdgeToTriggerMiddle;
      if (willAlignWithoutTopOverflow) {
        const isLastItem = items2.length > 0 && selectedItem === items2[items2.length - 1].ref.current;
        contentWrapper.style.bottom = "0px";
        const viewportOffsetBottom = content.clientHeight - viewport.offsetTop - viewport.offsetHeight;
        const clampedTriggerMiddleToBottomEdge = Math.max(
          triggerMiddleToBottomEdge,
          selectedItemHalfHeight + // viewport might have padding bottom, include it to avoid a scrollable viewport
          (isLastItem ? viewportPaddingBottom : 0) + viewportOffsetBottom + contentBorderBottomWidth
        );
        const height = contentTopToItemMiddle + clampedTriggerMiddleToBottomEdge;
        contentWrapper.style.height = height + "px";
      } else {
        const isFirstItem = items2.length > 0 && selectedItem === items2[0].ref.current;
        contentWrapper.style.top = "0px";
        const clampedTopEdgeToTriggerMiddle = Math.max(
          topEdgeToTriggerMiddle,
          contentBorderTopWidth + viewport.offsetTop + // viewport might have padding top, include it to avoid a scrollable viewport
          (isFirstItem ? viewportPaddingTop : 0) + selectedItemHalfHeight
        );
        const height = clampedTopEdgeToTriggerMiddle + itemMiddleToContentBottom;
        contentWrapper.style.height = height + "px";
        viewport.scrollTop = contentTopToItemMiddle - topEdgeToTriggerMiddle + viewport.offsetTop;
      }
      contentWrapper.style.margin = `${CONTENT_MARGIN}px 0`;
      contentWrapper.style.minHeight = minContentHeight + "px";
      contentWrapper.style.maxHeight = availableHeight + "px";
      onPlaced?.();
      requestAnimationFrame(() => shouldExpandOnScrollRef.current = true);
    }
  }, [
    getItems,
    context.trigger,
    context.valueNode,
    contentWrapper,
    content,
    viewport,
    selectedItem,
    selectedItemText,
    context.dir,
    onPlaced
  ]);
  useLayoutEffect2(() => position(), [position]);
  const [contentZIndex, setContentZIndex] = reactExports.useState();
  useLayoutEffect2(() => {
    if (content) setContentZIndex(window.getComputedStyle(content).zIndex);
  }, [content]);
  const handleScrollButtonChange = reactExports.useCallback(
    (node) => {
      if (node && shouldRepositionRef.current === true) {
        position();
        focusSelectedItem?.();
        shouldRepositionRef.current = false;
      }
    },
    [position, focusSelectedItem]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SelectViewportProvider,
    {
      scope: __scopeSelect,
      contentWrapper,
      shouldExpandOnScrollRef,
      onScrollButtonChange: handleScrollButtonChange,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          ref: setContentWrapper,
          style: {
            display: "flex",
            flexDirection: "column",
            position: "fixed",
            zIndex: contentZIndex
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Primitive$1.div,
            {
              ...popperProps,
              ref: composedRefs,
              style: {
                // When we get the height of the content, it includes borders. If we were to set
                // the height without having `boxSizing: 'border-box'` it would be too big.
                boxSizing: "border-box",
                // We need to ensure the content doesn't get taller than the wrapper
                maxHeight: "100%",
                ...popperProps.style
              }
            }
          )
        }
      )
    }
  );
});
SelectItemAlignedPosition.displayName = ITEM_ALIGNED_POSITION_NAME;
var POPPER_POSITION_NAME = "SelectPopperPosition";
var SelectPopperPosition = reactExports.forwardRef((props, forwardedRef) => {
  const {
    __scopeSelect,
    align = "start",
    collisionPadding = CONTENT_MARGIN,
    ...popperProps
  } = props;
  const popperScope = usePopperScope$1(__scopeSelect);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Content,
    {
      ...popperScope,
      ...popperProps,
      ref: forwardedRef,
      align,
      collisionPadding,
      style: {
        // Ensure border-box for floating-ui calculations
        boxSizing: "border-box",
        ...popperProps.style,
        // re-namespace exposed content custom properties
        ...{
          "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-select-content-available-width": "var(--radix-popper-available-width)",
          "--radix-select-content-available-height": "var(--radix-popper-available-height)",
          "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    }
  );
});
SelectPopperPosition.displayName = POPPER_POSITION_NAME;
var [SelectViewportProvider, useSelectViewportContext] = createSelectContext(CONTENT_NAME$1, {});
var VIEWPORT_NAME = "SelectViewport";
var SelectViewport = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, nonce, ...viewportProps } = props;
    const contentContext = useSelectContentContext(VIEWPORT_NAME, __scopeSelect);
    const viewportContext = useSelectViewportContext(VIEWPORT_NAME, __scopeSelect);
    const composedRefs = useComposedRefs(forwardedRef, contentContext.onViewportChange);
    const prevScrollTopRef = reactExports.useRef(0);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: `[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}`
          },
          nonce
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.Slot, { scope: __scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive$1.div,
        {
          "data-radix-select-viewport": "",
          role: "presentation",
          ...viewportProps,
          ref: composedRefs,
          style: {
            // we use position: 'relative' here on the `viewport` so that when we call
            // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
            // (independent of the scrollUpButton).
            position: "relative",
            flex: 1,
            // Viewport should only be scrollable in the vertical direction.
            // This won't work in vertical writing modes, so we'll need to
            // revisit this if/when that is supported
            // https://developer.chrome.com/blog/vertical-form-controls
            overflow: "hidden auto",
            ...viewportProps.style
          },
          onScroll: composeEventHandlers(viewportProps.onScroll, (event) => {
            const viewport = event.currentTarget;
            const { contentWrapper, shouldExpandOnScrollRef } = viewportContext;
            if (shouldExpandOnScrollRef?.current && contentWrapper) {
              const scrolledBy = Math.abs(prevScrollTopRef.current - viewport.scrollTop);
              if (scrolledBy > 0) {
                const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
                const cssMinHeight = parseFloat(contentWrapper.style.minHeight);
                const cssHeight = parseFloat(contentWrapper.style.height);
                const prevHeight = Math.max(cssMinHeight, cssHeight);
                if (prevHeight < availableHeight) {
                  const nextHeight = prevHeight + scrolledBy;
                  const clampedNextHeight = Math.min(availableHeight, nextHeight);
                  const heightDiff = nextHeight - clampedNextHeight;
                  contentWrapper.style.height = clampedNextHeight + "px";
                  if (contentWrapper.style.bottom === "0px") {
                    viewport.scrollTop = heightDiff > 0 ? heightDiff : 0;
                    contentWrapper.style.justifyContent = "flex-end";
                  }
                }
              }
            }
            prevScrollTopRef.current = viewport.scrollTop;
          })
        }
      ) })
    ] });
  }
);
SelectViewport.displayName = VIEWPORT_NAME;
var GROUP_NAME = "SelectGroup";
var [SelectGroupContextProvider, useSelectGroupContext] = createSelectContext(GROUP_NAME);
var SelectGroup = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...groupProps } = props;
    const groupId = useId();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectGroupContextProvider, { scope: __scopeSelect, id: groupId, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive$1.div, { role: "group", "aria-labelledby": groupId, ...groupProps, ref: forwardedRef }) });
  }
);
SelectGroup.displayName = GROUP_NAME;
var LABEL_NAME = "SelectLabel";
var SelectLabel$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...labelProps } = props;
    const groupContext = useSelectGroupContext(LABEL_NAME, __scopeSelect);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive$1.div, { id: groupContext.id, ...labelProps, ref: forwardedRef });
  }
);
SelectLabel$1.displayName = LABEL_NAME;
var ITEM_NAME = "SelectItem";
var [SelectItemContextProvider, useSelectItemContext] = createSelectContext(ITEM_NAME);
var SelectItem$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSelect,
      value,
      disabled = false,
      textValue: textValueProp,
      ...itemProps
    } = props;
    const context = useSelectContext(ITEM_NAME, __scopeSelect);
    const contentContext = useSelectContentContext(ITEM_NAME, __scopeSelect);
    const isSelected = context.value === value;
    const [textValue, setTextValue] = reactExports.useState(textValueProp ?? "");
    const [isFocused, setIsFocused] = reactExports.useState(false);
    const composedRefs = useComposedRefs(
      forwardedRef,
      (node) => contentContext.itemRefCallback?.(node, value, disabled)
    );
    const textId = useId();
    const pointerTypeRef = reactExports.useRef("touch");
    const handleSelect = () => {
      if (!disabled) {
        context.onValueChange(value);
        context.onOpenChange(false);
      }
    };
    if (value === "") {
      throw new Error(
        "A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SelectItemContextProvider,
      {
        scope: __scopeSelect,
        value,
        disabled,
        textId,
        isSelected,
        onItemTextChange: reactExports.useCallback((node) => {
          setTextValue((prevTextValue) => prevTextValue || (node?.textContent ?? "").trim());
        }, []),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Collection.ItemSlot,
          {
            scope: __scopeSelect,
            value,
            disabled,
            textValue,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Primitive$1.div,
              {
                role: "option",
                "aria-labelledby": textId,
                "data-highlighted": isFocused ? "" : void 0,
                "aria-selected": isSelected && isFocused,
                "data-state": isSelected ? "checked" : "unchecked",
                "aria-disabled": disabled || void 0,
                "data-disabled": disabled ? "" : void 0,
                tabIndex: disabled ? void 0 : -1,
                ...itemProps,
                ref: composedRefs,
                onFocus: composeEventHandlers(itemProps.onFocus, () => setIsFocused(true)),
                onBlur: composeEventHandlers(itemProps.onBlur, () => setIsFocused(false)),
                onClick: composeEventHandlers(itemProps.onClick, () => {
                  if (pointerTypeRef.current !== "mouse") handleSelect();
                }),
                onPointerUp: composeEventHandlers(itemProps.onPointerUp, () => {
                  if (pointerTypeRef.current === "mouse") handleSelect();
                }),
                onPointerDown: composeEventHandlers(itemProps.onPointerDown, (event) => {
                  pointerTypeRef.current = event.pointerType;
                }),
                onPointerMove: composeEventHandlers(itemProps.onPointerMove, (event) => {
                  pointerTypeRef.current = event.pointerType;
                  if (disabled) {
                    contentContext.onItemLeave?.();
                  } else if (pointerTypeRef.current === "mouse") {
                    event.currentTarget.focus({ preventScroll: true });
                  }
                }),
                onPointerLeave: composeEventHandlers(itemProps.onPointerLeave, (event) => {
                  if (event.currentTarget === document.activeElement) {
                    contentContext.onItemLeave?.();
                  }
                }),
                onKeyDown: composeEventHandlers(itemProps.onKeyDown, (event) => {
                  const isTypingAhead = contentContext.searchRef?.current !== "";
                  if (isTypingAhead && event.key === " ") return;
                  if (SELECTION_KEYS.includes(event.key)) handleSelect();
                  if (event.key === " ") event.preventDefault();
                })
              }
            )
          }
        )
      }
    );
  }
);
SelectItem$1.displayName = ITEM_NAME;
var ITEM_TEXT_NAME = "SelectItemText";
var SelectItemText = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, className, style, ...itemTextProps } = props;
    const context = useSelectContext(ITEM_TEXT_NAME, __scopeSelect);
    const contentContext = useSelectContentContext(ITEM_TEXT_NAME, __scopeSelect);
    const itemContext = useSelectItemContext(ITEM_TEXT_NAME, __scopeSelect);
    const nativeOptionsContext = useSelectNativeOptionsContext(ITEM_TEXT_NAME, __scopeSelect);
    const [itemTextNode, setItemTextNode] = reactExports.useState(null);
    const composedRefs = useComposedRefs(
      forwardedRef,
      (node) => setItemTextNode(node),
      itemContext.onItemTextChange,
      (node) => contentContext.itemTextRefCallback?.(node, itemContext.value, itemContext.disabled)
    );
    const textContent = itemTextNode?.textContent;
    const nativeOption = reactExports.useMemo(
      () => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: itemContext.value, disabled: itemContext.disabled, children: textContent }, itemContext.value),
      [itemContext.disabled, itemContext.value, textContent]
    );
    const { onNativeOptionAdd, onNativeOptionRemove } = nativeOptionsContext;
    useLayoutEffect2(() => {
      onNativeOptionAdd(nativeOption);
      return () => onNativeOptionRemove(nativeOption);
    }, [onNativeOptionAdd, onNativeOptionRemove, nativeOption]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive$1.span, { id: itemContext.textId, ...itemTextProps, ref: composedRefs }),
      itemContext.isSelected && context.valueNode && !context.valueNodeHasChildren ? reactDomExports.createPortal(itemTextProps.children, context.valueNode) : null
    ] });
  }
);
SelectItemText.displayName = ITEM_TEXT_NAME;
var ITEM_INDICATOR_NAME = "SelectItemIndicator";
var SelectItemIndicator = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...itemIndicatorProps } = props;
    const itemContext = useSelectItemContext(ITEM_INDICATOR_NAME, __scopeSelect);
    return itemContext.isSelected ? /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive$1.span, { "aria-hidden": true, ...itemIndicatorProps, ref: forwardedRef }) : null;
  }
);
SelectItemIndicator.displayName = ITEM_INDICATOR_NAME;
var SCROLL_UP_BUTTON_NAME = "SelectScrollUpButton";
var SelectScrollUpButton$1 = reactExports.forwardRef((props, forwardedRef) => {
  const contentContext = useSelectContentContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);
  const viewportContext = useSelectViewportContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);
  const [canScrollUp, setCanScrollUp] = reactExports.useState(false);
  const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);
  useLayoutEffect2(() => {
    if (contentContext.viewport && contentContext.isPositioned) {
      let handleScroll2 = function() {
        const canScrollUp2 = viewport.scrollTop > 0;
        setCanScrollUp(canScrollUp2);
      };
      const viewport = contentContext.viewport;
      handleScroll2();
      viewport.addEventListener("scroll", handleScroll2);
      return () => viewport.removeEventListener("scroll", handleScroll2);
    }
  }, [contentContext.viewport, contentContext.isPositioned]);
  return canScrollUp ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    SelectScrollButtonImpl,
    {
      ...props,
      ref: composedRefs,
      onAutoScroll: () => {
        const { viewport, selectedItem } = contentContext;
        if (viewport && selectedItem) {
          viewport.scrollTop = viewport.scrollTop - selectedItem.offsetHeight;
        }
      }
    }
  ) : null;
});
SelectScrollUpButton$1.displayName = SCROLL_UP_BUTTON_NAME;
var SCROLL_DOWN_BUTTON_NAME = "SelectScrollDownButton";
var SelectScrollDownButton$1 = reactExports.forwardRef((props, forwardedRef) => {
  const contentContext = useSelectContentContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);
  const viewportContext = useSelectViewportContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);
  const [canScrollDown, setCanScrollDown] = reactExports.useState(false);
  const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);
  useLayoutEffect2(() => {
    if (contentContext.viewport && contentContext.isPositioned) {
      let handleScroll2 = function() {
        const maxScroll = viewport.scrollHeight - viewport.clientHeight;
        const canScrollDown2 = Math.ceil(viewport.scrollTop) < maxScroll;
        setCanScrollDown(canScrollDown2);
      };
      const viewport = contentContext.viewport;
      handleScroll2();
      viewport.addEventListener("scroll", handleScroll2);
      return () => viewport.removeEventListener("scroll", handleScroll2);
    }
  }, [contentContext.viewport, contentContext.isPositioned]);
  return canScrollDown ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    SelectScrollButtonImpl,
    {
      ...props,
      ref: composedRefs,
      onAutoScroll: () => {
        const { viewport, selectedItem } = contentContext;
        if (viewport && selectedItem) {
          viewport.scrollTop = viewport.scrollTop + selectedItem.offsetHeight;
        }
      }
    }
  ) : null;
});
SelectScrollDownButton$1.displayName = SCROLL_DOWN_BUTTON_NAME;
var SelectScrollButtonImpl = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeSelect, onAutoScroll, ...scrollIndicatorProps } = props;
  const contentContext = useSelectContentContext("SelectScrollButton", __scopeSelect);
  const autoScrollTimerRef = reactExports.useRef(null);
  const getItems = useCollection(__scopeSelect);
  const clearAutoScrollTimer = reactExports.useCallback(() => {
    if (autoScrollTimerRef.current !== null) {
      window.clearInterval(autoScrollTimerRef.current);
      autoScrollTimerRef.current = null;
    }
  }, []);
  reactExports.useEffect(() => {
    return () => clearAutoScrollTimer();
  }, [clearAutoScrollTimer]);
  useLayoutEffect2(() => {
    const activeItem = getItems().find((item) => item.ref.current === document.activeElement);
    activeItem?.ref.current?.scrollIntoView({ block: "nearest" });
  }, [getItems]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive$1.div,
    {
      "aria-hidden": true,
      ...scrollIndicatorProps,
      ref: forwardedRef,
      style: { flexShrink: 0, ...scrollIndicatorProps.style },
      onPointerDown: composeEventHandlers(scrollIndicatorProps.onPointerDown, () => {
        if (autoScrollTimerRef.current === null) {
          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
        }
      }),
      onPointerMove: composeEventHandlers(scrollIndicatorProps.onPointerMove, () => {
        contentContext.onItemLeave?.();
        if (autoScrollTimerRef.current === null) {
          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
        }
      }),
      onPointerLeave: composeEventHandlers(scrollIndicatorProps.onPointerLeave, () => {
        clearAutoScrollTimer();
      })
    }
  );
});
var SEPARATOR_NAME = "SelectSeparator";
var SelectSeparator$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...separatorProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive$1.div, { "aria-hidden": true, ...separatorProps, ref: forwardedRef });
  }
);
SelectSeparator$1.displayName = SEPARATOR_NAME;
var ARROW_NAME$1 = "SelectArrow";
var SelectArrow = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...arrowProps } = props;
    const popperScope = usePopperScope$1(__scopeSelect);
    const context = useSelectContext(ARROW_NAME$1, __scopeSelect);
    const contentContext = useSelectContentContext(ARROW_NAME$1, __scopeSelect);
    return context.open && contentContext.position === "popper" ? /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow, { ...popperScope, ...arrowProps, ref: forwardedRef }) : null;
  }
);
SelectArrow.displayName = ARROW_NAME$1;
var BUBBLE_INPUT_NAME$2 = "SelectBubbleInput";
var SelectBubbleInput = reactExports.forwardRef(
  ({ __scopeSelect, value, ...props }, forwardedRef) => {
    const ref2 = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref2);
    const prevValue = usePrevious(value);
    reactExports.useEffect(() => {
      const select = ref2.current;
      if (!select) return;
      const selectProto = window.HTMLSelectElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(
        selectProto,
        "value"
      );
      const setValue = descriptor.set;
      if (prevValue !== value && setValue) {
        const event = new Event("change", { bubbles: true });
        setValue.call(select, value);
        select.dispatchEvent(event);
      }
    }, [prevValue, value]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive$1.select,
      {
        ...props,
        style: { ...VISUALLY_HIDDEN_STYLES, ...props.style },
        ref: composedRefs,
        defaultValue: value
      }
    );
  }
);
SelectBubbleInput.displayName = BUBBLE_INPUT_NAME$2;
function shouldShowPlaceholder(value) {
  return value === "" || value === void 0;
}
function useTypeaheadSearch(onSearchChange) {
  const handleSearchChange = useCallbackRef$1(onSearchChange);
  const searchRef = reactExports.useRef("");
  const timerRef = reactExports.useRef(0);
  const handleTypeaheadSearch = reactExports.useCallback(
    (key) => {
      const search = searchRef.current + key;
      handleSearchChange(search);
      (function updateSearch(value) {
        searchRef.current = value;
        window.clearTimeout(timerRef.current);
        if (value !== "") timerRef.current = window.setTimeout(() => updateSearch(""), 1e3);
      })(search);
    },
    [handleSearchChange]
  );
  const resetTypeahead = reactExports.useCallback(() => {
    searchRef.current = "";
    window.clearTimeout(timerRef.current);
  }, []);
  reactExports.useEffect(() => {
    return () => window.clearTimeout(timerRef.current);
  }, []);
  return [searchRef, handleTypeaheadSearch, resetTypeahead];
}
function findNextItem(items2, search, currentItem) {
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const normalizedSearch = isRepeated ? search[0] : search;
  const currentItemIndex = currentItem ? items2.indexOf(currentItem) : -1;
  let wrappedItems = wrapArray(items2, Math.max(currentItemIndex, 0));
  const excludeCurrentItem = normalizedSearch.length === 1;
  if (excludeCurrentItem) wrappedItems = wrappedItems.filter((v) => v !== currentItem);
  const nextItem = wrappedItems.find(
    (item) => item.textValue.toLowerCase().startsWith(normalizedSearch.toLowerCase())
  );
  return nextItem !== currentItem ? nextItem : void 0;
}
function wrapArray(array2, startIndex) {
  return array2.map((_2, index2) => array2[(startIndex + index2) % array2.length]);
}
var Root2 = Select$1;
var Trigger$1 = SelectTrigger$1;
var Value = SelectValue$1;
var Icon = SelectIcon;
var Portal = SelectPortal;
var Content2$1 = SelectContent$1;
var Viewport = SelectViewport;
var Label = SelectLabel$1;
var Item = SelectItem$1;
var ItemText = SelectItemText;
var ItemIndicator = SelectItemIndicator;
var ScrollUpButton = SelectScrollUpButton$1;
var ScrollDownButton = SelectScrollDownButton$1;
var Separator = SelectSeparator$1;
const Select = Root2;
const SelectValue = Value;
const SelectTrigger = reactExports.forwardRef(({ className, children, ...props }, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  Trigger$1,
  {
    ref: ref2,
    className: cn$2(
      "flex h-9 w-full items-center justify-between whitespace-nowrap rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1 hover:border-[#646cff] hover:border-1",
      className
    ),
    ...props,
    children: [
      children,
      /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CaretSortIcon, { className: "h-4 w-4 opacity-50" }) })
    ]
  }
));
SelectTrigger.displayName = Trigger$1.displayName;
const SelectScrollUpButton = reactExports.forwardRef(({ className, ...props }, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  ScrollUpButton,
  {
    ref: ref2,
    className: cn$2(
      "flex cursor-default items-center justify-center py-1",
      className
    ),
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronUpIcon, {})
  }
));
SelectScrollUpButton.displayName = ScrollUpButton.displayName;
const SelectScrollDownButton = reactExports.forwardRef(({ className, ...props }, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  ScrollDownButton,
  {
    ref: ref2,
    className: cn$2(
      "flex cursor-default items-center justify-center py-1",
      className
    ),
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronDownIcon, {})
  }
));
SelectScrollDownButton.displayName = ScrollDownButton.displayName;
const SelectContent = reactExports.forwardRef(({ className, children, position = "popper", ...props }, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
  Content2$1,
  {
    ref: ref2,
    className: cn$2(
      "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      position === "popper" && "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
      className
    ),
    position,
    ...props,
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SelectScrollUpButton, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Viewport,
        {
          className: cn$2(
            "p-1",
            position === "popper" && "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
          ),
          children
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(SelectScrollDownButton, {})
    ]
  }
) }));
SelectContent.displayName = Content2$1.displayName;
const SelectLabel = reactExports.forwardRef(({ className, ...props }, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Label,
  {
    ref: ref2,
    className: cn$2("px-2 py-1.5 text-sm font-semibold", className),
    ...props
  }
));
SelectLabel.displayName = Label.displayName;
const SelectItem = reactExports.forwardRef(({ className, children, ...props }, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  Item,
  {
    ref: ref2,
    className: cn$2(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    ),
    ...props,
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "absolute right-2 flex h-3.5 w-3.5 items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicator, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(CheckIcon, { className: "h-4 w-4" }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ItemText, { children })
    ]
  }
));
SelectItem.displayName = Item.displayName;
const SelectSeparator = reactExports.forwardRef(({ className, ...props }, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Separator,
  {
    ref: ref2,
    className: cn$2("-mx-1 my-1 h-px bg-muted", className),
    ...props
  }
));
SelectSeparator.displayName = Separator.displayName;
const useTheme = () => {
  const [theme, setTheme] = reactExports.useState(() => {
    const savedTheme = localStorage.getItem("theme");
    return savedTheme || "system";
  });
  reactExports.useEffect(() => {
    const darkModeMediaQuery = window.matchMedia(
      "(prefers-color-scheme: dark)"
    );
    const handleDarkModeChange = (e) => {
      if (theme === "system") {
        updateDocumentTheme(e.matches ? "dark" : "light");
      }
    };
    const updateDocumentTheme = (newTheme) => {
      document.documentElement.classList.toggle("dark", newTheme === "dark");
    };
    if (theme === "system") {
      updateDocumentTheme(darkModeMediaQuery.matches ? "dark" : "light");
    } else {
      updateDocumentTheme(theme);
    }
    darkModeMediaQuery.addEventListener("change", handleDarkModeChange);
    return () => {
      darkModeMediaQuery.removeEventListener("change", handleDarkModeChange);
    };
  }, [theme]);
  const setThemeWithSideEffect = reactExports.useCallback((newTheme) => {
    setTheme(newTheme);
    localStorage.setItem("theme", newTheme);
    if (newTheme !== "system") {
      document.documentElement.classList.toggle("dark", newTheme === "dark");
    }
  }, []);
  return reactExports.useMemo(
    () => [theme, setThemeWithSideEffect],
    [theme, setThemeWithSideEffect]
  );
};
const version = "0.21.0";
var SLOTTABLE_IDENTIFIER = /* @__PURE__ */ Symbol("radix.slottable");
// @__NO_SIDE_EFFECTS__
function createSlottable(ownerName) {
  const Slottable2 = ({ children }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
  };
  Slottable2.displayName = `${ownerName}.Slottable`;
  Slottable2.__radixId = SLOTTABLE_IDENTIFIER;
  return Slottable2;
}
var [createTooltipContext] = createContextScope("Tooltip", [
  createPopperScope
]);
var usePopperScope = createPopperScope();
var PROVIDER_NAME = "TooltipProvider";
var DEFAULT_DELAY_DURATION = 700;
var TOOLTIP_OPEN = "tooltip.open";
var [TooltipProviderContextProvider, useTooltipProviderContext] = createTooltipContext(PROVIDER_NAME);
var TooltipProvider$1 = (props) => {
  const {
    __scopeTooltip,
    delayDuration = DEFAULT_DELAY_DURATION,
    skipDelayDuration = 300,
    disableHoverableContent = false,
    children
  } = props;
  const isOpenDelayedRef = reactExports.useRef(true);
  const isPointerInTransitRef = reactExports.useRef(false);
  const skipDelayTimerRef = reactExports.useRef(0);
  reactExports.useEffect(() => {
    const skipDelayTimer = skipDelayTimerRef.current;
    return () => window.clearTimeout(skipDelayTimer);
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TooltipProviderContextProvider,
    {
      scope: __scopeTooltip,
      isOpenDelayedRef,
      delayDuration,
      onOpen: reactExports.useCallback(() => {
        window.clearTimeout(skipDelayTimerRef.current);
        isOpenDelayedRef.current = false;
      }, []),
      onClose: reactExports.useCallback(() => {
        window.clearTimeout(skipDelayTimerRef.current);
        skipDelayTimerRef.current = window.setTimeout(
          () => isOpenDelayedRef.current = true,
          skipDelayDuration
        );
      }, [skipDelayDuration]),
      isPointerInTransitRef,
      onPointerInTransitChange: reactExports.useCallback((inTransit) => {
        isPointerInTransitRef.current = inTransit;
      }, []),
      disableHoverableContent,
      children
    }
  );
};
TooltipProvider$1.displayName = PROVIDER_NAME;
var TOOLTIP_NAME = "Tooltip";
var [TooltipContextProvider, useTooltipContext] = createTooltipContext(TOOLTIP_NAME);
var Tooltip$1 = (props) => {
  const {
    __scopeTooltip,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    disableHoverableContent: disableHoverableContentProp,
    delayDuration: delayDurationProp
  } = props;
  const providerContext = useTooltipProviderContext(TOOLTIP_NAME, props.__scopeTooltip);
  const popperScope = usePopperScope(__scopeTooltip);
  const [trigger, setTrigger] = reactExports.useState(null);
  const contentId = useId();
  const openTimerRef = reactExports.useRef(0);
  const disableHoverableContent = disableHoverableContentProp ?? providerContext.disableHoverableContent;
  const delayDuration = delayDurationProp ?? providerContext.delayDuration;
  const wasOpenDelayedRef = reactExports.useRef(false);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: (open2) => {
      if (open2) {
        providerContext.onOpen();
        document.dispatchEvent(new CustomEvent(TOOLTIP_OPEN));
      } else {
        providerContext.onClose();
      }
      onOpenChange?.(open2);
    },
    caller: TOOLTIP_NAME
  });
  const stateAttribute = reactExports.useMemo(() => {
    return open ? wasOpenDelayedRef.current ? "delayed-open" : "instant-open" : "closed";
  }, [open]);
  const handleOpen = reactExports.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = 0;
    wasOpenDelayedRef.current = false;
    setOpen(true);
  }, [setOpen]);
  const handleClose = reactExports.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = 0;
    setOpen(false);
  }, [setOpen]);
  const handleDelayedOpen = reactExports.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = window.setTimeout(() => {
      wasOpenDelayedRef.current = true;
      setOpen(true);
      openTimerRef.current = 0;
    }, delayDuration);
  }, [delayDuration, setOpen]);
  reactExports.useEffect(() => {
    return () => {
      if (openTimerRef.current) {
        window.clearTimeout(openTimerRef.current);
        openTimerRef.current = 0;
      }
    };
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$2, { ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    TooltipContextProvider,
    {
      scope: __scopeTooltip,
      contentId,
      open,
      stateAttribute,
      trigger,
      onTriggerChange: setTrigger,
      onTriggerEnter: reactExports.useCallback(() => {
        if (providerContext.isOpenDelayedRef.current) handleDelayedOpen();
        else handleOpen();
      }, [providerContext.isOpenDelayedRef, handleDelayedOpen, handleOpen]),
      onTriggerLeave: reactExports.useCallback(() => {
        if (disableHoverableContent) {
          handleClose();
        } else {
          window.clearTimeout(openTimerRef.current);
          openTimerRef.current = 0;
        }
      }, [handleClose, disableHoverableContent]),
      onOpen: handleOpen,
      onClose: handleClose,
      disableHoverableContent,
      children
    }
  ) });
};
Tooltip$1.displayName = TOOLTIP_NAME;
var TRIGGER_NAME$1 = "TooltipTrigger";
var TooltipTrigger$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTooltip, ...triggerProps } = props;
    const context = useTooltipContext(TRIGGER_NAME$1, __scopeTooltip);
    const providerContext = useTooltipProviderContext(TRIGGER_NAME$1, __scopeTooltip);
    const popperScope = usePopperScope(__scopeTooltip);
    const ref2 = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref2, context.onTriggerChange);
    const isPointerDownRef = reactExports.useRef(false);
    const hasPointerMoveOpenedRef = reactExports.useRef(false);
    const handlePointerUp = reactExports.useCallback(() => isPointerDownRef.current = false, []);
    reactExports.useEffect(() => {
      return () => document.removeEventListener("pointerup", handlePointerUp);
    }, [handlePointerUp]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor, { asChild: true, ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive$1.button,
      {
        "aria-describedby": context.open ? context.contentId : void 0,
        "data-state": context.stateAttribute,
        ...triggerProps,
        ref: composedRefs,
        onPointerMove: composeEventHandlers(props.onPointerMove, (event) => {
          if (event.pointerType === "touch") return;
          if (!hasPointerMoveOpenedRef.current && !providerContext.isPointerInTransitRef.current) {
            context.onTriggerEnter();
            hasPointerMoveOpenedRef.current = true;
          }
        }),
        onPointerLeave: composeEventHandlers(props.onPointerLeave, () => {
          context.onTriggerLeave();
          hasPointerMoveOpenedRef.current = false;
        }),
        onPointerDown: composeEventHandlers(props.onPointerDown, () => {
          if (context.open) {
            context.onClose();
          }
          isPointerDownRef.current = true;
          document.addEventListener("pointerup", handlePointerUp, { once: true });
        }),
        onFocus: composeEventHandlers(props.onFocus, () => {
          if (!isPointerDownRef.current) context.onOpen();
        }),
        onBlur: composeEventHandlers(props.onBlur, context.onClose),
        onClick: composeEventHandlers(props.onClick, context.onClose)
      }
    ) });
  }
);
TooltipTrigger$1.displayName = TRIGGER_NAME$1;
var PORTAL_NAME = "TooltipPortal";
var [PortalProvider, usePortalContext] = createTooltipContext(PORTAL_NAME, {
  forceMount: void 0
});
var CONTENT_NAME = "TooltipContent";
var TooltipContent$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext(CONTENT_NAME, props.__scopeTooltip);
    const { forceMount = portalContext.forceMount, side = "top", ...contentProps } = props;
    const context = useTooltipContext(CONTENT_NAME, props.__scopeTooltip);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: context.disableHoverableContent ? /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContentImpl, { side, ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContentHoverable, { side, ...contentProps, ref: forwardedRef }) });
  }
);
var TooltipContentHoverable = reactExports.forwardRef((props, forwardedRef) => {
  const context = useTooltipContext(CONTENT_NAME, props.__scopeTooltip);
  const providerContext = useTooltipProviderContext(CONTENT_NAME, props.__scopeTooltip);
  const ref2 = reactExports.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref2);
  const [pointerGraceArea, setPointerGraceArea] = reactExports.useState(null);
  const { trigger, onClose } = context;
  const content = ref2.current;
  const { onPointerInTransitChange } = providerContext;
  const handleRemoveGraceArea = reactExports.useCallback(() => {
    setPointerGraceArea(null);
    onPointerInTransitChange(false);
  }, [onPointerInTransitChange]);
  const handleCreateGraceArea = reactExports.useCallback(
    (event, hoverTarget) => {
      const currentTarget = event.currentTarget;
      const exitPoint = { x: event.clientX, y: event.clientY };
      const exitSide = getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());
      const paddedExitPoints = getPaddedExitPoints(exitPoint, exitSide);
      const hoverTargetPoints = getPointsFromRect(hoverTarget.getBoundingClientRect());
      const graceArea = getHull([...paddedExitPoints, ...hoverTargetPoints]);
      setPointerGraceArea(graceArea);
      onPointerInTransitChange(true);
    },
    [onPointerInTransitChange]
  );
  reactExports.useEffect(() => {
    return () => handleRemoveGraceArea();
  }, [handleRemoveGraceArea]);
  reactExports.useEffect(() => {
    if (trigger && content) {
      const handleTriggerLeave = (event) => handleCreateGraceArea(event, content);
      const handleContentLeave = (event) => handleCreateGraceArea(event, trigger);
      trigger.addEventListener("pointerleave", handleTriggerLeave);
      content.addEventListener("pointerleave", handleContentLeave);
      return () => {
        trigger.removeEventListener("pointerleave", handleTriggerLeave);
        content.removeEventListener("pointerleave", handleContentLeave);
      };
    }
  }, [trigger, content, handleCreateGraceArea, handleRemoveGraceArea]);
  reactExports.useEffect(() => {
    if (pointerGraceArea) {
      const handleTrackPointerGrace = (event) => {
        const target = event.target;
        const pointerPosition = { x: event.clientX, y: event.clientY };
        const hasEnteredTarget = trigger?.contains(target) || content?.contains(target);
        const isPointerOutsideGraceArea = !isPointInPolygon(pointerPosition, pointerGraceArea);
        if (hasEnteredTarget) {
          handleRemoveGraceArea();
        } else if (isPointerOutsideGraceArea) {
          handleRemoveGraceArea();
          onClose();
        }
      };
      document.addEventListener("pointermove", handleTrackPointerGrace);
      return () => document.removeEventListener("pointermove", handleTrackPointerGrace);
    }
  }, [trigger, content, pointerGraceArea, onClose, handleRemoveGraceArea]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContentImpl, { ...props, ref: composedRefs });
});
var [VisuallyHiddenContentContextProvider, useVisuallyHiddenContentContext] = createTooltipContext(TOOLTIP_NAME, { isInside: false });
var Slottable = /* @__PURE__ */ createSlottable("TooltipContent");
var TooltipContentImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeTooltip,
      children,
      "aria-label": ariaLabel,
      onEscapeKeyDown,
      onPointerDownOutside,
      ...contentProps
    } = props;
    const context = useTooltipContext(CONTENT_NAME, __scopeTooltip);
    const popperScope = usePopperScope(__scopeTooltip);
    const { onClose } = context;
    reactExports.useEffect(() => {
      document.addEventListener(TOOLTIP_OPEN, onClose);
      return () => document.removeEventListener(TOOLTIP_OPEN, onClose);
    }, [onClose]);
    reactExports.useEffect(() => {
      if (context.trigger) {
        const handleScroll2 = (event) => {
          const target = event.target;
          if (target?.contains(context.trigger)) onClose();
        };
        window.addEventListener("scroll", handleScroll2, { capture: true });
        return () => window.removeEventListener("scroll", handleScroll2, { capture: true });
      }
    }, [context.trigger, onClose]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      DismissableLayer,
      {
        asChild: true,
        disableOutsidePointerEvents: false,
        onEscapeKeyDown,
        onPointerDownOutside,
        onFocusOutside: (event) => event.preventDefault(),
        onDismiss: onClose,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Content,
          {
            "data-state": context.stateAttribute,
            ...popperScope,
            ...contentProps,
            ref: forwardedRef,
            style: {
              ...contentProps.style,
              // re-namespace exposed content custom properties
              ...{
                "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
                "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
                "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
                "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
                "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
              }
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Slottable, { children }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(VisuallyHiddenContentContextProvider, { scope: __scopeTooltip, isInside: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Root$5, { id: context.contentId, role: "tooltip", children: ariaLabel || children }) })
            ]
          }
        )
      }
    );
  }
);
TooltipContent$1.displayName = CONTENT_NAME;
var ARROW_NAME = "TooltipArrow";
var TooltipArrow = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTooltip, ...arrowProps } = props;
    const popperScope = usePopperScope(__scopeTooltip);
    const visuallyHiddenContentContext = useVisuallyHiddenContentContext(
      ARROW_NAME,
      __scopeTooltip
    );
    return visuallyHiddenContentContext.isInside ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
TooltipArrow.displayName = ARROW_NAME;
function getExitSideFromRect(point, rect) {
  const top = Math.abs(rect.top - point.y);
  const bottom = Math.abs(rect.bottom - point.y);
  const right = Math.abs(rect.right - point.x);
  const left = Math.abs(rect.left - point.x);
  switch (Math.min(top, bottom, right, left)) {
    case left:
      return "left";
    case right:
      return "right";
    case top:
      return "top";
    case bottom:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function getPaddedExitPoints(exitPoint, exitSide, padding = 5) {
  const paddedExitPoints = [];
  switch (exitSide) {
    case "top":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y + padding },
        { x: exitPoint.x + padding, y: exitPoint.y + padding }
      );
      break;
    case "bottom":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y - padding },
        { x: exitPoint.x + padding, y: exitPoint.y - padding }
      );
      break;
    case "left":
      paddedExitPoints.push(
        { x: exitPoint.x + padding, y: exitPoint.y - padding },
        { x: exitPoint.x + padding, y: exitPoint.y + padding }
      );
      break;
    case "right":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y - padding },
        { x: exitPoint.x - padding, y: exitPoint.y + padding }
      );
      break;
  }
  return paddedExitPoints;
}
function getPointsFromRect(rect) {
  const { top, right, bottom, left } = rect;
  return [
    { x: left, y: top },
    { x: right, y: top },
    { x: right, y: bottom },
    { x: left, y: bottom }
  ];
}
function isPointInPolygon(point, polygon) {
  const { x: x2, y: y2 } = point;
  let inside = false;
  for (let i = 0, j2 = polygon.length - 1; i < polygon.length; j2 = i++) {
    const ii2 = polygon[i];
    const jj = polygon[j2];
    const xi2 = ii2.x;
    const yi2 = ii2.y;
    const xj = jj.x;
    const yj = jj.y;
    const intersect = yi2 > y2 !== yj > y2 && x2 < (xj - xi2) * (y2 - yi2) / (yj - yi2) + xi2;
    if (intersect) inside = !inside;
  }
  return inside;
}
function getHull(points) {
  const newPoints = points.slice();
  newPoints.sort((a2, b) => {
    if (a2.x < b.x) return -1;
    else if (a2.x > b.x) return 1;
    else if (a2.y < b.y) return -1;
    else if (a2.y > b.y) return 1;
    else return 0;
  });
  return getHullPresorted(newPoints);
}
function getHullPresorted(points) {
  if (points.length <= 1) return points.slice();
  const upperHull = [];
  for (let i = 0; i < points.length; i++) {
    const p2 = points[i];
    while (upperHull.length >= 2) {
      const q2 = upperHull[upperHull.length - 1];
      const r2 = upperHull[upperHull.length - 2];
      if ((q2.x - r2.x) * (p2.y - r2.y) >= (q2.y - r2.y) * (p2.x - r2.x)) upperHull.pop();
      else break;
    }
    upperHull.push(p2);
  }
  upperHull.pop();
  const lowerHull = [];
  for (let i = points.length - 1; i >= 0; i--) {
    const p2 = points[i];
    while (lowerHull.length >= 2) {
      const q2 = lowerHull[lowerHull.length - 1];
      const r2 = lowerHull[lowerHull.length - 2];
      if ((q2.x - r2.x) * (p2.y - r2.y) >= (q2.y - r2.y) * (p2.x - r2.x)) lowerHull.pop();
      else break;
    }
    lowerHull.push(p2);
  }
  lowerHull.pop();
  if (upperHull.length === 1 && lowerHull.length === 1 && upperHull[0].x === lowerHull[0].x && upperHull[0].y === lowerHull[0].y) {
    return upperHull;
  } else {
    return upperHull.concat(lowerHull);
  }
}
var Provider = TooltipProvider$1;
var Root3 = Tooltip$1;
var Trigger = TooltipTrigger$1;
var Content2 = TooltipContent$1;
const TooltipProvider = Provider;
const Tooltip = Root3;
const TooltipTrigger = Trigger;
const TooltipContent = reactExports.forwardRef(({ className, sideOffset = 4, ...props }, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Content2,
  {
    ref: ref2,
    sideOffset,
    className: cn$2(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-tooltip-content-transform-origin]",
      className
    ),
    ...props
  }
));
TooltipContent.displayName = Content2.displayName;
const Textarea = reactExports.forwardRef(
  ({ className, ...props }, ref2) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "textarea",
      {
        className: cn$2(
          "flex min-h-[60px] w-full rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50",
          className
        ),
        ref: ref2,
        ...props
      }
    );
  }
);
Textarea.displayName = "Textarea";
var SWITCH_NAME = "Switch";
var [createSwitchContext] = createContextScope(SWITCH_NAME);
var [SwitchProvider, useSwitchContext] = createSwitchContext(SWITCH_NAME);
var Switch$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSwitch,
      name: name2,
      checked: checkedProp,
      defaultChecked,
      required: required2,
      disabled,
      value = "on",
      onCheckedChange,
      form,
      ...switchProps
    } = props;
    const [button, setButton] = reactExports.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setButton(node));
    const hasConsumerStoppedPropagationRef = reactExports.useRef(false);
    const isFormControl = button ? form || !!button.closest("form") : true;
    const [checked, setChecked] = useControllableState({
      prop: checkedProp,
      defaultProp: defaultChecked ?? false,
      onChange: onCheckedChange,
      caller: SWITCH_NAME
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(SwitchProvider, { scope: __scopeSwitch, checked, disabled, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive$1.button,
        {
          type: "button",
          role: "switch",
          "aria-checked": checked,
          "aria-required": required2,
          "data-state": getState$1(checked),
          "data-disabled": disabled ? "" : void 0,
          disabled,
          value,
          ...switchProps,
          ref: composedRefs,
          onClick: composeEventHandlers(props.onClick, (event) => {
            setChecked((prevChecked) => !prevChecked);
            if (isFormControl) {
              hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();
              if (!hasConsumerStoppedPropagationRef.current) event.stopPropagation();
            }
          })
        }
      ),
      isFormControl && /* @__PURE__ */ jsxRuntimeExports.jsx(
        SwitchBubbleInput,
        {
          control: button,
          bubbles: !hasConsumerStoppedPropagationRef.current,
          name: name2,
          value,
          checked,
          required: required2,
          disabled,
          form,
          style: { transform: "translateX(-100%)" }
        }
      )
    ] });
  }
);
Switch$1.displayName = SWITCH_NAME;
var THUMB_NAME = "SwitchThumb";
var SwitchThumb = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSwitch, ...thumbProps } = props;
    const context = useSwitchContext(THUMB_NAME, __scopeSwitch);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive$1.span,
      {
        "data-state": getState$1(context.checked),
        "data-disabled": context.disabled ? "" : void 0,
        ...thumbProps,
        ref: forwardedRef
      }
    );
  }
);
SwitchThumb.displayName = THUMB_NAME;
var BUBBLE_INPUT_NAME$1 = "SwitchBubbleInput";
var SwitchBubbleInput = reactExports.forwardRef(
  ({
    __scopeSwitch,
    control,
    checked,
    bubbles = true,
    ...props
  }, forwardedRef) => {
    const ref2 = reactExports.useRef(null);
    const composedRefs = useComposedRefs(ref2, forwardedRef);
    const prevChecked = usePrevious(checked);
    const controlSize = useSize(control);
    reactExports.useEffect(() => {
      const input = ref2.current;
      if (!input) return;
      const inputProto = window.HTMLInputElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(
        inputProto,
        "checked"
      );
      const setChecked = descriptor.set;
      if (prevChecked !== checked && setChecked) {
        const event = new Event("click", { bubbles });
        setChecked.call(input, checked);
        input.dispatchEvent(event);
      }
    }, [prevChecked, checked, bubbles]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "input",
      {
        type: "checkbox",
        "aria-hidden": true,
        defaultChecked: checked,
        ...props,
        tabIndex: -1,
        ref: composedRefs,
        style: {
          ...props.style,
          ...controlSize,
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0
        }
      }
    );
  }
);
SwitchBubbleInput.displayName = BUBBLE_INPUT_NAME$1;
function getState$1(checked) {
  return checked ? "checked" : "unchecked";
}
var Root = Switch$1;
var Thumb = SwitchThumb;
const Switch = reactExports.forwardRef(({ className, ...props }, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Root,
  {
    className: cn$2(
      "peer inline-flex h-5 w-9 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    ),
    ...props,
    ref: ref2,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Thumb,
      {
        className: cn$2(
          "pointer-events-none block h-4 w-4 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-4 data-[state=unchecked]:translate-x-0"
        )
      }
    )
  }
));
Switch.displayName = Root.displayName;
const createEmptyHeader = () => ({
  name: "",
  value: "",
  enabled: true
});
const createHeaderFromBearerToken = (bearerToken, headerName) => ({
  name: headerName || "Authorization",
  value: headerName?.toLowerCase() === "authorization" || !headerName ? `Bearer ${bearerToken}` : bearerToken,
  enabled: true
});
const migrateFromLegacyAuth = (bearerToken, headerName) => {
  return bearerToken ? [createHeaderFromBearerToken(bearerToken, headerName)] : [];
};
const CustomHeaders = ({
  headers,
  onChange,
  className
}) => {
  const [isJsonMode, setIsJsonMode] = reactExports.useState(false);
  const [jsonValue, setJsonValue] = reactExports.useState("");
  const [jsonError, setJsonError] = reactExports.useState(null);
  const [visibleValues, setVisibleValues] = reactExports.useState(/* @__PURE__ */ new Set());
  const updateHeader = (index2, field, value) => {
    const newHeaders = [...headers];
    newHeaders[index2] = { ...newHeaders[index2], [field]: value };
    onChange(newHeaders);
  };
  const addHeader = () => {
    onChange([...headers, createEmptyHeader()]);
  };
  const removeHeader = (index2) => {
    const newHeaders = headers.filter((_2, i) => i !== index2);
    onChange(newHeaders);
  };
  const toggleValueVisibility = (index2) => {
    const newVisible = new Set(visibleValues);
    if (newVisible.has(index2)) {
      newVisible.delete(index2);
    } else {
      newVisible.add(index2);
    }
    setVisibleValues(newVisible);
  };
  const switchToJsonMode = () => {
    const jsonObject = {};
    headers.forEach((header) => {
      if (header.enabled && header.name.trim() && header.value.trim()) {
        jsonObject[header.name.trim()] = header.value.trim();
      }
    });
    setJsonValue(JSON.stringify(jsonObject, null, 2));
    setJsonError(null);
    setIsJsonMode(true);
  };
  const switchToFormMode = () => {
    try {
      const parsed = JSON.parse(jsonValue);
      if (typeof parsed !== "object" || parsed === null || Array.isArray(parsed)) {
        setJsonError("JSON must be an object with string key-value pairs");
        return;
      }
      const newHeaders = Object.entries(parsed).map(
        ([name2, value]) => ({
          name: name2,
          value: String(value),
          enabled: true
        })
      );
      onChange(newHeaders);
      setJsonError(null);
      setIsJsonMode(false);
    } catch {
      setJsonError("Invalid JSON format");
    }
  };
  const handleJsonChange = (value) => {
    setJsonValue(value);
    setJsonError(null);
  };
  if (isJsonMode) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `space-y-3 ${className}`, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center gap-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "text-sm font-semibold flex-shrink-0", children: "Custom Headers (JSON)" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            type: "button",
            variant: "outline",
            size: "sm",
            onClick: switchToFormMode,
            className: "flex-shrink-0",
            children: "Switch to Form"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Textarea,
          {
            value: jsonValue,
            onChange: (e) => handleJsonChange(e.target.value),
            placeholder: '{\\n  "Authorization": "Bearer token123",\\n  "X-Tenant-ID": "acme-inc",\\n  "X-Environment": "staging"\\n}',
            className: "font-mono text-sm min-h-[100px] resize-none"
          }
        ),
        jsonError && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-red-600", children: jsonError }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-muted-foreground", children: "Enter headers as a JSON object with string key-value pairs." })
      ] })
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `space-y-3 ${className}`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center gap-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "text-sm font-semibold flex-shrink-0", children: "Custom Headers" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-1 flex-shrink-0", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            type: "button",
            variant: "outline",
            size: "sm",
            onClick: switchToJsonMode,
            className: "text-xs px-2",
            children: "JSON"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Button,
          {
            type: "button",
            variant: "outline",
            size: "sm",
            onClick: addHeader,
            className: "text-xs px-2",
            "data-testid": "add-header-button",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Plus, { className: "w-3 h-3 mr-1" }),
              "Add"
            ]
          }
        )
      ] })
    ] }),
    headers.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center py-4 text-muted-foreground", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm", children: "No custom headers configured" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs mt-1", children: 'Click "Add" to get started' })
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-2 max-h-[300px] overflow-y-auto", children: headers.map((header, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: "flex items-start gap-2 p-2 border rounded-md",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Switch,
            {
              checked: header.enabled,
              onCheckedChange: (enabled) => updateHeader(index2, "enabled", enabled),
              className: "shrink-0 mt-2"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1 min-w-0 space-y-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input,
              {
                placeholder: "Header Name",
                value: header.name,
                onChange: (e) => updateHeader(index2, "name", e.target.value),
                className: "font-mono text-xs",
                "data-testid": `header-name-input-${index2}`
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Input,
                {
                  placeholder: "Header Value",
                  value: header.value,
                  onChange: (e) => updateHeader(index2, "value", e.target.value),
                  type: visibleValues.has(index2) ? "text" : "password",
                  className: "font-mono text-xs pr-8",
                  "data-testid": `header-value-input-${index2}`
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  type: "button",
                  variant: "ghost",
                  size: "sm",
                  onClick: () => toggleValueVisibility(index2),
                  className: "absolute right-1 top-1/2 -translate-y-1/2 h-6 w-6 p-0",
                  children: visibleValues.has(index2) ? /* @__PURE__ */ jsxRuntimeExports.jsx(EyeOff, { className: "w-3 h-3" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Eye, { className: "w-3 h-3" })
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              type: "button",
              variant: "ghost",
              size: "sm",
              onClick: () => removeHeader(index2),
              className: "shrink-0 text-red-600 hover:text-red-700 hover:bg-red-50 h-6 w-6 p-0 mt-2",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Trash2, { className: "w-3 h-3" })
            }
          )
        ]
      },
      index2
    )) }),
    headers.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-muted-foreground", children: "Use the toggle to enable/disable headers. Only enabled headers with both name and value will be sent." })
  ] });
};
const Sidebar = ({
  connectionStatus,
  transportType,
  setTransportType,
  command,
  setCommand,
  args,
  setArgs,
  sseUrl,
  setSseUrl,
  env,
  setEnv,
  customHeaders,
  setCustomHeaders,
  oauthClientId,
  setOauthClientId,
  oauthClientSecret,
  setOauthClientSecret,
  oauthScope,
  setOauthScope,
  onConnect,
  onDisconnect,
  logLevel,
  sendLogLevelRequest,
  loggingSupported,
  config: config2,
  setConfig,
  connectionType,
  setConnectionType,
  serverImplementation
}) => {
  const [theme, setTheme] = useTheme();
  const [showEnvVars, setShowEnvVars] = reactExports.useState(false);
  const [showAuthConfig, setShowAuthConfig] = reactExports.useState(false);
  const [showConfig, setShowConfig] = reactExports.useState(false);
  const [shownEnvVars, setShownEnvVars] = reactExports.useState(/* @__PURE__ */ new Set());
  const [showClientSecret, setShowClientSecret] = reactExports.useState(false);
  const [copiedServerEntry, setCopiedServerEntry] = reactExports.useState(false);
  const [copiedServerFile, setCopiedServerFile] = reactExports.useState(false);
  const { toast: toast2 } = useToast();
  const connectionTypeTip = "Connect to server directly (requires CORS config on server) or via MCP Inspector Proxy";
  const reportError2 = reactExports.useCallback(
    (error) => {
      toast2({
        title: "Error",
        description: `Failed to copy config: ${error instanceof Error ? error.message : String(error)}`,
        variant: "destructive"
      });
    },
    [toast2]
  );
  const generateServerConfig = reactExports.useCallback(() => {
    if (transportType === "stdio") {
      return {
        command,
        args: args.trim() ? args.split(/\s+/) : [],
        env: { ...env }
      };
    }
    if (transportType === "sse") {
      return {
        type: "sse",
        url: sseUrl,
        note: "For SSE connections, add this URL directly in your MCP Client"
      };
    }
    if (transportType === "streamable-http") {
      return {
        type: "streamable-http",
        url: sseUrl,
        note: "For Streamable HTTP connections, add this URL directly in your MCP Client"
      };
    }
    return {};
  }, [transportType, command, args, env, sseUrl]);
  const generateMCPServerEntry = reactExports.useCallback(() => {
    return JSON.stringify(generateServerConfig(), null, 4);
  }, [generateServerConfig]);
  const generateMCPServerFile = reactExports.useCallback(() => {
    return JSON.stringify(
      {
        mcpServers: {
          "default-server": generateServerConfig()
        }
      },
      null,
      4
    );
  }, [generateServerConfig]);
  const handleCopyServerEntry = reactExports.useCallback(() => {
    try {
      const configJson = generateMCPServerEntry();
      navigator.clipboard.writeText(configJson).then(() => {
        setCopiedServerEntry(true);
        toast2({
          title: "Config entry copied",
          description: transportType === "stdio" ? "Server configuration has been copied to clipboard. Add this to your mcp.json inside the 'mcpServers' object with your preferred server name." : transportType === "streamable-http" ? "Streamable HTTP URL has been copied. Use this URL directly in your MCP Client." : "SSE URL has been copied. Use this URL directly in your MCP Client."
        });
        setTimeout(() => {
          setCopiedServerEntry(false);
        }, 2e3);
      }).catch((error) => {
        reportError2(error);
      });
    } catch (error) {
      reportError2(error);
    }
  }, [generateMCPServerEntry, transportType, toast2, reportError2]);
  const handleCopyServerFile = reactExports.useCallback(() => {
    try {
      const configJson = generateMCPServerFile();
      navigator.clipboard.writeText(configJson).then(() => {
        setCopiedServerFile(true);
        toast2({
          title: "Servers file copied",
          description: "Servers configuration has been copied to clipboard. Add this to your mcp.json file. Current testing server will be added as 'default-server'"
        });
        setTimeout(() => {
          setCopiedServerFile(false);
        }, 2e3);
      }).catch((error) => {
        reportError2(error);
      });
    } catch (error) {
      reportError2(error);
    }
  }, [generateMCPServerFile, toast2, reportError2]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-card border-r border-border flex flex-col h-full", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-between p-4 border-b border-gray-200 dark:border-border", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("h1", { className: "ml-2 text-lg font-semibold", children: [
      "MCP Inspector v",
      version
    ] }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-4 flex-1 overflow-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "label",
          {
            className: "text-sm font-medium",
            htmlFor: "transport-type-select",
            children: "Transport Type"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Select,
          {
            value: transportType,
            onValueChange: (value) => setTransportType(value),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { id: "transport-type-select", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValue, { placeholder: "Select transport type" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(SelectContent, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: "stdio", children: "STDIO" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: "sse", children: "SSE" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: "streamable-http", children: "Streamable HTTP" })
              ] })
            ]
          }
        )
      ] }),
      transportType === "stdio" ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "text-sm font-medium", htmlFor: "command-input", children: "Command" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Input,
            {
              id: "command-input",
              placeholder: "Command",
              value: command,
              onChange: (e) => setCommand(e.target.value),
              onBlur: (e) => setCommand(e.target.value.trim()),
              className: "font-mono"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "label",
            {
              className: "text-sm font-medium",
              htmlFor: "arguments-input",
              children: "Arguments"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Input,
            {
              id: "arguments-input",
              placeholder: "Arguments (space-separated)",
              value: args,
              onChange: (e) => setArgs(e.target.value),
              className: "font-mono"
            }
          )
        ] })
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "text-sm font-medium", htmlFor: "sse-url-input", children: "URL" }),
          sseUrl ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Tooltip, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input,
              {
                id: "sse-url-input",
                placeholder: "URL",
                value: sseUrl,
                onChange: (e) => setSseUrl(e.target.value),
                className: "font-mono"
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContent, { children: sseUrl })
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
            Input,
            {
              id: "sse-url-input",
              placeholder: "URL",
              value: sseUrl,
              onChange: (e) => setSseUrl(e.target.value),
              className: "font-mono"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Tooltip, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "label",
              {
                className: "text-sm font-medium",
                htmlFor: "connection-type-select",
                children: "Connection Type"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Select,
              {
                value: connectionType,
                onValueChange: (value) => setConnectionType(value),
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { id: "connection-type-select", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValue, { placeholder: "Select connection type" }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(SelectContent, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: "proxy", children: "Via Proxy" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: "direct", children: "Direct" })
                  ] })
                ]
              }
            )
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContent, { children: connectionTypeTip })
        ] })
      ] }),
      transportType === "stdio" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Button,
          {
            variant: "outline",
            onClick: () => setShowEnvVars(!showEnvVars),
            className: "flex items-center w-full",
            "data-testid": "env-vars-button",
            "aria-expanded": showEnvVars,
            children: [
              showEnvVars ? /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronDown, { className: "w-4 h-4 mr-2" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRight, { className: "w-4 h-4 mr-2" }),
              "Environment Variables"
            ]
          }
        ),
        showEnvVars && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
          Object.entries(env).map(([key, value], idx) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2 pb-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Input,
                {
                  "aria-label": `Environment variable key ${idx + 1}`,
                  placeholder: "Key",
                  value: key,
                  onChange: (e) => {
                    const newKey = e.target.value;
                    const newEnv = Object.entries(env).reduce(
                      (acc, [k2, v]) => {
                        if (k2 === key) {
                          acc[newKey] = value;
                        } else {
                          acc[k2] = v;
                        }
                        return acc;
                      },
                      {}
                    );
                    setEnv(newEnv);
                    setShownEnvVars((prev) => {
                      const next = new Set(prev);
                      if (next.has(key)) {
                        next.delete(key);
                        next.add(newKey);
                      }
                      return next;
                    });
                  },
                  className: "font-mono"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  variant: "destructive",
                  size: "icon",
                  className: "h-9 w-9 p-0 shrink-0",
                  onClick: () => {
                    const { [key]: _removed, ...rest } = env;
                    setEnv(rest);
                  },
                  children: ""
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Input,
                {
                  "aria-label": `Environment variable value ${idx + 1}`,
                  type: shownEnvVars.has(key) ? "text" : "password",
                  placeholder: "Value",
                  value,
                  onChange: (e) => {
                    const newEnv = { ...env };
                    newEnv[key] = e.target.value;
                    setEnv(newEnv);
                  },
                  className: "font-mono"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  variant: "outline",
                  size: "icon",
                  className: "h-9 w-9 p-0 shrink-0",
                  onClick: () => {
                    setShownEnvVars((prev) => {
                      const next = new Set(prev);
                      if (next.has(key)) {
                        next.delete(key);
                      } else {
                        next.add(key);
                      }
                      return next;
                    });
                  },
                  "aria-label": shownEnvVars.has(key) ? "Hide value" : "Show value",
                  "aria-pressed": shownEnvVars.has(key),
                  title: shownEnvVars.has(key) ? "Hide value" : "Show value",
                  children: shownEnvVars.has(key) ? /* @__PURE__ */ jsxRuntimeExports.jsx(Eye, { className: "h-4 w-4", "aria-hidden": "true" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(EyeOff, { className: "h-4 w-4", "aria-hidden": "true" })
                }
              )
            ] })
          ] }, idx)),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              variant: "outline",
              className: "w-full mt-2",
              onClick: () => {
                const key = "";
                const newEnv = { ...env };
                newEnv[key] = "";
                setEnv(newEnv);
              },
              children: "Add Environment Variable"
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-2 mt-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Tooltip, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Button,
            {
              variant: "outline",
              size: "sm",
              onClick: handleCopyServerEntry,
              className: "w-full",
              children: [
                copiedServerEntry ? /* @__PURE__ */ jsxRuntimeExports.jsx(CheckCheck, { className: "h-4 w-4 mr-2" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Copy, { className: "h-4 w-4 mr-2" }),
                "Server Entry"
              ]
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContent, { children: "Copy Server Entry" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Tooltip, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Button,
            {
              variant: "outline",
              size: "sm",
              onClick: handleCopyServerFile,
              className: "w-full",
              children: [
                copiedServerFile ? /* @__PURE__ */ jsxRuntimeExports.jsx(CheckCheck, { className: "h-4 w-4 mr-2" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Copy, { className: "h-4 w-4 mr-2" }),
                "Servers File"
              ]
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContent, { children: "Copy Servers File" })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Button,
          {
            variant: "outline",
            onClick: () => setShowAuthConfig(!showAuthConfig),
            className: "flex items-center w-full",
            "data-testid": "auth-button",
            "aria-expanded": showAuthConfig,
            children: [
              showAuthConfig ? /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronDown, { className: "w-4 h-4 mr-2" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRight, { className: "w-4 h-4 mr-2" }),
              "Authentication"
            ]
          }
        ),
        showAuthConfig && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-3 rounded border overflow-hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            CustomHeaders,
            {
              headers: customHeaders,
              onChange: setCustomHeaders
            }
          ) }),
          transportType !== "stdio" && // OAuth Configuration
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2 p-3  rounded border", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "text-sm font-semibold flex items-center", children: "OAuth 2.0 Flow" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "text-sm font-medium", children: "Client ID" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Input,
                {
                  placeholder: "Client ID",
                  onChange: (e) => setOauthClientId(e.target.value),
                  value: oauthClientId,
                  "data-testid": "oauth-client-id-input",
                  className: "font-mono"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "text-sm font-medium", children: "Client Secret" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input,
                  {
                    type: showClientSecret ? "text" : "password",
                    placeholder: "Client Secret (optional)",
                    onChange: (e) => setOauthClientSecret(e.target.value),
                    value: oauthClientSecret,
                    "data-testid": "oauth-client-secret-input",
                    className: "font-mono"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    variant: "outline",
                    size: "icon",
                    className: "h-9 w-9 p-0 shrink-0",
                    onClick: () => setShowClientSecret(!showClientSecret),
                    "aria-label": showClientSecret ? "Hide secret" : "Show secret",
                    "aria-pressed": showClientSecret,
                    title: showClientSecret ? "Hide secret" : "Show secret",
                    children: showClientSecret ? /* @__PURE__ */ jsxRuntimeExports.jsx(Eye, { className: "h-4 w-4", "aria-hidden": "true" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(EyeOff, { className: "h-4 w-4", "aria-hidden": "true" })
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "text-sm font-medium", children: "Redirect URL" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Input,
                {
                  readOnly: true,
                  placeholder: "Redirect URL",
                  value: window.location.origin + "/oauth/callback",
                  className: "font-mono"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "text-sm font-medium", children: "Scope" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Input,
                {
                  placeholder: "Scope (space-separated)",
                  onChange: (e) => setOauthScope(e.target.value),
                  value: oauthScope,
                  "data-testid": "oauth-scope-input",
                  className: "font-mono"
                }
              )
            ] })
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Button,
          {
            variant: "outline",
            onClick: () => setShowConfig(!showConfig),
            className: "flex items-center w-full",
            "data-testid": "config-button",
            "aria-expanded": showConfig,
            children: [
              showConfig ? /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronDown, { className: "w-4 h-4 mr-2" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRight, { className: "w-4 h-4 mr-2" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Settings, { className: "w-4 h-4 mr-2" }),
              "Configuration"
            ]
          }
        ),
        showConfig && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-2", children: Object.entries(config2).map(([key, configItem]) => {
          const configKey = key;
          return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-1", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "label",
                {
                  className: "text-sm font-medium text-green-600 break-all",
                  htmlFor: `${configKey}-input`,
                  children: configItem.label
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Tooltip, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircleQuestionMark, { className: "h-4 w-4 text-muted-foreground" }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContent, { children: configItem.description })
              ] })
            ] }),
            typeof configItem.value === "number" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input,
              {
                id: `${configKey}-input`,
                type: "number",
                "data-testid": `${configKey}-input`,
                value: configItem.value,
                onChange: (e) => {
                  const newConfig = { ...config2 };
                  newConfig[configKey] = {
                    ...configItem,
                    value: Number(e.target.value)
                  };
                  setConfig(newConfig);
                },
                className: "font-mono"
              }
            ) : typeof configItem.value === "boolean" ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Select,
              {
                "data-testid": `${configKey}-select`,
                value: configItem.value.toString(),
                onValueChange: (val) => {
                  const newConfig = { ...config2 };
                  newConfig[configKey] = {
                    ...configItem,
                    value: val === "true"
                  };
                  setConfig(newConfig);
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { id: `${configKey}-input`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValue, {}) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(SelectContent, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: "true", children: "True" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: "false", children: "False" })
                  ] })
                ]
              }
            ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input,
              {
                id: `${configKey}-input`,
                "data-testid": `${configKey}-input`,
                value: configItem.value,
                onChange: (e) => {
                  const newConfig = { ...config2 };
                  newConfig[configKey] = {
                    ...configItem,
                    value: e.target.value
                  };
                  setConfig(newConfig);
                },
                className: "font-mono"
              }
            )
          ] }, key);
        }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
        connectionStatus === "connected" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Button,
            {
              "data-testid": "connect-button",
              onClick: () => {
                onDisconnect();
                onConnect();
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(RotateCcw, { className: "w-4 h-4 mr-2" }),
                transportType === "stdio" ? "Restart" : "Reconnect"
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { onClick: onDisconnect, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(RefreshCwOff, { className: "w-4 h-4 mr-2" }),
            "Disconnect"
          ] })
        ] }),
        connectionStatus !== "connected" && /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { className: "w-full", onClick: onConnect, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Play, { className: "w-4 h-4 mr-2" }),
          "Connect"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-center space-x-2 mb-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: `w-2 h-2 rounded-full ${(() => {
                switch (connectionStatus) {
                  case "connected":
                    return "bg-green-500";
                  case "error":
                    return "bg-red-500";
                  case "error-connecting-to-proxy":
                    return "bg-red-500";
                  default:
                    return "bg-gray-500";
                }
              })()}`
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm text-gray-600 dark:text-gray-400", children: (() => {
            switch (connectionStatus) {
              case "connected":
                return "Connected";
              case "error": {
                const hasProxyToken = config2.MCP_PROXY_AUTH_TOKEN?.value;
                if (!hasProxyToken) {
                  return "Connection Error - Did you add the proxy session token in Configuration?";
                }
                return "Connection Error - Check if your MCP server is running and proxy token is correct";
              }
              case "error-connecting-to-proxy":
                return "Error Connecting to MCP Inspector Proxy - Check Console logs";
              default:
                return "Disconnected";
            }
          })() })
        ] }),
        connectionStatus === "connected" && serverImplementation && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gray-50 dark:bg-gray-900 p-3 rounded-lg mb-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 mb-1", children: [
            serverImplementation.icons && serverImplementation.icons.length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
              IconDisplay,
              {
                icons: serverImplementation.icons,
                size: "sm"
              }
            ) : /* @__PURE__ */ jsxRuntimeExports.jsx(Server, { className: "w-4 h-4 text-gray-500" }),
            serverImplementation.websiteUrl ? /* @__PURE__ */ jsxRuntimeExports.jsx(
              "a",
              {
                href: serverImplementation.websiteUrl,
                target: "_blank",
                rel: "noopener noreferrer",
                className: "text-sm font-medium text-blue-600 dark:text-blue-400 hover:text-blue-700 dark:hover:text-blue-300 hover:underline transition-colors",
                children: serverImplementation.name || "MCP Server"
              }
            ) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm font-medium text-gray-800 dark:text-gray-200", children: serverImplementation.name || "MCP Server" })
          ] }),
          serverImplementation.version && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-xs text-gray-500 dark:text-gray-400", children: [
            "Version: ",
            serverImplementation.version
          ] })
        ] }),
        loggingSupported && connectionStatus === "connected" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "label",
            {
              className: "text-sm font-medium",
              htmlFor: "logging-level-select",
              children: "Logging Level"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Select,
            {
              value: logLevel,
              onValueChange: (value) => sendLogLevelRequest(value),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { id: "logging-level-select", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValue, { placeholder: "Select logging level" }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContent, { children: Object.values(LoggingLevelSchema.enum).map((level) => /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: level, children: level }, level)) })
              ]
            }
          )
        ] })
      ] })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-4 border-t", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Select,
        {
          value: theme,
          onValueChange: (value) => setTheme(value),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { className: "w-[100px]", id: "theme-select", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValue, {}) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(SelectContent, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: "system", children: "System" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: "light", children: "Light" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: "dark", children: "Dark" })
            ] })
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "ghost", title: "Inspector Documentation", asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "a",
          {
            href: "https://modelcontextprotocol.io/docs/tools/inspector",
            target: "_blank",
            rel: "noopener noreferrer",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircleQuestionMark, { className: "w-4 h-4 text-foreground" })
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "ghost", title: "Debugging Guide", asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "a",
          {
            href: "https://modelcontextprotocol.io/docs/tools/debugging",
            target: "_blank",
            rel: "noopener noreferrer",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(Bug, { className: "w-4 h-4 text-foreground" })
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            variant: "ghost",
            title: "Report bugs or contribute on GitHub",
            asChild: true,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "a",
              {
                href: "https://github.com/modelcontextprotocol/inspector",
                target: "_blank",
                rel: "noopener noreferrer",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(Github, { className: "w-4 h-4 text-foreground" })
              }
            )
          }
        )
      ] })
    ] }) })
  ] });
};
var CHECKBOX_NAME = "Checkbox";
var [createCheckboxContext] = createContextScope(CHECKBOX_NAME);
var [CheckboxProviderImpl, useCheckboxContext] = createCheckboxContext(CHECKBOX_NAME);
function CheckboxProvider(props) {
  const {
    __scopeCheckbox,
    checked: checkedProp,
    children,
    defaultChecked,
    disabled,
    form,
    name: name2,
    onCheckedChange,
    required: required2,
    value = "on",
    // @ts-expect-error
    internal_do_not_use_render
  } = props;
  const [checked, setChecked] = useControllableState({
    prop: checkedProp,
    defaultProp: defaultChecked ?? false,
    onChange: onCheckedChange,
    caller: CHECKBOX_NAME
  });
  const [control, setControl] = reactExports.useState(null);
  const [bubbleInput, setBubbleInput] = reactExports.useState(null);
  const hasConsumerStoppedPropagationRef = reactExports.useRef(false);
  const isFormControl = control ? !!form || !!control.closest("form") : (
    // We set this to true by default so that events bubble to forms without JS (SSR)
    true
  );
  const context = {
    checked,
    disabled,
    setChecked,
    control,
    setControl,
    name: name2,
    form,
    value,
    hasConsumerStoppedPropagationRef,
    required: required2,
    defaultChecked: isIndeterminate(defaultChecked) ? false : defaultChecked,
    isFormControl,
    bubbleInput,
    setBubbleInput
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    CheckboxProviderImpl,
    {
      scope: __scopeCheckbox,
      ...context,
      children: isFunction(internal_do_not_use_render) ? internal_do_not_use_render(context) : children
    }
  );
}
var TRIGGER_NAME = "CheckboxTrigger";
var CheckboxTrigger = reactExports.forwardRef(
  ({ __scopeCheckbox, onKeyDown, onClick, ...checkboxProps }, forwardedRef) => {
    const {
      control,
      value,
      disabled,
      checked,
      required: required2,
      setControl,
      setChecked,
      hasConsumerStoppedPropagationRef,
      isFormControl,
      bubbleInput
    } = useCheckboxContext(TRIGGER_NAME, __scopeCheckbox);
    const composedRefs = useComposedRefs(forwardedRef, setControl);
    const initialCheckedStateRef = reactExports.useRef(checked);
    reactExports.useEffect(() => {
      const form = control?.form;
      if (form) {
        const reset = () => setChecked(initialCheckedStateRef.current);
        form.addEventListener("reset", reset);
        return () => form.removeEventListener("reset", reset);
      }
    }, [control, setChecked]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive$1.button,
      {
        type: "button",
        role: "checkbox",
        "aria-checked": isIndeterminate(checked) ? "mixed" : checked,
        "aria-required": required2,
        "data-state": getState(checked),
        "data-disabled": disabled ? "" : void 0,
        disabled,
        value,
        ...checkboxProps,
        ref: composedRefs,
        onKeyDown: composeEventHandlers(onKeyDown, (event) => {
          if (event.key === "Enter") event.preventDefault();
        }),
        onClick: composeEventHandlers(onClick, (event) => {
          setChecked((prevChecked) => isIndeterminate(prevChecked) ? true : !prevChecked);
          if (bubbleInput && isFormControl) {
            hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();
            if (!hasConsumerStoppedPropagationRef.current) event.stopPropagation();
          }
        })
      }
    );
  }
);
CheckboxTrigger.displayName = TRIGGER_NAME;
var Checkbox$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeCheckbox,
      name: name2,
      checked,
      defaultChecked,
      required: required2,
      disabled,
      value,
      onCheckedChange,
      form,
      ...checkboxProps
    } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      CheckboxProvider,
      {
        __scopeCheckbox,
        checked,
        defaultChecked,
        disabled,
        required: required2,
        onCheckedChange,
        name: name2,
        form,
        value,
        internal_do_not_use_render: ({ isFormControl }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            CheckboxTrigger,
            {
              ...checkboxProps,
              ref: forwardedRef,
              __scopeCheckbox
            }
          ),
          isFormControl && /* @__PURE__ */ jsxRuntimeExports.jsx(
            CheckboxBubbleInput,
            {
              __scopeCheckbox
            }
          )
        ] })
      }
    );
  }
);
Checkbox$1.displayName = CHECKBOX_NAME;
var INDICATOR_NAME = "CheckboxIndicator";
var CheckboxIndicator = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeCheckbox, forceMount, ...indicatorProps } = props;
    const context = useCheckboxContext(INDICATOR_NAME, __scopeCheckbox);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Presence,
      {
        present: forceMount || isIndeterminate(context.checked) || context.checked === true,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive$1.span,
          {
            "data-state": getState(context.checked),
            "data-disabled": context.disabled ? "" : void 0,
            ...indicatorProps,
            ref: forwardedRef,
            style: { pointerEvents: "none", ...props.style }
          }
        )
      }
    );
  }
);
CheckboxIndicator.displayName = INDICATOR_NAME;
var BUBBLE_INPUT_NAME = "CheckboxBubbleInput";
var CheckboxBubbleInput = reactExports.forwardRef(
  ({ __scopeCheckbox, ...props }, forwardedRef) => {
    const {
      control,
      hasConsumerStoppedPropagationRef,
      checked,
      defaultChecked,
      required: required2,
      disabled,
      name: name2,
      value,
      form,
      bubbleInput,
      setBubbleInput
    } = useCheckboxContext(BUBBLE_INPUT_NAME, __scopeCheckbox);
    const composedRefs = useComposedRefs(forwardedRef, setBubbleInput);
    const prevChecked = usePrevious(checked);
    const controlSize = useSize(control);
    reactExports.useEffect(() => {
      const input = bubbleInput;
      if (!input) return;
      const inputProto = window.HTMLInputElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(
        inputProto,
        "checked"
      );
      const setChecked = descriptor.set;
      const bubbles = !hasConsumerStoppedPropagationRef.current;
      if (prevChecked !== checked && setChecked) {
        const event = new Event("click", { bubbles });
        input.indeterminate = isIndeterminate(checked);
        setChecked.call(input, isIndeterminate(checked) ? false : checked);
        input.dispatchEvent(event);
      }
    }, [bubbleInput, prevChecked, checked, hasConsumerStoppedPropagationRef]);
    const defaultCheckedRef = reactExports.useRef(isIndeterminate(checked) ? false : checked);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive$1.input,
      {
        type: "checkbox",
        "aria-hidden": true,
        defaultChecked: defaultChecked ?? defaultCheckedRef.current,
        required: required2,
        disabled,
        name: name2,
        value,
        form,
        ...props,
        tabIndex: -1,
        ref: composedRefs,
        style: {
          ...props.style,
          ...controlSize,
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0,
          // We transform because the input is absolutely positioned but we have
          // rendered it **after** the button. This pulls it back to sit on top
          // of the button.
          transform: "translateX(-100%)"
        }
      }
    );
  }
);
CheckboxBubbleInput.displayName = BUBBLE_INPUT_NAME;
function isFunction(value) {
  return typeof value === "function";
}
function isIndeterminate(checked) {
  return checked === "indeterminate";
}
function getState(checked) {
  return isIndeterminate(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}
const Checkbox = reactExports.forwardRef(({ className, ...props }, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Checkbox$1,
  {
    ref: ref2,
    className: cn$2(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    ),
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      CheckboxIndicator,
      {
        className: cn$2("flex items-center justify-center text-current"),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Check, { className: "h-4 w-4" })
      }
    )
  }
));
Checkbox.displayName = Checkbox$1.displayName;
const ResourceLinkView = reactExports.memo(
  ({
    uri: uri2,
    name: name2,
    description: description2,
    mimeType,
    resourceContent,
    onReadResource
  }) => {
    const [{ expanded, loading }, setState] = reactExports.useState({
      expanded: false,
      loading: false
    });
    const expandedContent = reactExports.useMemo(
      () => expanded && resourceContent ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-between items-center mb-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-semibold text-green-600", children: "Resource:" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(JsonView, { data: resourceContent, className: "bg-background" })
      ] }) : null,
      [expanded, resourceContent]
    );
    const handleClick = reactExports.useCallback(() => {
      if (!onReadResource) return;
      if (!expanded) {
        setState((prev) => ({ ...prev, expanded: true, loading: true }));
        onReadResource(uri2);
        setState((prev) => ({ ...prev, loading: false }));
      } else {
        setState((prev) => ({ ...prev, expanded: false }));
      }
    }, [expanded, onReadResource, uri2]);
    const handleKeyDown = reactExports.useCallback(
      (e) => {
        if ((e.key === "Enter" || e.key === " ") && onReadResource) {
          e.preventDefault();
          handleClick();
        }
      },
      [handleClick, onReadResource]
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-sm text-foreground bg-secondary py-2 px-3 rounded", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "flex justify-between items-center cursor-pointer focus:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-1 rounded",
          onClick: onReadResource ? handleClick : void 0,
          onKeyDown: onReadResource ? handleKeyDown : void 0,
          tabIndex: onReadResource ? 0 : -1,
          role: "button",
          "aria-expanded": expanded,
          "aria-label": `${expanded ? "Collapse" : "Expand"} resource ${uri2}`,
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1 min-w-0", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start justify-between gap-2 mb-1", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-300 hover:underline px-1 py-0.5 break-all font-mono flex-1 min-w-0", children: uri2 }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 flex-shrink-0", children: [
                mimeType && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200", children: mimeType }),
                onReadResource && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-2 flex-shrink-0", "aria-hidden": "true", children: loading ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-4 h-4 border-2 border-blue-500 border-t-transparent rounded-full animate-spin" }) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: expanded ? "" : "" }) })
              ] })
            ] }),
            name2 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "font-semibold text-sm text-gray-900 dark:text-gray-100 mb-1", children: name2 }),
            description2 && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-600 dark:text-gray-300 leading-relaxed", children: description2 })
          ] })
        }
      ),
      expandedContent
    ] });
  }
);
const checkContentCompatibility = (structuredContent, unstructuredContent) => {
  const textBlocks = unstructuredContent.filter(
    (block) => block.type === "text"
  );
  if (textBlocks.length === 0) {
    return {
      isCompatible: false,
      message: "No text blocks to match structured content"
    };
  }
  for (const textBlock of textBlocks) {
    const textContent = textBlock.text;
    if (!textContent) {
      continue;
    }
    try {
      const parsedContent = JSON.parse(textContent);
      const isEqual = JSON.stringify(parsedContent) === JSON.stringify(structuredContent);
      if (isEqual) {
        return {
          isCompatible: true,
          message: `Structured content matches text block${textBlocks.length > 1 ? " (multiple blocks)" : ""}${unstructuredContent.length > textBlocks.length ? " + other content" : ""}`
        };
      }
    } catch {
      continue;
    }
  }
  return {
    isCompatible: false,
    message: "No text block matches structured content"
  };
};
const ToolResults = ({
  toolResult,
  selectedTool,
  resourceContent,
  onReadResource,
  isPollingTask
}) => {
  if (!toolResult) return null;
  if ("content" in toolResult) {
    const parsedResult = CallToolResultSchema.safeParse(toolResult);
    if (!parsedResult.success) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-semibold mb-2", children: "Invalid Tool Result:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(JsonView, { data: toolResult }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-semibold mb-2", children: "Errors:" }),
        parsedResult.error.issues.map((issue2, idx) => /* @__PURE__ */ jsxRuntimeExports.jsx(JsonView, { data: issue2 }, idx))
      ] });
    }
    const structuredResult = parsedResult.data;
    const isError = structuredResult.isError ?? false;
    const relatedTask = structuredResult._meta?.["io.modelcontextprotocol/related-task"];
    const isTaskRunning = isPollingTask || !!relatedTask && structuredResult.content.some(
      (c) => c.type === "text" && (c.text?.includes("Polling") || c.text?.includes("Task status"))
    );
    let validationResult = null;
    const toolHasOutputSchema = selectedTool && hasOutputSchema(selectedTool.name);
    if (toolHasOutputSchema) {
      if (!structuredResult.structuredContent && !isError) {
        validationResult = {
          isValid: false,
          error: "Tool has an output schema but did not return structured content"
        };
      } else if (structuredResult.structuredContent) {
        validationResult = validateToolOutput(
          selectedTool.name,
          structuredResult.structuredContent
        );
      }
    }
    let compatibilityResult = null;
    if (structuredResult.structuredContent && structuredResult.content.length > 0 && selectedTool && hasOutputSchema(selectedTool.name)) {
      compatibilityResult = checkContentCompatibility(
        structuredResult.structuredContent,
        structuredResult.content
      );
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("h4", { className: "font-semibold mb-2", children: [
        "Tool Result:",
        " ",
        isError ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-red-600 font-semibold", children: "Error" }) : isTaskRunning ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-yellow-600 font-semibold", children: "Task Running" }) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-green-600 font-semibold", children: "Success" })
      ] }),
      structuredResult.structuredContent && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { className: "font-semibold mb-2 text-sm", children: "Structured Content:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gray-50 dark:bg-gray-900 p-3 rounded-lg", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(JsonView, { data: structuredResult.structuredContent }),
          validationResult && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: `mt-2 p-2 rounded text-sm ${validationResult.isValid ? "bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-200" : "bg-red-100 dark:bg-red-900 text-red-800 dark:text-red-200"}`,
              children: validationResult.isValid ? " Valid according to output schema" : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                " Validation Error: ",
                validationResult.error
              ] })
            }
          )
        ] })
      ] }),
      structuredResult._meta && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { className: "font-semibold mb-2 text-sm", children: "Meta:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-gray-50 dark:bg-gray-900 p-3 rounded-lg", children: /* @__PURE__ */ jsxRuntimeExports.jsx(JsonView, { data: structuredResult._meta }) })
      ] }),
      !structuredResult.structuredContent && validationResult && !validationResult.isValid && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-red-100 dark:bg-red-900 text-red-800 dark:text-red-200 p-2 rounded text-sm", children: [
        " Validation Error: ",
        validationResult.error
      ] }) }),
      structuredResult.content.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4", children: [
        structuredResult.structuredContent && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { className: "font-semibold mb-2 text-sm", children: "Unstructured Content:" }),
          compatibilityResult && /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: `mb-2 p-2 rounded text-sm ${compatibilityResult.isCompatible ? "bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200" : "bg-yellow-100 dark:bg-yellow-900 text-yellow-800 dark:text-yellow-200"}`,
              children: [
                compatibilityResult.isCompatible ? "" : "",
                " ",
                compatibilityResult.message
              ]
            }
          )
        ] }),
        structuredResult.content.map((item, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-2", children: [
          item.type === "text" && /* @__PURE__ */ jsxRuntimeExports.jsx(JsonView, { data: item.text, isError }),
          item.type === "image" && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              src: `data:${item.mimeType};base64,${item.data}`,
              alt: "Tool result image",
              className: "max-w-full h-auto"
            }
          ),
          item.type === "resource" && (item.resource?.mimeType?.startsWith("audio/") && "blob" in item.resource ? /* @__PURE__ */ jsxRuntimeExports.jsx(
            "audio",
            {
              controls: true,
              src: `data:${item.resource.mimeType};base64,${item.resource.blob}`,
              className: "w-full",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Your browser does not support audio playback" })
            }
          ) : /* @__PURE__ */ jsxRuntimeExports.jsx(JsonView, { data: item.resource })),
          item.type === "resource_link" && /* @__PURE__ */ jsxRuntimeExports.jsx(
            ResourceLinkView,
            {
              uri: item.uri,
              name: item.name,
              description: item.description,
              mimeType: item.mimeType,
              resourceContent: resourceContent[item.uri] || "",
              onReadResource
            }
          )
        ] }, index2))
      ] })
    ] });
  } else if ("toolResult" in toolResult) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-semibold mb-2", children: "Tool Result (Legacy):" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(JsonView, { data: toolResult.toolResult })
    ] });
  }
  return null;
};
const hasMeta = (tool) => typeof tool._meta !== "undefined";
const getTaskSupport = (tool) => {
  if (!tool) return "forbidden";
  const extendedTool = tool;
  const taskSupport = extendedTool.execution?.taskSupport;
  if (taskSupport === "forbidden" || taskSupport === "required" || taskSupport === "optional") {
    return taskSupport;
  }
  return "forbidden";
};
const hasAnnotations = (tool) => typeof tool.annotations !== "undefined" && tool.annotations !== null;
const AnnotationBadges = ({
  annotations
}) => {
  const getValueAndImplied = (value, defaultValue) => ({
    value: value ?? defaultValue,
    implied: value === void 0
  });
  const readOnly = getValueAndImplied(annotations?.readOnlyHint, false);
  const destructive = getValueAndImplied(annotations?.destructiveHint, true);
  const idempotent = getValueAndImplied(annotations?.idempotentHint, false);
  const openWorld = getValueAndImplied(annotations?.openWorldHint, true);
  const badges = [
    {
      label: "Read-only",
      value: readOnly.value,
      implied: readOnly.implied,
      description: "Tool does not modify its environment"
    },
    {
      label: "Destructive",
      value: destructive.value,
      implied: destructive.implied,
      description: "Tool may perform destructive updates (delete/overwrite data)"
    },
    {
      label: "Idempotent",
      value: idempotent.value,
      implied: idempotent.implied,
      description: "Calling repeatedly with same args has no additional effect"
    },
    {
      label: "Open-world",
      value: openWorld.value,
      implied: openWorld.implied,
      description: "Tool may interact with external entities beyond its local environment"
    }
  ];
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-wrap gap-1 mt-2", children: badges.map(({ label, value, implied, description: description2 }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "span",
    {
      title: `${description2}

Value: ${value ? "Yes" : "No"} (${implied ? "implied default" : "explicitly set"})`,
      className: cn$2(
        "inline-flex items-center px-2 py-0.5 rounded text-xs font-medium border",
        "bg-slate-100 text-slate-700 border-slate-300 dark:bg-slate-800 dark:text-slate-300 dark:border-slate-600",
        implied && "border-dashed opacity-60",
        !implied && "border-solid"
      ),
      children: [
        value ? "" : "",
        " ",
        label
      ]
    },
    label
  )) });
};
const ToolsTab = ({
  tools,
  listTools,
  clearTools,
  callTool,
  selectedTool,
  setSelectedTool,
  toolResult,
  isPollingTask,
  nextCursor,
  error,
  resourceContent,
  onReadResource,
  serverSupportsTaskRequests
}) => {
  const [params, setParams] = reactExports.useState({});
  const [runAsTask, setRunAsTask] = reactExports.useState(false);
  const [isToolRunning, setIsToolRunning] = reactExports.useState(false);
  const [isOutputSchemaExpanded, setIsOutputSchemaExpanded] = reactExports.useState(false);
  const [isMetadataExpanded, setIsMetadataExpanded] = reactExports.useState(false);
  const [metadataEntries, setMetadataEntries] = reactExports.useState([]);
  const [hasValidationErrors, setHasValidationErrors] = reactExports.useState(false);
  const formRefs = reactExports.useRef({});
  const { toast: toast2 } = useToast();
  const { copied, setCopied } = useCopy();
  const checkValidationErrors = (validateChildren = false) => {
    const errors2 = Object.values(formRefs.current).some(
      (ref2) => ref2 && (validateChildren ? !ref2.validateJson().isValid : ref2.hasJsonError())
    );
    setHasValidationErrors(errors2);
    return errors2;
  };
  reactExports.useEffect(() => {
    const params2 = Object.entries(
      selectedTool?.inputSchema.properties ?? []
    ).map(([key, value]) => {
      const resolvedValue = resolveRef(
        value,
        selectedTool?.inputSchema
      );
      return [
        key,
        generateDefaultValue(
          resolvedValue,
          key,
          selectedTool?.inputSchema
        )
      ];
    });
    setParams(Object.fromEntries(params2));
    const toolTaskSupport = serverSupportsTaskRequests ? getTaskSupport(selectedTool) : "forbidden";
    setRunAsTask(toolTaskSupport === "required");
    setHasValidationErrors(false);
    formRefs.current = {};
  }, [selectedTool, serverSupportsTaskRequests]);
  const hasReservedMetadataEntry = metadataEntries.some(({ key }) => {
    const trimmedKey = key.trim();
    return trimmedKey !== "" && isReservedMetaKey(trimmedKey);
  });
  const hasInvalidMetaPrefixEntry = metadataEntries.some(({ key }) => {
    const trimmedKey = key.trim();
    return trimmedKey !== "" && !hasValidMetaPrefix(trimmedKey);
  });
  const hasInvalidMetaNameEntry = metadataEntries.some(({ key }) => {
    const trimmedKey = key.trim();
    return trimmedKey !== "" && !hasValidMetaName(trimmedKey);
  });
  const taskSupport = serverSupportsTaskRequests ? getTaskSupport(selectedTool) : "forbidden";
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "tools", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ListPane,
      {
        items: tools,
        listItems: listTools,
        clearItems: () => {
          clearTools();
          setSelectedTool(null);
          setRunAsTask(false);
        },
        setSelectedItem: setSelectedTool,
        renderItem: (tool) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start w-full gap-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-shrink-0 mt-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconDisplay, { icons: tool.icons, size: "sm" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col flex-1 min-w-0", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "truncate", children: tool.title || tool.name }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm text-gray-500 text-left line-clamp-2", children: tool.description })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRight, { className: "w-4 h-4 flex-shrink-0 text-gray-400 mt-1" })
        ] }),
        title: "Tools",
        buttonText: nextCursor ? "List More Tools" : "List Tools",
        isButtonDisabled: !nextCursor && tools.length > 0
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-card border border-border rounded-lg shadow", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-4 border-b border-gray-200 dark:border-border", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
        selectedTool && /* @__PURE__ */ jsxRuntimeExports.jsx(
          IconDisplay,
          {
            icons: selectedTool.icons,
            size: "md"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold", children: selectedTool ? selectedTool.title || selectedTool.name : "Select a tool" })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-4", children: selectedTool ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
        error && /* @__PURE__ */ jsxRuntimeExports.jsxs(Alert, { variant: "destructive", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(CircleAlert, { className: "h-4 w-4" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(AlertTitle, { children: "Error" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(AlertDescription, { className: "break-all", children: error })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-600 dark:text-gray-400 whitespace-pre-wrap max-h-48 overflow-y-auto", children: selectedTool.description }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          AnnotationBadges,
          {
            annotations: hasAnnotations(selectedTool) ? selectedTool.annotations : void 0
          }
        ),
        Object.entries(selectedTool.inputSchema.properties ?? []).map(
          ([key, value]) => {
            const resolvedValue = resolveRef(
              value,
              selectedTool.inputSchema
            );
            const prop = normalizeUnionType(resolvedValue);
            const inputSchema = selectedTool.inputSchema;
            const required2 = isPropertyRequired(key, inputSchema);
            return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  Label$1,
                  {
                    htmlFor: key,
                    className: "block text-sm font-medium text-gray-700 dark:text-gray-300",
                    children: [
                      key,
                      required2 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-red-500 ml-1", children: "*" })
                    ]
                  }
                ),
                prop.nullable ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Checkbox,
                    {
                      id: key,
                      name: key,
                      checked: params[key] === null,
                      onCheckedChange: (checked) => setParams({
                        ...params,
                        [key]: checked ? null : prop.type === "array" ? void 0 : prop.default !== null ? prop.default : prop.type === "boolean" ? false : prop.type === "string" ? "" : prop.type === "number" || prop.type === "integer" ? void 0 : void 0
                      })
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "label",
                    {
                      htmlFor: key,
                      className: "text-sm font-medium text-gray-700 dark:text-gray-300",
                      children: "null"
                    }
                  )
                ] }) : null
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  role: "toolinputwrapper",
                  className: `${prop.nullable && params[key] === null ? "pointer-events-none opacity-50" : ""}`,
                  children: prop.type === "boolean" ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2 mt-2", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Checkbox,
                      {
                        id: key,
                        name: key,
                        checked: !!params[key],
                        onCheckedChange: (checked) => setParams({
                          ...params,
                          [key]: checked
                        })
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "label",
                      {
                        htmlFor: key,
                        className: "text-sm font-medium text-gray-700 dark:text-gray-300",
                        children: prop.description || "Toggle this option"
                      }
                    )
                  ] }) : prop.type === "string" && prop.enum ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    Select,
                    {
                      value: params[key] === void 0 ? "" : String(params[key]),
                      onValueChange: (value2) => {
                        if (value2 === "") {
                          setParams({
                            ...params,
                            [key]: void 0
                          });
                        } else {
                          setParams({
                            ...params,
                            [key]: value2
                          });
                        }
                      },
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { id: key, className: "mt-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                          SelectValue,
                          {
                            placeholder: prop.description || "Select an option"
                          }
                        ) }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContent, { children: prop.enum.map((option) => /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: option, children: option }, option)) })
                      ]
                    }
                  ) : prop.type === "string" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Textarea,
                    {
                      id: key,
                      name: key,
                      placeholder: prop.description,
                      value: params[key] === void 0 ? "" : String(params[key]),
                      onChange: (e) => {
                        const value2 = e.target.value;
                        if (value2 === "") {
                          setParams({
                            ...params,
                            [key]: void 0
                          });
                        } else {
                          setParams({
                            ...params,
                            [key]: value2
                          });
                        }
                      },
                      className: "mt-1"
                    }
                  ) : prop.type === "object" || prop.type === "array" ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    DynamicJsonForm,
                    {
                      ref: (ref2) => formRefs.current[key] = ref2,
                      schema: {
                        type: prop.type,
                        properties: prop.properties,
                        description: prop.description,
                        items: prop.items
                      },
                      value: params[key] ?? generateDefaultValue(prop),
                      onChange: (newValue) => {
                        setParams({
                          ...params,
                          [key]: newValue
                        });
                        setTimeout(checkValidationErrors, 100);
                      }
                    }
                  ) }) : prop.type === "number" || prop.type === "integer" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Input,
                    {
                      type: "number",
                      id: key,
                      name: key,
                      placeholder: prop.description,
                      value: params[key] === void 0 ? "" : String(params[key]),
                      onChange: (e) => {
                        const value2 = e.target.value;
                        if (value2 === "") {
                          setParams({
                            ...params,
                            [key]: void 0
                          });
                        } else {
                          const num = Number(value2);
                          if (!isNaN(num)) {
                            setParams({
                              ...params,
                              [key]: num
                            });
                          } else {
                            setParams({
                              ...params,
                              [key]: value2
                            });
                          }
                        }
                      },
                      className: "mt-1"
                    }
                  ) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    DynamicJsonForm,
                    {
                      ref: (ref2) => formRefs.current[key] = ref2,
                      schema: {
                        type: prop.type,
                        properties: prop.properties,
                        description: prop.description,
                        items: prop.items
                      },
                      value: params[key],
                      onChange: (newValue) => {
                        setParams({
                          ...params,
                          [key]: newValue
                        });
                        setTimeout(checkValidationErrors, 100);
                      }
                    }
                  ) })
                }
              )
            ] }, key);
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pb-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "text-sm font-semibold", children: "Tool-specific Metadata:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                size: "sm",
                variant: "outline",
                className: "h-6 px-2",
                onClick: () => setMetadataEntries((prev) => [
                  ...prev,
                  {
                    id: globalThis.crypto?.randomUUID?.() || Math.random().toString(36).slice(2),
                    key: "",
                    value: ""
                  }
                ]),
                children: "Add Pair"
              }
            )
          ] }),
          metadataEntries.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-muted-foreground", children: "No metadata pairs." }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-2", children: metadataEntries.map((entry, index2) => {
            const trimmedKey = entry.key.trim();
            const hasInvalidPrefix = trimmedKey !== "" && !hasValidMetaPrefix(trimmedKey);
            const isReservedKey = trimmedKey !== "" && isReservedMetaKey(trimmedKey);
            const hasInvalidName = trimmedKey !== "" && !hasValidMetaName(trimmedKey);
            const validationMessage = hasInvalidPrefix ? META_PREFIX_RULES_MESSAGE : isReservedKey ? RESERVED_NAMESPACE_MESSAGE : hasInvalidName ? META_NAME_RULES_MESSAGE : null;
            return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-1", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 w-full", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Label$1,
                  {
                    htmlFor: `metadata-key-${entry.id}`,
                    className: "text-xs shrink-0",
                    children: "Key"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input,
                  {
                    id: `metadata-key-${entry.id}`,
                    value: entry.key,
                    placeholder: "e.g. requestId",
                    onChange: (e) => {
                      const value = e.target.value;
                      setMetadataEntries(
                        (prev) => prev.map(
                          (m2, i) => i === index2 ? { ...m2, key: value } : m2
                        )
                      );
                    },
                    className: cn$2(
                      "h-8 flex-1",
                      validationMessage && "border-red-500 focus-visible:ring-red-500 focus-visible:ring-1"
                    ),
                    "aria-invalid": Boolean(validationMessage)
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Label$1,
                  {
                    htmlFor: `metadata-value-${entry.id}`,
                    className: "text-xs shrink-0",
                    children: "Value"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input,
                  {
                    id: `metadata-value-${entry.id}`,
                    value: entry.value,
                    placeholder: "e.g. 12345",
                    onChange: (e) => {
                      const value = e.target.value;
                      setMetadataEntries(
                        (prev) => prev.map(
                          (m2, i) => i === index2 ? { ...m2, value } : m2
                        )
                      );
                    },
                    className: "h-8 flex-1",
                    disabled: Boolean(validationMessage)
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    size: "sm",
                    variant: "ghost",
                    className: "h-8 w-8 p-0 ml-auto shrink-0",
                    onClick: () => setMetadataEntries(
                      (prev) => prev.filter((_2, i) => i !== index2)
                    ),
                    "aria-label": `Remove meta pair ${index2 + 1}`,
                    children: "-"
                  }
                )
              ] }),
              validationMessage && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-red-600 dark:text-red-400", children: validationMessage })
            ] }, entry.id);
          }) }),
          (hasReservedMetadataEntry || hasInvalidMetaPrefixEntry || hasInvalidMetaNameEntry) && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-red-600 dark:text-red-400", children: "Remove reserved or invalid metadata keys (prefix/name) before running the tool." })
        ] }),
        selectedTool.outputSchema && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gray-50 dark:bg-gray-900 p-3 rounded-lg", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "text-sm font-semibold", children: "Output Schema:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                size: "sm",
                variant: "ghost",
                onClick: () => setIsOutputSchemaExpanded(!isOutputSchemaExpanded),
                className: "h-6 px-2",
                children: isOutputSchemaExpanded ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronUp, { className: "h-3 w-3 mr-1" }),
                  "Collapse"
                ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronDown, { className: "h-3 w-3 mr-1" }),
                  "Expand"
                ] })
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: `transition-all ${isOutputSchemaExpanded ? "" : "max-h-[8rem] overflow-y-auto"}`,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(JsonView, { data: selectedTool.outputSchema })
            }
          )
        ] }),
        selectedTool && hasMeta(selectedTool) && selectedTool._meta && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gray-50 dark:bg-gray-900 p-3 rounded-lg", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "text-sm font-semibold", children: "Meta:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                size: "sm",
                variant: "ghost",
                onClick: () => setIsMetadataExpanded(!isMetadataExpanded),
                className: "h-6 px-2",
                children: isMetadataExpanded ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronUp, { className: "h-3 w-3 mr-1" }),
                  "Collapse"
                ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronDown, { className: "h-3 w-3 mr-1" }),
                  "Expand"
                ] })
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: `transition-all ${isMetadataExpanded ? "" : "max-h-[8rem] overflow-y-auto"}`,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(JsonView, { data: selectedTool._meta })
            }
          )
        ] }),
        taskSupport !== "forbidden" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              id: "run-as-task",
              checked: runAsTask,
              onCheckedChange: (checked) => setRunAsTask(checked),
              disabled: taskSupport === "required"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Label$1,
            {
              htmlFor: "run-as-task",
              className: "text-sm font-medium text-gray-700 dark:text-gray-300 cursor-pointer",
              children: "Run as task"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            onClick: async () => {
              if (checkValidationErrors(true)) return;
              try {
                setIsToolRunning(true);
                const metadata2 = metadataEntries.reduce((acc, { key, value }) => {
                  const trimmedKey = key.trim();
                  if (trimmedKey !== "" && hasValidMetaPrefix(trimmedKey) && !isReservedMetaKey(trimmedKey) && hasValidMetaName(trimmedKey)) {
                    acc[trimmedKey] = value;
                  }
                  return acc;
                }, {});
                await callTool(
                  selectedTool.name,
                  params,
                  Object.keys(metadata2).length ? metadata2 : void 0,
                  runAsTask
                );
              } finally {
                setIsToolRunning(false);
              }
            },
            disabled: isToolRunning || isPollingTask || hasValidationErrors || hasReservedMetadataEntry || hasInvalidMetaPrefixEntry || hasInvalidMetaNameEntry,
            children: isToolRunning || isPollingTask ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(LoaderCircle, { className: "w-4 h-4 mr-2 animate-spin" }),
              isPollingTask ? "Polling Task..." : "Running..."
            ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Send, { className: "w-4 h-4 mr-2" }),
              "Run Tool"
            ] })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex gap-2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Button,
          {
            onClick: async () => {
              try {
                navigator.clipboard.writeText(
                  JSON.stringify(params, null, 2)
                );
                setCopied(true);
              } catch (error2) {
                toast2({
                  title: "Error",
                  description: `There was an error copying input to the clipboard: ${error2 instanceof Error ? error2.message : String(error2)}`,
                  variant: "destructive"
                });
              }
            },
            children: [
              copied ? /* @__PURE__ */ jsxRuntimeExports.jsx(CheckCheck, { className: "h-4 w-4 mr-2 dark:text-green-700 text-green-600" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Copy, { className: "h-4 w-4 mr-2" }),
              "Copy Input"
            ]
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          ToolResults,
          {
            toolResult,
            selectedTool,
            resourceContent,
            onReadResource,
            isPollingTask
          }
        )
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(AlertDescription, { children: "Select a tool from the list to view its details and run it" }) }) })
    ] })
  ] }) });
};
const TaskStatusIcon = ({ status }) => {
  switch (status) {
    case "working":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Clock, { className: "h-4 w-4 animate-pulse text-blue-500" });
    case "input_required":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(TriangleAlert, { className: "h-4 w-4 text-yellow-500" });
    case "completed":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(CircleCheck, { className: "h-4 w-4 text-green-500" });
    case "failed":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(CircleX, { className: "h-4 w-4 text-red-500" });
    case "cancelled":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(CircleX, { className: "h-4 w-4 text-gray-500" });
    default:
      return /* @__PURE__ */ jsxRuntimeExports.jsx(CirclePlay, { className: "h-4 w-4" });
  }
};
const TasksTab = ({
  tasks,
  listTasks,
  clearTasks,
  cancelTask,
  selectedTask,
  setSelectedTask,
  error,
  nextCursor
}) => {
  const [isCancelling, setIsCancelling] = reactExports.useState(null);
  const displayedTask = selectedTask ? tasks.find((t) => t.taskId === selectedTask.taskId) || selectedTask : null;
  const handleCancel = async (taskId) => {
    setIsCancelling(taskId);
    try {
      await cancelTask(taskId);
    } finally {
      setIsCancelling(null);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "tasks", className: "flex-1 overflow-hidden p-0 m-0", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex h-full overflow-hidden p-4 gap-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-1/3", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      ListPane,
      {
        title: "Tasks",
        items: tasks,
        setSelectedItem: setSelectedTask,
        listItems: listTasks,
        clearItems: clearTasks,
        buttonText: nextCursor ? "List More Tasks" : "List Tasks",
        isButtonDisabled: !nextCursor && tasks.length > 0,
        renderItem: (task) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 overflow-hidden w-full", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(TaskStatusIcon, { status: task.status }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col overflow-hidden", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "truncate font-medium", children: task.taskId }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "truncate text-xs text-muted-foreground", children: [
              task.status,
              " -",
              " ",
              new Date(task.lastUpdatedAt).toLocaleString()
            ] })
          ] })
        ] })
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1 overflow-y-auto p-4 bg-background border border-border rounded-lg", children: [
      error && /* @__PURE__ */ jsxRuntimeExports.jsxs(Alert, { variant: "destructive", className: "mb-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(CircleAlert, { className: "h-4 w-4" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(AlertTitle, { children: "Error" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(AlertDescription, { children: error })
      ] }),
      displayedTask ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between border-b pb-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-bold tracking-tight", children: "Task Details" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-muted-foreground", children: [
              "ID: ",
              displayedTask.taskId
            ] })
          ] }),
          (displayedTask.status === "working" || displayedTask.status === "input_required") && /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Button,
            {
              variant: "destructive",
              size: "sm",
              "aria-label": `Cancel task ${displayedTask.taskId}`,
              onClick: () => handleCancel(displayedTask.taskId),
              disabled: isCancelling === displayedTask.taskId,
              children: [
                isCancelling === displayedTask.taskId ? /* @__PURE__ */ jsxRuntimeExports.jsx(RefreshCw, { className: "mr-2 h-4 w-4 animate-spin" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(CircleX, { className: "mr-2 h-4 w-4" }),
                "Cancel Task"
              ]
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rounded-lg border p-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm font-medium text-muted-foreground", children: "Status" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-1 flex items-center gap-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(TaskStatusIcon, { status: displayedTask.status }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "span",
                {
                  className: cn$2(
                    "font-semibold capitalize",
                    displayedTask.status === "working" && "text-blue-500",
                    displayedTask.status === "completed" && "text-green-500",
                    displayedTask.status === "failed" && "text-red-500",
                    displayedTask.status === "cancelled" && "text-gray-500",
                    displayedTask.status === "input_required" && "text-yellow-500"
                  ),
                  children: displayedTask.status.replace("_", " ")
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rounded-lg border p-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm font-medium text-muted-foreground", children: "Last Updated" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-1 font-medium", children: new Date(displayedTask.lastUpdatedAt).toLocaleString() })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rounded-lg border p-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm font-medium text-muted-foreground", children: "Created At" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-1 font-medium", children: new Date(displayedTask.createdAt).toLocaleString() })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rounded-lg border p-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm font-medium text-muted-foreground", children: "TTL" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-1 font-medium", children: displayedTask.ttl === null ? "Infinite" : `${displayedTask.ttl}ms` })
          ] })
        ] }),
        displayedTask.statusMessage && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rounded-lg border p-3", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm font-medium text-muted-foreground", children: "Status Message" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-1 whitespace-pre-wrap", children: displayedTask.statusMessage })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold", children: "Full Task Object" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rounded-md border", children: /* @__PURE__ */ jsxRuntimeExports.jsx(JsonView, { data: displayedTask }) })
        ] })
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex h-full items-center justify-center text-muted-foreground", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Clock, { className: "mx-auto mb-4 h-12 w-12 opacity-20" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-medium", children: "No Task Selected" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Select a task from the list to view its details." }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Button,
          {
            variant: "outline",
            size: "sm",
            className: "mt-4",
            onClick: listTasks,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(RefreshCw, { className: "mr-2 h-4 w-4" }),
              "Refresh Tasks"
            ]
          }
        )
      ] }) })
    ] })
  ] }) });
};
var fm = Object.defineProperty;
var pm = (e, i, r2) => i in e ? fm(e, i, { enumerable: true, configurable: true, writable: true, value: r2 }) : e[i] = r2;
var F = (e, i, r2) => pm(e, typeof i != "symbol" ? i + "" : i, r2);
const ho = React.forwardRef(({ content: e, children: i, ...r2 }, a2) => /* @__PURE__ */ jsxRuntimeExports.jsx("span", { ref: a2, ...r2, children: e || i }));
ho.displayName = "UIText";
const _o = React.forwardRef(({ label: e, onPress: i, onClick: r2, children: a2, ...t }, n) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "button",
  {
    ref: n,
    onClick: (s2) => {
      i && i(), r2 && r2(s2);
    },
    style: {
      padding: "8px 16px",
      backgroundColor: "#007bff",
      color: "white",
      border: "none",
      borderRadius: "4px",
      cursor: "pointer"
    },
    ...t,
    children: e || a2
  }
));
_o.displayName = "UIButton";
const bo = React.forwardRef(
  ({
    direction: e = "vertical",
    spacing: i = "8",
    align: r2 = "stretch",
    justify: a2 = "flex-start",
    children: t,
    ...n
  }, o) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      ref: o,
      style: {
        display: "flex",
        flexDirection: e === "horizontal" ? "row" : "column",
        gap: `${i}px`,
        alignItems: r2,
        justifyContent: a2
      },
      ...n,
      children: t
    }
  )
);
bo.displayName = "UIStack";
const yo = React.forwardRef(({ src: e, alt: i, width: r2, height: a2, children: t, ...n }, o) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "img",
  {
    ref: o,
    src: e,
    alt: i,
    width: r2,
    height: a2,
    style: {
      maxWidth: "100%",
      height: "auto",
      borderRadius: "8px",
      boxShadow: "0 2px 8px rgba(0, 0, 0, 0.1)"
    },
    ...n
  }
));
yo.displayName = "UIImage";
var If = Object.defineProperty, ye = (e, i) => {
  for (var r2 in i) If(e, r2, { get: i[r2], enumerable: true, configurable: true, set: (a2) => i[r2] = () => a2 });
}, Io = "2025-11-21", kf = "ui/notifications/sandbox-proxy-ready", m = {};
ye(m, { xor: () => Cc, xid: () => uc, void: () => Rc, uuidv7: () => ec, uuidv6: () => Qd, uuidv4: () => Xd, uuid: () => Kd, util: () => T, url: () => tc, uppercase: () => hi, unknown: () => Fe2, union: () => qi, undefined: () => Oc, ulid: () => sc, uint64: () => Tc, uint32: () => xc, tuple: () => Jn, trim: () => ki, treeifyError: () => Ao, transform: () => Bi, toUpperCase: () => Si, toLowerCase: () => wi, toJSONSchema: () => Td, templateLiteral: () => Xc, symbol: () => Uc, superRefine: () => ga, success: () => Bc, stringbool: () => am, stringFormat: () => bc, string: () => ri, strictObject: () => Ac, startsWith: () => bi, slugify: () => xi, size: () => Tt, setErrorMap: () => Vg, set: () => Vc, safeParseAsync: () => Ld, safeParse: () => Cd, safeEncodeAsync: () => qd, safeEncode: () => Gd, safeDecodeAsync: () => Yd, safeDecode: () => Wd, registry: () => Wr, regexes: () => Ve, regex: () => vi, refine: () => va, record: () => Vn, readonly: () => la, property: () => _n, promise: () => Qc, prettifyError: () => Co, preprocess: () => sm, prefault: () => ia, positive: () => pn2, pipe: () => ht, partialRecord: () => Mc, parseAsync: () => Zd, parse: () => Ad, overwrite: () => Ie, optional: () => vt, object: () => jc, number: () => En, nullish: () => Yc, nullable: () => gt, null: () => Nn, normalize: () => Ii, nonpositive: () => gn, nonoptional: () => ra, nonnegative: () => hn, never: () => Gi, negative: () => vn, nativeEnum: () => Gc, nanoid: () => nc, nan: () => Hc, multipleOf: () => tt, minSize: () => ze, minLength: () => Me, mime: () => $i, meta: () => rm, maxSize: () => ot, maxLength: () => Ut, map: () => Jc, mac: () => cc, lte: () => le, lt: () => xe, lowercase: () => gi, looseRecord: () => Fc, looseObject: () => Zc, locales: () => Gr, literal: () => Wc, length: () => Ot, lazy: () => ma, ksuid: () => lc, keyof: () => Dc, jwt: () => _c, json: () => om, iso: () => $n, ipv6: () => mc, ipv4: () => dc, intersection: () => Mn, int64: () => zc, int32: () => Sc, int: () => ni, instanceof: () => nm, includes: () => _i, httpUrl: () => ic, hostname: () => yc, hex: () => $c, hash: () => Ic, guid: () => Hd, gte: () => ee, gt: () => Ee, globalRegistry: () => ue, getErrorMap: () => Gg, function: () => ai, fromJSONSchema: () => Bg, formatError: () => Sr, float64: () => wc, float32: () => kc, flattenError: () => wr, file: () => qc, exactOptional: () => Kn, enum: () => Yi, endsWith: () => yi, encodeAsync: () => Jd, encode: () => Md, emoji: () => rc, email: () => Bd, e164: () => hc, discriminatedUnion: () => Lc, describe: () => im, decodeAsync: () => Vd, decode: () => Fd, date: () => Pc, custom: () => tm, cuid2: () => oc, cuid: () => ac, core: () => ko, config: () => H, coerce: () => lm, codec: () => Kc, clone: () => me, cidrv6: () => pc, cidrv4: () => fc, check: () => em, catch: () => oa, boolean: () => zn, bigint: () => Ec, base64url: () => gc, base64: () => vc, array: () => Zt, any: () => Nc, _function: () => ai, _default: () => ea, _ZodString: () => Ei, ZodXor: () => Zn, ZodXID: () => Pi, ZodVoid: () => jn, ZodUnknown: () => Pn, ZodUnion: () => Lt, ZodUndefined: () => Un, ZodUUID: () => he, ZodURL: () => Pt, ZodULID: () => Ri, ZodType: () => x, ZodTuple: () => Fn, ZodTransform: () => Bn, ZodTemplateLiteral: () => da, ZodSymbol: () => Tn, ZodSuccess: () => na, ZodStringFormat: () => Z, ZodString: () => Rt, ZodSet: () => Wn, ZodRecord: () => Mt, ZodRealError: () => re, ZodReadonly: () => ua, ZodPromise: () => fa, ZodPrefault: () => ta, ZodPipe: () => Xi, ZodOptional: () => Hi, ZodObject: () => Ct, ZodNumberFormat: () => Ge, ZodNumber: () => Dt, ZodNullable: () => Xn, ZodNull: () => On, ZodNonOptional: () => Ki, ZodNever: () => Dn, ZodNanoID: () => Ui, ZodNaN: () => sa, ZodMap: () => Gn, ZodMAC: () => xn, ZodLiteral: () => qn, ZodLazy: () => ca, ZodKSUID: () => Di, ZodJWT: () => Ji, ZodIssueCode: () => Jg, ZodIntersection: () => Ln, ZodISOTime: () => wn, ZodISODuration: () => Sn, ZodISODateTime: () => In, ZodISODate: () => kn, ZodIPv6: () => Ai, ZodIPv4: () => ji, ZodGUID: () => pt, ZodFunction: () => pa, ZodFirstPartyTypeKind: () => hr, ZodFile: () => Yn, ZodExactOptional: () => Hn, ZodError: () => Fg, ZodEnum: () => at, ZodEmoji: () => Ti, ZodEmail: () => zi, ZodE164: () => Fi, ZodDiscriminatedUnion: () => Cn, ZodDefault: () => Qn, ZodDate: () => Wi, ZodCustomStringFormat: () => st, ZodCustom: () => Ft, ZodCodec: () => Qi, ZodCatch: () => aa, ZodCUID2: () => Ni, ZodCUID: () => Oi, ZodCIDRv6: () => Ci, ZodCIDRv4: () => Zi, ZodBoolean: () => jt, ZodBigIntFormat: () => Vi, ZodBigInt: () => At, ZodBase64URL: () => Mi, ZodBase64: () => Li, ZodArray: () => An, ZodAny: () => Rn, TimePrecision: () => ul, NEVER: () => wo, $output: () => il, $input: () => rl, $brand: () => So });
var ko = {};
ye(ko, { version: () => Cs, util: () => T, treeifyError: () => Ao, toJSONSchema: () => Td, toDotPath: () => Zo, safeParseAsync: () => Mo, safeParse: () => Lo, safeEncodeAsync: () => ip, safeEncode: () => ep, safeDecodeAsync: () => rp, safeDecode: () => tp, registry: () => Wr, regexes: () => Ve, process: () => D, prettifyError: () => Co, parseAsync: () => pr, parse: () => fr, meta: () => Jl, locales: () => Gr, isValidJWT: () => du, isValidBase64URL: () => su, isValidBase64: () => Zr, initializeContext: () => it, globalRegistry: () => ue, globalConfig: () => Kt, formatError: () => Sr, flattenError: () => wr, finalize: () => nt, extractDefs: () => rt, encodeAsync: () => Xf, encode: () => Hf, describe: () => Fl, decodeAsync: () => Qf, decode: () => Kf, createToJSONSchemaMethod: () => Gl, createStandardJSONSchemaMethod: () => ft, config: () => H, clone: () => me, _xor: () => hg, _xid: () => nn, _void: () => Nl, _uuidv7: () => Kr, _uuidv6: () => Hr, _uuidv4: () => Br, _uuid: () => Yr, _url: () => pi, _uppercase: () => hi, _unknown: () => Ul, _union: () => gg, _undefined: () => El, _ulid: () => rn, _uint64: () => Sl, _uint32: () => bl, _tuple: () => yg, _trim: () => ki, _transform: () => Eg, _toUpperCase: () => Si, _toLowerCase: () => wi, _templateLiteral: () => jg, _symbol: () => xl, _superRefine: () => Ll, _success: () => Ng, _stringbool: () => Vl, _stringFormat: () => Nt, _string: () => al, _startsWith: () => bi, _slugify: () => xi, _size: () => Tt, _set: () => kg, _safeParseAsync: () => wt, _safeParse: () => kt, _safeEncodeAsync: () => Nr, _safeEncode: () => Ur, _safeDecodeAsync: () => Rr, _safeDecode: () => Or, _regex: () => vi, _refine: () => Cl, _record: () => $g, _readonly: () => Dg, _property: () => _n, _promise: () => Zg, _positive: () => pn2, _pipe: () => Pg, _parseAsync: () => It, _parse: () => $t, _overwrite: () => Ie, _optional: () => zg, _number: () => fl, _nullable: () => Tg, _null: () => zl, _normalize: () => Ii, _nonpositive: () => gn, _nonoptional: () => Og, _nonnegative: () => hn, _never: () => Ol, _negative: () => vn, _nativeEnum: () => Sg, _nanoid: () => Qr, _nan: () => Dl, _multipleOf: () => tt, _minSize: () => ze, _minLength: () => Me, _min: () => ee, _mime: () => $i, _maxSize: () => ot, _maxLength: () => Ut, _max: () => le, _map: () => Ig, _mac: () => sl, _lte: () => le, _lt: () => xe, _lowercase: () => gi, _literal: () => xg, _length: () => Ot, _lazy: () => Ag, _ksuid: () => an, _jwt: () => fn, _isoTime: () => cl, _isoDuration: () => ml, _isoDateTime: () => ll, _isoDate: () => dl, _ipv6: () => sn, _ipv4: () => on, _intersection: () => bg, _int64: () => wl, _int32: () => _l, _int: () => vl, _includes: () => _i, _guid: () => ii, _gte: () => ee, _gt: () => Ee, _float64: () => hl, _float32: () => gl, _file: () => Al, _enum: () => wg, _endsWith: () => yi, _encodeAsync: () => zr, _encode: () => xr, _emoji: () => Xr, _email: () => qr, _e164: () => mn, _discriminatedUnion: () => _g, _default: () => Ug, _decodeAsync: () => Tr, _decode: () => Er, _date: () => Rl, _custom: () => Zl, _cuid2: () => tn, _cuid: () => en, _coercedString: () => ol, _coercedNumber: () => pl, _coercedDate: () => Pl, _coercedBoolean: () => $l, _coercedBigint: () => kl, _cidrv6: () => ln, _cidrv4: () => un, _check: () => Ml, _catch: () => Rg, _boolean: () => yl, _bigint: () => Il, _base64url: () => cn, _base64: () => dn, _array: () => jl, _any: () => Tl, TimePrecision: () => ul, NEVER: () => wo, JSONSchemaGenerator: () => Lg, JSONSchema: () => Mg, Doc: () => Zs, $output: () => il, $input: () => rl, $constructor: () => p, $brand: () => So, $ZodXor: () => zu, $ZodXID: () => Bs, $ZodVoid: () => $u, $ZodUnknown: () => bu, $ZodUnion: () => fi, $ZodUndefined: () => gu, $ZodUUID: () => Ms, $ZodURL: () => Js, $ZodULID: () => Ys, $ZodType: () => S, $ZodTuple: () => Fr, $ZodTransform: () => Au, $ZodTemplateLiteral: () => Yu, $ZodSymbol: () => vu, $ZodSuccess: () => Ju, $ZodStringFormat: () => A, $ZodString: () => zt, $ZodSet: () => Ru, $ZodRegistry: () => nl, $ZodRecord: () => Ou, $ZodRealError: () => ie, $ZodReadonly: () => qu, $ZodPromise: () => Hu, $ZodPrefault: () => Mu, $ZodPipe: () => Wu, $ZodOptional: () => Jr, $ZodObjectJIT: () => Eu, $ZodObject: () => xu, $ZodNumberFormat: () => fu, $ZodNumber: () => Cr, $ZodNullable: () => Cu, $ZodNull: () => hu, $ZodNonOptional: () => Fu, $ZodNever: () => yu, $ZodNanoID: () => Gs, $ZodNaN: () => Gu, $ZodMap: () => Nu, $ZodMAC: () => ru, $ZodLiteral: () => Du, $ZodLazy: () => Ku, $ZodKSUID: () => Hs, $ZodJWT: () => cu, $ZodIntersection: () => Uu, $ZodISOTime: () => Qs, $ZodISODuration: () => eu, $ZodISODateTime: () => Ks, $ZodISODate: () => Xs, $ZodIPv6: () => iu, $ZodIPv4: () => tu, $ZodGUID: () => Ls, $ZodFunction: () => Bu, $ZodFile: () => ju, $ZodExactOptional: () => Zu, $ZodError: () => kr, $ZodEnum: () => Pu, $ZodEncodeError: () => li, $ZodEmoji: () => Vs, $ZodEmail: () => Fs, $ZodE164: () => lu, $ZodDiscriminatedUnion: () => Tu, $ZodDefault: () => Lu, $ZodDate: () => Iu, $ZodCustomStringFormat: () => mu, $ZodCustom: () => Xu, $ZodCodec: () => Vr, $ZodCheckUpperCase: () => Os, $ZodCheckStringFormat: () => Et, $ZodCheckStartsWith: () => Rs, $ZodCheckSizeEquals: () => Ss, $ZodCheckRegex: () => Ts, $ZodCheckProperty: () => Ds, $ZodCheckOverwrite: () => As, $ZodCheckNumberFormat: () => $s, $ZodCheckMultipleOf: () => ys, $ZodCheckMinSize: () => ws, $ZodCheckMinLength: () => Es, $ZodCheckMimeType: () => js, $ZodCheckMaxSize: () => ks, $ZodCheckMaxLength: () => xs, $ZodCheckLowerCase: () => Us, $ZodCheckLessThan: () => jr, $ZodCheckLengthEquals: () => zs, $ZodCheckIncludes: () => Ns, $ZodCheckGreaterThan: () => Ar, $ZodCheckEndsWith: () => Ps, $ZodCheckBigIntFormat: () => Is, $ZodCheck: () => M, $ZodCatch: () => Vu, $ZodCUID2: () => qs, $ZodCUID: () => Ws, $ZodCIDRv6: () => au, $ZodCIDRv4: () => nu, $ZodBoolean: () => Lr, $ZodBigIntFormat: () => pu, $ZodBigInt: () => Mr, $ZodBase64URL: () => uu, $ZodBase64: () => ou, $ZodAsyncError: () => Ce, $ZodArray: () => ku, $ZodAny: () => _u });
var wo = Object.freeze({ status: "aborted" });
function p(e, i, r2) {
  function a2(s2, u2) {
    if (s2._zod || Object.defineProperty(s2, "_zod", { value: { def: u2, constr: o, traits: /* @__PURE__ */ new Set() }, enumerable: false }), s2._zod.traits.has(e)) return;
    s2._zod.traits.add(e), i(s2, u2);
    let l = o.prototype, d2 = Object.keys(l);
    for (let c = 0; c < d2.length; c++) {
      let f2 = d2[c];
      f2 in s2 || (s2[f2] = l[f2].bind(s2));
    }
  }
  let t = (r2 == null ? void 0 : r2.Parent) ?? Object;
  class n extends t {
  }
  Object.defineProperty(n, "name", { value: e });
  function o(s2) {
    var u2;
    let l = r2 != null && r2.Parent ? new n() : this;
    a2(l, s2), (u2 = l._zod).deferred ?? (u2.deferred = []);
    for (let d2 of l._zod.deferred) d2();
    return l;
  }
  return Object.defineProperty(o, "init", { value: a2 }), Object.defineProperty(o, Symbol.hasInstance, { value: (s2) => {
    var u2, l;
    return r2 != null && r2.Parent && s2 instanceof r2.Parent ? true : (l = (u2 = s2 == null ? void 0 : s2._zod) == null ? void 0 : u2.traits) == null ? void 0 : l.has(e);
  } }), Object.defineProperty(o, "name", { value: e }), o;
}
var So = /* @__PURE__ */ Symbol("zod_brand");
class Ce extends Error {
  constructor() {
    super("Encountered Promise during synchronous parse. Use .parseAsync() instead.");
  }
}
class li extends Error {
  constructor(i) {
    super(`Encountered unidirectional transform during encode: ${i}`), this.name = "ZodEncodeError";
  }
}
var Kt = {};
function H(e) {
  return e && Object.assign(Kt, e), Kt;
}
var T = {};
ye(T, { unwrapMessage: () => dt, uint8ArrayToHex: () => Yf, uint8ArrayToBase64url: () => Wf, uint8ArrayToBase64: () => Do, stringifyPrimitive: () => k, slugify: () => Eo, shallowClone: () => To, safeExtend: () => Lf, required: () => Jf, randomString: () => Rf, propertyKeyTypes: () => Qt, promiseAllObject: () => Nf, primitiveTypes: () => Uo, prefixIssues: () => pe, pick: () => Af, partial: () => Ff, parsedType: () => w, optionalKeys: () => Oo, omit: () => Zf, objectClone: () => Tf, numKeys: () => Pf, nullish: () => Je, normalizeParams: () => _, mergeDefs: () => $e, merge: () => Mf, jsonStringifyReplacer: () => Xt, joinValues: () => h, issue: () => ei, isPlainObject: () => Le, isObject: () => Qe, hexToUint8Array: () => qf, getSizableOrigin: () => ci, getParsedType: () => Df, getLengthableOrigin: () => mi, getEnumValues: () => $r, getElementAtPath: () => Of, floatSafeRemainder: () => xo, finalizeIssue: () => de, extend: () => Cf, escapeRegex: () => be, esc: () => mr, defineLazy: () => z, createTransparentProxy: () => jf, cloneDef: () => Uf, clone: () => me, cleanRegex: () => di, cleanEnum: () => Vf, captureStackTrace: () => Ir, cached: () => yt, base64urlToUint8Array: () => Gf, base64ToUint8Array: () => Po, assignProp: () => Te, assertNotEqual: () => Sf, assertNever: () => Ef, assertIs: () => xf, assertEqual: () => wf, assert: () => zf, allowsEval: () => zo, aborted: () => je, NUMBER_FORMAT_RANGES: () => No, Class: () => Bf, BIGINT_FORMAT_RANGES: () => Ro });
function wf(e) {
  return e;
}
function Sf(e) {
  return e;
}
function xf(e) {
}
function Ef(e) {
  throw Error("Unexpected value in exhaustive check");
}
function zf(e) {
}
function $r(e) {
  let i = Object.values(e).filter((r2) => typeof r2 == "number");
  return Object.entries(e).filter(([r2, a2]) => i.indexOf(+r2) === -1).map(([r2, a2]) => a2);
}
function h(e, i = "|") {
  return e.map((r2) => k(r2)).join(i);
}
function Xt(e, i) {
  return typeof i == "bigint" ? i.toString() : i;
}
function yt(e) {
  return { get value() {
    {
      let i = e();
      return Object.defineProperty(this, "value", { value: i }), i;
    }
  } };
}
function Je(e) {
  return e == null;
}
function di(e) {
  let i = e.startsWith("^") ? 1 : 0, r2 = e.endsWith("$") ? e.length - 1 : e.length;
  return e.slice(i, r2);
}
function xo(e, i) {
  let r2 = (e.toString().split(".")[1] || "").length, a2 = i.toString(), t = (a2.split(".")[1] || "").length;
  if (t === 0 && /\d?e-\d?/.test(a2)) {
    let u2 = a2.match(/\d?e-(\d?)/);
    u2 != null && u2[1] && (t = Number.parseInt(u2[1]));
  }
  let n = r2 > t ? r2 : t, o = Number.parseInt(e.toFixed(n).replace(".", "")), s2 = Number.parseInt(i.toFixed(n).replace(".", ""));
  return o % s2 / 10 ** n;
}
var ja = /* @__PURE__ */ Symbol("evaluating");
function z(e, i, r2) {
  let a2;
  Object.defineProperty(e, i, { get() {
    if (a2 !== ja)
      return a2 === void 0 && (a2 = ja, a2 = r2()), a2;
  }, set(t) {
    Object.defineProperty(e, i, { value: t });
  }, configurable: true });
}
function Tf(e) {
  return Object.create(Object.getPrototypeOf(e), Object.getOwnPropertyDescriptors(e));
}
function Te(e, i, r2) {
  Object.defineProperty(e, i, { value: r2, writable: true, enumerable: true, configurable: true });
}
function $e(...e) {
  let i = {};
  for (let r2 of e) {
    let a2 = Object.getOwnPropertyDescriptors(r2);
    Object.assign(i, a2);
  }
  return Object.defineProperties({}, i);
}
function Uf(e) {
  return $e(e._zod.def);
}
function Of(e, i) {
  return i ? i.reduce((r2, a2) => r2 == null ? void 0 : r2[a2], e) : e;
}
function Nf(e) {
  let i = Object.keys(e), r2 = i.map((a2) => e[a2]);
  return Promise.all(r2).then((a2) => {
    let t = {};
    for (let n = 0; n < i.length; n++) t[i[n]] = a2[n];
    return t;
  });
}
function Rf(e = 10) {
  let i = "";
  for (let r2 = 0; r2 < e; r2++) i += "abcdefghijklmnopqrstuvwxyz"[Math.floor(Math.random() * 26)];
  return i;
}
function mr(e) {
  return JSON.stringify(e);
}
function Eo(e) {
  return e.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
var Ir = "captureStackTrace" in Error ? Error.captureStackTrace : (...e) => {
};
function Qe(e) {
  return typeof e == "object" && e !== null && !Array.isArray(e);
}
var zo = yt(() => {
  var e;
  if (typeof navigator < "u" && ((e = navigator == null ? void 0 : navigator.userAgent) != null && e.includes("Cloudflare"))) return false;
  try {
    return new Function(""), true;
  } catch {
    return false;
  }
});
function Le(e) {
  if (Qe(e) === false) return false;
  let i = e.constructor;
  if (i === void 0 || typeof i != "function") return true;
  let r2 = i.prototype;
  return !(Qe(r2) === false || Object.prototype.hasOwnProperty.call(r2, "isPrototypeOf") === false);
}
function To(e) {
  return Le(e) ? { ...e } : Array.isArray(e) ? [...e] : e;
}
function Pf(e) {
  let i = 0;
  for (let r2 in e) Object.prototype.hasOwnProperty.call(e, r2) && i++;
  return i;
}
var Df = (e) => {
  let i = typeof e;
  switch (i) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(e) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      return Array.isArray(e) ? "array" : e === null ? "null" : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? "promise" : typeof Map < "u" && e instanceof Map ? "map" : typeof Set < "u" && e instanceof Set ? "set" : typeof Date < "u" && e instanceof Date ? "date" : typeof File < "u" && e instanceof File ? "file" : "object";
    default:
      throw Error(`Unknown data type: ${i}`);
  }
}, Qt = /* @__PURE__ */ new Set(["string", "number", "symbol"]), Uo = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function be(e) {
  return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function me(e, i, r2) {
  let a2 = new e._zod.constr(i ?? e._zod.def);
  return (!i || r2 != null && r2.parent) && (a2._zod.parent = e), a2;
}
function _(e) {
  let i = e;
  if (!i) return {};
  if (typeof i == "string") return { error: () => i };
  if ((i == null ? void 0 : i.message) !== void 0) {
    if ((i == null ? void 0 : i.error) !== void 0) throw Error("Cannot specify both `message` and `error` params");
    i.error = i.message;
  }
  return delete i.message, typeof i.error == "string" ? { ...i, error: () => i.error } : i;
}
function jf(e) {
  let i;
  return new Proxy({}, { get(r2, a2, t) {
    return i ?? (i = e()), Reflect.get(i, a2, t);
  }, set(r2, a2, t, n) {
    return i ?? (i = e()), Reflect.set(i, a2, t, n);
  }, has(r2, a2) {
    return i ?? (i = e()), Reflect.has(i, a2);
  }, deleteProperty(r2, a2) {
    return i ?? (i = e()), Reflect.deleteProperty(i, a2);
  }, ownKeys(r2) {
    return i ?? (i = e()), Reflect.ownKeys(i);
  }, getOwnPropertyDescriptor(r2, a2) {
    return i ?? (i = e()), Reflect.getOwnPropertyDescriptor(i, a2);
  }, defineProperty(r2, a2, t) {
    return i ?? (i = e()), Reflect.defineProperty(i, a2, t);
  } });
}
function k(e) {
  return typeof e == "bigint" ? e.toString() + "n" : typeof e == "string" ? `"${e}"` : `${e}`;
}
function Oo(e) {
  return Object.keys(e).filter((i) => e[i]._zod.optin === "optional" && e[i]._zod.optout === "optional");
}
var No = { safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER], int32: [-2147483648, 2147483647], uint32: [0, 4294967295], float32: [-34028234663852886e22, 34028234663852886e22], float64: [-Number.MAX_VALUE, Number.MAX_VALUE] }, Ro = { int64: [BigInt("-9223372036854775808"), BigInt("9223372036854775807")], uint64: [BigInt(0), BigInt("18446744073709551615")] };
function Af(e, i) {
  let r2 = e._zod.def, a2 = r2.checks;
  if (a2 && a2.length > 0) throw Error(".pick() cannot be used on object schemas containing refinements");
  let t = $e(e._zod.def, { get shape() {
    let n = {};
    for (let o in i) {
      if (!(o in r2.shape)) throw Error(`Unrecognized key: "${o}"`);
      i[o] && (n[o] = r2.shape[o]);
    }
    return Te(this, "shape", n), n;
  }, checks: [] });
  return me(e, t);
}
function Zf(e, i) {
  let r2 = e._zod.def, a2 = r2.checks;
  if (a2 && a2.length > 0) throw Error(".omit() cannot be used on object schemas containing refinements");
  let t = $e(e._zod.def, { get shape() {
    let n = { ...e._zod.def.shape };
    for (let o in i) {
      if (!(o in r2.shape)) throw Error(`Unrecognized key: "${o}"`);
      i[o] && delete n[o];
    }
    return Te(this, "shape", n), n;
  }, checks: [] });
  return me(e, t);
}
function Cf(e, i) {
  if (!Le(i)) throw Error("Invalid input to extend: expected a plain object");
  let r2 = e._zod.def.checks;
  if (r2 && r2.length > 0) {
    let t = e._zod.def.shape;
    for (let n in i) if (Object.getOwnPropertyDescriptor(t, n) !== void 0) throw Error("Cannot overwrite keys on object schemas containing refinements. Use `.safeExtend()` instead.");
  }
  let a2 = $e(e._zod.def, { get shape() {
    let t = { ...e._zod.def.shape, ...i };
    return Te(this, "shape", t), t;
  } });
  return me(e, a2);
}
function Lf(e, i) {
  if (!Le(i)) throw Error("Invalid input to safeExtend: expected a plain object");
  let r2 = $e(e._zod.def, { get shape() {
    let a2 = { ...e._zod.def.shape, ...i };
    return Te(this, "shape", a2), a2;
  } });
  return me(e, r2);
}
function Mf(e, i) {
  let r2 = $e(e._zod.def, { get shape() {
    let a2 = { ...e._zod.def.shape, ...i._zod.def.shape };
    return Te(this, "shape", a2), a2;
  }, get catchall() {
    return i._zod.def.catchall;
  }, checks: [] });
  return me(e, r2);
}
function Ff(e, i, r2) {
  let a2 = i._zod.def.checks;
  if (a2 && a2.length > 0) throw Error(".partial() cannot be used on object schemas containing refinements");
  let t = $e(i._zod.def, { get shape() {
    let n = i._zod.def.shape, o = { ...n };
    if (r2) for (let s2 in r2) {
      if (!(s2 in n)) throw Error(`Unrecognized key: "${s2}"`);
      r2[s2] && (o[s2] = e ? new e({ type: "optional", innerType: n[s2] }) : n[s2]);
    }
    else for (let s2 in n) o[s2] = e ? new e({ type: "optional", innerType: n[s2] }) : n[s2];
    return Te(this, "shape", o), o;
  }, checks: [] });
  return me(i, t);
}
function Jf(e, i, r2) {
  let a2 = $e(i._zod.def, { get shape() {
    let t = i._zod.def.shape, n = { ...t };
    if (r2) for (let o in r2) {
      if (!(o in n)) throw Error(`Unrecognized key: "${o}"`);
      r2[o] && (n[o] = new e({ type: "nonoptional", innerType: t[o] }));
    }
    else for (let o in t) n[o] = new e({ type: "nonoptional", innerType: t[o] });
    return Te(this, "shape", n), n;
  } });
  return me(i, a2);
}
function je(e, i = 0) {
  var r2;
  if (e.aborted === true) return true;
  for (let a2 = i; a2 < e.issues.length; a2++) if (((r2 = e.issues[a2]) == null ? void 0 : r2.continue) !== true) return true;
  return false;
}
function pe(e, i) {
  return i.map((r2) => {
    var a2;
    return (a2 = r2).path ?? (a2.path = []), r2.path.unshift(e), r2;
  });
}
function dt(e) {
  return typeof e == "string" ? e : e == null ? void 0 : e.message;
}
function de(e, i, r2) {
  var t, n, o, s2, u2, l;
  let a2 = { ...e, path: e.path ?? [] };
  if (!e.message) {
    let d2 = dt((o = (n = (t = e.inst) == null ? void 0 : t._zod.def) == null ? void 0 : n.error) == null ? void 0 : o.call(n, e)) ?? dt((s2 = i == null ? void 0 : i.error) == null ? void 0 : s2.call(i, e)) ?? dt((u2 = r2.customError) == null ? void 0 : u2.call(r2, e)) ?? dt((l = r2.localeError) == null ? void 0 : l.call(r2, e)) ?? "Invalid input";
    a2.message = d2;
  }
  return delete a2.inst, delete a2.continue, !(i != null && i.reportInput) && delete a2.input, a2;
}
function ci(e) {
  return e instanceof Set ? "set" : e instanceof Map ? "map" : e instanceof File ? "file" : "unknown";
}
function mi(e) {
  return Array.isArray(e) ? "array" : typeof e == "string" ? "string" : "unknown";
}
function w(e) {
  let i = typeof e;
  switch (i) {
    case "number":
      return Number.isNaN(e) ? "nan" : "number";
    case "object": {
      if (e === null) return "null";
      if (Array.isArray(e)) return "array";
      let r2 = e;
      if (r2 && Object.getPrototypeOf(r2) !== Object.prototype && "constructor" in r2 && r2.constructor) return r2.constructor.name;
    }
  }
  return i;
}
function ei(...e) {
  let [i, r2, a2] = e;
  return typeof i == "string" ? { message: i, code: "custom", input: r2, inst: a2 } : { ...i };
}
function Vf(e) {
  return Object.entries(e).filter(([i, r2]) => Number.isNaN(Number.parseInt(i, 10))).map((i) => i[1]);
}
function Po(e) {
  let i = atob(e), r2 = new Uint8Array(i.length);
  for (let a2 = 0; a2 < i.length; a2++) r2[a2] = i.charCodeAt(a2);
  return r2;
}
function Do(e) {
  let i = "";
  for (let r2 = 0; r2 < e.length; r2++) i += String.fromCharCode(e[r2]);
  return btoa(i);
}
function Gf(e) {
  let i = e.replace(/-/g, "+").replace(/_/g, "/"), r2 = "=".repeat((4 - i.length % 4) % 4);
  return Po(i + r2);
}
function Wf(e) {
  return Do(e).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function qf(e) {
  let i = e.replace(/^0x/, "");
  if (i.length % 2 !== 0) throw Error("Invalid hex string length");
  let r2 = new Uint8Array(i.length / 2);
  for (let a2 = 0; a2 < i.length; a2 += 2) r2[a2 / 2] = Number.parseInt(i.slice(a2, a2 + 2), 16);
  return r2;
}
function Yf(e) {
  return Array.from(e).map((i) => i.toString(16).padStart(2, "0")).join("");
}
class Bf {
  constructor(...i) {
  }
}
var jo = (e, i) => {
  e.name = "$ZodError", Object.defineProperty(e, "_zod", { value: e._zod, enumerable: false }), Object.defineProperty(e, "issues", { value: i, enumerable: false }), e.message = JSON.stringify(i, Xt, 2), Object.defineProperty(e, "toString", { value: () => e.message, enumerable: false });
}, kr = p("$ZodError", jo), ie = p("$ZodError", jo, { Parent: Error });
function wr(e, i = (r2) => r2.message) {
  let r2 = {}, a2 = [];
  for (let t of e.issues) t.path.length > 0 ? (r2[t.path[0]] = r2[t.path[0]] || [], r2[t.path[0]].push(i(t))) : a2.push(i(t));
  return { formErrors: a2, fieldErrors: r2 };
}
function Sr(e, i = (r2) => r2.message) {
  let r2 = { _errors: [] }, a2 = (t) => {
    for (let n of t.issues) if (n.code === "invalid_union" && n.errors.length) n.errors.map((o) => a2({ issues: o }));
    else if (n.code === "invalid_key") a2({ issues: n.issues });
    else if (n.code === "invalid_element") a2({ issues: n.issues });
    else if (n.path.length === 0) r2._errors.push(i(n));
    else {
      let o = r2, s2 = 0;
      for (; s2 < n.path.length; ) {
        let u2 = n.path[s2];
        s2 !== n.path.length - 1 ? o[u2] = o[u2] || { _errors: [] } : (o[u2] = o[u2] || { _errors: [] }, o[u2]._errors.push(i(n))), o = o[u2], s2++;
      }
    }
  };
  return a2(e), r2;
}
function Ao(e, i = (r2) => r2.message) {
  let r2 = { errors: [] }, a2 = (t, n = []) => {
    var o, s2;
    for (let u2 of t.issues) if (u2.code === "invalid_union" && u2.errors.length) u2.errors.map((l) => a2({ issues: l }, u2.path));
    else if (u2.code === "invalid_key") a2({ issues: u2.issues }, u2.path);
    else if (u2.code === "invalid_element") a2({ issues: u2.issues }, u2.path);
    else {
      let l = [...n, ...u2.path];
      if (l.length === 0) {
        r2.errors.push(i(u2));
        continue;
      }
      let d2 = r2, c = 0;
      for (; c < l.length; ) {
        let f2 = l[c], v = c === l.length - 1;
        typeof f2 == "string" ? (d2.properties ?? (d2.properties = {}), (o = d2.properties)[f2] ?? (o[f2] = { errors: [] }), d2 = d2.properties[f2]) : (d2.items ?? (d2.items = []), (s2 = d2.items)[f2] ?? (s2[f2] = { errors: [] }), d2 = d2.items[f2]), v && d2.errors.push(i(u2)), c++;
      }
    }
  };
  return a2(e), r2;
}
function Zo(e) {
  let i = [], r2 = e.map((a2) => typeof a2 == "object" ? a2.key : a2);
  for (let a2 of r2) typeof a2 == "number" ? i.push(`[${a2}]`) : typeof a2 == "symbol" ? i.push(`[${JSON.stringify(String(a2))}]`) : /[^\w$]/.test(a2) ? i.push(`[${JSON.stringify(a2)}]`) : (i.length && i.push("."), i.push(a2));
  return i.join("");
}
function Co(e) {
  var a2;
  let i = [], r2 = [...e.issues].sort((t, n) => (t.path ?? []).length - (n.path ?? []).length);
  for (let t of r2) i.push(` ${t.message}`), (a2 = t.path) != null && a2.length && i.push(`   at ${Zo(t.path)}`);
  return i.join(`
`);
}
var $t = (e) => (i, r2, a2, t) => {
  let n = a2 ? Object.assign(a2, { async: false }) : { async: false }, o = i._zod.run({ value: r2, issues: [] }, n);
  if (o instanceof Promise) throw new Ce();
  if (o.issues.length) {
    let s2 = new ((t == null ? void 0 : t.Err) ?? e)(o.issues.map((u2) => de(u2, n, H())));
    throw Ir(s2, t == null ? void 0 : t.callee), s2;
  }
  return o.value;
}, fr = $t(ie), It = (e) => async (i, r2, a2, t) => {
  let n = a2 ? Object.assign(a2, { async: true }) : { async: true }, o = i._zod.run({ value: r2, issues: [] }, n);
  if (o instanceof Promise && (o = await o), o.issues.length) {
    let s2 = new ((t == null ? void 0 : t.Err) ?? e)(o.issues.map((u2) => de(u2, n, H())));
    throw Ir(s2, t == null ? void 0 : t.callee), s2;
  }
  return o.value;
}, pr = It(ie), kt = (e) => (i, r2, a2) => {
  let t = a2 ? { ...a2, async: false } : { async: false }, n = i._zod.run({ value: r2, issues: [] }, t);
  if (n instanceof Promise) throw new Ce();
  return n.issues.length ? { success: false, error: new (e ?? kr)(n.issues.map((o) => de(o, t, H()))) } : { success: true, data: n.value };
}, Lo = kt(ie), wt = (e) => async (i, r2, a2) => {
  let t = a2 ? Object.assign(a2, { async: true }) : { async: true }, n = i._zod.run({ value: r2, issues: [] }, t);
  return n instanceof Promise && (n = await n), n.issues.length ? { success: false, error: new e(n.issues.map((o) => de(o, t, H()))) } : { success: true, data: n.value };
}, Mo = wt(ie), xr = (e) => (i, r2, a2) => {
  let t = a2 ? Object.assign(a2, { direction: "backward" }) : { direction: "backward" };
  return $t(e)(i, r2, t);
}, Hf = xr(ie), Er = (e) => (i, r2, a2) => $t(e)(i, r2, a2), Kf = Er(ie), zr = (e) => async (i, r2, a2) => {
  let t = a2 ? Object.assign(a2, { direction: "backward" }) : { direction: "backward" };
  return It(e)(i, r2, t);
}, Xf = zr(ie), Tr = (e) => async (i, r2, a2) => It(e)(i, r2, a2), Qf = Tr(ie), Ur = (e) => (i, r2, a2) => {
  let t = a2 ? Object.assign(a2, { direction: "backward" }) : { direction: "backward" };
  return kt(e)(i, r2, t);
}, ep = Ur(ie), Or = (e) => (i, r2, a2) => kt(e)(i, r2, a2), tp = Or(ie), Nr = (e) => async (i, r2, a2) => {
  let t = a2 ? Object.assign(a2, { direction: "backward" }) : { direction: "backward" };
  return wt(e)(i, r2, t);
}, ip = Nr(ie), Rr = (e) => async (i, r2, a2) => wt(e)(i, r2, a2), rp = Rr(ie), Ve = {};
ye(Ve, { xid: () => Go, uuid7: () => sp, uuid6: () => op, uuid4: () => ap, uuid: () => et, uppercase: () => _s, unicodeEmail: () => Ko, undefined: () => gs, ulid: () => Vo, time: () => ls, string: () => cs, sha512_hex: () => zp, sha512_base64url: () => Up, sha512_base64: () => Tp, sha384_hex: () => Sp, sha384_base64url: () => Ep, sha384_base64: () => xp, sha256_hex: () => Ip, sha256_base64url: () => wp, sha256_base64: () => kp, sha1_hex: () => bp, sha1_base64url: () => $p, sha1_base64: () => yp, rfc5322Email: () => lp, number: () => Dr, null: () => vs, nanoid: () => qo, md5_hex: () => gp, md5_base64url: () => _p, md5_base64: () => hp, mac: () => ts, lowercase: () => hs, ksuid: () => Wo, ipv6: () => es, ipv4: () => Qo, integer: () => fs, idnEmail: () => dp, html5Email: () => up, hostname: () => fp, hex: () => vp, guid: () => Bo, extendedDuration: () => np, emoji: () => Xo, email: () => Ho, e164: () => as, duration: () => Yo, domain: () => pp, datetime: () => ds, date: () => ss, cuid2: () => Jo, cuid: () => Fo, cidrv6: () => rs, cidrv4: () => is, browserEmail: () => cp, boolean: () => ps, bigint: () => ms, base64url: () => Pr, base64: () => ns });
var Fo = /^[cC][^\s-]{8,}$/, Jo = /^[0-9a-z]+$/, Vo = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/, Go = /^[0-9a-vA-V]{20}$/, Wo = /^[A-Za-z0-9]{27}$/, qo = /^[a-zA-Z0-9_-]{21}$/, Yo = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/, np = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, Bo = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/, et = (e) => e ? new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${e}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`) : /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/, ap = et(4), op = et(6), sp = et(7), Ho = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/, up = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/, lp = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/, Ko = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u, dp = Ko, cp = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/, mp = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
function Xo() {
  return new RegExp(mp, "u");
}
var Qo = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, es = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/, ts = (e) => {
  let i = be(e ?? ":");
  return new RegExp(`^(?:[0-9A-F]{2}${i}){5}[0-9A-F]{2}$|^(?:[0-9a-f]{2}${i}){5}[0-9a-f]{2}$`);
}, is = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/, rs = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, ns = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/, Pr = /^[A-Za-z0-9_-]*$/, fp = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/, pp = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/, as = /^\+[1-9]\d{6,14}$/, os = "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))", ss = new RegExp(`^${os}$`);
function us(e) {
  return typeof e.precision == "number" ? e.precision === -1 ? "(?:[01]\\d|2[0-3]):[0-5]\\d" : e.precision === 0 ? "(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d" : `(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d\\.\\d{${e.precision}}` : "(?:[01]\\d|2[0-3]):[0-5]\\d(?::[0-5]\\d(?:\\.\\d+)?)?";
}
function ls(e) {
  return new RegExp(`^${us(e)}$`);
}
function ds(e) {
  let i = us({ precision: e.precision }), r2 = ["Z"];
  e.local && r2.push(""), e.offset && r2.push("([+-](?:[01]\\d|2[0-3]):[0-5]\\d)");
  let a2 = `${i}(?:${r2.join("|")})`;
  return new RegExp(`^${os}T(?:${a2})$`);
}
var cs = (e) => {
  let i = e ? `[\\s\\S]{${(e == null ? void 0 : e.minimum) ?? 0},${(e == null ? void 0 : e.maximum) ?? ""}}` : "[\\s\\S]*";
  return new RegExp(`^${i}$`);
}, ms = /^-?\d+n?$/, fs = /^-?\d+$/, Dr = /^-?\d+(?:\.\d+)?$/, ps = /^(?:true|false)$/i, vs = /^null$/i, gs = /^undefined$/i, hs = /^[^A-Z]*$/, _s = /^[^a-z]*$/, vp = /^[0-9a-fA-F]*$/;
function St(e, i) {
  return new RegExp(`^[A-Za-z0-9+/]{${e}}${i}$`);
}
function xt(e) {
  return new RegExp(`^[A-Za-z0-9_-]{${e}}$`);
}
var gp = /^[0-9a-fA-F]{32}$/, hp = St(22, "=="), _p = xt(22), bp = /^[0-9a-fA-F]{40}$/, yp = St(27, "="), $p = xt(27), Ip = /^[0-9a-fA-F]{64}$/, kp = St(43, "="), wp = xt(43), Sp = /^[0-9a-fA-F]{96}$/, xp = St(64, ""), Ep = xt(64), zp = /^[0-9a-fA-F]{128}$/, Tp = St(86, "=="), Up = xt(86), M = p("$ZodCheck", (e, i) => {
  var r2;
  e._zod ?? (e._zod = {}), e._zod.def = i, (r2 = e._zod).onattach ?? (r2.onattach = []);
}), bs = { number: "number", bigint: "bigint", object: "date" }, jr = p("$ZodCheckLessThan", (e, i) => {
  M.init(e, i);
  let r2 = bs[typeof i.value];
  e._zod.onattach.push((a2) => {
    let t = a2._zod.bag, n = (i.inclusive ? t.maximum : t.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    i.value < n && (i.inclusive ? t.maximum = i.value : t.exclusiveMaximum = i.value);
  }), e._zod.check = (a2) => {
    (i.inclusive ? a2.value <= i.value : a2.value < i.value) || a2.issues.push({ origin: r2, code: "too_big", maximum: typeof i.value == "object" ? i.value.getTime() : i.value, input: a2.value, inclusive: i.inclusive, inst: e, continue: !i.abort });
  };
}), Ar = p("$ZodCheckGreaterThan", (e, i) => {
  M.init(e, i);
  let r2 = bs[typeof i.value];
  e._zod.onattach.push((a2) => {
    let t = a2._zod.bag, n = (i.inclusive ? t.minimum : t.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    i.value > n && (i.inclusive ? t.minimum = i.value : t.exclusiveMinimum = i.value);
  }), e._zod.check = (a2) => {
    (i.inclusive ? a2.value >= i.value : a2.value > i.value) || a2.issues.push({ origin: r2, code: "too_small", minimum: typeof i.value == "object" ? i.value.getTime() : i.value, input: a2.value, inclusive: i.inclusive, inst: e, continue: !i.abort });
  };
}), ys = p("$ZodCheckMultipleOf", (e, i) => {
  M.init(e, i), e._zod.onattach.push((r2) => {
    var a2;
    (a2 = r2._zod.bag).multipleOf ?? (a2.multipleOf = i.value);
  }), e._zod.check = (r2) => {
    if (typeof r2.value != typeof i.value) throw Error("Cannot mix number and bigint in multiple_of check.");
    (typeof r2.value == "bigint" ? r2.value % i.value === BigInt(0) : xo(r2.value, i.value) === 0) || r2.issues.push({ origin: typeof r2.value, code: "not_multiple_of", divisor: i.value, input: r2.value, inst: e, continue: !i.abort });
  };
}), $s = p("$ZodCheckNumberFormat", (e, i) => {
  var o;
  M.init(e, i), i.format = i.format || "float64";
  let r2 = (o = i.format) == null ? void 0 : o.includes("int"), a2 = r2 ? "int" : "number", [t, n] = No[i.format];
  e._zod.onattach.push((s2) => {
    let u2 = s2._zod.bag;
    u2.format = i.format, u2.minimum = t, u2.maximum = n, r2 && (u2.pattern = fs);
  }), e._zod.check = (s2) => {
    let u2 = s2.value;
    if (r2) {
      if (!Number.isInteger(u2)) {
        s2.issues.push({ expected: a2, format: i.format, code: "invalid_type", continue: false, input: u2, inst: e });
        return;
      }
      if (!Number.isSafeInteger(u2)) {
        u2 > 0 ? s2.issues.push({ input: u2, code: "too_big", maximum: Number.MAX_SAFE_INTEGER, note: "Integers must be within the safe integer range.", inst: e, origin: a2, inclusive: true, continue: !i.abort }) : s2.issues.push({ input: u2, code: "too_small", minimum: Number.MIN_SAFE_INTEGER, note: "Integers must be within the safe integer range.", inst: e, origin: a2, inclusive: true, continue: !i.abort });
        return;
      }
    }
    u2 < t && s2.issues.push({ origin: "number", input: u2, code: "too_small", minimum: t, inclusive: true, inst: e, continue: !i.abort }), u2 > n && s2.issues.push({ origin: "number", input: u2, code: "too_big", maximum: n, inclusive: true, inst: e, continue: !i.abort });
  };
}), Is = p("$ZodCheckBigIntFormat", (e, i) => {
  M.init(e, i);
  let [r2, a2] = Ro[i.format];
  e._zod.onattach.push((t) => {
    let n = t._zod.bag;
    n.format = i.format, n.minimum = r2, n.maximum = a2;
  }), e._zod.check = (t) => {
    let n = t.value;
    n < r2 && t.issues.push({ origin: "bigint", input: n, code: "too_small", minimum: r2, inclusive: true, inst: e, continue: !i.abort }), n > a2 && t.issues.push({ origin: "bigint", input: n, code: "too_big", maximum: a2, inclusive: true, inst: e, continue: !i.abort });
  };
}), ks = p("$ZodCheckMaxSize", (e, i) => {
  var r2;
  M.init(e, i), (r2 = e._zod.def).when ?? (r2.when = (a2) => {
    let t = a2.value;
    return !Je(t) && t.size !== void 0;
  }), e._zod.onattach.push((a2) => {
    let t = a2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    i.maximum < t && (a2._zod.bag.maximum = i.maximum);
  }), e._zod.check = (a2) => {
    let t = a2.value;
    t.size <= i.maximum || a2.issues.push({ origin: ci(t), code: "too_big", maximum: i.maximum, inclusive: true, input: t, inst: e, continue: !i.abort });
  };
}), ws = p("$ZodCheckMinSize", (e, i) => {
  var r2;
  M.init(e, i), (r2 = e._zod.def).when ?? (r2.when = (a2) => {
    let t = a2.value;
    return !Je(t) && t.size !== void 0;
  }), e._zod.onattach.push((a2) => {
    let t = a2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    i.minimum > t && (a2._zod.bag.minimum = i.minimum);
  }), e._zod.check = (a2) => {
    let t = a2.value;
    t.size >= i.minimum || a2.issues.push({ origin: ci(t), code: "too_small", minimum: i.minimum, inclusive: true, input: t, inst: e, continue: !i.abort });
  };
}), Ss = p("$ZodCheckSizeEquals", (e, i) => {
  var r2;
  M.init(e, i), (r2 = e._zod.def).when ?? (r2.when = (a2) => {
    let t = a2.value;
    return !Je(t) && t.size !== void 0;
  }), e._zod.onattach.push((a2) => {
    let t = a2._zod.bag;
    t.minimum = i.size, t.maximum = i.size, t.size = i.size;
  }), e._zod.check = (a2) => {
    let t = a2.value, n = t.size;
    if (n === i.size) return;
    let o = n > i.size;
    a2.issues.push({ origin: ci(t), ...o ? { code: "too_big", maximum: i.size } : { code: "too_small", minimum: i.size }, inclusive: true, exact: true, input: a2.value, inst: e, continue: !i.abort });
  };
}), xs = p("$ZodCheckMaxLength", (e, i) => {
  var r2;
  M.init(e, i), (r2 = e._zod.def).when ?? (r2.when = (a2) => {
    let t = a2.value;
    return !Je(t) && t.length !== void 0;
  }), e._zod.onattach.push((a2) => {
    let t = a2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    i.maximum < t && (a2._zod.bag.maximum = i.maximum);
  }), e._zod.check = (a2) => {
    let t = a2.value;
    if (t.length <= i.maximum) return;
    let n = mi(t);
    a2.issues.push({ origin: n, code: "too_big", maximum: i.maximum, inclusive: true, input: t, inst: e, continue: !i.abort });
  };
}), Es = p("$ZodCheckMinLength", (e, i) => {
  var r2;
  M.init(e, i), (r2 = e._zod.def).when ?? (r2.when = (a2) => {
    let t = a2.value;
    return !Je(t) && t.length !== void 0;
  }), e._zod.onattach.push((a2) => {
    let t = a2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    i.minimum > t && (a2._zod.bag.minimum = i.minimum);
  }), e._zod.check = (a2) => {
    let t = a2.value;
    if (t.length >= i.minimum) return;
    let n = mi(t);
    a2.issues.push({ origin: n, code: "too_small", minimum: i.minimum, inclusive: true, input: t, inst: e, continue: !i.abort });
  };
}), zs = p("$ZodCheckLengthEquals", (e, i) => {
  var r2;
  M.init(e, i), (r2 = e._zod.def).when ?? (r2.when = (a2) => {
    let t = a2.value;
    return !Je(t) && t.length !== void 0;
  }), e._zod.onattach.push((a2) => {
    let t = a2._zod.bag;
    t.minimum = i.length, t.maximum = i.length, t.length = i.length;
  }), e._zod.check = (a2) => {
    let t = a2.value, n = t.length;
    if (n === i.length) return;
    let o = mi(t), s2 = n > i.length;
    a2.issues.push({ origin: o, ...s2 ? { code: "too_big", maximum: i.length } : { code: "too_small", minimum: i.length }, inclusive: true, exact: true, input: a2.value, inst: e, continue: !i.abort });
  };
}), Et = p("$ZodCheckStringFormat", (e, i) => {
  var r2, a2;
  M.init(e, i), e._zod.onattach.push((t) => {
    let n = t._zod.bag;
    n.format = i.format, i.pattern && (n.patterns ?? (n.patterns = /* @__PURE__ */ new Set()), n.patterns.add(i.pattern));
  }), i.pattern ? (r2 = e._zod).check ?? (r2.check = (t) => {
    i.pattern.lastIndex = 0, !i.pattern.test(t.value) && t.issues.push({ origin: "string", code: "invalid_format", format: i.format, input: t.value, ...i.pattern ? { pattern: i.pattern.toString() } : {}, inst: e, continue: !i.abort });
  }) : (a2 = e._zod).check ?? (a2.check = () => {
  });
}), Ts = p("$ZodCheckRegex", (e, i) => {
  Et.init(e, i), e._zod.check = (r2) => {
    i.pattern.lastIndex = 0, !i.pattern.test(r2.value) && r2.issues.push({ origin: "string", code: "invalid_format", format: "regex", input: r2.value, pattern: i.pattern.toString(), inst: e, continue: !i.abort });
  };
}), Us = p("$ZodCheckLowerCase", (e, i) => {
  i.pattern ?? (i.pattern = hs), Et.init(e, i);
}), Os = p("$ZodCheckUpperCase", (e, i) => {
  i.pattern ?? (i.pattern = _s), Et.init(e, i);
}), Ns = p("$ZodCheckIncludes", (e, i) => {
  M.init(e, i);
  let r2 = be(i.includes), a2 = new RegExp(typeof i.position == "number" ? `^.{${i.position}}${r2}` : r2);
  i.pattern = a2, e._zod.onattach.push((t) => {
    let n = t._zod.bag;
    n.patterns ?? (n.patterns = /* @__PURE__ */ new Set()), n.patterns.add(a2);
  }), e._zod.check = (t) => {
    t.value.includes(i.includes, i.position) || t.issues.push({ origin: "string", code: "invalid_format", format: "includes", includes: i.includes, input: t.value, inst: e, continue: !i.abort });
  };
}), Rs = p("$ZodCheckStartsWith", (e, i) => {
  M.init(e, i);
  let r2 = new RegExp(`^${be(i.prefix)}.*`);
  i.pattern ?? (i.pattern = r2), e._zod.onattach.push((a2) => {
    let t = a2._zod.bag;
    t.patterns ?? (t.patterns = /* @__PURE__ */ new Set()), t.patterns.add(r2);
  }), e._zod.check = (a2) => {
    a2.value.startsWith(i.prefix) || a2.issues.push({ origin: "string", code: "invalid_format", format: "starts_with", prefix: i.prefix, input: a2.value, inst: e, continue: !i.abort });
  };
}), Ps = p("$ZodCheckEndsWith", (e, i) => {
  M.init(e, i);
  let r2 = new RegExp(`.*${be(i.suffix)}$`);
  i.pattern ?? (i.pattern = r2), e._zod.onattach.push((a2) => {
    let t = a2._zod.bag;
    t.patterns ?? (t.patterns = /* @__PURE__ */ new Set()), t.patterns.add(r2);
  }), e._zod.check = (a2) => {
    a2.value.endsWith(i.suffix) || a2.issues.push({ origin: "string", code: "invalid_format", format: "ends_with", suffix: i.suffix, input: a2.value, inst: e, continue: !i.abort });
  };
});
function Aa(e, i, r2) {
  e.issues.length && i.issues.push(...pe(r2, e.issues));
}
var Ds = p("$ZodCheckProperty", (e, i) => {
  M.init(e, i), e._zod.check = (r2) => {
    let a2 = i.schema._zod.run({ value: r2.value[i.property], issues: [] }, {});
    if (a2 instanceof Promise) return a2.then((t) => Aa(t, r2, i.property));
    Aa(a2, r2, i.property);
  };
}), js = p("$ZodCheckMimeType", (e, i) => {
  M.init(e, i);
  let r2 = new Set(i.mime);
  e._zod.onattach.push((a2) => {
    a2._zod.bag.mime = i.mime;
  }), e._zod.check = (a2) => {
    r2.has(a2.value.type) || a2.issues.push({ code: "invalid_value", values: i.mime, input: a2.value.type, inst: e, continue: !i.abort });
  };
}), As = p("$ZodCheckOverwrite", (e, i) => {
  M.init(e, i), e._zod.check = (r2) => {
    r2.value = i.tx(r2.value);
  };
});
class Zs {
  constructor(i = []) {
    this.content = [], this.indent = 0, this && (this.args = i);
  }
  indented(i) {
    this.indent += 1, i(this), this.indent -= 1;
  }
  write(i) {
    if (typeof i == "function") {
      i(this, { execution: "sync" }), i(this, { execution: "async" });
      return;
    }
    let r2 = i.split(`
`).filter((n) => n), a2 = Math.min(...r2.map((n) => n.length - n.trimStart().length)), t = r2.map((n) => n.slice(a2)).map((n) => " ".repeat(this.indent * 2) + n);
    for (let n of t) this.content.push(n);
  }
  compile() {
    let i = Function, r2 = this == null ? void 0 : this.args, a2 = [...((this == null ? void 0 : this.content) ?? [""]).map((t) => `  ${t}`)];
    return new i(...r2, a2.join(`
`));
  }
}
var Cs = { major: 4, minor: 3, patch: 5 }, S = p("$ZodType", (e, i) => {
  var t;
  var r2;
  e ?? (e = {}), e._zod.def = i, e._zod.bag = e._zod.bag || {}, e._zod.version = Cs;
  let a2 = [...e._zod.def.checks ?? []];
  e._zod.traits.has("$ZodCheck") && a2.unshift(e);
  for (let n of a2) for (let o of n._zod.onattach) o(e);
  if (a2.length === 0) (r2 = e._zod).deferred ?? (r2.deferred = []), (t = e._zod.deferred) == null || t.push(() => {
    e._zod.run = e._zod.parse;
  });
  else {
    let n = (s2, u2, l) => {
      let d2 = je(s2), c;
      for (let f2 of u2) {
        if (f2._zod.def.when) {
          if (!f2._zod.def.when(s2)) continue;
        } else if (d2) continue;
        let v = s2.issues.length, g2 = f2._zod.check(s2);
        if (g2 instanceof Promise && (l == null ? void 0 : l.async) === false) throw new Ce();
        if (c || g2 instanceof Promise) c = (c ?? Promise.resolve()).then(async () => {
          await g2, s2.issues.length !== v && (d2 || (d2 = je(s2, v)));
        });
        else {
          if (s2.issues.length === v) continue;
          d2 || (d2 = je(s2, v));
        }
      }
      return c ? c.then(() => s2) : s2;
    }, o = (s2, u2, l) => {
      if (je(s2)) return s2.aborted = true, s2;
      let d2 = n(u2, a2, l);
      if (d2 instanceof Promise) {
        if (l.async === false) throw new Ce();
        return d2.then((c) => e._zod.parse(c, l));
      }
      return e._zod.parse(d2, l);
    };
    e._zod.run = (s2, u2) => {
      if (u2.skipChecks) return e._zod.parse(s2, u2);
      if (u2.direction === "backward") {
        let d2 = e._zod.parse({ value: s2.value, issues: [] }, { ...u2, skipChecks: true });
        return d2 instanceof Promise ? d2.then((c) => o(c, s2, u2)) : o(d2, s2, u2);
      }
      let l = e._zod.parse(s2, u2);
      if (l instanceof Promise) {
        if (u2.async === false) throw new Ce();
        return l.then((d2) => n(d2, a2, u2));
      }
      return n(l, a2, u2);
    };
  }
  z(e, "~standard", () => ({ validate: (n) => {
    var o;
    try {
      let s2 = Lo(e, n);
      return s2.success ? { value: s2.data } : { issues: (o = s2.error) == null ? void 0 : o.issues };
    } catch {
      return Mo(e, n).then((u2) => {
        var l;
        return u2.success ? { value: u2.data } : { issues: (l = u2.error) == null ? void 0 : l.issues };
      });
    }
  }, vendor: "zod", version: 1 }));
}), zt = p("$ZodString", (e, i) => {
  var r2;
  S.init(e, i), e._zod.pattern = [...((r2 = e == null ? void 0 : e._zod.bag) == null ? void 0 : r2.patterns) ?? []].pop() ?? cs(e._zod.bag), e._zod.parse = (a2, t) => {
    if (i.coerce) try {
      a2.value = String(a2.value);
    } catch {
    }
    return typeof a2.value == "string" || a2.issues.push({ expected: "string", code: "invalid_type", input: a2.value, inst: e }), a2;
  };
}), A = p("$ZodStringFormat", (e, i) => {
  Et.init(e, i), zt.init(e, i);
}), Ls = p("$ZodGUID", (e, i) => {
  i.pattern ?? (i.pattern = Bo), A.init(e, i);
}), Ms = p("$ZodUUID", (e, i) => {
  if (i.version) {
    let r2 = { v1: 1, v2: 2, v3: 3, v4: 4, v5: 5, v6: 6, v7: 7, v8: 8 }[i.version];
    if (r2 === void 0) throw Error(`Invalid UUID version: "${i.version}"`);
    i.pattern ?? (i.pattern = et(r2));
  } else i.pattern ?? (i.pattern = et());
  A.init(e, i);
}), Fs = p("$ZodEmail", (e, i) => {
  i.pattern ?? (i.pattern = Ho), A.init(e, i);
}), Js = p("$ZodURL", (e, i) => {
  A.init(e, i), e._zod.check = (r2) => {
    try {
      let a2 = r2.value.trim(), t = new URL(a2);
      i.hostname && (i.hostname.lastIndex = 0, !i.hostname.test(t.hostname) && r2.issues.push({ code: "invalid_format", format: "url", note: "Invalid hostname", pattern: i.hostname.source, input: r2.value, inst: e, continue: !i.abort })), i.protocol && (i.protocol.lastIndex = 0, !i.protocol.test(t.protocol.endsWith(":") ? t.protocol.slice(0, -1) : t.protocol) && r2.issues.push({ code: "invalid_format", format: "url", note: "Invalid protocol", pattern: i.protocol.source, input: r2.value, inst: e, continue: !i.abort })), i.normalize ? r2.value = t.href : r2.value = a2;
      return;
    } catch {
      r2.issues.push({ code: "invalid_format", format: "url", input: r2.value, inst: e, continue: !i.abort });
    }
  };
}), Vs = p("$ZodEmoji", (e, i) => {
  i.pattern ?? (i.pattern = Xo()), A.init(e, i);
}), Gs = p("$ZodNanoID", (e, i) => {
  i.pattern ?? (i.pattern = qo), A.init(e, i);
}), Ws = p("$ZodCUID", (e, i) => {
  i.pattern ?? (i.pattern = Fo), A.init(e, i);
}), qs = p("$ZodCUID2", (e, i) => {
  i.pattern ?? (i.pattern = Jo), A.init(e, i);
}), Ys = p("$ZodULID", (e, i) => {
  i.pattern ?? (i.pattern = Vo), A.init(e, i);
}), Bs = p("$ZodXID", (e, i) => {
  i.pattern ?? (i.pattern = Go), A.init(e, i);
}), Hs = p("$ZodKSUID", (e, i) => {
  i.pattern ?? (i.pattern = Wo), A.init(e, i);
}), Ks = p("$ZodISODateTime", (e, i) => {
  i.pattern ?? (i.pattern = ds(i)), A.init(e, i);
}), Xs = p("$ZodISODate", (e, i) => {
  i.pattern ?? (i.pattern = ss), A.init(e, i);
}), Qs = p("$ZodISOTime", (e, i) => {
  i.pattern ?? (i.pattern = ls(i)), A.init(e, i);
}), eu = p("$ZodISODuration", (e, i) => {
  i.pattern ?? (i.pattern = Yo), A.init(e, i);
}), tu = p("$ZodIPv4", (e, i) => {
  i.pattern ?? (i.pattern = Qo), A.init(e, i), e._zod.bag.format = "ipv4";
}), iu = p("$ZodIPv6", (e, i) => {
  i.pattern ?? (i.pattern = es), A.init(e, i), e._zod.bag.format = "ipv6", e._zod.check = (r2) => {
    try {
      new URL(`http://[${r2.value}]`);
    } catch {
      r2.issues.push({ code: "invalid_format", format: "ipv6", input: r2.value, inst: e, continue: !i.abort });
    }
  };
}), ru = p("$ZodMAC", (e, i) => {
  i.pattern ?? (i.pattern = ts(i.delimiter)), A.init(e, i), e._zod.bag.format = "mac";
}), nu = p("$ZodCIDRv4", (e, i) => {
  i.pattern ?? (i.pattern = is), A.init(e, i);
}), au = p("$ZodCIDRv6", (e, i) => {
  i.pattern ?? (i.pattern = rs), A.init(e, i), e._zod.check = (r2) => {
    let a2 = r2.value.split("/");
    try {
      if (a2.length !== 2) throw Error();
      let [t, n] = a2;
      if (!n) throw Error();
      let o = Number(n);
      if (`${o}` !== n || o < 0 || o > 128) throw Error();
      new URL(`http://[${t}]`);
    } catch {
      r2.issues.push({ code: "invalid_format", format: "cidrv6", input: r2.value, inst: e, continue: !i.abort });
    }
  };
});
function Zr(e) {
  if (e === "") return true;
  if (e.length % 4 !== 0) return false;
  try {
    return atob(e), true;
  } catch {
    return false;
  }
}
var ou = p("$ZodBase64", (e, i) => {
  i.pattern ?? (i.pattern = ns), A.init(e, i), e._zod.bag.contentEncoding = "base64", e._zod.check = (r2) => {
    Zr(r2.value) || r2.issues.push({ code: "invalid_format", format: "base64", input: r2.value, inst: e, continue: !i.abort });
  };
});
function su(e) {
  if (!Pr.test(e)) return false;
  let i = e.replace(/[-_]/g, (a2) => a2 === "-" ? "+" : "/"), r2 = i.padEnd(Math.ceil(i.length / 4) * 4, "=");
  return Zr(r2);
}
var uu = p("$ZodBase64URL", (e, i) => {
  i.pattern ?? (i.pattern = Pr), A.init(e, i), e._zod.bag.contentEncoding = "base64url", e._zod.check = (r2) => {
    su(r2.value) || r2.issues.push({ code: "invalid_format", format: "base64url", input: r2.value, inst: e, continue: !i.abort });
  };
}), lu = p("$ZodE164", (e, i) => {
  i.pattern ?? (i.pattern = as), A.init(e, i);
});
function du(e, i = null) {
  try {
    let r2 = e.split(".");
    if (r2.length !== 3) return false;
    let [a2] = r2;
    if (!a2) return false;
    let t = JSON.parse(atob(a2));
    return !("typ" in t && (t == null ? void 0 : t.typ) !== "JWT" || !t.alg || i && (!("alg" in t) || t.alg !== i));
  } catch {
    return false;
  }
}
var cu = p("$ZodJWT", (e, i) => {
  A.init(e, i), e._zod.check = (r2) => {
    du(r2.value, i.alg) || r2.issues.push({ code: "invalid_format", format: "jwt", input: r2.value, inst: e, continue: !i.abort });
  };
}), mu = p("$ZodCustomStringFormat", (e, i) => {
  A.init(e, i), e._zod.check = (r2) => {
    i.fn(r2.value) || r2.issues.push({ code: "invalid_format", format: i.format, input: r2.value, inst: e, continue: !i.abort });
  };
}), Cr = p("$ZodNumber", (e, i) => {
  S.init(e, i), e._zod.pattern = e._zod.bag.pattern ?? Dr, e._zod.parse = (r2, a2) => {
    if (i.coerce) try {
      r2.value = Number(r2.value);
    } catch {
    }
    let t = r2.value;
    if (typeof t == "number" && !Number.isNaN(t) && Number.isFinite(t)) return r2;
    let n = typeof t == "number" ? Number.isNaN(t) ? "NaN" : Number.isFinite(t) ? void 0 : "Infinity" : void 0;
    return r2.issues.push({ expected: "number", code: "invalid_type", input: t, inst: e, ...n ? { received: n } : {} }), r2;
  };
}), fu = p("$ZodNumberFormat", (e, i) => {
  $s.init(e, i), Cr.init(e, i);
}), Lr = p("$ZodBoolean", (e, i) => {
  S.init(e, i), e._zod.pattern = ps, e._zod.parse = (r2, a2) => {
    if (i.coerce) try {
      r2.value = !!r2.value;
    } catch {
    }
    let t = r2.value;
    return typeof t == "boolean" || r2.issues.push({ expected: "boolean", code: "invalid_type", input: t, inst: e }), r2;
  };
}), Mr = p("$ZodBigInt", (e, i) => {
  S.init(e, i), e._zod.pattern = ms, e._zod.parse = (r2, a2) => {
    if (i.coerce) try {
      r2.value = BigInt(r2.value);
    } catch {
    }
    return typeof r2.value == "bigint" || r2.issues.push({ expected: "bigint", code: "invalid_type", input: r2.value, inst: e }), r2;
  };
}), pu = p("$ZodBigIntFormat", (e, i) => {
  Is.init(e, i), Mr.init(e, i);
}), vu = p("$ZodSymbol", (e, i) => {
  S.init(e, i), e._zod.parse = (r2, a2) => {
    let t = r2.value;
    return typeof t == "symbol" || r2.issues.push({ expected: "symbol", code: "invalid_type", input: t, inst: e }), r2;
  };
}), gu = p("$ZodUndefined", (e, i) => {
  S.init(e, i), e._zod.pattern = gs, e._zod.values = /* @__PURE__ */ new Set([void 0]), e._zod.optin = "optional", e._zod.optout = "optional", e._zod.parse = (r2, a2) => {
    let t = r2.value;
    return typeof t > "u" || r2.issues.push({ expected: "undefined", code: "invalid_type", input: t, inst: e }), r2;
  };
}), hu = p("$ZodNull", (e, i) => {
  S.init(e, i), e._zod.pattern = vs, e._zod.values = /* @__PURE__ */ new Set([null]), e._zod.parse = (r2, a2) => {
    let t = r2.value;
    return t === null || r2.issues.push({ expected: "null", code: "invalid_type", input: t, inst: e }), r2;
  };
}), _u = p("$ZodAny", (e, i) => {
  S.init(e, i), e._zod.parse = (r2) => r2;
}), bu = p("$ZodUnknown", (e, i) => {
  S.init(e, i), e._zod.parse = (r2) => r2;
}), yu = p("$ZodNever", (e, i) => {
  S.init(e, i), e._zod.parse = (r2, a2) => (r2.issues.push({ expected: "never", code: "invalid_type", input: r2.value, inst: e }), r2);
}), $u = p("$ZodVoid", (e, i) => {
  S.init(e, i), e._zod.parse = (r2, a2) => {
    let t = r2.value;
    return typeof t > "u" || r2.issues.push({ expected: "void", code: "invalid_type", input: t, inst: e }), r2;
  };
}), Iu = p("$ZodDate", (e, i) => {
  S.init(e, i), e._zod.parse = (r2, a2) => {
    if (i.coerce) try {
      r2.value = new Date(r2.value);
    } catch {
    }
    let t = r2.value, n = t instanceof Date;
    return n && !Number.isNaN(t.getTime()) || r2.issues.push({ expected: "date", code: "invalid_type", input: t, ...n ? { received: "Invalid Date" } : {}, inst: e }), r2;
  };
});
function Za(e, i, r2) {
  e.issues.length && i.issues.push(...pe(r2, e.issues)), i.value[r2] = e.value;
}
var ku = p("$ZodArray", (e, i) => {
  S.init(e, i), e._zod.parse = (r2, a2) => {
    let t = r2.value;
    if (!Array.isArray(t)) return r2.issues.push({ expected: "array", code: "invalid_type", input: t, inst: e }), r2;
    r2.value = Array(t.length);
    let n = [];
    for (let o = 0; o < t.length; o++) {
      let s2 = t[o], u2 = i.element._zod.run({ value: s2, issues: [] }, a2);
      u2 instanceof Promise ? n.push(u2.then((l) => Za(l, r2, o))) : Za(u2, r2, o);
    }
    return n.length ? Promise.all(n).then(() => r2) : r2;
  };
});
function ti(e, i, r2, a2, t) {
  if (e.issues.length) {
    if (t && !(r2 in a2)) return;
    i.issues.push(...pe(r2, e.issues));
  }
  e.value === void 0 ? r2 in a2 && (i.value[r2] = void 0) : i.value[r2] = e.value;
}
function wu(e) {
  var a2, t, n, o;
  let i = Object.keys(e.shape);
  for (let s2 of i) if (!((o = (n = (t = (a2 = e.shape) == null ? void 0 : a2[s2]) == null ? void 0 : t._zod) == null ? void 0 : n.traits) != null && o.has("$ZodType"))) throw Error(`Invalid element at key "${s2}": expected a Zod schema`);
  let r2 = Oo(e.shape);
  return { ...e, keys: i, keySet: new Set(i), numKeys: i.length, optionalKeys: new Set(r2) };
}
function Su(e, i, r2, a2, t, n) {
  let o = [], s2 = t.keySet, u2 = t.catchall._zod, l = u2.def.type, d2 = u2.optout === "optional";
  for (let c in i) {
    if (s2.has(c)) continue;
    if (l === "never") {
      o.push(c);
      continue;
    }
    let f2 = u2.run({ value: i[c], issues: [] }, a2);
    f2 instanceof Promise ? e.push(f2.then((v) => ti(v, r2, c, i, d2))) : ti(f2, r2, c, i, d2);
  }
  return o.length && r2.issues.push({ code: "unrecognized_keys", keys: o, input: i, inst: n }), e.length ? Promise.all(e).then(() => r2) : r2;
}
var xu = p("$ZodObject", (e, i) => {
  var o;
  if (S.init(e, i), !((o = Object.getOwnPropertyDescriptor(i, "shape")) != null && o.get)) {
    let s2 = i.shape;
    Object.defineProperty(i, "shape", { get: () => {
      let u2 = { ...s2 };
      return Object.defineProperty(i, "shape", { value: u2 }), u2;
    } });
  }
  let r2 = yt(() => wu(i));
  z(e._zod, "propValues", () => {
    let s2 = i.shape, u2 = {};
    for (let l in s2) {
      let d2 = s2[l]._zod;
      if (d2.values) {
        u2[l] ?? (u2[l] = /* @__PURE__ */ new Set());
        for (let c of d2.values) u2[l].add(c);
      }
    }
    return u2;
  });
  let a2 = Qe, t = i.catchall, n;
  e._zod.parse = (s2, u2) => {
    n ?? (n = r2.value);
    let l = s2.value;
    if (!a2(l)) return s2.issues.push({ expected: "object", code: "invalid_type", input: l, inst: e }), s2;
    s2.value = {};
    let d2 = [], c = n.shape;
    for (let f2 of n.keys) {
      let v = c[f2], g2 = v._zod.optout === "optional", b = v._zod.run({ value: l[f2], issues: [] }, u2);
      b instanceof Promise ? d2.push(b.then(($2) => ti($2, s2, f2, l, g2))) : ti(b, s2, f2, l, g2);
    }
    return t ? Su(d2, l, s2, u2, r2.value, e) : d2.length ? Promise.all(d2).then(() => s2) : s2;
  };
}), Eu = p("$ZodObjectJIT", (e, i) => {
  xu.init(e, i);
  let r2 = e._zod.parse, a2 = yt(() => wu(i)), t = (c) => {
    var N2, G2;
    let f2 = new Zs(["shape", "payload", "ctx"]), v = a2.value, g2 = (U2) => {
      let O = mr(U2);
      return `shape[${O}]._zod.run({ value: input[${O}], issues: [] }, ctx)`;
    };
    f2.write("const input = payload.value;");
    let b = /* @__PURE__ */ Object.create(null), $2 = 0;
    for (let U2 of v.keys) b[U2] = `key_${$2++}`;
    f2.write("const newResult = {};");
    for (let U2 of v.keys) {
      let O = b[U2], R2 = mr(U2), E2 = ((G2 = (N2 = c[U2]) == null ? void 0 : N2._zod) == null ? void 0 : G2.optout) === "optional";
      f2.write(`const ${O} = ${g2(U2)};`), E2 ? f2.write(`
        if (${O}.issues.length) {
          if (${R2} in input) {
            payload.issues = payload.issues.concat(${O}.issues.map(iss => ({
              ...iss,
              path: iss.path ? [${R2}, ...iss.path] : [${R2}]
            })));
          }
        }
        
        if (${O}.value === undefined) {
          if (${R2} in input) {
            newResult[${R2}] = undefined;
          }
        } else {
          newResult[${R2}] = ${O}.value;
        }
        
      `) : f2.write(`
        if (${O}.issues.length) {
          payload.issues = payload.issues.concat(${O}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${R2}, ...iss.path] : [${R2}]
          })));
        }
        
        if (${O}.value === undefined) {
          if (${R2} in input) {
            newResult[${R2}] = undefined;
          }
        } else {
          newResult[${R2}] = ${O}.value;
        }
        
      `);
    }
    f2.write("payload.value = newResult;"), f2.write("return payload;");
    let I2 = f2.compile();
    return (U2, O) => I2(c, U2, O);
  }, n, o = Qe, s2 = !Kt.jitless, u2 = s2 && zo.value, l = i.catchall, d2;
  e._zod.parse = (c, f2) => {
    d2 ?? (d2 = a2.value);
    let v = c.value;
    return o(v) ? s2 && u2 && (f2 == null ? void 0 : f2.async) === false && f2.jitless !== true ? (n || (n = t(i.shape)), c = n(c, f2), l ? Su([], v, c, f2, d2, e) : c) : r2(c, f2) : (c.issues.push({ expected: "object", code: "invalid_type", input: v, inst: e }), c);
  };
});
function Ca(e, i, r2, a2) {
  for (let n of e) if (n.issues.length === 0) return i.value = n.value, i;
  let t = e.filter((n) => !je(n));
  return t.length === 1 ? (i.value = t[0].value, t[0]) : (i.issues.push({ code: "invalid_union", input: i.value, inst: r2, errors: e.map((n) => n.issues.map((o) => de(o, a2, H()))) }), i);
}
var fi = p("$ZodUnion", (e, i) => {
  S.init(e, i), z(e._zod, "optin", () => i.options.some((t) => t._zod.optin === "optional") ? "optional" : void 0), z(e._zod, "optout", () => i.options.some((t) => t._zod.optout === "optional") ? "optional" : void 0), z(e._zod, "values", () => {
    if (i.options.every((t) => t._zod.values)) return new Set(i.options.flatMap((t) => Array.from(t._zod.values)));
  }), z(e._zod, "pattern", () => {
    if (i.options.every((t) => t._zod.pattern)) {
      let t = i.options.map((n) => n._zod.pattern);
      return new RegExp(`^(${t.map((n) => di(n.source)).join("|")})$`);
    }
  });
  let r2 = i.options.length === 1, a2 = i.options[0]._zod.run;
  e._zod.parse = (t, n) => {
    if (r2) return a2(t, n);
    let o = false, s2 = [];
    for (let u2 of i.options) {
      let l = u2._zod.run({ value: t.value, issues: [] }, n);
      if (l instanceof Promise) s2.push(l), o = true;
      else {
        if (l.issues.length === 0) return l;
        s2.push(l);
      }
    }
    return o ? Promise.all(s2).then((u2) => Ca(u2, t, e, n)) : Ca(s2, t, e, n);
  };
});
function La(e, i, r2, a2) {
  let t = e.filter((n) => n.issues.length === 0);
  return t.length === 1 ? (i.value = t[0].value, i) : (t.length === 0 ? i.issues.push({ code: "invalid_union", input: i.value, inst: r2, errors: e.map((n) => n.issues.map((o) => de(o, a2, H()))) }) : i.issues.push({ code: "invalid_union", input: i.value, inst: r2, errors: [], inclusive: false }), i);
}
var zu = p("$ZodXor", (e, i) => {
  fi.init(e, i), i.inclusive = false;
  let r2 = i.options.length === 1, a2 = i.options[0]._zod.run;
  e._zod.parse = (t, n) => {
    if (r2) return a2(t, n);
    let o = false, s2 = [];
    for (let u2 of i.options) {
      let l = u2._zod.run({ value: t.value, issues: [] }, n);
      l instanceof Promise ? (s2.push(l), o = true) : s2.push(l);
    }
    return o ? Promise.all(s2).then((u2) => La(u2, t, e, n)) : La(s2, t, e, n);
  };
}), Tu = p("$ZodDiscriminatedUnion", (e, i) => {
  i.inclusive = false, fi.init(e, i);
  let r2 = e._zod.parse;
  z(e._zod, "propValues", () => {
    let t = {};
    for (let n of i.options) {
      let o = n._zod.propValues;
      if (!o || Object.keys(o).length === 0) throw Error(`Invalid discriminated union option at index "${i.options.indexOf(n)}"`);
      for (let [s2, u2] of Object.entries(o)) {
        t[s2] || (t[s2] = /* @__PURE__ */ new Set());
        for (let l of u2) t[s2].add(l);
      }
    }
    return t;
  });
  let a2 = yt(() => {
    var o;
    let t = i.options, n = /* @__PURE__ */ new Map();
    for (let s2 of t) {
      let u2 = (o = s2._zod.propValues) == null ? void 0 : o[i.discriminator];
      if (!u2 || u2.size === 0) throw Error(`Invalid discriminated union option at index "${i.options.indexOf(s2)}"`);
      for (let l of u2) {
        if (n.has(l)) throw Error(`Duplicate discriminator value "${String(l)}"`);
        n.set(l, s2);
      }
    }
    return n;
  });
  e._zod.parse = (t, n) => {
    let o = t.value;
    if (!Qe(o)) return t.issues.push({ code: "invalid_type", expected: "object", input: o, inst: e }), t;
    let s2 = a2.value.get(o == null ? void 0 : o[i.discriminator]);
    return s2 ? s2._zod.run(t, n) : i.unionFallback ? r2(t, n) : (t.issues.push({ code: "invalid_union", errors: [], note: "No matching discriminator", discriminator: i.discriminator, input: o, path: [i.discriminator], inst: e }), t);
  };
}), Uu = p("$ZodIntersection", (e, i) => {
  S.init(e, i), e._zod.parse = (r2, a2) => {
    let t = r2.value, n = i.left._zod.run({ value: t, issues: [] }, a2), o = i.right._zod.run({ value: t, issues: [] }, a2);
    return n instanceof Promise || o instanceof Promise ? Promise.all([n, o]).then(([s2, u2]) => Ma(r2, s2, u2)) : Ma(r2, n, o);
  };
});
function vr(e, i) {
  if (e === i) return { valid: true, data: e };
  if (e instanceof Date && i instanceof Date && +e == +i) return { valid: true, data: e };
  if (Le(e) && Le(i)) {
    let r2 = Object.keys(i), a2 = Object.keys(e).filter((n) => r2.indexOf(n) !== -1), t = { ...e, ...i };
    for (let n of a2) {
      let o = vr(e[n], i[n]);
      if (!o.valid) return { valid: false, mergeErrorPath: [n, ...o.mergeErrorPath] };
      t[n] = o.data;
    }
    return { valid: true, data: t };
  }
  if (Array.isArray(e) && Array.isArray(i)) {
    if (e.length !== i.length) return { valid: false, mergeErrorPath: [] };
    let r2 = [];
    for (let a2 = 0; a2 < e.length; a2++) {
      let t = e[a2], n = i[a2], o = vr(t, n);
      if (!o.valid) return { valid: false, mergeErrorPath: [a2, ...o.mergeErrorPath] };
      r2.push(o.data);
    }
    return { valid: true, data: r2 };
  }
  return { valid: false, mergeErrorPath: [] };
}
function Ma(e, i, r2) {
  let a2 = /* @__PURE__ */ new Map(), t;
  for (let s2 of i.issues) if (s2.code === "unrecognized_keys") {
    t ?? (t = s2);
    for (let u2 of s2.keys)
      a2.has(u2) || a2.set(u2, {}), a2.get(u2).l = true;
  } else e.issues.push(s2);
  for (let s2 of r2.issues) if (s2.code === "unrecognized_keys") for (let u2 of s2.keys)
    a2.has(u2) || a2.set(u2, {}), a2.get(u2).r = true;
  else e.issues.push(s2);
  let n = [...a2].filter(([, s2]) => s2.l && s2.r).map(([s2]) => s2);
  if (n.length && t && e.issues.push({ ...t, keys: n }), je(e)) return e;
  let o = vr(i.value, r2.value);
  if (!o.valid) throw Error(`Unmergable intersection. Error path: ${JSON.stringify(o.mergeErrorPath)}`);
  return e.value = o.data, e;
}
var Fr = p("$ZodTuple", (e, i) => {
  S.init(e, i);
  let r2 = i.items;
  e._zod.parse = (a2, t) => {
    let n = a2.value;
    if (!Array.isArray(n)) return a2.issues.push({ input: n, inst: e, expected: "tuple", code: "invalid_type" }), a2;
    a2.value = [];
    let o = [], s2 = [...r2].reverse().findIndex((d2) => d2._zod.optin !== "optional"), u2 = s2 === -1 ? 0 : r2.length - s2;
    if (!i.rest) {
      let d2 = n.length > r2.length, c = n.length < u2 - 1;
      if (d2 || c) return a2.issues.push({ ...d2 ? { code: "too_big", maximum: r2.length, inclusive: true } : { code: "too_small", minimum: r2.length }, input: n, inst: e, origin: "array" }), a2;
    }
    let l = -1;
    for (let d2 of r2) {
      if (l++, l >= n.length && l >= u2)
        continue;
      let c = d2._zod.run({ value: n[l], issues: [] }, t);
      c instanceof Promise ? o.push(c.then((f2) => Wt(f2, a2, l))) : Wt(c, a2, l);
    }
    if (i.rest) {
      let d2 = n.slice(r2.length);
      for (let c of d2) {
        l++;
        let f2 = i.rest._zod.run({ value: c, issues: [] }, t);
        f2 instanceof Promise ? o.push(f2.then((v) => Wt(v, a2, l))) : Wt(f2, a2, l);
      }
    }
    return o.length ? Promise.all(o).then(() => a2) : a2;
  };
});
function Wt(e, i, r2) {
  e.issues.length && i.issues.push(...pe(r2, e.issues)), i.value[r2] = e.value;
}
var Ou = p("$ZodRecord", (e, i) => {
  S.init(e, i), e._zod.parse = (r2, a2) => {
    let t = r2.value;
    if (!Le(t)) return r2.issues.push({ expected: "record", code: "invalid_type", input: t, inst: e }), r2;
    let n = [], o = i.keyType._zod.values;
    if (o) {
      r2.value = {};
      let s2 = /* @__PURE__ */ new Set();
      for (let l of o) if (typeof l == "string" || typeof l == "number" || typeof l == "symbol") {
        s2.add(typeof l == "number" ? l.toString() : l);
        let d2 = i.valueType._zod.run({ value: t[l], issues: [] }, a2);
        d2 instanceof Promise ? n.push(d2.then((c) => {
          c.issues.length && r2.issues.push(...pe(l, c.issues)), r2.value[l] = c.value;
        })) : (d2.issues.length && r2.issues.push(...pe(l, d2.issues)), r2.value[l] = d2.value);
      }
      let u2;
      for (let l in t) s2.has(l) || (u2 = u2 ?? [], u2.push(l));
      u2 && u2.length > 0 && r2.issues.push({ code: "unrecognized_keys", input: t, inst: e, keys: u2 });
    } else {
      r2.value = {};
      for (let s2 of Reflect.ownKeys(t)) {
        if (s2 === "__proto__") continue;
        let u2 = i.keyType._zod.run({ value: s2, issues: [] }, a2);
        if (u2 instanceof Promise) throw Error("Async schemas not supported in object keys currently");
        if (typeof s2 == "string" && Dr.test(s2) && u2.issues.length && u2.issues.some((d2) => d2.code === "invalid_type" && d2.expected === "number")) {
          let d2 = i.keyType._zod.run({ value: Number(s2), issues: [] }, a2);
          if (d2 instanceof Promise) throw Error("Async schemas not supported in object keys currently");
          d2.issues.length === 0 && (u2 = d2);
        }
        if (u2.issues.length) {
          i.mode === "loose" ? r2.value[s2] = t[s2] : r2.issues.push({ code: "invalid_key", origin: "record", issues: u2.issues.map((d2) => de(d2, a2, H())), input: s2, path: [s2], inst: e });
          continue;
        }
        let l = i.valueType._zod.run({ value: t[s2], issues: [] }, a2);
        l instanceof Promise ? n.push(l.then((d2) => {
          d2.issues.length && r2.issues.push(...pe(s2, d2.issues)), r2.value[u2.value] = d2.value;
        })) : (l.issues.length && r2.issues.push(...pe(s2, l.issues)), r2.value[u2.value] = l.value);
      }
    }
    return n.length ? Promise.all(n).then(() => r2) : r2;
  };
}), Nu = p("$ZodMap", (e, i) => {
  S.init(e, i), e._zod.parse = (r2, a2) => {
    let t = r2.value;
    if (!(t instanceof Map)) return r2.issues.push({ expected: "map", code: "invalid_type", input: t, inst: e }), r2;
    let n = [];
    r2.value = /* @__PURE__ */ new Map();
    for (let [o, s2] of t) {
      let u2 = i.keyType._zod.run({ value: o, issues: [] }, a2), l = i.valueType._zod.run({ value: s2, issues: [] }, a2);
      u2 instanceof Promise || l instanceof Promise ? n.push(Promise.all([u2, l]).then(([d2, c]) => {
        Fa(d2, c, r2, o, t, e, a2);
      })) : Fa(u2, l, r2, o, t, e, a2);
    }
    return n.length ? Promise.all(n).then(() => r2) : r2;
  };
});
function Fa(e, i, r2, a2, t, n, o) {
  e.issues.length && (Qt.has(typeof a2) ? r2.issues.push(...pe(a2, e.issues)) : r2.issues.push({ code: "invalid_key", origin: "map", input: t, inst: n, issues: e.issues.map((s2) => de(s2, o, H())) })), i.issues.length && (Qt.has(typeof a2) ? r2.issues.push(...pe(a2, i.issues)) : r2.issues.push({ origin: "map", code: "invalid_element", input: t, inst: n, key: a2, issues: i.issues.map((s2) => de(s2, o, H())) })), r2.value.set(e.value, i.value);
}
var Ru = p("$ZodSet", (e, i) => {
  S.init(e, i), e._zod.parse = (r2, a2) => {
    let t = r2.value;
    if (!(t instanceof Set)) return r2.issues.push({ input: t, inst: e, expected: "set", code: "invalid_type" }), r2;
    let n = [];
    r2.value = /* @__PURE__ */ new Set();
    for (let o of t) {
      let s2 = i.valueType._zod.run({ value: o, issues: [] }, a2);
      s2 instanceof Promise ? n.push(s2.then((u2) => Ja(u2, r2))) : Ja(s2, r2);
    }
    return n.length ? Promise.all(n).then(() => r2) : r2;
  };
});
function Ja(e, i) {
  e.issues.length && i.issues.push(...e.issues), i.value.add(e.value);
}
var Pu = p("$ZodEnum", (e, i) => {
  S.init(e, i);
  let r2 = $r(i.entries), a2 = new Set(r2);
  e._zod.values = a2, e._zod.pattern = new RegExp(`^(${r2.filter((t) => Qt.has(typeof t)).map((t) => typeof t == "string" ? be(t) : t.toString()).join("|")})$`), e._zod.parse = (t, n) => {
    let o = t.value;
    return a2.has(o) || t.issues.push({ code: "invalid_value", values: r2, input: o, inst: e }), t;
  };
}), Du = p("$ZodLiteral", (e, i) => {
  if (S.init(e, i), i.values.length === 0) throw Error("Cannot create literal schema with no valid values");
  let r2 = new Set(i.values);
  e._zod.values = r2, e._zod.pattern = new RegExp(`^(${i.values.map((a2) => typeof a2 == "string" ? be(a2) : a2 ? be(a2.toString()) : String(a2)).join("|")})$`), e._zod.parse = (a2, t) => {
    let n = a2.value;
    return r2.has(n) || a2.issues.push({ code: "invalid_value", values: i.values, input: n, inst: e }), a2;
  };
}), ju = p("$ZodFile", (e, i) => {
  S.init(e, i), e._zod.parse = (r2, a2) => {
    let t = r2.value;
    return t instanceof File || r2.issues.push({ expected: "file", code: "invalid_type", input: t, inst: e }), r2;
  };
}), Au = p("$ZodTransform", (e, i) => {
  S.init(e, i), e._zod.parse = (r2, a2) => {
    if (a2.direction === "backward") throw new li(e.constructor.name);
    let t = i.transform(r2.value, r2);
    if (a2.async) return (t instanceof Promise ? t : Promise.resolve(t)).then((n) => (r2.value = n, r2));
    if (t instanceof Promise) throw new Ce();
    return r2.value = t, r2;
  };
});
function Va(e, i) {
  return e.issues.length && i === void 0 ? { issues: [], value: void 0 } : e;
}
var Jr = p("$ZodOptional", (e, i) => {
  S.init(e, i), e._zod.optin = "optional", e._zod.optout = "optional", z(e._zod, "values", () => i.innerType._zod.values ? /* @__PURE__ */ new Set([...i.innerType._zod.values, void 0]) : void 0), z(e._zod, "pattern", () => {
    let r2 = i.innerType._zod.pattern;
    return r2 ? new RegExp(`^(${di(r2.source)})?$`) : void 0;
  }), e._zod.parse = (r2, a2) => {
    if (i.innerType._zod.optin === "optional") {
      let t = i.innerType._zod.run(r2, a2);
      return t instanceof Promise ? t.then((n) => Va(n, r2.value)) : Va(t, r2.value);
    }
    return r2.value === void 0 ? r2 : i.innerType._zod.run(r2, a2);
  };
}), Zu = p("$ZodExactOptional", (e, i) => {
  Jr.init(e, i), z(e._zod, "values", () => i.innerType._zod.values), z(e._zod, "pattern", () => i.innerType._zod.pattern), e._zod.parse = (r2, a2) => i.innerType._zod.run(r2, a2);
}), Cu = p("$ZodNullable", (e, i) => {
  S.init(e, i), z(e._zod, "optin", () => i.innerType._zod.optin), z(e._zod, "optout", () => i.innerType._zod.optout), z(e._zod, "pattern", () => {
    let r2 = i.innerType._zod.pattern;
    return r2 ? new RegExp(`^(${di(r2.source)}|null)$`) : void 0;
  }), z(e._zod, "values", () => i.innerType._zod.values ? /* @__PURE__ */ new Set([...i.innerType._zod.values, null]) : void 0), e._zod.parse = (r2, a2) => r2.value === null ? r2 : i.innerType._zod.run(r2, a2);
}), Lu = p("$ZodDefault", (e, i) => {
  S.init(e, i), e._zod.optin = "optional", z(e._zod, "values", () => i.innerType._zod.values), e._zod.parse = (r2, a2) => {
    if (a2.direction === "backward") return i.innerType._zod.run(r2, a2);
    if (r2.value === void 0) return r2.value = i.defaultValue, r2;
    let t = i.innerType._zod.run(r2, a2);
    return t instanceof Promise ? t.then((n) => Ga(n, i)) : Ga(t, i);
  };
});
function Ga(e, i) {
  return e.value === void 0 && (e.value = i.defaultValue), e;
}
var Mu = p("$ZodPrefault", (e, i) => {
  S.init(e, i), e._zod.optin = "optional", z(e._zod, "values", () => i.innerType._zod.values), e._zod.parse = (r2, a2) => (a2.direction === "backward" || r2.value === void 0 && (r2.value = i.defaultValue), i.innerType._zod.run(r2, a2));
}), Fu = p("$ZodNonOptional", (e, i) => {
  S.init(e, i), z(e._zod, "values", () => {
    let r2 = i.innerType._zod.values;
    return r2 ? new Set([...r2].filter((a2) => a2 !== void 0)) : void 0;
  }), e._zod.parse = (r2, a2) => {
    let t = i.innerType._zod.run(r2, a2);
    return t instanceof Promise ? t.then((n) => Wa(n, e)) : Wa(t, e);
  };
});
function Wa(e, i) {
  return !e.issues.length && e.value === void 0 && e.issues.push({ code: "invalid_type", expected: "nonoptional", input: e.value, inst: i }), e;
}
var Ju = p("$ZodSuccess", (e, i) => {
  S.init(e, i), e._zod.parse = (r2, a2) => {
    if (a2.direction === "backward") throw new li("ZodSuccess");
    let t = i.innerType._zod.run(r2, a2);
    return t instanceof Promise ? t.then((n) => (r2.value = n.issues.length === 0, r2)) : (r2.value = t.issues.length === 0, r2);
  };
}), Vu = p("$ZodCatch", (e, i) => {
  S.init(e, i), z(e._zod, "optin", () => i.innerType._zod.optin), z(e._zod, "optout", () => i.innerType._zod.optout), z(e._zod, "values", () => i.innerType._zod.values), e._zod.parse = (r2, a2) => {
    if (a2.direction === "backward") return i.innerType._zod.run(r2, a2);
    let t = i.innerType._zod.run(r2, a2);
    return t instanceof Promise ? t.then((n) => (r2.value = n.value, n.issues.length && (r2.value = i.catchValue({ ...r2, error: { issues: n.issues.map((o) => de(o, a2, H())) }, input: r2.value }), r2.issues = []), r2)) : (r2.value = t.value, t.issues.length && (r2.value = i.catchValue({ ...r2, error: { issues: t.issues.map((n) => de(n, a2, H())) }, input: r2.value }), r2.issues = []), r2);
  };
}), Gu = p("$ZodNaN", (e, i) => {
  S.init(e, i), e._zod.parse = (r2, a2) => ((typeof r2.value != "number" || !Number.isNaN(r2.value)) && r2.issues.push({ input: r2.value, inst: e, expected: "nan", code: "invalid_type" }), r2);
}), Wu = p("$ZodPipe", (e, i) => {
  S.init(e, i), z(e._zod, "values", () => i.in._zod.values), z(e._zod, "optin", () => i.in._zod.optin), z(e._zod, "optout", () => i.out._zod.optout), z(e._zod, "propValues", () => i.in._zod.propValues), e._zod.parse = (r2, a2) => {
    if (a2.direction === "backward") {
      let n = i.out._zod.run(r2, a2);
      return n instanceof Promise ? n.then((o) => qt(o, i.in, a2)) : qt(n, i.in, a2);
    }
    let t = i.in._zod.run(r2, a2);
    return t instanceof Promise ? t.then((n) => qt(n, i.out, a2)) : qt(t, i.out, a2);
  };
});
function qt(e, i, r2) {
  return e.issues.length ? (e.aborted = true, e) : i._zod.run({ value: e.value, issues: e.issues }, r2);
}
var Vr = p("$ZodCodec", (e, i) => {
  S.init(e, i), z(e._zod, "values", () => i.in._zod.values), z(e._zod, "optin", () => i.in._zod.optin), z(e._zod, "optout", () => i.out._zod.optout), z(e._zod, "propValues", () => i.in._zod.propValues), e._zod.parse = (r2, a2) => {
    if ((a2.direction || "forward") === "forward") {
      let t = i.in._zod.run(r2, a2);
      return t instanceof Promise ? t.then((n) => Yt(n, i, a2)) : Yt(t, i, a2);
    } else {
      let t = i.out._zod.run(r2, a2);
      return t instanceof Promise ? t.then((n) => Yt(n, i, a2)) : Yt(t, i, a2);
    }
  };
});
function Yt(e, i, r2) {
  if (e.issues.length) return e.aborted = true, e;
  if ((r2.direction || "forward") === "forward") {
    let a2 = i.transform(e.value, e);
    return a2 instanceof Promise ? a2.then((t) => Bt(e, t, i.out, r2)) : Bt(e, a2, i.out, r2);
  } else {
    let a2 = i.reverseTransform(e.value, e);
    return a2 instanceof Promise ? a2.then((t) => Bt(e, t, i.in, r2)) : Bt(e, a2, i.in, r2);
  }
}
function Bt(e, i, r2, a2) {
  return e.issues.length ? (e.aborted = true, e) : r2._zod.run({ value: i, issues: e.issues }, a2);
}
var qu = p("$ZodReadonly", (e, i) => {
  S.init(e, i), z(e._zod, "propValues", () => i.innerType._zod.propValues), z(e._zod, "values", () => i.innerType._zod.values), z(e._zod, "optin", () => {
    var r2, a2;
    return (a2 = (r2 = i.innerType) == null ? void 0 : r2._zod) == null ? void 0 : a2.optin;
  }), z(e._zod, "optout", () => {
    var r2, a2;
    return (a2 = (r2 = i.innerType) == null ? void 0 : r2._zod) == null ? void 0 : a2.optout;
  }), e._zod.parse = (r2, a2) => {
    if (a2.direction === "backward") return i.innerType._zod.run(r2, a2);
    let t = i.innerType._zod.run(r2, a2);
    return t instanceof Promise ? t.then(qa) : qa(t);
  };
});
function qa(e) {
  return e.value = Object.freeze(e.value), e;
}
var Yu = p("$ZodTemplateLiteral", (e, i) => {
  S.init(e, i);
  let r2 = [];
  for (let a2 of i.parts) if (typeof a2 == "object" && a2 !== null) {
    if (!a2._zod.pattern) throw Error(`Invalid template literal part, no pattern found: ${[...a2._zod.traits].shift()}`);
    let t = a2._zod.pattern instanceof RegExp ? a2._zod.pattern.source : a2._zod.pattern;
    if (!t) throw Error(`Invalid template literal part: ${a2._zod.traits}`);
    let n = t.startsWith("^") ? 1 : 0, o = t.endsWith("$") ? t.length - 1 : t.length;
    r2.push(t.slice(n, o));
  } else if (a2 === null || Uo.has(typeof a2)) r2.push(be(`${a2}`));
  else throw Error(`Invalid template literal part: ${a2}`);
  e._zod.pattern = new RegExp(`^${r2.join("")}$`), e._zod.parse = (a2, t) => typeof a2.value != "string" ? (a2.issues.push({ input: a2.value, inst: e, expected: "string", code: "invalid_type" }), a2) : (e._zod.pattern.lastIndex = 0, e._zod.pattern.test(a2.value) || a2.issues.push({ input: a2.value, inst: e, code: "invalid_format", format: i.format ?? "template_literal", pattern: e._zod.pattern.source }), a2);
}), Bu = p("$ZodFunction", (e, i) => (S.init(e, i), e._def = i, e._zod.def = i, e.implement = (r2) => {
  if (typeof r2 != "function") throw Error("implement() must be called with a function");
  return function(...a2) {
    let t = e._def.input ? fr(e._def.input, a2) : a2, n = Reflect.apply(r2, this, t);
    return e._def.output ? fr(e._def.output, n) : n;
  };
}, e.implementAsync = (r2) => {
  if (typeof r2 != "function") throw Error("implementAsync() must be called with a function");
  return async function(...a2) {
    let t = e._def.input ? await pr(e._def.input, a2) : a2, n = await Reflect.apply(r2, this, t);
    return e._def.output ? await pr(e._def.output, n) : n;
  };
}, e._zod.parse = (r2, a2) => typeof r2.value != "function" ? (r2.issues.push({ code: "invalid_type", expected: "function", input: r2.value, inst: e }), r2) : (e._def.output && e._def.output._zod.def.type === "promise" ? r2.value = e.implementAsync(r2.value) : r2.value = e.implement(r2.value), r2), e.input = (...r2) => {
  let a2 = e.constructor;
  return Array.isArray(r2[0]) ? new a2({ type: "function", input: new Fr({ type: "tuple", items: r2[0], rest: r2[1] }), output: e._def.output }) : new a2({ type: "function", input: r2[0], output: e._def.output });
}, e.output = (r2) => new e.constructor({ type: "function", input: e._def.input, output: r2 }), e)), Hu = p("$ZodPromise", (e, i) => {
  S.init(e, i), e._zod.parse = (r2, a2) => Promise.resolve(r2.value).then((t) => i.innerType._zod.run({ value: t, issues: [] }, a2));
}), Ku = p("$ZodLazy", (e, i) => {
  S.init(e, i), z(e._zod, "innerType", () => i.getter()), z(e._zod, "pattern", () => {
    var r2, a2;
    return (a2 = (r2 = e._zod.innerType) == null ? void 0 : r2._zod) == null ? void 0 : a2.pattern;
  }), z(e._zod, "propValues", () => {
    var r2, a2;
    return (a2 = (r2 = e._zod.innerType) == null ? void 0 : r2._zod) == null ? void 0 : a2.propValues;
  }), z(e._zod, "optin", () => {
    var r2, a2;
    return ((a2 = (r2 = e._zod.innerType) == null ? void 0 : r2._zod) == null ? void 0 : a2.optin) ?? void 0;
  }), z(e._zod, "optout", () => {
    var r2, a2;
    return ((a2 = (r2 = e._zod.innerType) == null ? void 0 : r2._zod) == null ? void 0 : a2.optout) ?? void 0;
  }), e._zod.parse = (r2, a2) => e._zod.innerType._zod.run(r2, a2);
}), Xu = p("$ZodCustom", (e, i) => {
  M.init(e, i), S.init(e, i), e._zod.parse = (r2, a2) => r2, e._zod.check = (r2) => {
    let a2 = r2.value, t = i.fn(a2);
    if (t instanceof Promise) return t.then((n) => Ya(n, r2, a2, e));
    Ya(t, r2, a2, e);
  };
});
function Ya(e, i, r2, a2) {
  if (!e) {
    let t = { code: "custom", input: r2, inst: a2, path: [...a2._zod.def.path ?? []], continue: !a2._zod.def.abort };
    a2._zod.def.params && (t.params = a2._zod.def.params), i.issues.push(ei(t));
  }
}
var Gr = {};
ye(Gr, { zhTW: () => fg, zhCN: () => cg, yo: () => vg2, vi: () => lg, uz: () => sg, ur: () => ag, uk: () => tl, ua: () => rg, tr: () => tg, th: () => Qv, ta: () => Kv, sv: () => Bv, sl: () => qv, ru: () => Gv, pt: () => Jv, ps: () => Cv, pl: () => Mv, ota: () => Av, no: () => Dv, nl: () => Rv, ms: () => Ov, mk: () => Tv, lt: () => Ev, ko: () => Sv, km: () => el, kh: () => kv, ka: () => $v, ja: () => bv, it: () => hv, is: () => vv, id: () => fv, hy: () => cv, hu: () => lv, he: () => sv, frCA: () => av, fr: () => rv, fi: () => tv, fa: () => Qp, es: () => Kp, eo: () => Bp, en: () => Qu, de: () => Wp, da: () => Vp, cs: () => Fp, ca: () => Lp, bg: () => Zp, be: () => jp, az: () => Pp, ar: () => Np });
var Op = () => {
  let e = { string: { unit: "", verb: " " }, file: { unit: "", verb: " " }, array: { unit: "", verb: " " }, set: { unit: "", verb: " " } };
  function i(t) {
    return e[t] ?? null;
  }
  let r2 = { regex: "", email: " ", url: "", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "   ISO", date: "  ISO", time: "  ISO", duration: "  ISO", ipv4: " IPv4", ipv6: " IPv6", cidrv4: "   IPv4", cidrv6: "   IPv6", base64: "  base64-encoded", base64url: "  base64url-encoded", json_string: "   JSON", e164: "   E.164", jwt: "JWT", template_literal: "" }, a2 = { nan: "NaN" };
  return (t) => {
    switch (t.code) {
      case "invalid_type": {
        let n = a2[t.expected] ?? t.expected, o = w(t.input), s2 = a2[o] ?? o;
        return /^[A-Z]/.test(t.expected) ? `  :   instanceof ${t.expected}    ${s2}` : `  :   ${n}    ${s2}`;
      }
      case "invalid_value":
        return t.values.length === 1 ? `  :   ${k(t.values[0])}` : `  :     : ${h(t.values, "|")}`;
      case "too_big": {
        let n = t.inclusive ? "<=" : "<", o = i(t.origin);
        return o ? `   :    ${t.origin ?? ""} ${n} ${t.maximum.toString()} ${o.unit ?? ""}` : `  :    ${t.origin ?? ""} ${n} ${t.maximum.toString()}`;
      }
      case "too_small": {
        let n = t.inclusive ? ">=" : ">", o = i(t.origin);
        return o ? `  :   ${t.origin}   ${n} ${t.minimum.toString()} ${o.unit}` : `  :   ${t.origin}   ${n} ${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let n = t;
        return n.format === "starts_with" ? `  :     "${t.prefix}"` : n.format === "ends_with" ? `  :     "${n.suffix}"` : n.format === "includes" ? `  :    "${n.includes}"` : n.format === "regex" ? `  :     ${n.pattern}` : `${r2[n.format] ?? t.format}  `;
      }
      case "not_multiple_of":
        return `  :      ${t.divisor}`;
      case "unrecognized_keys":
        return `${t.keys.length > 1 ? "" : ""} ${t.keys.length > 1 ? "" : ""}: ${h(t.keys, " ")}`;
      case "invalid_key":
        return `    ${t.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `    ${t.origin}`;
      default:
        return "  ";
    }
  };
};
function Np() {
  return { localeError: Op() };
}
var Rp = () => {
  let e = { string: { unit: "simvol", verb: "olmaldr" }, file: { unit: "bayt", verb: "olmaldr" }, array: { unit: "element", verb: "olmaldr" }, set: { unit: "element", verb: "olmaldr" } };
  function i(t) {
    return e[t] ?? null;
  }
  let r2 = { regex: "input", email: "email address", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO datetime", date: "ISO date", time: "ISO time", duration: "ISO duration", ipv4: "IPv4 address", ipv6: "IPv6 address", cidrv4: "IPv4 range", cidrv6: "IPv6 range", base64: "base64-encoded string", base64url: "base64url-encoded string", json_string: "JSON string", e164: "E.164 number", jwt: "JWT", template_literal: "input" }, a2 = { nan: "NaN" };
  return (t) => {
    switch (t.code) {
      case "invalid_type": {
        let n = a2[t.expected] ?? t.expected, o = w(t.input), s2 = a2[o] ?? o;
        return /^[A-Z]/.test(t.expected) ? `Yanl dyr: gzlniln instanceof ${t.expected}, daxil olan ${s2}` : `Yanl dyr: gzlniln ${n}, daxil olan ${s2}`;
      }
      case "invalid_value":
        return t.values.length === 1 ? `Yanl dyr: gzlniln ${k(t.values[0])}` : `Yanl seim: aadaklardan biri olmaldr: ${h(t.values, "|")}`;
      case "too_big": {
        let n = t.inclusive ? "<=" : "<", o = i(t.origin);
        return o ? `ox byk: gzlniln ${t.origin ?? "dyr"} ${n}${t.maximum.toString()} ${o.unit ?? "element"}` : `ox byk: gzlniln ${t.origin ?? "dyr"} ${n}${t.maximum.toString()}`;
      }
      case "too_small": {
        let n = t.inclusive ? ">=" : ">", o = i(t.origin);
        return o ? `ox kiik: gzlniln ${t.origin} ${n}${t.minimum.toString()} ${o.unit}` : `ox kiik: gzlniln ${t.origin} ${n}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let n = t;
        return n.format === "starts_with" ? `Yanl mtn: "${n.prefix}" il balamaldr` : n.format === "ends_with" ? `Yanl mtn: "${n.suffix}" il bitmlidir` : n.format === "includes" ? `Yanl mtn: "${n.includes}" daxil olmaldr` : n.format === "regex" ? `Yanl mtn: ${n.pattern} ablonuna uyun olmaldr` : `Yanl ${r2[n.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `Yanl dd: ${t.divisor} il bln biln olmaldr`;
      case "unrecognized_keys":
        return `Tannmayan aar${t.keys.length > 1 ? "lar" : ""}: ${h(t.keys, ", ")}`;
      case "invalid_key":
        return `${t.origin} daxilind yanl aar`;
      case "invalid_union":
        return "Yanl dyr";
      case "invalid_element":
        return `${t.origin} daxilind yanl dyr`;
      default:
        return "Yanl dyr";
    }
  };
};
function Pp() {
  return { localeError: Rp() };
}
function Ba(e, i, r2, a2) {
  let t = Math.abs(e), n = t % 10, o = t % 100;
  return o >= 11 && o <= 19 ? a2 : n === 1 ? i : n >= 2 && n <= 4 ? r2 : a2;
}
var Dp = () => {
  let e = { string: { unit: { one: "", few: "", many: "" }, verb: "" }, array: { unit: { one: "", few: "", many: "" }, verb: "" }, set: { unit: { one: "", few: "", many: "" }, verb: "" }, file: { unit: { one: "", few: "", many: "" }, verb: "" } };
  function i(t) {
    return e[t] ?? null;
  }
  let r2 = { regex: "", email: "email ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO   ", date: "ISO ", time: "ISO ", duration: "ISO ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "   base64", base64url: "   base64url", json_string: "JSON ", e164: " E.164", jwt: "JWT", template_literal: "" }, a2 = { nan: "NaN", number: "", array: "" };
  return (t) => {
    switch (t.code) {
      case "invalid_type": {
        let n = a2[t.expected] ?? t.expected, o = w(t.input), s2 = a2[o] ?? o;
        return /^[A-Z]/.test(t.expected) ? ` :  instanceof ${t.expected},  ${s2}` : ` :  ${n},  ${s2}`;
      }
      case "invalid_value":
        return t.values.length === 1 ? ` :  ${k(t.values[0])}` : ` :    ${h(t.values, "|")}`;
      case "too_big": {
        let n = t.inclusive ? "<=" : "<", o = i(t.origin);
        if (o) {
          let s2 = Number(t.maximum), u2 = Ba(s2, o.unit.one, o.unit.few, o.unit.many);
          return ` : ,  ${t.origin ?? ""}  ${o.verb} ${n}${t.maximum.toString()} ${u2}`;
        }
        return ` : ,  ${t.origin ?? ""}   ${n}${t.maximum.toString()}`;
      }
      case "too_small": {
        let n = t.inclusive ? ">=" : ">", o = i(t.origin);
        if (o) {
          let s2 = Number(t.minimum), u2 = Ba(s2, o.unit.one, o.unit.few, o.unit.many);
          return ` : ,  ${t.origin}  ${o.verb} ${n}${t.minimum.toString()} ${u2}`;
        }
        return ` : ,  ${t.origin}   ${n}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let n = t;
        return n.format === "starts_with" ? ` :    "${n.prefix}"` : n.format === "ends_with" ? ` :    "${n.suffix}"` : n.format === "includes" ? ` :   "${n.includes}"` : n.format === "regex" ? ` :    ${n.pattern}` : ` ${r2[n.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return ` :    ${t.divisor}`;
      case "unrecognized_keys":
        return ` ${t.keys.length > 1 ? "" : ""}: ${h(t.keys, ", ")}`;
      case "invalid_key":
        return `   ${t.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${t.origin}`;
      default:
        return " ";
    }
  };
};
function jp() {
  return { localeError: Dp() };
}
var Ap = () => {
  let e = { string: { unit: "", verb: " " }, file: { unit: "", verb: " " }, array: { unit: "", verb: " " }, set: { unit: "", verb: " " } };
  function i(t) {
    return e[t] ?? null;
  }
  let r2 = { regex: "", email: " ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO ", date: "ISO ", time: "ISO ", duration: "ISO ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64- ", base64url: "base64url- ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "" }, a2 = { nan: "NaN", number: "", array: "" };
  return (t) => {
    switch (t.code) {
      case "invalid_type": {
        let n = a2[t.expected] ?? t.expected, o = w(t.input), s2 = a2[o] ?? o;
        return /^[A-Z]/.test(t.expected) ? ` :  instanceof ${t.expected},  ${s2}` : ` :  ${n},  ${s2}`;
      }
      case "invalid_value":
        return t.values.length === 1 ? ` :  ${k(t.values[0])}` : ` :    ${h(t.values, "|")}`;
      case "too_big": {
        let n = t.inclusive ? "<=" : "<", o = i(t.origin);
        return o ? ` :   ${t.origin ?? ""}   ${n}${t.maximum.toString()} ${o.unit ?? ""}` : ` :   ${t.origin ?? ""}   ${n}${t.maximum.toString()}`;
      }
      case "too_small": {
        let n = t.inclusive ? ">=" : ">", o = i(t.origin);
        return o ? ` :   ${t.origin}   ${n}${t.minimum.toString()} ${o.unit}` : ` :   ${t.origin}   ${n}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let n = t;
        if (n.format === "starts_with") return ` :     "${n.prefix}"`;
        if (n.format === "ends_with") return ` :     "${n.suffix}"`;
        if (n.format === "includes") return ` :    "${n.includes}"`;
        if (n.format === "regex") return ` :     ${n.pattern}`;
        let o = "";
        return n.format === "emoji" && (o = ""), n.format === "datetime" && (o = ""), n.format === "date" && (o = ""), n.format === "time" && (o = ""), n.format === "duration" && (o = ""), `${o} ${r2[n.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return ` :      ${t.divisor}`;
      case "unrecognized_keys":
        return `${t.keys.length > 1 ? "" : ""} ${t.keys.length > 1 ? "" : ""}: ${h(t.keys, ", ")}`;
      case "invalid_key":
        return `   ${t.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${t.origin}`;
      default:
        return " ";
    }
  };
};
function Zp() {
  return { localeError: Ap() };
}
var Cp = () => {
  let e = { string: { unit: "carcters", verb: "contenir" }, file: { unit: "bytes", verb: "contenir" }, array: { unit: "elements", verb: "contenir" }, set: { unit: "elements", verb: "contenir" } };
  function i(t) {
    return e[t] ?? null;
  }
  let r2 = { regex: "entrada", email: "adrea electrnica", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "data i hora ISO", date: "data ISO", time: "hora ISO", duration: "durada ISO", ipv4: "adrea IPv4", ipv6: "adrea IPv6", cidrv4: "rang IPv4", cidrv6: "rang IPv6", base64: "cadena codificada en base64", base64url: "cadena codificada en base64url", json_string: "cadena JSON", e164: "nmero E.164", jwt: "JWT", template_literal: "entrada" }, a2 = { nan: "NaN" };
  return (t) => {
    switch (t.code) {
      case "invalid_type": {
        let n = a2[t.expected] ?? t.expected, o = w(t.input), s2 = a2[o] ?? o;
        return /^[A-Z]/.test(t.expected) ? `Tipus invlid: s'esperava instanceof ${t.expected}, s'ha rebut ${s2}` : `Tipus invlid: s'esperava ${n}, s'ha rebut ${s2}`;
      }
      case "invalid_value":
        return t.values.length === 1 ? `Valor invlid: s'esperava ${k(t.values[0])}` : `Opci invlida: s'esperava una de ${h(t.values, " o ")}`;
      case "too_big": {
        let n = t.inclusive ? "com a mxim" : "menys de", o = i(t.origin);
        return o ? `Massa gran: s'esperava que ${t.origin ?? "el valor"} contingus ${n} ${t.maximum.toString()} ${o.unit ?? "elements"}` : `Massa gran: s'esperava que ${t.origin ?? "el valor"} fos ${n} ${t.maximum.toString()}`;
      }
      case "too_small": {
        let n = t.inclusive ? "com a mnim" : "ms de", o = i(t.origin);
        return o ? `Massa petit: s'esperava que ${t.origin} contingus ${n} ${t.minimum.toString()} ${o.unit}` : `Massa petit: s'esperava que ${t.origin} fos ${n} ${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let n = t;
        return n.format === "starts_with" ? `Format invlid: ha de comenar amb "${n.prefix}"` : n.format === "ends_with" ? `Format invlid: ha d'acabar amb "${n.suffix}"` : n.format === "includes" ? `Format invlid: ha d'incloure "${n.includes}"` : n.format === "regex" ? `Format invlid: ha de coincidir amb el patr ${n.pattern}` : `Format invlid per a ${r2[n.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `Nmero invlid: ha de ser mltiple de ${t.divisor}`;
      case "unrecognized_keys":
        return `Clau${t.keys.length > 1 ? "s" : ""} no reconeguda${t.keys.length > 1 ? "s" : ""}: ${h(t.keys, ", ")}`;
      case "invalid_key":
        return `Clau invlida a ${t.origin}`;
      case "invalid_union":
        return "Entrada invlida";
      case "invalid_element":
        return `Element invlid a ${t.origin}`;
      default:
        return "Entrada invlida";
    }
  };
};
function Lp() {
  return { localeError: Cp() };
}
var Mp = () => {
  let e = { string: { unit: "znak", verb: "mt" }, file: { unit: "bajt", verb: "mt" }, array: { unit: "prvk", verb: "mt" }, set: { unit: "prvk", verb: "mt" } };
  function i(t) {
    return e[t] ?? null;
  }
  let r2 = { regex: "regulrn vraz", email: "e-mailov adresa", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "datum a as ve formtu ISO", date: "datum ve formtu ISO", time: "as ve formtu ISO", duration: "doba trvn ISO", ipv4: "IPv4 adresa", ipv6: "IPv6 adresa", cidrv4: "rozsah IPv4", cidrv6: "rozsah IPv6", base64: "etzec zakdovan ve formtu base64", base64url: "etzec zakdovan ve formtu base64url", json_string: "etzec ve formtu JSON", e164: "slo E.164", jwt: "JWT", template_literal: "vstup" }, a2 = { nan: "NaN", number: "slo", string: "etzec", function: "funkce", array: "pole" };
  return (t) => {
    switch (t.code) {
      case "invalid_type": {
        let n = a2[t.expected] ?? t.expected, o = w(t.input), s2 = a2[o] ?? o;
        return /^[A-Z]/.test(t.expected) ? `Neplatn vstup: oekvno instanceof ${t.expected}, obdreno ${s2}` : `Neplatn vstup: oekvno ${n}, obdreno ${s2}`;
      }
      case "invalid_value":
        return t.values.length === 1 ? `Neplatn vstup: oekvno ${k(t.values[0])}` : `Neplatn monost: oekvna jedna z hodnot ${h(t.values, "|")}`;
      case "too_big": {
        let n = t.inclusive ? "<=" : "<", o = i(t.origin);
        return o ? `Hodnota je pli velk: ${t.origin ?? "hodnota"} mus mt ${n}${t.maximum.toString()} ${o.unit ?? "prvk"}` : `Hodnota je pli velk: ${t.origin ?? "hodnota"} mus bt ${n}${t.maximum.toString()}`;
      }
      case "too_small": {
        let n = t.inclusive ? ">=" : ">", o = i(t.origin);
        return o ? `Hodnota je pli mal: ${t.origin ?? "hodnota"} mus mt ${n}${t.minimum.toString()} ${o.unit ?? "prvk"}` : `Hodnota je pli mal: ${t.origin ?? "hodnota"} mus bt ${n}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let n = t;
        return n.format === "starts_with" ? `Neplatn etzec: mus zanat na "${n.prefix}"` : n.format === "ends_with" ? `Neplatn etzec: mus konit na "${n.suffix}"` : n.format === "includes" ? `Neplatn etzec: mus obsahovat "${n.includes}"` : n.format === "regex" ? `Neplatn etzec: mus odpovdat vzoru ${n.pattern}` : `Neplatn formt ${r2[n.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `Neplatn slo: mus bt nsobkem ${t.divisor}`;
      case "unrecognized_keys":
        return `Neznm kle: ${h(t.keys, ", ")}`;
      case "invalid_key":
        return `Neplatn kl v ${t.origin}`;
      case "invalid_union":
        return "Neplatn vstup";
      case "invalid_element":
        return `Neplatn hodnota v ${t.origin}`;
      default:
        return "Neplatn vstup";
    }
  };
};
function Fp() {
  return { localeError: Mp() };
}
var Jp = () => {
  let e = { string: { unit: "tegn", verb: "havde" }, file: { unit: "bytes", verb: "havde" }, array: { unit: "elementer", verb: "indeholdt" }, set: { unit: "elementer", verb: "indeholdt" } };
  function i(t) {
    return e[t] ?? null;
  }
  let r2 = { regex: "input", email: "e-mailadresse", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO dato- og klokkeslt", date: "ISO-dato", time: "ISO-klokkeslt", duration: "ISO-varighed", ipv4: "IPv4-omrde", ipv6: "IPv6-omrde", cidrv4: "IPv4-spektrum", cidrv6: "IPv6-spektrum", base64: "base64-kodet streng", base64url: "base64url-kodet streng", json_string: "JSON-streng", e164: "E.164-nummer", jwt: "JWT", template_literal: "input" }, a2 = { nan: "NaN", string: "streng", number: "tal", boolean: "boolean", array: "liste", object: "objekt", set: "st", file: "fil" };
  return (t) => {
    switch (t.code) {
      case "invalid_type": {
        let n = a2[t.expected] ?? t.expected, o = w(t.input), s2 = a2[o] ?? o;
        return /^[A-Z]/.test(t.expected) ? `Ugyldigt input: forventede instanceof ${t.expected}, fik ${s2}` : `Ugyldigt input: forventede ${n}, fik ${s2}`;
      }
      case "invalid_value":
        return t.values.length === 1 ? `Ugyldig vrdi: forventede ${k(t.values[0])}` : `Ugyldigt valg: forventede en af flgende ${h(t.values, "|")}`;
      case "too_big": {
        let n = t.inclusive ? "<=" : "<", o = i(t.origin), s2 = a2[t.origin] ?? t.origin;
        return o ? `For stor: forventede ${s2 ?? "value"} ${o.verb} ${n} ${t.maximum.toString()} ${o.unit ?? "elementer"}` : `For stor: forventede ${s2 ?? "value"} havde ${n} ${t.maximum.toString()}`;
      }
      case "too_small": {
        let n = t.inclusive ? ">=" : ">", o = i(t.origin), s2 = a2[t.origin] ?? t.origin;
        return o ? `For lille: forventede ${s2} ${o.verb} ${n} ${t.minimum.toString()} ${o.unit}` : `For lille: forventede ${s2} havde ${n} ${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let n = t;
        return n.format === "starts_with" ? `Ugyldig streng: skal starte med "${n.prefix}"` : n.format === "ends_with" ? `Ugyldig streng: skal ende med "${n.suffix}"` : n.format === "includes" ? `Ugyldig streng: skal indeholde "${n.includes}"` : n.format === "regex" ? `Ugyldig streng: skal matche mnsteret ${n.pattern}` : `Ugyldig ${r2[n.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `Ugyldigt tal: skal vre deleligt med ${t.divisor}`;
      case "unrecognized_keys":
        return `${t.keys.length > 1 ? "Ukendte ngler" : "Ukendt ngle"}: ${h(t.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig ngle i ${t.origin}`;
      case "invalid_union":
        return "Ugyldigt input: matcher ingen af de tilladte typer";
      case "invalid_element":
        return `Ugyldig vrdi i ${t.origin}`;
      default:
        return "Ugyldigt input";
    }
  };
};
function Vp() {
  return { localeError: Jp() };
}
var Gp = () => {
  let e = { string: { unit: "Zeichen", verb: "zu haben" }, file: { unit: "Bytes", verb: "zu haben" }, array: { unit: "Elemente", verb: "zu haben" }, set: { unit: "Elemente", verb: "zu haben" } };
  function i(t) {
    return e[t] ?? null;
  }
  let r2 = { regex: "Eingabe", email: "E-Mail-Adresse", url: "URL", emoji: "Emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO-Datum und -Uhrzeit", date: "ISO-Datum", time: "ISO-Uhrzeit", duration: "ISO-Dauer", ipv4: "IPv4-Adresse", ipv6: "IPv6-Adresse", cidrv4: "IPv4-Bereich", cidrv6: "IPv6-Bereich", base64: "Base64-codierter String", base64url: "Base64-URL-codierter String", json_string: "JSON-String", e164: "E.164-Nummer", jwt: "JWT", template_literal: "Eingabe" }, a2 = { nan: "NaN", number: "Zahl", array: "Array" };
  return (t) => {
    switch (t.code) {
      case "invalid_type": {
        let n = a2[t.expected] ?? t.expected, o = w(t.input), s2 = a2[o] ?? o;
        return /^[A-Z]/.test(t.expected) ? `Ungltige Eingabe: erwartet instanceof ${t.expected}, erhalten ${s2}` : `Ungltige Eingabe: erwartet ${n}, erhalten ${s2}`;
      }
      case "invalid_value":
        return t.values.length === 1 ? `Ungltige Eingabe: erwartet ${k(t.values[0])}` : `Ungltige Option: erwartet eine von ${h(t.values, "|")}`;
      case "too_big": {
        let n = t.inclusive ? "<=" : "<", o = i(t.origin);
        return o ? `Zu gro: erwartet, dass ${t.origin ?? "Wert"} ${n}${t.maximum.toString()} ${o.unit ?? "Elemente"} hat` : `Zu gro: erwartet, dass ${t.origin ?? "Wert"} ${n}${t.maximum.toString()} ist`;
      }
      case "too_small": {
        let n = t.inclusive ? ">=" : ">", o = i(t.origin);
        return o ? `Zu klein: erwartet, dass ${t.origin} ${n}${t.minimum.toString()} ${o.unit} hat` : `Zu klein: erwartet, dass ${t.origin} ${n}${t.minimum.toString()} ist`;
      }
      case "invalid_format": {
        let n = t;
        return n.format === "starts_with" ? `Ungltiger String: muss mit "${n.prefix}" beginnen` : n.format === "ends_with" ? `Ungltiger String: muss mit "${n.suffix}" enden` : n.format === "includes" ? `Ungltiger String: muss "${n.includes}" enthalten` : n.format === "regex" ? `Ungltiger String: muss dem Muster ${n.pattern} entsprechen` : `Ungltig: ${r2[n.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `Ungltige Zahl: muss ein Vielfaches von ${t.divisor} sein`;
      case "unrecognized_keys":
        return `${t.keys.length > 1 ? "Unbekannte Schlssel" : "Unbekannter Schlssel"}: ${h(t.keys, ", ")}`;
      case "invalid_key":
        return `Ungltiger Schlssel in ${t.origin}`;
      case "invalid_union":
        return "Ungltige Eingabe";
      case "invalid_element":
        return `Ungltiger Wert in ${t.origin}`;
      default:
        return "Ungltige Eingabe";
    }
  };
};
function Wp() {
  return { localeError: Gp() };
}
var qp = () => {
  let e = { string: { unit: "characters", verb: "to have" }, file: { unit: "bytes", verb: "to have" }, array: { unit: "items", verb: "to have" }, set: { unit: "items", verb: "to have" }, map: { unit: "entries", verb: "to have" } };
  function i(t) {
    return e[t] ?? null;
  }
  let r2 = { regex: "input", email: "email address", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO datetime", date: "ISO date", time: "ISO time", duration: "ISO duration", ipv4: "IPv4 address", ipv6: "IPv6 address", mac: "MAC address", cidrv4: "IPv4 range", cidrv6: "IPv6 range", base64: "base64-encoded string", base64url: "base64url-encoded string", json_string: "JSON string", e164: "E.164 number", jwt: "JWT", template_literal: "input" }, a2 = { nan: "NaN" };
  return (t) => {
    switch (t.code) {
      case "invalid_type": {
        let n = a2[t.expected] ?? t.expected, o = w(t.input), s2 = a2[o] ?? o;
        return `Invalid input: expected ${n}, received ${s2}`;
      }
      case "invalid_value":
        return t.values.length === 1 ? `Invalid input: expected ${k(t.values[0])}` : `Invalid option: expected one of ${h(t.values, "|")}`;
      case "too_big": {
        let n = t.inclusive ? "<=" : "<", o = i(t.origin);
        return o ? `Too big: expected ${t.origin ?? "value"} to have ${n}${t.maximum.toString()} ${o.unit ?? "elements"}` : `Too big: expected ${t.origin ?? "value"} to be ${n}${t.maximum.toString()}`;
      }
      case "too_small": {
        let n = t.inclusive ? ">=" : ">", o = i(t.origin);
        return o ? `Too small: expected ${t.origin} to have ${n}${t.minimum.toString()} ${o.unit}` : `Too small: expected ${t.origin} to be ${n}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let n = t;
        return n.format === "starts_with" ? `Invalid string: must start with "${n.prefix}"` : n.format === "ends_with" ? `Invalid string: must end with "${n.suffix}"` : n.format === "includes" ? `Invalid string: must include "${n.includes}"` : n.format === "regex" ? `Invalid string: must match pattern ${n.pattern}` : `Invalid ${r2[n.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${t.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${t.keys.length > 1 ? "s" : ""}: ${h(t.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${t.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${t.origin}`;
      default:
        return "Invalid input";
    }
  };
};
function Qu() {
  return { localeError: qp() };
}
var Yp = () => {
  let e = { string: { unit: "karaktrojn", verb: "havi" }, file: { unit: "bajtojn", verb: "havi" }, array: { unit: "elementojn", verb: "havi" }, set: { unit: "elementojn", verb: "havi" } };
  function i(t) {
    return e[t] ?? null;
  }
  let r2 = { regex: "enigo", email: "retadreso", url: "URL", emoji: "emoio", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO-datotempo", date: "ISO-dato", time: "ISO-tempo", duration: "ISO-daro", ipv4: "IPv4-adreso", ipv6: "IPv6-adreso", cidrv4: "IPv4-rango", cidrv6: "IPv6-rango", base64: "64-ume kodita karaktraro", base64url: "URL-64-ume kodita karaktraro", json_string: "JSON-karaktraro", e164: "E.164-nombro", jwt: "JWT", template_literal: "enigo" }, a2 = { nan: "NaN", number: "nombro", array: "tabelo", null: "senvalora" };
  return (t) => {
    switch (t.code) {
      case "invalid_type": {
        let n = a2[t.expected] ?? t.expected, o = w(t.input), s2 = a2[o] ?? o;
        return /^[A-Z]/.test(t.expected) ? `Nevalida enigo: atendiis instanceof ${t.expected}, riceviis ${s2}` : `Nevalida enigo: atendiis ${n}, riceviis ${s2}`;
      }
      case "invalid_value":
        return t.values.length === 1 ? `Nevalida enigo: atendiis ${k(t.values[0])}` : `Nevalida opcio: atendiis unu el ${h(t.values, "|")}`;
      case "too_big": {
        let n = t.inclusive ? "<=" : "<", o = i(t.origin);
        return o ? `Tro granda: atendiis ke ${t.origin ?? "valoro"} havu ${n}${t.maximum.toString()} ${o.unit ?? "elementojn"}` : `Tro granda: atendiis ke ${t.origin ?? "valoro"} havu ${n}${t.maximum.toString()}`;
      }
      case "too_small": {
        let n = t.inclusive ? ">=" : ">", o = i(t.origin);
        return o ? `Tro malgranda: atendiis ke ${t.origin} havu ${n}${t.minimum.toString()} ${o.unit}` : `Tro malgranda: atendiis ke ${t.origin} estu ${n}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let n = t;
        return n.format === "starts_with" ? `Nevalida karaktraro: devas komencii per "${n.prefix}"` : n.format === "ends_with" ? `Nevalida karaktraro: devas finii per "${n.suffix}"` : n.format === "includes" ? `Nevalida karaktraro: devas inkluzivi "${n.includes}"` : n.format === "regex" ? `Nevalida karaktraro: devas kongrui kun la modelo ${n.pattern}` : `Nevalida ${r2[n.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${t.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${t.keys.length > 1 ? "j" : ""} losilo${t.keys.length > 1 ? "j" : ""}: ${h(t.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida losilo en ${t.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${t.origin}`;
      default:
        return "Nevalida enigo";
    }
  };
};
function Bp() {
  return { localeError: Yp() };
}
var Hp = () => {
  let e = { string: { unit: "caracteres", verb: "tener" }, file: { unit: "bytes", verb: "tener" }, array: { unit: "elementos", verb: "tener" }, set: { unit: "elementos", verb: "tener" } };
  function i(t) {
    return e[t] ?? null;
  }
  let r2 = { regex: "entrada", email: "direccin de correo electrnico", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "fecha y hora ISO", date: "fecha ISO", time: "hora ISO", duration: "duracin ISO", ipv4: "direccin IPv4", ipv6: "direccin IPv6", cidrv4: "rango IPv4", cidrv6: "rango IPv6", base64: "cadena codificada en base64", base64url: "URL codificada en base64", json_string: "cadena JSON", e164: "nmero E.164", jwt: "JWT", template_literal: "entrada" }, a2 = { nan: "NaN", string: "texto", number: "nmero", boolean: "booleano", array: "arreglo", object: "objeto", set: "conjunto", file: "archivo", date: "fecha", bigint: "nmero grande", symbol: "smbolo", undefined: "indefinido", null: "nulo", function: "funcin", map: "mapa", record: "registro", tuple: "tupla", enum: "enumeracin", union: "unin", literal: "literal", promise: "promesa", void: "vaco", never: "nunca", unknown: "desconocido", any: "cualquiera" };
  return (t) => {
    switch (t.code) {
      case "invalid_type": {
        let n = a2[t.expected] ?? t.expected, o = w(t.input), s2 = a2[o] ?? o;
        return /^[A-Z]/.test(t.expected) ? `Entrada invlida: se esperaba instanceof ${t.expected}, recibido ${s2}` : `Entrada invlida: se esperaba ${n}, recibido ${s2}`;
      }
      case "invalid_value":
        return t.values.length === 1 ? `Entrada invlida: se esperaba ${k(t.values[0])}` : `Opcin invlida: se esperaba una de ${h(t.values, "|")}`;
      case "too_big": {
        let n = t.inclusive ? "<=" : "<", o = i(t.origin), s2 = a2[t.origin] ?? t.origin;
        return o ? `Demasiado grande: se esperaba que ${s2 ?? "valor"} tuviera ${n}${t.maximum.toString()} ${o.unit ?? "elementos"}` : `Demasiado grande: se esperaba que ${s2 ?? "valor"} fuera ${n}${t.maximum.toString()}`;
      }
      case "too_small": {
        let n = t.inclusive ? ">=" : ">", o = i(t.origin), s2 = a2[t.origin] ?? t.origin;
        return o ? `Demasiado pequeo: se esperaba que ${s2} tuviera ${n}${t.minimum.toString()} ${o.unit}` : `Demasiado pequeo: se esperaba que ${s2} fuera ${n}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let n = t;
        return n.format === "starts_with" ? `Cadena invlida: debe comenzar con "${n.prefix}"` : n.format === "ends_with" ? `Cadena invlida: debe terminar en "${n.suffix}"` : n.format === "includes" ? `Cadena invlida: debe incluir "${n.includes}"` : n.format === "regex" ? `Cadena invlida: debe coincidir con el patrn ${n.pattern}` : `Invlido ${r2[n.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `Nmero invlido: debe ser mltiplo de ${t.divisor}`;
      case "unrecognized_keys":
        return `Llave${t.keys.length > 1 ? "s" : ""} desconocida${t.keys.length > 1 ? "s" : ""}: ${h(t.keys, ", ")}`;
      case "invalid_key":
        return `Llave invlida en ${a2[t.origin] ?? t.origin}`;
      case "invalid_union":
        return "Entrada invlida";
      case "invalid_element":
        return `Valor invlido en ${a2[t.origin] ?? t.origin}`;
      default:
        return "Entrada invlida";
    }
  };
};
function Kp() {
  return { localeError: Hp() };
}
var Xp = () => {
  let e = { string: { unit: "", verb: " " }, file: { unit: "", verb: " " }, array: { unit: "", verb: " " }, set: { unit: "", verb: " " } };
  function i(t) {
    return e[t] ?? null;
  }
  let r2 = { regex: "", email: " ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "   ", date: " ", time: " ", duration: "  ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64-encoded ", base64url: "base64url-encoded ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "" }, a2 = { nan: "NaN", number: "", array: "" };
  return (t) => {
    switch (t.code) {
      case "invalid_type": {
        let n = a2[t.expected] ?? t.expected, o = w(t.input), s2 = a2[o] ?? o;
        return /^[A-Z]/.test(t.expected) ? ` :  instanceof ${t.expected}  ${s2}  ` : ` :  ${n}  ${s2}  `;
      }
      case "invalid_value":
        return t.values.length === 1 ? ` :  ${k(t.values[0])} ` : ` :    ${h(t.values, "|")} `;
      case "too_big": {
        let n = t.inclusive ? "<=" : "<", o = i(t.origin);
        return o ? ` : ${t.origin ?? ""}  ${n}${t.maximum.toString()} ${o.unit ?? ""} ` : ` : ${t.origin ?? ""}  ${n}${t.maximum.toString()} `;
      }
      case "too_small": {
        let n = t.inclusive ? ">=" : ">", o = i(t.origin);
        return o ? ` : ${t.origin}  ${n}${t.minimum.toString()} ${o.unit} ` : ` : ${t.origin}  ${n}${t.minimum.toString()} `;
      }
      case "invalid_format": {
        let n = t;
        return n.format === "starts_with" ? ` :   "${n.prefix}"  ` : n.format === "ends_with" ? ` :   "${n.suffix}"  ` : n.format === "includes" ? ` :   "${n.includes}" ` : n.format === "regex" ? ` :    ${n.pattern}   ` : `${r2[n.format] ?? t.format} `;
      }
      case "not_multiple_of":
        return ` :   ${t.divisor} `;
      case "unrecognized_keys":
        return `${t.keys.length > 1 ? "" : ""} : ${h(t.keys, ", ")}`;
      case "invalid_key":
        return `   ${t.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${t.origin}`;
      default:
        return " ";
    }
  };
};
function Qp() {
  return { localeError: Xp() };
}
var ev = () => {
  let e = { string: { unit: "merkki", subject: "merkkijonon" }, file: { unit: "tavua", subject: "tiedoston" }, array: { unit: "alkiota", subject: "listan" }, set: { unit: "alkiota", subject: "joukon" }, number: { unit: "", subject: "luvun" }, bigint: { unit: "", subject: "suuren kokonaisluvun" }, int: { unit: "", subject: "kokonaisluvun" }, date: { unit: "", subject: "pivmrn" } };
  function i(t) {
    return e[t] ?? null;
  }
  let r2 = { regex: "snnllinen lauseke", email: "shkpostiosoite", url: "URL-osoite", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO-aikaleima", date: "ISO-pivmr", time: "ISO-aika", duration: "ISO-kesto", ipv4: "IPv4-osoite", ipv6: "IPv6-osoite", cidrv4: "IPv4-alue", cidrv6: "IPv6-alue", base64: "base64-koodattu merkkijono", base64url: "base64url-koodattu merkkijono", json_string: "JSON-merkkijono", e164: "E.164-luku", jwt: "JWT", template_literal: "templaattimerkkijono" }, a2 = { nan: "NaN" };
  return (t) => {
    switch (t.code) {
      case "invalid_type": {
        let n = a2[t.expected] ?? t.expected, o = w(t.input), s2 = a2[o] ?? o;
        return /^[A-Z]/.test(t.expected) ? `Virheellinen tyyppi: odotettiin instanceof ${t.expected}, oli ${s2}` : `Virheellinen tyyppi: odotettiin ${n}, oli ${s2}`;
      }
      case "invalid_value":
        return t.values.length === 1 ? `Virheellinen syte: tytyy olla ${k(t.values[0])}` : `Virheellinen valinta: tytyy olla yksi seuraavista: ${h(t.values, "|")}`;
      case "too_big": {
        let n = t.inclusive ? "<=" : "<", o = i(t.origin);
        return o ? `Liian suuri: ${o.subject} tytyy olla ${n}${t.maximum.toString()} ${o.unit}`.trim() : `Liian suuri: arvon tytyy olla ${n}${t.maximum.toString()}`;
      }
      case "too_small": {
        let n = t.inclusive ? ">=" : ">", o = i(t.origin);
        return o ? `Liian pieni: ${o.subject} tytyy olla ${n}${t.minimum.toString()} ${o.unit}`.trim() : `Liian pieni: arvon tytyy olla ${n}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let n = t;
        return n.format === "starts_with" ? `Virheellinen syte: tytyy alkaa "${n.prefix}"` : n.format === "ends_with" ? `Virheellinen syte: tytyy loppua "${n.suffix}"` : n.format === "includes" ? `Virheellinen syte: tytyy sislt "${n.includes}"` : n.format === "regex" ? `Virheellinen syte: tytyy vastata snnllist lauseketta ${n.pattern}` : `Virheellinen ${r2[n.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: tytyy olla luvun ${t.divisor} monikerta`;
      case "unrecognized_keys":
        return `${t.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${h(t.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return "Virheellinen syte";
    }
  };
};
function tv() {
  return { localeError: ev() };
}
var iv = () => {
  let e = { string: { unit: "caractres", verb: "avoir" }, file: { unit: "octets", verb: "avoir" }, array: { unit: "lments", verb: "avoir" }, set: { unit: "lments", verb: "avoir" } };
  function i(t) {
    return e[t] ?? null;
  }
  let r2 = { regex: "entre", email: "adresse e-mail", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "date et heure ISO", date: "date ISO", time: "heure ISO", duration: "dure ISO", ipv4: "adresse IPv4", ipv6: "adresse IPv6", cidrv4: "plage IPv4", cidrv6: "plage IPv6", base64: "chane encode en base64", base64url: "chane encode en base64url", json_string: "chane JSON", e164: "numro E.164", jwt: "JWT", template_literal: "entre" }, a2 = { nan: "NaN", number: "nombre", array: "tableau" };
  return (t) => {
    switch (t.code) {
      case "invalid_type": {
        let n = a2[t.expected] ?? t.expected, o = w(t.input), s2 = a2[o] ?? o;
        return /^[A-Z]/.test(t.expected) ? `Entre invalide : instanceof ${t.expected} attendu, ${s2} reu` : `Entre invalide : ${n} attendu, ${s2} reu`;
      }
      case "invalid_value":
        return t.values.length === 1 ? `Entre invalide : ${k(t.values[0])} attendu` : `Option invalide : une valeur parmi ${h(t.values, "|")} attendue`;
      case "too_big": {
        let n = t.inclusive ? "<=" : "<", o = i(t.origin);
        return o ? `Trop grand : ${t.origin ?? "valeur"} doit ${o.verb} ${n}${t.maximum.toString()} ${o.unit ?? "lment(s)"}` : `Trop grand : ${t.origin ?? "valeur"} doit tre ${n}${t.maximum.toString()}`;
      }
      case "too_small": {
        let n = t.inclusive ? ">=" : ">", o = i(t.origin);
        return o ? `Trop petit : ${t.origin} doit ${o.verb} ${n}${t.minimum.toString()} ${o.unit}` : `Trop petit : ${t.origin} doit tre ${n}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let n = t;
        return n.format === "starts_with" ? `Chane invalide : doit commencer par "${n.prefix}"` : n.format === "ends_with" ? `Chane invalide : doit se terminer par "${n.suffix}"` : n.format === "includes" ? `Chane invalide : doit inclure "${n.includes}"` : n.format === "regex" ? `Chane invalide : doit correspondre au modle ${n.pattern}` : `${r2[n.format] ?? t.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit tre un multiple de ${t.divisor}`;
      case "unrecognized_keys":
        return `Cl${t.keys.length > 1 ? "s" : ""} non reconnue${t.keys.length > 1 ? "s" : ""} : ${h(t.keys, ", ")}`;
      case "invalid_key":
        return `Cl invalide dans ${t.origin}`;
      case "invalid_union":
        return "Entre invalide";
      case "invalid_element":
        return `Valeur invalide dans ${t.origin}`;
      default:
        return "Entre invalide";
    }
  };
};
function rv() {
  return { localeError: iv() };
}
var nv = () => {
  let e = { string: { unit: "caractres", verb: "avoir" }, file: { unit: "octets", verb: "avoir" }, array: { unit: "lments", verb: "avoir" }, set: { unit: "lments", verb: "avoir" } };
  function i(t) {
    return e[t] ?? null;
  }
  let r2 = { regex: "entre", email: "adresse courriel", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "date-heure ISO", date: "date ISO", time: "heure ISO", duration: "dure ISO", ipv4: "adresse IPv4", ipv6: "adresse IPv6", cidrv4: "plage IPv4", cidrv6: "plage IPv6", base64: "chane encode en base64", base64url: "chane encode en base64url", json_string: "chane JSON", e164: "numro E.164", jwt: "JWT", template_literal: "entre" }, a2 = { nan: "NaN" };
  return (t) => {
    switch (t.code) {
      case "invalid_type": {
        let n = a2[t.expected] ?? t.expected, o = w(t.input), s2 = a2[o] ?? o;
        return /^[A-Z]/.test(t.expected) ? `Entre invalide : attendu instanceof ${t.expected}, reu ${s2}` : `Entre invalide : attendu ${n}, reu ${s2}`;
      }
      case "invalid_value":
        return t.values.length === 1 ? `Entre invalide : attendu ${k(t.values[0])}` : `Option invalide : attendu l'une des valeurs suivantes ${h(t.values, "|")}`;
      case "too_big": {
        let n = t.inclusive ? "" : "<", o = i(t.origin);
        return o ? `Trop grand : attendu que ${t.origin ?? "la valeur"} ait ${n}${t.maximum.toString()} ${o.unit}` : `Trop grand : attendu que ${t.origin ?? "la valeur"} soit ${n}${t.maximum.toString()}`;
      }
      case "too_small": {
        let n = t.inclusive ? "" : ">", o = i(t.origin);
        return o ? `Trop petit : attendu que ${t.origin} ait ${n}${t.minimum.toString()} ${o.unit}` : `Trop petit : attendu que ${t.origin} soit ${n}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let n = t;
        return n.format === "starts_with" ? `Chane invalide : doit commencer par "${n.prefix}"` : n.format === "ends_with" ? `Chane invalide : doit se terminer par "${n.suffix}"` : n.format === "includes" ? `Chane invalide : doit inclure "${n.includes}"` : n.format === "regex" ? `Chane invalide : doit correspondre au motif ${n.pattern}` : `${r2[n.format] ?? t.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit tre un multiple de ${t.divisor}`;
      case "unrecognized_keys":
        return `Cl${t.keys.length > 1 ? "s" : ""} non reconnue${t.keys.length > 1 ? "s" : ""} : ${h(t.keys, ", ")}`;
      case "invalid_key":
        return `Cl invalide dans ${t.origin}`;
      case "invalid_union":
        return "Entre invalide";
      case "invalid_element":
        return `Valeur invalide dans ${t.origin}`;
      default:
        return "Entre invalide";
    }
  };
};
function av() {
  return { localeError: nv() };
}
var ov = () => {
  let e = { string: { label: "", gender: "f" }, number: { label: "", gender: "m" }, boolean: { label: " ", gender: "m" }, bigint: { label: "BigInt", gender: "m" }, date: { label: "", gender: "m" }, array: { label: "", gender: "m" }, object: { label: "", gender: "m" }, null: { label: "  (null)", gender: "m" }, undefined: { label: "   (undefined)", gender: "m" }, symbol: { label: " (Symbol)", gender: "m" }, function: { label: "", gender: "f" }, map: { label: " (Map)", gender: "f" }, set: { label: " (Set)", gender: "f" }, file: { label: "", gender: "m" }, promise: { label: "Promise", gender: "m" }, NaN: { label: "NaN", gender: "m" }, unknown: { label: "  ", gender: "m" }, value: { label: "", gender: "m" } }, i = { string: { unit: "", shortLabel: "", longLabel: "" }, file: { unit: "", shortLabel: "", longLabel: "" }, array: { unit: "", shortLabel: "", longLabel: "" }, set: { unit: "", shortLabel: "", longLabel: "" }, number: { unit: "", shortLabel: "", longLabel: "" } }, r2 = (l) => l ? e[l] : void 0, a2 = (l) => {
    let d2 = r2(l);
    return d2 ? d2.label : l ?? e.unknown.label;
  }, t = (l) => `${a2(l)}`, n = (l) => {
    var d2;
    return (((d2 = r2(l)) == null ? void 0 : d2.gender) ?? "m") === "f" ? " " : " ";
  }, o = (l) => l ? i[l] ?? null : null, s2 = { regex: { label: "", gender: "m" }, email: { label: " ", gender: "f" }, url: { label: " ", gender: "f" }, emoji: { label: "'", gender: "m" }, uuid: { label: "UUID", gender: "m" }, nanoid: { label: "nanoid", gender: "m" }, guid: { label: "GUID", gender: "m" }, cuid: { label: "cuid", gender: "m" }, cuid2: { label: "cuid2", gender: "m" }, ulid: { label: "ULID", gender: "m" }, xid: { label: "XID", gender: "m" }, ksuid: { label: "KSUID", gender: "m" }, datetime: { label: "  ISO", gender: "m" }, date: { label: " ISO", gender: "m" }, time: { label: " ISO", gender: "m" }, duration: { label: "  ISO", gender: "m" }, ipv4: { label: " IPv4", gender: "f" }, ipv6: { label: " IPv6", gender: "f" }, cidrv4: { label: " IPv4", gender: "m" }, cidrv6: { label: " IPv6", gender: "m" }, base64: { label: "  64", gender: "f" }, base64url: { label: "  64  ", gender: "f" }, json_string: { label: " JSON", gender: "f" }, e164: { label: " E.164", gender: "m" }, jwt: { label: "JWT", gender: "m" }, ends_with: { label: "", gender: "m" }, includes: { label: "", gender: "m" }, lowercase: { label: "", gender: "m" }, starts_with: { label: "", gender: "m" }, uppercase: { label: "", gender: "m" } }, u2 = { nan: "NaN" };
  return (l) => {
    var d2;
    switch (l.code) {
      case "invalid_type": {
        let c = l.expected, f2 = u2[c ?? ""] ?? a2(c), v = w(l.input), g2 = u2[v] ?? ((d2 = e[v]) == null ? void 0 : d2.label) ?? v;
        return /^[A-Z]/.test(l.expected) ? `  :   instanceof ${l.expected},  ${g2}` : `  :   ${f2},  ${g2}`;
      }
      case "invalid_value": {
        if (l.values.length === 1) return `  :    ${k(l.values[0])}`;
        let c = l.values.map((v) => k(v));
        if (l.values.length === 2) return `  :    ${c[0]}  ${c[1]}`;
        let f2 = c[c.length - 1];
        return `  :    ${c.slice(0, -1).join(", ")}  ${f2}`;
      }
      case "too_big": {
        let c = o(l.origin), f2 = t(l.origin ?? "value");
        if (l.origin === "string") return `${(c == null ? void 0 : c.longLabel) ?? ""} : ${f2}   ${l.maximum.toString()} ${(c == null ? void 0 : c.unit) ?? ""} ${l.inclusive ? " " : " "}`.trim();
        if (l.origin === "number") {
          let b = l.inclusive ? `   -${l.maximum}` : ` -${l.maximum}`;
          return ` : ${f2}   ${b}`;
        }
        if (l.origin === "array" || l.origin === "set") {
          let b = l.origin === "set" ? "" : "", $2 = l.inclusive ? `${l.maximum} ${(c == null ? void 0 : c.unit) ?? ""}  ` : ` -${l.maximum} ${(c == null ? void 0 : c.unit) ?? ""}`;
          return ` : ${f2} ${b}  ${$2}`.trim();
        }
        let v = l.inclusive ? "<=" : "<", g2 = n(l.origin ?? "value");
        return c != null && c.unit ? `${c.longLabel} : ${f2} ${g2} ${v}${l.maximum.toString()} ${c.unit}` : `${(c == null ? void 0 : c.longLabel) ?? ""} : ${f2} ${g2} ${v}${l.maximum.toString()}`;
      }
      case "too_small": {
        let c = o(l.origin), f2 = t(l.origin ?? "value");
        if (l.origin === "string") return `${(c == null ? void 0 : c.shortLabel) ?? ""} : ${f2}   ${l.minimum.toString()} ${(c == null ? void 0 : c.unit) ?? ""} ${l.inclusive ? " " : ""}`.trim();
        if (l.origin === "number") {
          let b = l.inclusive ? `   -${l.minimum}` : ` -${l.minimum}`;
          return ` : ${f2}   ${b}`;
        }
        if (l.origin === "array" || l.origin === "set") {
          let b = l.origin === "set" ? "" : "";
          if (l.minimum === 1 && l.inclusive) {
            let I2 = (l.origin === "set", "  ");
            return ` : ${f2} ${b}  ${I2}`;
          }
          let $2 = l.inclusive ? `${l.minimum} ${(c == null ? void 0 : c.unit) ?? ""}  ` : ` -${l.minimum} ${(c == null ? void 0 : c.unit) ?? ""}`;
          return ` : ${f2} ${b}  ${$2}`.trim();
        }
        let v = l.inclusive ? ">=" : ">", g2 = n(l.origin ?? "value");
        return c != null && c.unit ? `${c.shortLabel} : ${f2} ${g2} ${v}${l.minimum.toString()} ${c.unit}` : `${(c == null ? void 0 : c.shortLabel) ?? ""} : ${f2} ${g2} ${v}${l.minimum.toString()}`;
      }
      case "invalid_format": {
        let c = l;
        if (c.format === "starts_with") return `    "${c.prefix}"`;
        if (c.format === "ends_with") return `    "${c.suffix}"`;
        if (c.format === "includes") return `   "${c.includes}"`;
        if (c.format === "regex") return `    ${c.pattern}`;
        let f2 = s2[c.format], v = (f2 == null ? void 0 : f2.label) ?? c.format, g2 = ((f2 == null ? void 0 : f2.gender) ?? "m") === "f" ? "" : "";
        return `${v}  ${g2}`;
      }
      case "not_multiple_of":
        return `  :     ${l.divisor}`;
      case "unrecognized_keys":
        return `${l.keys.length > 1 ? "" : ""}  ${l.keys.length > 1 ? "" : ""}: ${h(l.keys, ", ")}`;
      case "invalid_key":
        return "   ";
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `   ${t(l.origin ?? "array")}`;
      default:
        return "  ";
    }
  };
};
function sv() {
  return { localeError: ov() };
}
var uv = () => {
  let e = { string: { unit: "karakter", verb: "legyen" }, file: { unit: "byte", verb: "legyen" }, array: { unit: "elem", verb: "legyen" }, set: { unit: "elem", verb: "legyen" } };
  function i(t) {
    return e[t] ?? null;
  }
  let r2 = { regex: "bemenet", email: "email cm", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO idblyeg", date: "ISO dtum", time: "ISO id", duration: "ISO idintervallum", ipv4: "IPv4 cm", ipv6: "IPv6 cm", cidrv4: "IPv4 tartomny", cidrv6: "IPv6 tartomny", base64: "base64-kdolt string", base64url: "base64url-kdolt string", json_string: "JSON string", e164: "E.164 szm", jwt: "JWT", template_literal: "bemenet" }, a2 = { nan: "NaN", number: "szm", array: "tmb" };
  return (t) => {
    switch (t.code) {
      case "invalid_type": {
        let n = a2[t.expected] ?? t.expected, o = w(t.input), s2 = a2[o] ?? o;
        return /^[A-Z]/.test(t.expected) ? `rvnytelen bemenet: a vrt rtk instanceof ${t.expected}, a kapott rtk ${s2}` : `rvnytelen bemenet: a vrt rtk ${n}, a kapott rtk ${s2}`;
      }
      case "invalid_value":
        return t.values.length === 1 ? `rvnytelen bemenet: a vrt rtk ${k(t.values[0])}` : `rvnytelen opci: valamelyik rtk vrt ${h(t.values, "|")}`;
      case "too_big": {
        let n = t.inclusive ? "<=" : "<", o = i(t.origin);
        return o ? `Tl nagy: ${t.origin ?? "rtk"} mrete tl nagy ${n}${t.maximum.toString()} ${o.unit ?? "elem"}` : `Tl nagy: a bemeneti rtk ${t.origin ?? "rtk"} tl nagy: ${n}${t.maximum.toString()}`;
      }
      case "too_small": {
        let n = t.inclusive ? ">=" : ">", o = i(t.origin);
        return o ? `Tl kicsi: a bemeneti rtk ${t.origin} mrete tl kicsi ${n}${t.minimum.toString()} ${o.unit}` : `Tl kicsi: a bemeneti rtk ${t.origin} tl kicsi ${n}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let n = t;
        return n.format === "starts_with" ? `rvnytelen string: "${n.prefix}" rtkkel kell kezddnie` : n.format === "ends_with" ? `rvnytelen string: "${n.suffix}" rtkkel kell vgzdnie` : n.format === "includes" ? `rvnytelen string: "${n.includes}" rtket kell tartalmaznia` : n.format === "regex" ? `rvnytelen string: ${n.pattern} mintnak kell megfelelnie` : `rvnytelen ${r2[n.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `rvnytelen szm: ${t.divisor} tbbszrsnek kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${t.keys.length > 1 ? "s" : ""}: ${h(t.keys, ", ")}`;
      case "invalid_key":
        return `rvnytelen kulcs ${t.origin}`;
      case "invalid_union":
        return "rvnytelen bemenet";
      case "invalid_element":
        return `rvnytelen rtk: ${t.origin}`;
      default:
        return "rvnytelen bemenet";
    }
  };
};
function lv() {
  return { localeError: uv() };
}
function Ha(e, i, r2) {
  return Math.abs(e) === 1 ? i : r2;
}
function Ye(e) {
  if (!e) return "";
  let i = ["", "", "", "", "", "", ""], r2 = e[e.length - 1];
  return e + (i.includes(r2) ? "" : "");
}
var dv = () => {
  let e = { string: { unit: { one: "", many: "" }, verb: "" }, file: { unit: { one: "", many: "" }, verb: "" }, array: { unit: { one: "", many: "" }, verb: "" }, set: { unit: { one: "", many: "" }, verb: "" } };
  function i(t) {
    return e[t] ?? null;
  }
  let r2 = { regex: "", email: ". ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO   ", date: "ISO ", time: "ISO ", duration: "ISO ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64  ", base64url: "base64url  ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "" }, a2 = { nan: "NaN", number: "", array: "" };
  return (t) => {
    switch (t.code) {
      case "invalid_type": {
        let n = a2[t.expected] ?? t.expected, o = w(t.input), s2 = a2[o] ?? o;
        return /^[A-Z]/.test(t.expected) ? `    instanceof ${t.expected},   ${s2}` : `    ${n},   ${s2}`;
      }
      case "invalid_value":
        return t.values.length === 1 ? `    ${k(t.values[1])}` : `      ${h(t.values, "|")}`;
      case "too_big": {
        let n = t.inclusive ? "<=" : "<", o = i(t.origin);
        if (o) {
          let s2 = Number(t.maximum), u2 = Ha(s2, o.unit.one, o.unit.many);
          return `    ,  ${Ye(t.origin ?? "")}  ${n}${t.maximum.toString()} ${u2}`;
        }
        return `    ,  ${Ye(t.origin ?? "")}  ${n}${t.maximum.toString()}`;
      }
      case "too_small": {
        let n = t.inclusive ? ">=" : ">", o = i(t.origin);
        if (o) {
          let s2 = Number(t.minimum), u2 = Ha(s2, o.unit.one, o.unit.many);
          return `    ,  ${Ye(t.origin)}  ${n}${t.minimum.toString()} ${u2}`;
        }
        return `    ,  ${Ye(t.origin)}  ${n}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let n = t;
        return n.format === "starts_with" ? `     "${n.prefix}"-` : n.format === "ends_with" ? `     "${n.suffix}"-` : n.format === "includes" ? `     "${n.includes}"` : n.format === "regex" ? `     ${n.pattern} ` : ` ${r2[n.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `      ${t.divisor}-`;
      case "unrecognized_keys":
        return ` ${t.keys.length > 1 ? "" : ""}. ${h(t.keys, ", ")}`;
      case "invalid_key":
        return `  ${Ye(t.origin)}-`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `  ${Ye(t.origin)}-`;
      default:
        return " ";
    }
  };
};
function cv() {
  return { localeError: dv() };
}
var mv = () => {
  let e = { string: { unit: "karakter", verb: "memiliki" }, file: { unit: "byte", verb: "memiliki" }, array: { unit: "item", verb: "memiliki" }, set: { unit: "item", verb: "memiliki" } };
  function i(t) {
    return e[t] ?? null;
  }
  let r2 = { regex: "input", email: "alamat email", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "tanggal dan waktu format ISO", date: "tanggal format ISO", time: "jam format ISO", duration: "durasi format ISO", ipv4: "alamat IPv4", ipv6: "alamat IPv6", cidrv4: "rentang alamat IPv4", cidrv6: "rentang alamat IPv6", base64: "string dengan enkode base64", base64url: "string dengan enkode base64url", json_string: "string JSON", e164: "angka E.164", jwt: "JWT", template_literal: "input" }, a2 = { nan: "NaN" };
  return (t) => {
    switch (t.code) {
      case "invalid_type": {
        let n = a2[t.expected] ?? t.expected, o = w(t.input), s2 = a2[o] ?? o;
        return /^[A-Z]/.test(t.expected) ? `Input tidak valid: diharapkan instanceof ${t.expected}, diterima ${s2}` : `Input tidak valid: diharapkan ${n}, diterima ${s2}`;
      }
      case "invalid_value":
        return t.values.length === 1 ? `Input tidak valid: diharapkan ${k(t.values[0])}` : `Pilihan tidak valid: diharapkan salah satu dari ${h(t.values, "|")}`;
      case "too_big": {
        let n = t.inclusive ? "<=" : "<", o = i(t.origin);
        return o ? `Terlalu besar: diharapkan ${t.origin ?? "value"} memiliki ${n}${t.maximum.toString()} ${o.unit ?? "elemen"}` : `Terlalu besar: diharapkan ${t.origin ?? "value"} menjadi ${n}${t.maximum.toString()}`;
      }
      case "too_small": {
        let n = t.inclusive ? ">=" : ">", o = i(t.origin);
        return o ? `Terlalu kecil: diharapkan ${t.origin} memiliki ${n}${t.minimum.toString()} ${o.unit}` : `Terlalu kecil: diharapkan ${t.origin} menjadi ${n}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let n = t;
        return n.format === "starts_with" ? `String tidak valid: harus dimulai dengan "${n.prefix}"` : n.format === "ends_with" ? `String tidak valid: harus berakhir dengan "${n.suffix}"` : n.format === "includes" ? `String tidak valid: harus menyertakan "${n.includes}"` : n.format === "regex" ? `String tidak valid: harus sesuai pola ${n.pattern}` : `${r2[n.format] ?? t.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${t.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${t.keys.length > 1 ? "s" : ""}: ${h(t.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${t.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${t.origin}`;
      default:
        return "Input tidak valid";
    }
  };
};
function fv() {
  return { localeError: mv() };
}
var pv = () => {
  let e = { string: { unit: "stafi", verb: "a hafa" }, file: { unit: "bti", verb: "a hafa" }, array: { unit: "hluti", verb: "a hafa" }, set: { unit: "hluti", verb: "a hafa" } };
  function i(t) {
    return e[t] ?? null;
  }
  let r2 = { regex: "gildi", email: "netfang", url: "vefsl", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO dagsetning og tmi", date: "ISO dagsetning", time: "ISO tmi", duration: "ISO tmalengd", ipv4: "IPv4 address", ipv6: "IPv6 address", cidrv4: "IPv4 range", cidrv6: "IPv6 range", base64: "base64-encoded strengur", base64url: "base64url-encoded strengur", json_string: "JSON strengur", e164: "E.164 tlugildi", jwt: "JWT", template_literal: "gildi" }, a2 = { nan: "NaN", number: "nmer", array: "fylki" };
  return (t) => {
    switch (t.code) {
      case "invalid_type": {
        let n = a2[t.expected] ?? t.expected, o = w(t.input), s2 = a2[o] ?? o;
        return /^[A-Z]/.test(t.expected) ? `Rangt gildi:  slst inn ${s2} ar sem  a vera instanceof ${t.expected}` : `Rangt gildi:  slst inn ${s2} ar sem  a vera ${n}`;
      }
      case "invalid_value":
        return t.values.length === 1 ? `Rangt gildi: gert r fyrir ${k(t.values[0])}` : `gilt val: m vera eitt af eftirfarandi ${h(t.values, "|")}`;
      case "too_big": {
        let n = t.inclusive ? "<=" : "<", o = i(t.origin);
        return o ? `Of strt: gert er r fyrir a ${t.origin ?? "gildi"} hafi ${n}${t.maximum.toString()} ${o.unit ?? "hluti"}` : `Of strt: gert er r fyrir a ${t.origin ?? "gildi"} s ${n}${t.maximum.toString()}`;
      }
      case "too_small": {
        let n = t.inclusive ? ">=" : ">", o = i(t.origin);
        return o ? `Of lti: gert er r fyrir a ${t.origin} hafi ${n}${t.minimum.toString()} ${o.unit}` : `Of lti: gert er r fyrir a ${t.origin} s ${n}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let n = t;
        return n.format === "starts_with" ? `gildur strengur: verur a byrja  "${n.prefix}"` : n.format === "ends_with" ? `gildur strengur: verur a enda  "${n.suffix}"` : n.format === "includes" ? `gildur strengur: verur a innihalda "${n.includes}"` : n.format === "regex" ? `gildur strengur: verur a fylgja mynstri ${n.pattern}` : `Rangt ${r2[n.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `Rng tala: verur a vera margfeldi af ${t.divisor}`;
      case "unrecognized_keys":
        return `ekkt ${t.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${h(t.keys, ", ")}`;
      case "invalid_key":
        return `Rangur lykill  ${t.origin}`;
      case "invalid_union":
        return "Rangt gildi";
      case "invalid_element":
        return `Rangt gildi  ${t.origin}`;
      default:
        return "Rangt gildi";
    }
  };
};
function vv() {
  return { localeError: pv() };
}
var gv = () => {
  let e = { string: { unit: "caratteri", verb: "avere" }, file: { unit: "byte", verb: "avere" }, array: { unit: "elementi", verb: "avere" }, set: { unit: "elementi", verb: "avere" } };
  function i(t) {
    return e[t] ?? null;
  }
  let r2 = { regex: "input", email: "indirizzo email", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "data e ora ISO", date: "data ISO", time: "ora ISO", duration: "durata ISO", ipv4: "indirizzo IPv4", ipv6: "indirizzo IPv6", cidrv4: "intervallo IPv4", cidrv6: "intervallo IPv6", base64: "stringa codificata in base64", base64url: "URL codificata in base64", json_string: "stringa JSON", e164: "numero E.164", jwt: "JWT", template_literal: "input" }, a2 = { nan: "NaN", number: "numero", array: "vettore" };
  return (t) => {
    switch (t.code) {
      case "invalid_type": {
        let n = a2[t.expected] ?? t.expected, o = w(t.input), s2 = a2[o] ?? o;
        return /^[A-Z]/.test(t.expected) ? `Input non valido: atteso instanceof ${t.expected}, ricevuto ${s2}` : `Input non valido: atteso ${n}, ricevuto ${s2}`;
      }
      case "invalid_value":
        return t.values.length === 1 ? `Input non valido: atteso ${k(t.values[0])}` : `Opzione non valida: atteso uno tra ${h(t.values, "|")}`;
      case "too_big": {
        let n = t.inclusive ? "<=" : "<", o = i(t.origin);
        return o ? `Troppo grande: ${t.origin ?? "valore"} deve avere ${n}${t.maximum.toString()} ${o.unit ?? "elementi"}` : `Troppo grande: ${t.origin ?? "valore"} deve essere ${n}${t.maximum.toString()}`;
      }
      case "too_small": {
        let n = t.inclusive ? ">=" : ">", o = i(t.origin);
        return o ? `Troppo piccolo: ${t.origin} deve avere ${n}${t.minimum.toString()} ${o.unit}` : `Troppo piccolo: ${t.origin} deve essere ${n}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let n = t;
        return n.format === "starts_with" ? `Stringa non valida: deve iniziare con "${n.prefix}"` : n.format === "ends_with" ? `Stringa non valida: deve terminare con "${n.suffix}"` : n.format === "includes" ? `Stringa non valida: deve includere "${n.includes}"` : n.format === "regex" ? `Stringa non valida: deve corrispondere al pattern ${n.pattern}` : `Invalid ${r2[n.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${t.divisor}`;
      case "unrecognized_keys":
        return `Chiav${t.keys.length > 1 ? "i" : "e"} non riconosciut${t.keys.length > 1 ? "e" : "a"}: ${h(t.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${t.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${t.origin}`;
      default:
        return "Input non valido";
    }
  };
};
function hv() {
  return { localeError: gv() };
}
var _v = () => {
  let e = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function i(t) {
    return e[t] ?? null;
  }
  let r2 = { regex: "", email: "", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO", date: "ISO", time: "ISO", duration: "ISO", ipv4: "IPv4", ipv6: "IPv6", cidrv4: "IPv4", cidrv6: "IPv6", base64: "base64", base64url: "base64url", json_string: "JSON", e164: "E.164", jwt: "JWT", template_literal: "" }, a2 = { nan: "NaN", number: "", array: "" };
  return (t) => {
    switch (t.code) {
      case "invalid_type": {
        let n = a2[t.expected] ?? t.expected, o = w(t.input), s2 = a2[o] ?? o;
        return /^[A-Z]/.test(t.expected) ? `: instanceof ${t.expected}${s2}` : `: ${n}${s2}`;
      }
      case "invalid_value":
        return t.values.length === 1 ? `: ${k(t.values[0])}` : `: ${h(t.values, "")}`;
      case "too_big": {
        let n = t.inclusive ? "" : "", o = i(t.origin);
        return o ? `: ${t.origin ?? ""}${t.maximum.toString()}${o.unit ?? ""}${n}` : `: ${t.origin ?? ""}${t.maximum.toString()}${n}`;
      }
      case "too_small": {
        let n = t.inclusive ? "" : "", o = i(t.origin);
        return o ? `: ${t.origin}${t.minimum.toString()}${o.unit}${n}` : `: ${t.origin}${t.minimum.toString()}${n}`;
      }
      case "invalid_format": {
        let n = t;
        return n.format === "starts_with" ? `: "${n.prefix}"` : n.format === "ends_with" ? `: "${n.suffix}"` : n.format === "includes" ? `: "${n.includes}"` : n.format === "regex" ? `: ${n.pattern}` : `${r2[n.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `: ${t.divisor}`;
      case "unrecognized_keys":
        return `${t.keys.length > 1 ? "" : ""}: ${h(t.keys, "")}`;
      case "invalid_key":
        return `${t.origin}`;
      case "invalid_union":
        return "";
      case "invalid_element":
        return `${t.origin}`;
      default:
        return "";
    }
  };
};
function bv() {
  return { localeError: _v() };
}
var yv = () => {
  let e = { string: { unit: "", verb: " " }, file: { unit: "", verb: " " }, array: { unit: "", verb: " " }, set: { unit: "", verb: " " } };
  function i(t) {
    return e[t] ?? null;
  }
  let r2 = { regex: "", email: "- ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "-", date: "", time: "", duration: "", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64- ", base64url: "base64url- ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "" }, a2 = { nan: "NaN", number: "", string: "", boolean: "", function: "", array: "" };
  return (t) => {
    switch (t.code) {
      case "invalid_type": {
        let n = a2[t.expected] ?? t.expected, o = w(t.input), s2 = a2[o] ?? o;
        return /^[A-Z]/.test(t.expected) ? ` :  instanceof ${t.expected},  ${s2}` : ` :  ${n},  ${s2}`;
      }
      case "invalid_value":
        return t.values.length === 1 ? ` :  ${k(t.values[0])}` : ` :  - ${h(t.values, "|")}-`;
      case "too_big": {
        let n = t.inclusive ? "<=" : "<", o = i(t.origin);
        return o ? ` :  ${t.origin ?? ""} ${o.verb} ${n}${t.maximum.toString()} ${o.unit}` : ` :  ${t.origin ?? ""}  ${n}${t.maximum.toString()}`;
      }
      case "too_small": {
        let n = t.inclusive ? ">=" : ">", o = i(t.origin);
        return o ? ` :  ${t.origin} ${o.verb} ${n}${t.minimum.toString()} ${o.unit}` : ` :  ${t.origin}  ${n}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let n = t;
        return n.format === "starts_with" ? ` :   "${n.prefix}"-` : n.format === "ends_with" ? ` :   "${n.suffix}"-` : n.format === "includes" ? ` :   "${n.includes}"-` : n.format === "regex" ? ` :    ${n.pattern}` : ` ${r2[n.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return ` :   ${t.divisor}- `;
      case "unrecognized_keys":
        return ` ${t.keys.length > 1 ? "" : ""}: ${h(t.keys, ", ")}`;
      case "invalid_key":
        return `  ${t.origin}-`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `  ${t.origin}-`;
      default:
        return " ";
    }
  };
};
function $v() {
  return { localeError: yv() };
}
var Iv = () => {
  let e = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function i(t) {
    return e[t] ?? null;
  }
  let r2 = { regex: "", email: "", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "  ISO", date: " ISO", time: " ISO", duration: " ISO", ipv4: " IPv4", ipv6: " IPv6", cidrv4: " IPv4", cidrv6: " IPv6", base64: " base64", base64url: " base64url", json_string: " JSON", e164: " E.164", jwt: "JWT", template_literal: "" }, a2 = { nan: "NaN", number: "", array: " (Array)", null: " (null)" };
  return (t) => {
    switch (t.code) {
      case "invalid_type": {
        let n = a2[t.expected] ?? t.expected, o = w(t.input), s2 = a2[o] ?? o;
        return /^[A-Z]/.test(t.expected) ? `  instanceof ${t.expected}  ${s2}` : `  ${n}  ${s2}`;
      }
      case "invalid_value":
        return t.values.length === 1 ? `  ${k(t.values[0])}` : `  ${h(t.values, "|")}`;
      case "too_big": {
        let n = t.inclusive ? "<=" : "<", o = i(t.origin);
        return o ? `  ${t.origin ?? ""} ${n} ${t.maximum.toString()} ${o.unit ?? ""}` : `  ${t.origin ?? ""} ${n} ${t.maximum.toString()}`;
      }
      case "too_small": {
        let n = t.inclusive ? ">=" : ">", o = i(t.origin);
        return o ? `  ${t.origin} ${n} ${t.minimum.toString()} ${o.unit}` : `  ${t.origin} ${n} ${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let n = t;
        return n.format === "starts_with" ? `  "${n.prefix}"` : n.format === "ends_with" ? `  "${n.suffix}"` : n.format === "includes" ? `  "${n.includes}"` : n.format === "regex" ? `  ${n.pattern}` : ` ${r2[n.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `  ${t.divisor}`;
      case "unrecognized_keys":
        return ` ${h(t.keys, ", ")}`;
      case "invalid_key":
        return ` ${t.origin}`;
      case "invalid_union":
        return "";
      case "invalid_element":
        return ` ${t.origin}`;
      default:
        return "";
    }
  };
};
function el() {
  return { localeError: Iv() };
}
function kv() {
  return el();
}
var wv = () => {
  let e = { string: { unit: "", verb: "to have" }, file: { unit: "", verb: "to have" }, array: { unit: "", verb: "to have" }, set: { unit: "", verb: "to have" } };
  function i(t) {
    return e[t] ?? null;
  }
  let r2 = { regex: "", email: " ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO ", date: "ISO ", time: "ISO ", duration: "ISO ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64  ", base64url: "base64url  ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "" }, a2 = { nan: "NaN" };
  return (t) => {
    switch (t.code) {
      case "invalid_type": {
        let n = a2[t.expected] ?? t.expected, o = w(t.input), s2 = a2[o] ?? o;
        return /^[A-Z]/.test(t.expected) ? ` :   instanceof ${t.expected},   ${s2}` : ` :   ${n},   ${s2}`;
      }
      case "invalid_value":
        return t.values.length === 1 ? ` :  ${k(t.values[0])}  ` : ` : ${h(t.values, " ")}   `;
      case "too_big": {
        let n = t.inclusive ? "" : "", o = n === "" ? " " : " ", s2 = i(t.origin), u2 = (s2 == null ? void 0 : s2.unit) ?? "";
        return s2 ? `${t.origin ?? ""}  : ${t.maximum.toString()}${u2} ${n}${o}` : `${t.origin ?? ""}  : ${t.maximum.toString()} ${n}${o}`;
      }
      case "too_small": {
        let n = t.inclusive ? "" : "", o = n === "" ? " " : " ", s2 = i(t.origin), u2 = (s2 == null ? void 0 : s2.unit) ?? "";
        return s2 ? `${t.origin ?? ""}  : ${t.minimum.toString()}${u2} ${n}${o}` : `${t.origin ?? ""}  : ${t.minimum.toString()} ${n}${o}`;
      }
      case "invalid_format": {
        let n = t;
        return n.format === "starts_with" ? ` : "${n.prefix}"()  ` : n.format === "ends_with" ? ` : "${n.suffix}"()  ` : n.format === "includes" ? ` : "${n.includes}"()  ` : n.format === "regex" ? ` :  ${n.pattern}   ` : ` ${r2[n.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return ` : ${t.divisor}  `;
      case "unrecognized_keys":
        return `   : ${h(t.keys, ", ")}`;
      case "invalid_key":
        return ` : ${t.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return ` : ${t.origin}`;
      default:
        return " ";
    }
  };
};
function Sv() {
  return { localeError: wv() };
}
var lt = (e) => e.charAt(0).toUpperCase() + e.slice(1);
function Ka(e) {
  let i = Math.abs(e), r2 = i % 10, a2 = i % 100;
  return a2 >= 11 && a2 <= 19 || r2 === 0 ? "many" : r2 === 1 ? "one" : "few";
}
var xv = () => {
  let e = { string: { unit: { one: "simbolis", few: "simboliai", many: "simboli" }, verb: { smaller: { inclusive: "turi bti ne ilgesn kaip", notInclusive: "turi bti trumpesn kaip" }, bigger: { inclusive: "turi bti ne trumpesn kaip", notInclusive: "turi bti ilgesn kaip" } } }, file: { unit: { one: "baitas", few: "baitai", many: "bait" }, verb: { smaller: { inclusive: "turi bti ne didesnis kaip", notInclusive: "turi bti maesnis kaip" }, bigger: { inclusive: "turi bti ne maesnis kaip", notInclusive: "turi bti didesnis kaip" } } }, array: { unit: { one: "element", few: "elementus", many: "element" }, verb: { smaller: { inclusive: "turi turti ne daugiau kaip", notInclusive: "turi turti maiau kaip" }, bigger: { inclusive: "turi turti ne maiau kaip", notInclusive: "turi turti daugiau kaip" } } }, set: { unit: { one: "element", few: "elementus", many: "element" }, verb: { smaller: { inclusive: "turi turti ne daugiau kaip", notInclusive: "turi turti maiau kaip" }, bigger: { inclusive: "turi turti ne maiau kaip", notInclusive: "turi turti daugiau kaip" } } } };
  function i(t, n, o, s2) {
    let u2 = e[t] ?? null;
    return u2 === null ? u2 : { unit: u2.unit[n], verb: u2.verb[s2][o ? "inclusive" : "notInclusive"] };
  }
  let r2 = { regex: "vestis", email: "el. pato adresas", url: "URL", emoji: "jaustukas", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO data ir laikas", date: "ISO data", time: "ISO laikas", duration: "ISO trukm", ipv4: "IPv4 adresas", ipv6: "IPv6 adresas", cidrv4: "IPv4 tinklo prefiksas (CIDR)", cidrv6: "IPv6 tinklo prefiksas (CIDR)", base64: "base64 ukoduota eilut", base64url: "base64url ukoduota eilut", json_string: "JSON eilut", e164: "E.164 numeris", jwt: "JWT", template_literal: "vestis" }, a2 = { nan: "NaN", number: "skaiius", bigint: "sveikasis skaiius", string: "eilut", boolean: "login reikm", undefined: "neapibrta reikm", function: "funkcija", symbol: "simbolis", array: "masyvas", object: "objektas", null: "nulin reikm" };
  return (t) => {
    switch (t.code) {
      case "invalid_type": {
        let n = a2[t.expected] ?? t.expected, o = w(t.input), s2 = a2[o] ?? o;
        return /^[A-Z]/.test(t.expected) ? `Gautas tipas ${s2}, o tiktasi - instanceof ${t.expected}` : `Gautas tipas ${s2}, o tiktasi - ${n}`;
      }
      case "invalid_value":
        return t.values.length === 1 ? `Privalo bti ${k(t.values[0])}` : `Privalo bti vienas i ${h(t.values, "|")} pasirinkim`;
      case "too_big": {
        let n = a2[t.origin] ?? t.origin, o = i(t.origin, Ka(Number(t.maximum)), t.inclusive ?? false, "smaller");
        if (o != null && o.verb) return `${lt(n ?? t.origin ?? "reikm")} ${o.verb} ${t.maximum.toString()} ${o.unit ?? "element"}`;
        let s2 = t.inclusive ? "ne didesnis kaip" : "maesnis kaip";
        return `${lt(n ?? t.origin ?? "reikm")} turi bti ${s2} ${t.maximum.toString()} ${o == null ? void 0 : o.unit}`;
      }
      case "too_small": {
        let n = a2[t.origin] ?? t.origin, o = i(t.origin, Ka(Number(t.minimum)), t.inclusive ?? false, "bigger");
        if (o != null && o.verb) return `${lt(n ?? t.origin ?? "reikm")} ${o.verb} ${t.minimum.toString()} ${o.unit ?? "element"}`;
        let s2 = t.inclusive ? "ne maesnis kaip" : "didesnis kaip";
        return `${lt(n ?? t.origin ?? "reikm")} turi bti ${s2} ${t.minimum.toString()} ${o == null ? void 0 : o.unit}`;
      }
      case "invalid_format": {
        let n = t;
        return n.format === "starts_with" ? `Eilut privalo prasidti "${n.prefix}"` : n.format === "ends_with" ? `Eilut privalo pasibaigti "${n.suffix}"` : n.format === "includes" ? `Eilut privalo traukti "${n.includes}"` : n.format === "regex" ? `Eilut privalo atitikti ${n.pattern}` : `Neteisingas ${r2[n.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `Skaiius privalo bti ${t.divisor} kartotinis.`;
      case "unrecognized_keys":
        return `Neatpaint${t.keys.length > 1 ? "i" : "as"} rakt${t.keys.length > 1 ? "ai" : "as"}: ${h(t.keys, ", ")}`;
      case "invalid_key":
        return "Rastas klaidingas raktas";
      case "invalid_union":
        return "Klaidinga vestis";
      case "invalid_element": {
        let n = a2[t.origin] ?? t.origin;
        return `${lt(n ?? t.origin ?? "reikm")} turi klaiding vest`;
      }
      default:
        return "Klaidinga vestis";
    }
  };
};
function Ev() {
  return { localeError: xv() };
}
var zv = () => {
  let e = { string: { unit: "", verb: " " }, file: { unit: "", verb: " " }, array: { unit: "", verb: " " }, set: { unit: "", verb: " " } };
  function i(t) {
    return e[t] ?? null;
  }
  let r2 = { regex: "", email: "  -", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO   ", date: "ISO ", time: "ISO ", duration: "ISO ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64- ", base64url: "base64url- ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "" }, a2 = { nan: "NaN", number: "", array: "" };
  return (t) => {
    switch (t.code) {
      case "invalid_type": {
        let n = a2[t.expected] ?? t.expected, o = w(t.input), s2 = a2[o] ?? o;
        return /^[A-Z]/.test(t.expected) ? ` :   instanceof ${t.expected},  ${s2}` : ` :   ${n},  ${s2}`;
      }
      case "invalid_value":
        return t.values.length === 1 ? `Invalid input: expected ${k(t.values[0])}` : ` :    ${h(t.values, "|")}`;
      case "too_big": {
        let n = t.inclusive ? "<=" : "<", o = i(t.origin);
        return o ? ` :   ${t.origin ?? ""}   ${n}${t.maximum.toString()} ${o.unit ?? ""}` : ` :   ${t.origin ?? ""}   ${n}${t.maximum.toString()}`;
      }
      case "too_small": {
        let n = t.inclusive ? ">=" : ">", o = i(t.origin);
        return o ? ` :   ${t.origin}   ${n}${t.minimum.toString()} ${o.unit}` : ` :   ${t.origin}   ${n}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let n = t;
        return n.format === "starts_with" ? ` :     "${n.prefix}"` : n.format === "ends_with" ? ` :     "${n.suffix}"` : n.format === "includes" ? ` :    "${n.includes}"` : n.format === "regex" ? ` :      ${n.pattern}` : `Invalid ${r2[n.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return ` :      ${t.divisor}`;
      case "unrecognized_keys":
        return `${t.keys.length > 1 ? " " : " "}: ${h(t.keys, ", ")}`;
      case "invalid_key":
        return `   ${t.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${t.origin}`;
      default:
        return " ";
    }
  };
};
function Tv() {
  return { localeError: zv() };
}
var Uv = () => {
  let e = { string: { unit: "aksara", verb: "mempunyai" }, file: { unit: "bait", verb: "mempunyai" }, array: { unit: "elemen", verb: "mempunyai" }, set: { unit: "elemen", verb: "mempunyai" } };
  function i(t) {
    return e[t] ?? null;
  }
  let r2 = { regex: "input", email: "alamat e-mel", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "tarikh masa ISO", date: "tarikh ISO", time: "masa ISO", duration: "tempoh ISO", ipv4: "alamat IPv4", ipv6: "alamat IPv6", cidrv4: "julat IPv4", cidrv6: "julat IPv6", base64: "string dikodkan base64", base64url: "string dikodkan base64url", json_string: "string JSON", e164: "nombor E.164", jwt: "JWT", template_literal: "input" }, a2 = { nan: "NaN", number: "nombor" };
  return (t) => {
    switch (t.code) {
      case "invalid_type": {
        let n = a2[t.expected] ?? t.expected, o = w(t.input), s2 = a2[o] ?? o;
        return /^[A-Z]/.test(t.expected) ? `Input tidak sah: dijangka instanceof ${t.expected}, diterima ${s2}` : `Input tidak sah: dijangka ${n}, diterima ${s2}`;
      }
      case "invalid_value":
        return t.values.length === 1 ? `Input tidak sah: dijangka ${k(t.values[0])}` : `Pilihan tidak sah: dijangka salah satu daripada ${h(t.values, "|")}`;
      case "too_big": {
        let n = t.inclusive ? "<=" : "<", o = i(t.origin);
        return o ? `Terlalu besar: dijangka ${t.origin ?? "nilai"} ${o.verb} ${n}${t.maximum.toString()} ${o.unit ?? "elemen"}` : `Terlalu besar: dijangka ${t.origin ?? "nilai"} adalah ${n}${t.maximum.toString()}`;
      }
      case "too_small": {
        let n = t.inclusive ? ">=" : ">", o = i(t.origin);
        return o ? `Terlalu kecil: dijangka ${t.origin} ${o.verb} ${n}${t.minimum.toString()} ${o.unit}` : `Terlalu kecil: dijangka ${t.origin} adalah ${n}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let n = t;
        return n.format === "starts_with" ? `String tidak sah: mesti bermula dengan "${n.prefix}"` : n.format === "ends_with" ? `String tidak sah: mesti berakhir dengan "${n.suffix}"` : n.format === "includes" ? `String tidak sah: mesti mengandungi "${n.includes}"` : n.format === "regex" ? `String tidak sah: mesti sepadan dengan corak ${n.pattern}` : `${r2[n.format] ?? t.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${t.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${h(t.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${t.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${t.origin}`;
      default:
        return "Input tidak sah";
    }
  };
};
function Ov() {
  return { localeError: Uv() };
}
var Nv = () => {
  let e = { string: { unit: "tekens", verb: "heeft" }, file: { unit: "bytes", verb: "heeft" }, array: { unit: "elementen", verb: "heeft" }, set: { unit: "elementen", verb: "heeft" } };
  function i(t) {
    return e[t] ?? null;
  }
  let r2 = { regex: "invoer", email: "emailadres", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO datum en tijd", date: "ISO datum", time: "ISO tijd", duration: "ISO duur", ipv4: "IPv4-adres", ipv6: "IPv6-adres", cidrv4: "IPv4-bereik", cidrv6: "IPv6-bereik", base64: "base64-gecodeerde tekst", base64url: "base64 URL-gecodeerde tekst", json_string: "JSON string", e164: "E.164-nummer", jwt: "JWT", template_literal: "invoer" }, a2 = { nan: "NaN", number: "getal" };
  return (t) => {
    switch (t.code) {
      case "invalid_type": {
        let n = a2[t.expected] ?? t.expected, o = w(t.input), s2 = a2[o] ?? o;
        return /^[A-Z]/.test(t.expected) ? `Ongeldige invoer: verwacht instanceof ${t.expected}, ontving ${s2}` : `Ongeldige invoer: verwacht ${n}, ontving ${s2}`;
      }
      case "invalid_value":
        return t.values.length === 1 ? `Ongeldige invoer: verwacht ${k(t.values[0])}` : `Ongeldige optie: verwacht n van ${h(t.values, "|")}`;
      case "too_big": {
        let n = t.inclusive ? "<=" : "<", o = i(t.origin), s2 = t.origin === "date" ? "laat" : t.origin === "string" ? "lang" : "groot";
        return o ? `Te ${s2}: verwacht dat ${t.origin ?? "waarde"} ${n}${t.maximum.toString()} ${o.unit ?? "elementen"} ${o.verb}` : `Te ${s2}: verwacht dat ${t.origin ?? "waarde"} ${n}${t.maximum.toString()} is`;
      }
      case "too_small": {
        let n = t.inclusive ? ">=" : ">", o = i(t.origin), s2 = t.origin === "date" ? "vroeg" : t.origin === "string" ? "kort" : "klein";
        return o ? `Te ${s2}: verwacht dat ${t.origin} ${n}${t.minimum.toString()} ${o.unit} ${o.verb}` : `Te ${s2}: verwacht dat ${t.origin} ${n}${t.minimum.toString()} is`;
      }
      case "invalid_format": {
        let n = t;
        return n.format === "starts_with" ? `Ongeldige tekst: moet met "${n.prefix}" beginnen` : n.format === "ends_with" ? `Ongeldige tekst: moet op "${n.suffix}" eindigen` : n.format === "includes" ? `Ongeldige tekst: moet "${n.includes}" bevatten` : n.format === "regex" ? `Ongeldige tekst: moet overeenkomen met patroon ${n.pattern}` : `Ongeldig: ${r2[n.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${t.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${t.keys.length > 1 ? "s" : ""}: ${h(t.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${t.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${t.origin}`;
      default:
        return "Ongeldige invoer";
    }
  };
};
function Rv() {
  return { localeError: Nv() };
}
var Pv = () => {
  let e = { string: { unit: "tegn", verb: " ha" }, file: { unit: "bytes", verb: " ha" }, array: { unit: "elementer", verb: " inneholde" }, set: { unit: "elementer", verb: " inneholde" } };
  function i(t) {
    return e[t] ?? null;
  }
  let r2 = { regex: "input", email: "e-postadresse", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO dato- og klokkeslett", date: "ISO-dato", time: "ISO-klokkeslett", duration: "ISO-varighet", ipv4: "IPv4-omrde", ipv6: "IPv6-omrde", cidrv4: "IPv4-spekter", cidrv6: "IPv6-spekter", base64: "base64-enkodet streng", base64url: "base64url-enkodet streng", json_string: "JSON-streng", e164: "E.164-nummer", jwt: "JWT", template_literal: "input" }, a2 = { nan: "NaN", number: "tall", array: "liste" };
  return (t) => {
    switch (t.code) {
      case "invalid_type": {
        let n = a2[t.expected] ?? t.expected, o = w(t.input), s2 = a2[o] ?? o;
        return /^[A-Z]/.test(t.expected) ? `Ugyldig input: forventet instanceof ${t.expected}, fikk ${s2}` : `Ugyldig input: forventet ${n}, fikk ${s2}`;
      }
      case "invalid_value":
        return t.values.length === 1 ? `Ugyldig verdi: forventet ${k(t.values[0])}` : `Ugyldig valg: forventet en av ${h(t.values, "|")}`;
      case "too_big": {
        let n = t.inclusive ? "<=" : "<", o = i(t.origin);
        return o ? `For stor(t): forventet ${t.origin ?? "value"} til  ha ${n}${t.maximum.toString()} ${o.unit ?? "elementer"}` : `For stor(t): forventet ${t.origin ?? "value"} til  ha ${n}${t.maximum.toString()}`;
      }
      case "too_small": {
        let n = t.inclusive ? ">=" : ">", o = i(t.origin);
        return o ? `For lite(n): forventet ${t.origin} til  ha ${n}${t.minimum.toString()} ${o.unit}` : `For lite(n): forventet ${t.origin} til  ha ${n}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let n = t;
        return n.format === "starts_with" ? `Ugyldig streng: m starte med "${n.prefix}"` : n.format === "ends_with" ? `Ugyldig streng: m ende med "${n.suffix}"` : n.format === "includes" ? `Ugyldig streng: m inneholde "${n.includes}"` : n.format === "regex" ? `Ugyldig streng: m matche mnsteret ${n.pattern}` : `Ugyldig ${r2[n.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: m vre et multiplum av ${t.divisor}`;
      case "unrecognized_keys":
        return `${t.keys.length > 1 ? "Ukjente nkler" : "Ukjent nkkel"}: ${h(t.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig nkkel i ${t.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${t.origin}`;
      default:
        return "Ugyldig input";
    }
  };
};
function Dv() {
  return { localeError: Pv() };
}
var jv = () => {
  let e = { string: { unit: "harf", verb: "olmaldr" }, file: { unit: "bayt", verb: "olmaldr" }, array: { unit: "unsur", verb: "olmaldr" }, set: { unit: "unsur", verb: "olmaldr" } };
  function i(t) {
    return e[t] ?? null;
  }
  let r2 = { regex: "giren", email: "epostagh", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO hengm", date: "ISO tarihi", time: "ISO zaman", duration: "ISO mddeti", ipv4: "IPv4 nin", ipv6: "IPv6 nin", cidrv4: "IPv4 menzili", cidrv6: "IPv6 menzili", base64: "base64-ifreli metin", base64url: "base64url-ifreli metin", json_string: "JSON metin", e164: "E.164 says", jwt: "JWT", template_literal: "giren" }, a2 = { nan: "NaN", number: "numara", array: "saf", null: "gayb" };
  return (t) => {
    switch (t.code) {
      case "invalid_type": {
        let n = a2[t.expected] ?? t.expected, o = w(t.input), s2 = a2[o] ?? o;
        return /^[A-Z]/.test(t.expected) ? `Fsit giren: umulan instanceof ${t.expected}, alnan ${s2}` : `Fsit giren: umulan ${n}, alnan ${s2}`;
      }
      case "invalid_value":
        return t.values.length === 1 ? `Fsit giren: umulan ${k(t.values[0])}` : `Fsit tercih: mteberler ${h(t.values, "|")}`;
      case "too_big": {
        let n = t.inclusive ? "<=" : "<", o = i(t.origin);
        return o ? `Fazla byk: ${t.origin ?? "value"}, ${n}${t.maximum.toString()} ${o.unit ?? "elements"} sahip olmalyd.` : `Fazla byk: ${t.origin ?? "value"}, ${n}${t.maximum.toString()} olmalyd.`;
      }
      case "too_small": {
        let n = t.inclusive ? ">=" : ">", o = i(t.origin);
        return o ? `Fazla kk: ${t.origin}, ${n}${t.minimum.toString()} ${o.unit} sahip olmalyd.` : `Fazla kk: ${t.origin}, ${n}${t.minimum.toString()} olmalyd.`;
      }
      case "invalid_format": {
        let n = t;
        return n.format === "starts_with" ? `Fsit metin: "${n.prefix}" ile balamal.` : n.format === "ends_with" ? `Fsit metin: "${n.suffix}" ile bitmeli.` : n.format === "includes" ? `Fsit metin: "${n.includes}" ihtiv etmeli.` : n.format === "regex" ? `Fsit metin: ${n.pattern} nakna uymal.` : `Fsit ${r2[n.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `Fsit say: ${t.divisor} kat olmalyd.`;
      case "unrecognized_keys":
        return `Tannmayan anahtar ${t.keys.length > 1 ? "s" : ""}: ${h(t.keys, ", ")}`;
      case "invalid_key":
        return `${t.origin} iin tannmayan anahtar var.`;
      case "invalid_union":
        return "Giren tannamad.";
      case "invalid_element":
        return `${t.origin} iin tannmayan kymet var.`;
      default:
        return "Kymet tannamad.";
    }
  };
};
function Av() {
  return { localeError: jv() };
}
var Zv = () => {
  let e = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function i(t) {
    return e[t] ?? null;
  }
  let r2 = { regex: "", email: "", url: "  ", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "  ", date: "", time: "", duration: "", ipv4: " IPv4 ", ipv6: " IPv6 ", cidrv4: " IPv4 ", cidrv6: " IPv6 ", base64: "base64-encoded ", base64url: "base64url-encoded ", json_string: "JSON ", e164: " E.164 ", jwt: "JWT", template_literal: "" }, a2 = { nan: "NaN", number: "", array: "" };
  return (t) => {
    switch (t.code) {
      case "invalid_type": {
        let n = a2[t.expected] ?? t.expected, o = w(t.input), s2 = a2[o] ?? o;
        return /^[A-Z]/.test(t.expected) ? ` :  instanceof ${t.expected} ,  ${s2}  ` : ` :  ${n} ,  ${s2}  `;
      }
      case "invalid_value":
        return t.values.length === 1 ? ` :  ${k(t.values[0])} ` : ` :    ${h(t.values, "|")}  `;
      case "too_big": {
        let n = t.inclusive ? "<=" : "<", o = i(t.origin);
        return o ? ` : ${t.origin ?? ""}  ${n}${t.maximum.toString()} ${o.unit ?? ""} ` : ` : ${t.origin ?? ""}  ${n}${t.maximum.toString()} `;
      }
      case "too_small": {
        let n = t.inclusive ? ">=" : ">", o = i(t.origin);
        return o ? ` : ${t.origin}  ${n}${t.minimum.toString()} ${o.unit} ` : ` : ${t.origin}  ${n}${t.minimum.toString()} `;
      }
      case "invalid_format": {
        let n = t;
        return n.format === "starts_with" ? ` :   "${n.prefix}"   ` : n.format === "ends_with" ? ` :   "${n.suffix}"    ` : n.format === "includes" ? ` :  "${n.includes}" ` : n.format === "regex" ? ` :   ${n.pattern}   ` : `${r2[n.format] ?? t.format}  `;
      }
      case "not_multiple_of":
        return ` :   ${t.divisor}  `;
      case "unrecognized_keys":
        return ` ${t.keys.length > 1 ? "" : ""}: ${h(t.keys, ", ")}`;
      case "invalid_key":
        return `   ${t.origin} `;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${t.origin} `;
      default:
        return " ";
    }
  };
};
function Cv() {
  return { localeError: Zv() };
}
var Lv = () => {
  let e = { string: { unit: "znakw", verb: "mie" }, file: { unit: "bajtw", verb: "mie" }, array: { unit: "elementw", verb: "mie" }, set: { unit: "elementw", verb: "mie" } };
  function i(t) {
    return e[t] ?? null;
  }
  let r2 = { regex: "wyraenie", email: "adres email", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "data i godzina w formacie ISO", date: "data w formacie ISO", time: "godzina w formacie ISO", duration: "czas trwania ISO", ipv4: "adres IPv4", ipv6: "adres IPv6", cidrv4: "zakres IPv4", cidrv6: "zakres IPv6", base64: "cig znakw zakodowany w formacie base64", base64url: "cig znakw zakodowany w formacie base64url", json_string: "cig znakw w formacie JSON", e164: "liczba E.164", jwt: "JWT", template_literal: "wejcie" }, a2 = { nan: "NaN", number: "liczba", array: "tablica" };
  return (t) => {
    switch (t.code) {
      case "invalid_type": {
        let n = a2[t.expected] ?? t.expected, o = w(t.input), s2 = a2[o] ?? o;
        return /^[A-Z]/.test(t.expected) ? `Nieprawidowe dane wejciowe: oczekiwano instanceof ${t.expected}, otrzymano ${s2}` : `Nieprawidowe dane wejciowe: oczekiwano ${n}, otrzymano ${s2}`;
      }
      case "invalid_value":
        return t.values.length === 1 ? `Nieprawidowe dane wejciowe: oczekiwano ${k(t.values[0])}` : `Nieprawidowa opcja: oczekiwano jednej z wartoci ${h(t.values, "|")}`;
      case "too_big": {
        let n = t.inclusive ? "<=" : "<", o = i(t.origin);
        return o ? `Za dua warto: oczekiwano, e ${t.origin ?? "warto"} bdzie mie ${n}${t.maximum.toString()} ${o.unit ?? "elementw"}` : `Zbyt du(y/a/e): oczekiwano, e ${t.origin ?? "warto"} bdzie wynosi ${n}${t.maximum.toString()}`;
      }
      case "too_small": {
        let n = t.inclusive ? ">=" : ">", o = i(t.origin);
        return o ? `Za maa warto: oczekiwano, e ${t.origin ?? "warto"} bdzie mie ${n}${t.minimum.toString()} ${o.unit ?? "elementw"}` : `Zbyt ma(y/a/e): oczekiwano, e ${t.origin ?? "warto"} bdzie wynosi ${n}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let n = t;
        return n.format === "starts_with" ? `Nieprawidowy cig znakw: musi zaczyna si od "${n.prefix}"` : n.format === "ends_with" ? `Nieprawidowy cig znakw: musi koczy si na "${n.suffix}"` : n.format === "includes" ? `Nieprawidowy cig znakw: musi zawiera "${n.includes}"` : n.format === "regex" ? `Nieprawidowy cig znakw: musi odpowiada wzorcowi ${n.pattern}` : `Nieprawidow(y/a/e) ${r2[n.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `Nieprawidowa liczba: musi by wielokrotnoci ${t.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${t.keys.length > 1 ? "s" : ""}: ${h(t.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawidowy klucz w ${t.origin}`;
      case "invalid_union":
        return "Nieprawidowe dane wejciowe";
      case "invalid_element":
        return `Nieprawidowa warto w ${t.origin}`;
      default:
        return "Nieprawidowe dane wejciowe";
    }
  };
};
function Mv() {
  return { localeError: Lv() };
}
var Fv = () => {
  let e = { string: { unit: "caracteres", verb: "ter" }, file: { unit: "bytes", verb: "ter" }, array: { unit: "itens", verb: "ter" }, set: { unit: "itens", verb: "ter" } };
  function i(t) {
    return e[t] ?? null;
  }
  let r2 = { regex: "padro", email: "endereo de e-mail", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "data e hora ISO", date: "data ISO", time: "hora ISO", duration: "durao ISO", ipv4: "endereo IPv4", ipv6: "endereo IPv6", cidrv4: "faixa de IPv4", cidrv6: "faixa de IPv6", base64: "texto codificado em base64", base64url: "URL codificada em base64", json_string: "texto JSON", e164: "nmero E.164", jwt: "JWT", template_literal: "entrada" }, a2 = { nan: "NaN", number: "nmero", null: "nulo" };
  return (t) => {
    switch (t.code) {
      case "invalid_type": {
        let n = a2[t.expected] ?? t.expected, o = w(t.input), s2 = a2[o] ?? o;
        return /^[A-Z]/.test(t.expected) ? `Tipo invlido: esperado instanceof ${t.expected}, recebido ${s2}` : `Tipo invlido: esperado ${n}, recebido ${s2}`;
      }
      case "invalid_value":
        return t.values.length === 1 ? `Entrada invlida: esperado ${k(t.values[0])}` : `Opo invlida: esperada uma das ${h(t.values, "|")}`;
      case "too_big": {
        let n = t.inclusive ? "<=" : "<", o = i(t.origin);
        return o ? `Muito grande: esperado que ${t.origin ?? "valor"} tivesse ${n}${t.maximum.toString()} ${o.unit ?? "elementos"}` : `Muito grande: esperado que ${t.origin ?? "valor"} fosse ${n}${t.maximum.toString()}`;
      }
      case "too_small": {
        let n = t.inclusive ? ">=" : ">", o = i(t.origin);
        return o ? `Muito pequeno: esperado que ${t.origin} tivesse ${n}${t.minimum.toString()} ${o.unit}` : `Muito pequeno: esperado que ${t.origin} fosse ${n}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let n = t;
        return n.format === "starts_with" ? `Texto invlido: deve comear com "${n.prefix}"` : n.format === "ends_with" ? `Texto invlido: deve terminar com "${n.suffix}"` : n.format === "includes" ? `Texto invlido: deve incluir "${n.includes}"` : n.format === "regex" ? `Texto invlido: deve corresponder ao padro ${n.pattern}` : `${r2[n.format] ?? t.format} invlido`;
      }
      case "not_multiple_of":
        return `Nmero invlido: deve ser mltiplo de ${t.divisor}`;
      case "unrecognized_keys":
        return `Chave${t.keys.length > 1 ? "s" : ""} desconhecida${t.keys.length > 1 ? "s" : ""}: ${h(t.keys, ", ")}`;
      case "invalid_key":
        return `Chave invlida em ${t.origin}`;
      case "invalid_union":
        return "Entrada invlida";
      case "invalid_element":
        return `Valor invlido em ${t.origin}`;
      default:
        return "Campo invlido";
    }
  };
};
function Jv() {
  return { localeError: Fv() };
}
function Xa(e, i, r2, a2) {
  let t = Math.abs(e), n = t % 10, o = t % 100;
  return o >= 11 && o <= 19 ? a2 : n === 1 ? i : n >= 2 && n <= 4 ? r2 : a2;
}
var Vv = () => {
  let e = { string: { unit: { one: "", few: "", many: "" }, verb: "" }, file: { unit: { one: "", few: "", many: "" }, verb: "" }, array: { unit: { one: "", few: "", many: "" }, verb: "" }, set: { unit: { one: "", few: "", many: "" }, verb: "" } };
  function i(t) {
    return e[t] ?? null;
  }
  let r2 = { regex: "", email: "email ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO   ", date: "ISO ", time: "ISO ", duration: "ISO ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "   base64", base64url: "   base64url", json_string: "JSON ", e164: " E.164", jwt: "JWT", template_literal: "" }, a2 = { nan: "NaN", number: "", array: "" };
  return (t) => {
    switch (t.code) {
      case "invalid_type": {
        let n = a2[t.expected] ?? t.expected, o = w(t.input), s2 = a2[o] ?? o;
        return /^[A-Z]/.test(t.expected) ? ` :  instanceof ${t.expected},  ${s2}` : ` :  ${n},  ${s2}`;
      }
      case "invalid_value":
        return t.values.length === 1 ? ` :  ${k(t.values[0])}` : ` :    ${h(t.values, "|")}`;
      case "too_big": {
        let n = t.inclusive ? "<=" : "<", o = i(t.origin);
        if (o) {
          let s2 = Number(t.maximum), u2 = Xa(s2, o.unit.one, o.unit.few, o.unit.many);
          return `  : ,  ${t.origin ?? ""}   ${n}${t.maximum.toString()} ${u2}`;
        }
        return `  : ,  ${t.origin ?? ""}  ${n}${t.maximum.toString()}`;
      }
      case "too_small": {
        let n = t.inclusive ? ">=" : ">", o = i(t.origin);
        if (o) {
          let s2 = Number(t.minimum), u2 = Xa(s2, o.unit.one, o.unit.few, o.unit.many);
          return `  : ,  ${t.origin}   ${n}${t.minimum.toString()} ${u2}`;
        }
        return `  : ,  ${t.origin}  ${n}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let n = t;
        return n.format === "starts_with" ? ` :    "${n.prefix}"` : n.format === "ends_with" ? ` :    "${n.suffix}"` : n.format === "includes" ? ` :   "${n.includes}"` : n.format === "regex" ? ` :    ${n.pattern}` : ` ${r2[n.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return ` :    ${t.divisor}`;
      case "unrecognized_keys":
        return `${t.keys.length > 1 ? "" : ""} ${t.keys.length > 1 ? "" : ""}: ${h(t.keys, ", ")}`;
      case "invalid_key":
        return `   ${t.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `   ${t.origin}`;
      default:
        return "  ";
    }
  };
};
function Gv() {
  return { localeError: Vv() };
}
var Wv = () => {
  let e = { string: { unit: "znakov", verb: "imeti" }, file: { unit: "bajtov", verb: "imeti" }, array: { unit: "elementov", verb: "imeti" }, set: { unit: "elementov", verb: "imeti" } };
  function i(t) {
    return e[t] ?? null;
  }
  let r2 = { regex: "vnos", email: "e-potni naslov", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO datum in as", date: "ISO datum", time: "ISO as", duration: "ISO trajanje", ipv4: "IPv4 naslov", ipv6: "IPv6 naslov", cidrv4: "obseg IPv4", cidrv6: "obseg IPv6", base64: "base64 kodiran niz", base64url: "base64url kodiran niz", json_string: "JSON niz", e164: "E.164 tevilka", jwt: "JWT", template_literal: "vnos" }, a2 = { nan: "NaN", number: "tevilo", array: "tabela" };
  return (t) => {
    switch (t.code) {
      case "invalid_type": {
        let n = a2[t.expected] ?? t.expected, o = w(t.input), s2 = a2[o] ?? o;
        return /^[A-Z]/.test(t.expected) ? `Neveljaven vnos: priakovano instanceof ${t.expected}, prejeto ${s2}` : `Neveljaven vnos: priakovano ${n}, prejeto ${s2}`;
      }
      case "invalid_value":
        return t.values.length === 1 ? `Neveljaven vnos: priakovano ${k(t.values[0])}` : `Neveljavna monost: priakovano eno izmed ${h(t.values, "|")}`;
      case "too_big": {
        let n = t.inclusive ? "<=" : "<", o = i(t.origin);
        return o ? `Preveliko: priakovano, da bo ${t.origin ?? "vrednost"} imelo ${n}${t.maximum.toString()} ${o.unit ?? "elementov"}` : `Preveliko: priakovano, da bo ${t.origin ?? "vrednost"} ${n}${t.maximum.toString()}`;
      }
      case "too_small": {
        let n = t.inclusive ? ">=" : ">", o = i(t.origin);
        return o ? `Premajhno: priakovano, da bo ${t.origin} imelo ${n}${t.minimum.toString()} ${o.unit}` : `Premajhno: priakovano, da bo ${t.origin} ${n}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let n = t;
        return n.format === "starts_with" ? `Neveljaven niz: mora se zaeti z "${n.prefix}"` : n.format === "ends_with" ? `Neveljaven niz: mora se konati z "${n.suffix}"` : n.format === "includes" ? `Neveljaven niz: mora vsebovati "${n.includes}"` : n.format === "regex" ? `Neveljaven niz: mora ustrezati vzorcu ${n.pattern}` : `Neveljaven ${r2[n.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno tevilo: mora biti vekratnik ${t.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${t.keys.length > 1 ? "i kljui" : " klju"}: ${h(t.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven klju v ${t.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${t.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
};
function qv() {
  return { localeError: Wv() };
}
var Yv = () => {
  let e = { string: { unit: "tecken", verb: "att ha" }, file: { unit: "bytes", verb: "att ha" }, array: { unit: "objekt", verb: "att innehlla" }, set: { unit: "objekt", verb: "att innehlla" } };
  function i(t) {
    return e[t] ?? null;
  }
  let r2 = { regex: "reguljrt uttryck", email: "e-postadress", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO-datum och tid", date: "ISO-datum", time: "ISO-tid", duration: "ISO-varaktighet", ipv4: "IPv4-intervall", ipv6: "IPv6-intervall", cidrv4: "IPv4-spektrum", cidrv6: "IPv6-spektrum", base64: "base64-kodad strng", base64url: "base64url-kodad strng", json_string: "JSON-strng", e164: "E.164-nummer", jwt: "JWT", template_literal: "mall-literal" }, a2 = { nan: "NaN", number: "antal", array: "lista" };
  return (t) => {
    switch (t.code) {
      case "invalid_type": {
        let n = a2[t.expected] ?? t.expected, o = w(t.input), s2 = a2[o] ?? o;
        return /^[A-Z]/.test(t.expected) ? `Ogiltig inmatning: frvntat instanceof ${t.expected}, fick ${s2}` : `Ogiltig inmatning: frvntat ${n}, fick ${s2}`;
      }
      case "invalid_value":
        return t.values.length === 1 ? `Ogiltig inmatning: frvntat ${k(t.values[0])}` : `Ogiltigt val: frvntade en av ${h(t.values, "|")}`;
      case "too_big": {
        let n = t.inclusive ? "<=" : "<", o = i(t.origin);
        return o ? `Fr stor(t): frvntade ${t.origin ?? "vrdet"} att ha ${n}${t.maximum.toString()} ${o.unit ?? "element"}` : `Fr stor(t): frvntat ${t.origin ?? "vrdet"} att ha ${n}${t.maximum.toString()}`;
      }
      case "too_small": {
        let n = t.inclusive ? ">=" : ">", o = i(t.origin);
        return o ? `Fr lite(t): frvntade ${t.origin ?? "vrdet"} att ha ${n}${t.minimum.toString()} ${o.unit}` : `Fr lite(t): frvntade ${t.origin ?? "vrdet"} att ha ${n}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let n = t;
        return n.format === "starts_with" ? `Ogiltig strng: mste brja med "${n.prefix}"` : n.format === "ends_with" ? `Ogiltig strng: mste sluta med "${n.suffix}"` : n.format === "includes" ? `Ogiltig strng: mste innehlla "${n.includes}"` : n.format === "regex" ? `Ogiltig strng: mste matcha mnstret "${n.pattern}"` : `Ogiltig(t) ${r2[n.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: mste vara en multipel av ${t.divisor}`;
      case "unrecognized_keys":
        return `${t.keys.length > 1 ? "Oknda nycklar" : "Oknd nyckel"}: ${h(t.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${t.origin ?? "vrdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt vrde i ${t.origin ?? "vrdet"}`;
      default:
        return "Ogiltig input";
    }
  };
};
function Bv() {
  return { localeError: Yv() };
}
var Hv = () => {
  let e = { string: { unit: "", verb: " " }, file: { unit: "", verb: " " }, array: { unit: "", verb: " " }, set: { unit: "", verb: " " } };
  function i(t) {
    return e[t] ?? null;
  }
  let r2 = { regex: "", email: " ", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO  ", date: "ISO ", time: "ISO ", duration: "ISO  ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64-encoded ", base64url: "base64url-encoded ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "input" }, a2 = { nan: "NaN", number: "", array: "", null: "" };
  return (t) => {
    switch (t.code) {
      case "invalid_type": {
        let n = a2[t.expected] ?? t.expected, o = w(t.input), s2 = a2[o] ?? o;
        return /^[A-Z]/.test(t.expected) ? ` :  instanceof ${t.expected},  ${s2}` : ` :  ${n},  ${s2}`;
      }
      case "invalid_value":
        return t.values.length === 1 ? ` :  ${k(t.values[0])}` : ` :  ${h(t.values, "|")}  `;
      case "too_big": {
        let n = t.inclusive ? "<=" : "<", o = i(t.origin);
        return o ? ` :  ${t.origin ?? ""} ${n}${t.maximum.toString()} ${o.unit ?? ""}   ` : ` :  ${t.origin ?? ""} ${n}${t.maximum.toString()}   `;
      }
      case "too_small": {
        let n = t.inclusive ? ">=" : ">", o = i(t.origin);
        return o ? ` :  ${t.origin} ${n}${t.minimum.toString()} ${o.unit}   ` : ` :  ${t.origin} ${n}${t.minimum.toString()}   `;
      }
      case "invalid_format": {
        let n = t;
        return n.format === "starts_with" ? ` : "${n.prefix}"   ` : n.format === "ends_with" ? ` : "${n.suffix}"   ` : n.format === "includes" ? ` : "${n.includes}"   ` : n.format === "regex" ? ` : ${n.pattern}   ` : ` ${r2[n.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return ` : ${t.divisor}    `;
      case "unrecognized_keys":
        return `  ${t.keys.length > 1 ? "" : ""}: ${h(t.keys, ", ")}`;
      case "invalid_key":
        return `${t.origin}   `;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `${t.origin}   `;
      default:
        return " ";
    }
  };
};
function Kv() {
  return { localeError: Hv() };
}
var Xv = () => {
  let e = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function i(t) {
    return e[t] ?? null;
  }
  let r2 = { regex: "", email: "", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: " ISO", date: " ISO", time: " ISO", duration: " ISO", ipv4: " IPv4", ipv6: " IPv6", cidrv4: " IP  IPv4", cidrv6: " IP  IPv6", base64: " Base64", base64url: " Base64  URL", json_string: " JSON", e164: " (E.164)", jwt: " JWT", template_literal: "" }, a2 = { nan: "NaN", number: "", array: " (Array)", null: " (null)" };
  return (t) => {
    switch (t.code) {
      case "invalid_type": {
        let n = a2[t.expected] ?? t.expected, o = w(t.input), s2 = a2[o] ?? o;
        return /^[A-Z]/.test(t.expected) ? `:  instanceof ${t.expected}  ${s2}` : `:  ${n}  ${s2}`;
      }
      case "invalid_value":
        return t.values.length === 1 ? `:  ${k(t.values[0])}` : `:  ${h(t.values, "|")}`;
      case "too_big": {
        let n = t.inclusive ? "" : "", o = i(t.origin);
        return o ? `: ${t.origin ?? ""} ${n} ${t.maximum.toString()} ${o.unit ?? ""}` : `: ${t.origin ?? ""} ${n} ${t.maximum.toString()}`;
      }
      case "too_small": {
        let n = t.inclusive ? "" : "", o = i(t.origin);
        return o ? `: ${t.origin} ${n} ${t.minimum.toString()} ${o.unit}` : `: ${t.origin} ${n} ${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let n = t;
        return n.format === "starts_with" ? `:  "${n.prefix}"` : n.format === "ends_with" ? `:  "${n.suffix}"` : n.format === "includes" ? `:  "${n.includes}" ` : n.format === "regex" ? `:  ${n.pattern}` : `: ${r2[n.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `:  ${t.divisor} `;
      case "unrecognized_keys":
        return `: ${h(t.keys, ", ")}`;
      case "invalid_key":
        return ` ${t.origin}`;
      case "invalid_union":
        return ": ";
      case "invalid_element":
        return ` ${t.origin}`;
      default:
        return "";
    }
  };
};
function Qv() {
  return { localeError: Xv() };
}
var eg = () => {
  let e = { string: { unit: "karakter", verb: "olmal" }, file: { unit: "bayt", verb: "olmal" }, array: { unit: "e", verb: "olmal" }, set: { unit: "e", verb: "olmal" } };
  function i(t) {
    return e[t] ?? null;
  }
  let r2 = { regex: "girdi", email: "e-posta adresi", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO tarih ve saat", date: "ISO tarih", time: "ISO saat", duration: "ISO sre", ipv4: "IPv4 adresi", ipv6: "IPv6 adresi", cidrv4: "IPv4 aral", cidrv6: "IPv6 aral", base64: "base64 ile ifrelenmi metin", base64url: "base64url ile ifrelenmi metin", json_string: "JSON dizesi", e164: "E.164 says", jwt: "JWT", template_literal: "ablon dizesi" }, a2 = { nan: "NaN" };
  return (t) => {
    switch (t.code) {
      case "invalid_type": {
        let n = a2[t.expected] ?? t.expected, o = w(t.input), s2 = a2[o] ?? o;
        return /^[A-Z]/.test(t.expected) ? `Geersiz deer: beklenen instanceof ${t.expected}, alnan ${s2}` : `Geersiz deer: beklenen ${n}, alnan ${s2}`;
      }
      case "invalid_value":
        return t.values.length === 1 ? `Geersiz deer: beklenen ${k(t.values[0])}` : `Geersiz seenek: aadakilerden biri olmal: ${h(t.values, "|")}`;
      case "too_big": {
        let n = t.inclusive ? "<=" : "<", o = i(t.origin);
        return o ? `ok byk: beklenen ${t.origin ?? "deer"} ${n}${t.maximum.toString()} ${o.unit ?? "e"}` : `ok byk: beklenen ${t.origin ?? "deer"} ${n}${t.maximum.toString()}`;
      }
      case "too_small": {
        let n = t.inclusive ? ">=" : ">", o = i(t.origin);
        return o ? `ok kk: beklenen ${t.origin} ${n}${t.minimum.toString()} ${o.unit}` : `ok kk: beklenen ${t.origin} ${n}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let n = t;
        return n.format === "starts_with" ? `Geersiz metin: "${n.prefix}" ile balamal` : n.format === "ends_with" ? `Geersiz metin: "${n.suffix}" ile bitmeli` : n.format === "includes" ? `Geersiz metin: "${n.includes}" iermeli` : n.format === "regex" ? `Geersiz metin: ${n.pattern} desenine uymal` : `Geersiz ${r2[n.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `Geersiz say: ${t.divisor} ile tam blnebilmeli`;
      case "unrecognized_keys":
        return `Tannmayan anahtar${t.keys.length > 1 ? "lar" : ""}: ${h(t.keys, ", ")}`;
      case "invalid_key":
        return `${t.origin} iinde geersiz anahtar`;
      case "invalid_union":
        return "Geersiz deer";
      case "invalid_element":
        return `${t.origin} iinde geersiz deer`;
      default:
        return "Geersiz deer";
    }
  };
};
function tg() {
  return { localeError: eg() };
}
var ig = () => {
  let e = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function i(t) {
    return e[t] ?? null;
  }
  let r2 = { regex: " ", email: "  ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "   ISO", date: " ISO", time: " ISO", duration: " ISO", ipv4: " IPv4", ipv6: " IPv6", cidrv4: " IPv4", cidrv6: " IPv6", base64: "   base64", base64url: "   base64url", json_string: " JSON", e164: " E.164", jwt: "JWT", template_literal: " " }, a2 = { nan: "NaN", number: "", array: "" };
  return (t) => {
    switch (t.code) {
      case "invalid_type": {
        let n = a2[t.expected] ?? t.expected, o = w(t.input), s2 = a2[o] ?? o;
        return /^[A-Z]/.test(t.expected) ? `  :  instanceof ${t.expected},  ${s2}` : `  :  ${n},  ${s2}`;
      }
      case "invalid_value":
        return t.values.length === 1 ? `  :  ${k(t.values[0])}` : ` :    ${h(t.values, "|")}`;
      case "too_big": {
        let n = t.inclusive ? "<=" : "<", o = i(t.origin);
        return o ? ` : ,  ${t.origin ?? ""} ${o.verb} ${n}${t.maximum.toString()} ${o.unit ?? ""}` : ` : ,  ${t.origin ?? ""}  ${n}${t.maximum.toString()}`;
      }
      case "too_small": {
        let n = t.inclusive ? ">=" : ">", o = i(t.origin);
        return o ? ` : ,  ${t.origin} ${o.verb} ${n}${t.minimum.toString()} ${o.unit}` : ` : ,  ${t.origin}  ${n}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let n = t;
        return n.format === "starts_with" ? ` :    "${n.prefix}"` : n.format === "ends_with" ? ` :    "${n.suffix}"` : n.format === "includes" ? ` :   "${n.includes}"` : n.format === "regex" ? ` :    ${n.pattern}` : ` ${r2[n.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return ` :    ${t.divisor}`;
      case "unrecognized_keys":
        return ` ${t.keys.length > 1 ? "" : ""}: ${h(t.keys, ", ")}`;
      case "invalid_key":
        return `   ${t.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `   ${t.origin}`;
      default:
        return "  ";
    }
  };
};
function tl() {
  return { localeError: ig() };
}
function rg() {
  return tl();
}
var ng = () => {
  let e = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function i(t) {
    return e[t] ?? null;
  }
  let r2 = { regex: " ", email: "  ", url: "  ", emoji: "", uuid: "   ", uuidv4: "     4", uuidv6: "     6", nanoid: "  ", guid: "   ", cuid: "   ", cuid2: "    2", ulid: "   ", xid: "  ", ksuid: "    ", datetime: "    ", date: "   ", time: "   ", duration: "   ", ipv4: "   4 ", ipv6: "   6 ", cidrv4: "   4 ", cidrv6: "   6 ", base64: " 64   ", base64url: " 64      ", json_string: "    ", e164: " 164 ", jwt: "  ", template_literal: " " }, a2 = { nan: "NaN", number: "", array: "", null: "" };
  return (t) => {
    switch (t.code) {
      case "invalid_type": {
        let n = a2[t.expected] ?? t.expected, o = w(t.input), s2 = a2[o] ?? o;
        return /^[A-Z]/.test(t.expected) ? `  : instanceof ${t.expected}   ${s2}  ` : `  : ${n}   ${s2}  `;
      }
      case "invalid_value":
        return t.values.length === 1 ? `  : ${k(t.values[0])}  ` : ` : ${h(t.values, "|")}     `;
      case "too_big": {
        let n = t.inclusive ? "<=" : "<", o = i(t.origin);
        return o ? ` : ${t.origin ?? ""}  ${n}${t.maximum.toString()} ${o.unit ?? ""}   ` : ` : ${t.origin ?? ""}  ${n}${t.maximum.toString()}   `;
      }
      case "too_small": {
        let n = t.inclusive ? ">=" : ">", o = i(t.origin);
        return o ? ` : ${t.origin}  ${n}${t.minimum.toString()} ${o.unit}   ` : ` : ${t.origin}  ${n}${t.minimum.toString()}   `;
      }
      case "invalid_format": {
        let n = t;
        return n.format === "starts_with" ? ` : "${n.prefix}"    ` : n.format === "ends_with" ? ` : "${n.suffix}"    ` : n.format === "includes" ? ` : "${n.includes}"   ` : n.format === "regex" ? ` :  ${n.pattern}    ` : ` ${r2[n.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return ` : ${t.divisor}    `;
      case "unrecognized_keys":
        return `   ${t.keys.length > 1 ? "" : ""}: ${h(t.keys, " ")}`;
      case "invalid_key":
        return `${t.origin}   `;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `${t.origin}   `;
      default:
        return "  ";
    }
  };
};
function ag() {
  return { localeError: ng() };
}
var og = () => {
  let e = { string: { unit: "belgi", verb: "bolishi kerak" }, file: { unit: "bayt", verb: "bolishi kerak" }, array: { unit: "element", verb: "bolishi kerak" }, set: { unit: "element", verb: "bolishi kerak" } };
  function i(t) {
    return e[t] ?? null;
  }
  let r2 = { regex: "kirish", email: "elektron pochta manzili", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO sana va vaqti", date: "ISO sana", time: "ISO vaqt", duration: "ISO davomiylik", ipv4: "IPv4 manzil", ipv6: "IPv6 manzil", mac: "MAC manzil", cidrv4: "IPv4 diapazon", cidrv6: "IPv6 diapazon", base64: "base64 kodlangan satr", base64url: "base64url kodlangan satr", json_string: "JSON satr", e164: "E.164 raqam", jwt: "JWT", template_literal: "kirish" }, a2 = { nan: "NaN", number: "raqam", array: "massiv" };
  return (t) => {
    switch (t.code) {
      case "invalid_type": {
        let n = a2[t.expected] ?? t.expected, o = w(t.input), s2 = a2[o] ?? o;
        return /^[A-Z]/.test(t.expected) ? `Notogri kirish: kutilgan instanceof ${t.expected}, qabul qilingan ${s2}` : `Notogri kirish: kutilgan ${n}, qabul qilingan ${s2}`;
      }
      case "invalid_value":
        return t.values.length === 1 ? `Notogri kirish: kutilgan ${k(t.values[0])}` : `Notogri variant: quyidagilardan biri kutilgan ${h(t.values, "|")}`;
      case "too_big": {
        let n = t.inclusive ? "<=" : "<", o = i(t.origin);
        return o ? `Juda katta: kutilgan ${t.origin ?? "qiymat"} ${n}${t.maximum.toString()} ${o.unit} ${o.verb}` : `Juda katta: kutilgan ${t.origin ?? "qiymat"} ${n}${t.maximum.toString()}`;
      }
      case "too_small": {
        let n = t.inclusive ? ">=" : ">", o = i(t.origin);
        return o ? `Juda kichik: kutilgan ${t.origin} ${n}${t.minimum.toString()} ${o.unit} ${o.verb}` : `Juda kichik: kutilgan ${t.origin} ${n}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let n = t;
        return n.format === "starts_with" ? `Notogri satr: "${n.prefix}" bilan boshlanishi kerak` : n.format === "ends_with" ? `Notogri satr: "${n.suffix}" bilan tugashi kerak` : n.format === "includes" ? `Notogri satr: "${n.includes}" ni oz ichiga olishi kerak` : n.format === "regex" ? `Notogri satr: ${n.pattern} shabloniga mos kelishi kerak` : `Notogri ${r2[n.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `Notogri raqam: ${t.divisor} ning karralisi bolishi kerak`;
      case "unrecognized_keys":
        return `Nomalum kalit${t.keys.length > 1 ? "lar" : ""}: ${h(t.keys, ", ")}`;
      case "invalid_key":
        return `${t.origin} dagi kalit notogri`;
      case "invalid_union":
        return "Notogri kirish";
      case "invalid_element":
        return `${t.origin} da notogri qiymat`;
      default:
        return "Notogri kirish";
    }
  };
};
function sg() {
  return { localeError: og() };
}
var ug = () => {
  let e = { string: { unit: "k t", verb: "c" }, file: { unit: "byte", verb: "c" }, array: { unit: "phn t", verb: "c" }, set: { unit: "phn t", verb: "c" } };
  function i(t) {
    return e[t] ?? null;
  }
  let r2 = { regex: "u vo", email: "a ch email", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ngy gi ISO", date: "ngy ISO", time: "gi ISO", duration: "khong thi gian ISO", ipv4: "a ch IPv4", ipv6: "a ch IPv6", cidrv4: "di IPv4", cidrv6: "di IPv6", base64: "chui m ha base64", base64url: "chui m ha base64url", json_string: "chui JSON", e164: "s E.164", jwt: "JWT", template_literal: "u vo" }, a2 = { nan: "NaN", number: "s", array: "mng" };
  return (t) => {
    switch (t.code) {
      case "invalid_type": {
        let n = a2[t.expected] ?? t.expected, o = w(t.input), s2 = a2[o] ?? o;
        return /^[A-Z]/.test(t.expected) ? `u vo khng hp l: mong i instanceof ${t.expected}, nhn c ${s2}` : `u vo khng hp l: mong i ${n}, nhn c ${s2}`;
      }
      case "invalid_value":
        return t.values.length === 1 ? `u vo khng hp l: mong i ${k(t.values[0])}` : `Ty chn khng hp l: mong i mt trong cc gi tr ${h(t.values, "|")}`;
      case "too_big": {
        let n = t.inclusive ? "<=" : "<", o = i(t.origin);
        return o ? `Qu ln: mong i ${t.origin ?? "gi tr"} ${o.verb} ${n}${t.maximum.toString()} ${o.unit ?? "phn t"}` : `Qu ln: mong i ${t.origin ?? "gi tr"} ${n}${t.maximum.toString()}`;
      }
      case "too_small": {
        let n = t.inclusive ? ">=" : ">", o = i(t.origin);
        return o ? `Qu nh: mong i ${t.origin} ${o.verb} ${n}${t.minimum.toString()} ${o.unit}` : `Qu nh: mong i ${t.origin} ${n}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let n = t;
        return n.format === "starts_with" ? `Chui khng hp l: phi bt u bng "${n.prefix}"` : n.format === "ends_with" ? `Chui khng hp l: phi kt thc bng "${n.suffix}"` : n.format === "includes" ? `Chui khng hp l: phi bao gm "${n.includes}"` : n.format === "regex" ? `Chui khng hp l: phi khp vi mu ${n.pattern}` : `${r2[n.format] ?? t.format} khng hp l`;
      }
      case "not_multiple_of":
        return `S khng hp l: phi l bi s ca ${t.divisor}`;
      case "unrecognized_keys":
        return `Kha khng c nhn dng: ${h(t.keys, ", ")}`;
      case "invalid_key":
        return `Kha khng hp l trong ${t.origin}`;
      case "invalid_union":
        return "u vo khng hp l";
      case "invalid_element":
        return `Gi tr khng hp l trong ${t.origin}`;
      default:
        return "u vo khng hp l";
    }
  };
};
function lg() {
  return { localeError: ug() };
}
var dg = () => {
  let e = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function i(t) {
    return e[t] ?? null;
  }
  let r2 = { regex: "", email: "", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO", date: "ISO", time: "ISO", duration: "ISO", ipv4: "IPv4", ipv6: "IPv6", cidrv4: "IPv4", cidrv6: "IPv6", base64: "base64", base64url: "base64url", json_string: "JSON", e164: "E.164", jwt: "JWT", template_literal: "" }, a2 = { nan: "NaN", number: "", array: "", null: "(null)" };
  return (t) => {
    switch (t.code) {
      case "invalid_type": {
        let n = a2[t.expected] ?? t.expected, o = w(t.input), s2 = a2[o] ?? o;
        return /^[A-Z]/.test(t.expected) ? ` instanceof ${t.expected} ${s2}` : ` ${n} ${s2}`;
      }
      case "invalid_value":
        return t.values.length === 1 ? ` ${k(t.values[0])}` : ` ${h(t.values, "|")}`;
      case "too_big": {
        let n = t.inclusive ? "<=" : "<", o = i(t.origin);
        return o ? ` ${t.origin ?? ""} ${n}${t.maximum.toString()} ${o.unit ?? ""}` : ` ${t.origin ?? ""} ${n}${t.maximum.toString()}`;
      }
      case "too_small": {
        let n = t.inclusive ? ">=" : ">", o = i(t.origin);
        return o ? ` ${t.origin} ${n}${t.minimum.toString()} ${o.unit}` : ` ${t.origin} ${n}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let n = t;
        return n.format === "starts_with" ? ` "${n.prefix}" ` : n.format === "ends_with" ? ` "${n.suffix}" ` : n.format === "includes" ? ` "${n.includes}"` : n.format === "regex" ? ` ${n.pattern}` : `${r2[n.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return ` ${t.divisor} `;
      case "unrecognized_keys":
        return `(key): ${h(t.keys, ", ")}`;
      case "invalid_key":
        return `${t.origin} (key)`;
      case "invalid_union":
        return "";
      case "invalid_element":
        return `${t.origin} (value)`;
      default:
        return "";
    }
  };
};
function cg() {
  return { localeError: dg() };
}
var mg = () => {
  let e = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function i(t) {
    return e[t] ?? null;
  }
  let r2 = { regex: "", email: "", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO ", date: "ISO ", time: "ISO ", duration: "ISO ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64 ", base64url: "base64url ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "" }, a2 = { nan: "NaN" };
  return (t) => {
    switch (t.code) {
      case "invalid_type": {
        let n = a2[t.expected] ?? t.expected, o = w(t.input), s2 = a2[o] ?? o;
        return /^[A-Z]/.test(t.expected) ? ` instanceof ${t.expected} ${s2}` : ` ${n} ${s2}`;
      }
      case "invalid_value":
        return t.values.length === 1 ? ` ${k(t.values[0])}` : ` ${h(t.values, "|")}`;
      case "too_big": {
        let n = t.inclusive ? "<=" : "<", o = i(t.origin);
        return o ? ` ${t.origin ?? ""}  ${n}${t.maximum.toString()} ${o.unit ?? ""}` : ` ${t.origin ?? ""}  ${n}${t.maximum.toString()}`;
      }
      case "too_small": {
        let n = t.inclusive ? ">=" : ">", o = i(t.origin);
        return o ? ` ${t.origin}  ${n}${t.minimum.toString()} ${o.unit}` : ` ${t.origin}  ${n}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let n = t;
        return n.format === "starts_with" ? ` "${n.prefix}" ` : n.format === "ends_with" ? ` "${n.suffix}" ` : n.format === "includes" ? ` "${n.includes}"` : n.format === "regex" ? ` ${n.pattern}` : ` ${r2[n.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return ` ${t.divisor} `;
      case "unrecognized_keys":
        return `${t.keys.length > 1 ? "" : ""}${h(t.keys, "")}`;
      case "invalid_key":
        return `${t.origin} `;
      case "invalid_union":
        return "";
      case "invalid_element":
        return `${t.origin} `;
      default:
        return "";
    }
  };
};
function fg() {
  return { localeError: mg() };
}
var pg = () => {
  let e = { string: { unit: "mi", verb: "n" }, file: { unit: "bytes", verb: "n" }, array: { unit: "nkan", verb: "n" }, set: { unit: "nkan", verb: "n" } };
  function i(t) {
    return e[t] ?? null;
  }
  let r2 = { regex: "r bwl", email: "drs ml", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "kk ISO", date: "j ISO", time: "kk ISO", duration: "kk t p ISO", ipv4: "drs IPv4", ipv6: "drs IPv6", cidrv4: "gbgb IPv4", cidrv6: "gbgb IPv6", base64: "r t a k n base64", base64url: "r base64url", json_string: "r JSON", e164: "nmb E.164", jwt: "JWT", template_literal: "r bwl" }, a2 = { nan: "NaN", number: "nmb", array: "akop" };
  return (t) => {
    switch (t.code) {
      case "invalid_type": {
        let n = a2[t.expected] ?? t.expected, o = w(t.input), s2 = a2[o] ?? o;
        return /^[A-Z]/.test(t.expected) ? `bwl ae: a n lti fi instanceof ${t.expected}, m a r ${s2}` : `bwl ae: a n lti fi ${n}, m a r ${s2}`;
      }
      case "invalid_value":
        return t.values.length === 1 ? `bwl ae: a n lti fi ${k(t.values[0])}` : `yn ae: yan kan lra ${h(t.values, "|")}`;
      case "too_big": {
        let n = t.inclusive ? "<=" : "<", o = i(t.origin);
        return o ? `T p j: a n lti j p ${t.origin ?? "iye"} ${o.verb} ${n}${t.maximum} ${o.unit}` : `T p j: a n lti j ${n}${t.maximum}`;
      }
      case "too_small": {
        let n = t.inclusive ? ">=" : ">", o = i(t.origin);
        return o ? `Kr ju: a n lti j p ${t.origin} ${o.verb} ${n}${t.minimum} ${o.unit}` : `Kr ju: a n lti j ${n}${t.minimum}`;
      }
      case "invalid_format": {
        let n = t;
        return n.format === "starts_with" ? `r ae: gbd br pl "${n.prefix}"` : n.format === "ends_with" ? `r ae: gbd par pl "${n.suffix}"` : n.format === "includes" ? `r ae: gbd n "${n.includes}"` : n.format === "regex" ? `r ae: gbd b pr mu ${n.pattern}` : `Ae: ${r2[n.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `Nmb ae: gbd j y ppn ti ${t.divisor}`;
      case "unrecognized_keys":
        return `Btn m: ${h(t.keys, ", ")}`;
      case "invalid_key":
        return `Btn ae nn ${t.origin}`;
      case "invalid_union":
        return "bwl ae";
      case "invalid_element":
        return `Iye ae nn ${t.origin}`;
      default:
        return "bwl ae";
    }
  };
};
function vg2() {
  return { localeError: pg() };
}
var Qa, il = /* @__PURE__ */ Symbol("ZodOutput"), rl = /* @__PURE__ */ Symbol("ZodInput");
class nl {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map();
  }
  add(i, ...r2) {
    let a2 = r2[0];
    return this._map.set(i, a2), a2 && typeof a2 == "object" && "id" in a2 && this._idmap.set(a2.id, i), this;
  }
  clear() {
    return this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map(), this;
  }
  remove(i) {
    let r2 = this._map.get(i);
    return r2 && typeof r2 == "object" && "id" in r2 && this._idmap.delete(r2.id), this._map.delete(i), this;
  }
  get(i) {
    let r2 = i._zod.parent;
    if (r2) {
      let a2 = { ...this.get(r2) ?? {} };
      delete a2.id;
      let t = { ...a2, ...this._map.get(i) };
      return Object.keys(t).length ? t : void 0;
    }
    return this._map.get(i);
  }
  has(i) {
    return this._map.has(i);
  }
}
function Wr() {
  return new nl();
}
(Qa = globalThis).__zod_globalRegistry ?? (Qa.__zod_globalRegistry = Wr());
var ue = globalThis.__zod_globalRegistry;
function al(e, i) {
  return new e({ type: "string", ..._(i) });
}
function ol(e, i) {
  return new e({ type: "string", coerce: true, ..._(i) });
}
function qr(e, i) {
  return new e({ type: "string", format: "email", check: "string_format", abort: false, ..._(i) });
}
function ii(e, i) {
  return new e({ type: "string", format: "guid", check: "string_format", abort: false, ..._(i) });
}
function Yr(e, i) {
  return new e({ type: "string", format: "uuid", check: "string_format", abort: false, ..._(i) });
}
function Br(e, i) {
  return new e({ type: "string", format: "uuid", check: "string_format", abort: false, version: "v4", ..._(i) });
}
function Hr(e, i) {
  return new e({ type: "string", format: "uuid", check: "string_format", abort: false, version: "v6", ..._(i) });
}
function Kr(e, i) {
  return new e({ type: "string", format: "uuid", check: "string_format", abort: false, version: "v7", ..._(i) });
}
function pi(e, i) {
  return new e({ type: "string", format: "url", check: "string_format", abort: false, ..._(i) });
}
function Xr(e, i) {
  return new e({ type: "string", format: "emoji", check: "string_format", abort: false, ..._(i) });
}
function Qr(e, i) {
  return new e({ type: "string", format: "nanoid", check: "string_format", abort: false, ..._(i) });
}
function en(e, i) {
  return new e({ type: "string", format: "cuid", check: "string_format", abort: false, ..._(i) });
}
function tn(e, i) {
  return new e({ type: "string", format: "cuid2", check: "string_format", abort: false, ..._(i) });
}
function rn(e, i) {
  return new e({ type: "string", format: "ulid", check: "string_format", abort: false, ..._(i) });
}
function nn(e, i) {
  return new e({ type: "string", format: "xid", check: "string_format", abort: false, ..._(i) });
}
function an(e, i) {
  return new e({ type: "string", format: "ksuid", check: "string_format", abort: false, ..._(i) });
}
function on(e, i) {
  return new e({ type: "string", format: "ipv4", check: "string_format", abort: false, ..._(i) });
}
function sn(e, i) {
  return new e({ type: "string", format: "ipv6", check: "string_format", abort: false, ..._(i) });
}
function sl(e, i) {
  return new e({ type: "string", format: "mac", check: "string_format", abort: false, ..._(i) });
}
function un(e, i) {
  return new e({ type: "string", format: "cidrv4", check: "string_format", abort: false, ..._(i) });
}
function ln(e, i) {
  return new e({ type: "string", format: "cidrv6", check: "string_format", abort: false, ..._(i) });
}
function dn(e, i) {
  return new e({ type: "string", format: "base64", check: "string_format", abort: false, ..._(i) });
}
function cn(e, i) {
  return new e({ type: "string", format: "base64url", check: "string_format", abort: false, ..._(i) });
}
function mn(e, i) {
  return new e({ type: "string", format: "e164", check: "string_format", abort: false, ..._(i) });
}
function fn(e, i) {
  return new e({ type: "string", format: "jwt", check: "string_format", abort: false, ..._(i) });
}
var ul = { Any: null, Minute: -1, Second: 0, Millisecond: 3, Microsecond: 6 };
function ll(e, i) {
  return new e({ type: "string", format: "datetime", check: "string_format", offset: false, local: false, precision: null, ..._(i) });
}
function dl(e, i) {
  return new e({ type: "string", format: "date", check: "string_format", ..._(i) });
}
function cl(e, i) {
  return new e({ type: "string", format: "time", check: "string_format", precision: null, ..._(i) });
}
function ml(e, i) {
  return new e({ type: "string", format: "duration", check: "string_format", ..._(i) });
}
function fl(e, i) {
  return new e({ type: "number", checks: [], ..._(i) });
}
function pl(e, i) {
  return new e({ type: "number", coerce: true, checks: [], ..._(i) });
}
function vl(e, i) {
  return new e({ type: "number", check: "number_format", abort: false, format: "safeint", ..._(i) });
}
function gl(e, i) {
  return new e({ type: "number", check: "number_format", abort: false, format: "float32", ..._(i) });
}
function hl(e, i) {
  return new e({ type: "number", check: "number_format", abort: false, format: "float64", ..._(i) });
}
function _l(e, i) {
  return new e({ type: "number", check: "number_format", abort: false, format: "int32", ..._(i) });
}
function bl(e, i) {
  return new e({ type: "number", check: "number_format", abort: false, format: "uint32", ..._(i) });
}
function yl(e, i) {
  return new e({ type: "boolean", ..._(i) });
}
function $l(e, i) {
  return new e({ type: "boolean", coerce: true, ..._(i) });
}
function Il(e, i) {
  return new e({ type: "bigint", ..._(i) });
}
function kl(e, i) {
  return new e({ type: "bigint", coerce: true, ..._(i) });
}
function wl(e, i) {
  return new e({ type: "bigint", check: "bigint_format", abort: false, format: "int64", ..._(i) });
}
function Sl(e, i) {
  return new e({ type: "bigint", check: "bigint_format", abort: false, format: "uint64", ..._(i) });
}
function xl(e, i) {
  return new e({ type: "symbol", ..._(i) });
}
function El(e, i) {
  return new e({ type: "undefined", ..._(i) });
}
function zl(e, i) {
  return new e({ type: "null", ..._(i) });
}
function Tl(e) {
  return new e({ type: "any" });
}
function Ul(e) {
  return new e({ type: "unknown" });
}
function Ol(e, i) {
  return new e({ type: "never", ..._(i) });
}
function Nl(e, i) {
  return new e({ type: "void", ..._(i) });
}
function Rl(e, i) {
  return new e({ type: "date", ..._(i) });
}
function Pl(e, i) {
  return new e({ type: "date", coerce: true, ..._(i) });
}
function Dl(e, i) {
  return new e({ type: "nan", ..._(i) });
}
function xe(e, i) {
  return new jr({ check: "less_than", ..._(i), value: e, inclusive: false });
}
function le(e, i) {
  return new jr({ check: "less_than", ..._(i), value: e, inclusive: true });
}
function Ee(e, i) {
  return new Ar({ check: "greater_than", ..._(i), value: e, inclusive: false });
}
function ee(e, i) {
  return new Ar({ check: "greater_than", ..._(i), value: e, inclusive: true });
}
function pn2(e) {
  return Ee(0, e);
}
function vn(e) {
  return xe(0, e);
}
function gn(e) {
  return le(0, e);
}
function hn(e) {
  return ee(0, e);
}
function tt(e, i) {
  return new ys({ check: "multiple_of", ..._(i), value: e });
}
function ot(e, i) {
  return new ks({ check: "max_size", ..._(i), maximum: e });
}
function ze(e, i) {
  return new ws({ check: "min_size", ..._(i), minimum: e });
}
function Tt(e, i) {
  return new Ss({ check: "size_equals", ..._(i), size: e });
}
function Ut(e, i) {
  return new xs({ check: "max_length", ..._(i), maximum: e });
}
function Me(e, i) {
  return new Es({ check: "min_length", ..._(i), minimum: e });
}
function Ot(e, i) {
  return new zs({ check: "length_equals", ..._(i), length: e });
}
function vi(e, i) {
  return new Ts({ check: "string_format", format: "regex", ..._(i), pattern: e });
}
function gi(e) {
  return new Us({ check: "string_format", format: "lowercase", ..._(e) });
}
function hi(e) {
  return new Os({ check: "string_format", format: "uppercase", ..._(e) });
}
function _i(e, i) {
  return new Ns({ check: "string_format", format: "includes", ..._(i), includes: e });
}
function bi(e, i) {
  return new Rs({ check: "string_format", format: "starts_with", ..._(i), prefix: e });
}
function yi(e, i) {
  return new Ps({ check: "string_format", format: "ends_with", ..._(i), suffix: e });
}
function _n(e, i, r2) {
  return new Ds({ check: "property", property: e, schema: i, ..._(r2) });
}
function $i(e, i) {
  return new js({ check: "mime_type", mime: e, ..._(i) });
}
function Ie(e) {
  return new As({ check: "overwrite", tx: e });
}
function Ii(e) {
  return Ie((i) => i.normalize(e));
}
function ki() {
  return Ie((e) => e.trim());
}
function wi() {
  return Ie((e) => e.toLowerCase());
}
function Si() {
  return Ie((e) => e.toUpperCase());
}
function xi() {
  return Ie((e) => Eo(e));
}
function jl(e, i, r2) {
  return new e({ type: "array", element: i, ..._(r2) });
}
function gg(e, i, r2) {
  return new e({ type: "union", options: i, ..._(r2) });
}
function hg(e, i, r2) {
  return new e({ type: "union", options: i, inclusive: false, ..._(r2) });
}
function _g(e, i, r2, a2) {
  return new e({ type: "union", options: r2, discriminator: i, ..._(a2) });
}
function bg(e, i, r2) {
  return new e({ type: "intersection", left: i, right: r2 });
}
function yg(e, i, r2, a2) {
  let t = r2 instanceof S;
  return new e({ type: "tuple", items: i, rest: t ? r2 : null, ..._(t ? a2 : r2) });
}
function $g(e, i, r2, a2) {
  return new e({ type: "record", keyType: i, valueType: r2, ..._(a2) });
}
function Ig(e, i, r2, a2) {
  return new e({ type: "map", keyType: i, valueType: r2, ..._(a2) });
}
function kg(e, i, r2) {
  return new e({ type: "set", valueType: i, ..._(r2) });
}
function wg(e, i, r2) {
  let a2 = Array.isArray(i) ? Object.fromEntries(i.map((t) => [t, t])) : i;
  return new e({ type: "enum", entries: a2, ..._(r2) });
}
function Sg(e, i, r2) {
  return new e({ type: "enum", entries: i, ..._(r2) });
}
function xg(e, i, r2) {
  return new e({ type: "literal", values: Array.isArray(i) ? i : [i], ..._(r2) });
}
function Al(e, i) {
  return new e({ type: "file", ..._(i) });
}
function Eg(e, i) {
  return new e({ type: "transform", transform: i });
}
function zg(e, i) {
  return new e({ type: "optional", innerType: i });
}
function Tg(e, i) {
  return new e({ type: "nullable", innerType: i });
}
function Ug(e, i, r2) {
  return new e({ type: "default", innerType: i, get defaultValue() {
    return typeof r2 == "function" ? r2() : To(r2);
  } });
}
function Og(e, i, r2) {
  return new e({ type: "nonoptional", innerType: i, ..._(r2) });
}
function Ng(e, i) {
  return new e({ type: "success", innerType: i });
}
function Rg(e, i, r2) {
  return new e({ type: "catch", innerType: i, catchValue: typeof r2 == "function" ? r2 : () => r2 });
}
function Pg(e, i, r2) {
  return new e({ type: "pipe", in: i, out: r2 });
}
function Dg(e, i) {
  return new e({ type: "readonly", innerType: i });
}
function jg(e, i, r2) {
  return new e({ type: "template_literal", parts: i, ..._(r2) });
}
function Ag(e, i) {
  return new e({ type: "lazy", getter: i });
}
function Zg(e, i) {
  return new e({ type: "promise", innerType: i });
}
function Zl(e, i, r2) {
  let a2 = _(r2);
  return a2.abort ?? (a2.abort = true), new e({ type: "custom", check: "custom", fn: i, ...a2 });
}
function Cl(e, i, r2) {
  return new e({ type: "custom", check: "custom", fn: i, ..._(r2) });
}
function Ll(e) {
  let i = Ml((r2) => (r2.addIssue = (a2) => {
    if (typeof a2 == "string") r2.issues.push(ei(a2, r2.value, i._zod.def));
    else {
      let t = a2;
      t.fatal && (t.continue = false), t.code ?? (t.code = "custom"), t.input ?? (t.input = r2.value), t.inst ?? (t.inst = i), t.continue ?? (t.continue = !i._zod.def.abort), r2.issues.push(ei(t));
    }
  }, e(r2.value, r2)));
  return i;
}
function Ml(e, i) {
  let r2 = new M({ check: "custom", ..._(i) });
  return r2._zod.check = e, r2;
}
function Fl(e) {
  let i = new M({ check: "describe" });
  return i._zod.onattach = [(r2) => {
    let a2 = ue.get(r2) ?? {};
    ue.add(r2, { ...a2, description: e });
  }], i._zod.check = () => {
  }, i;
}
function Jl(e) {
  let i = new M({ check: "meta" });
  return i._zod.onattach = [(r2) => {
    let a2 = ue.get(r2) ?? {};
    ue.add(r2, { ...a2, ...e });
  }], i._zod.check = () => {
  }, i;
}
function Vl(e, i) {
  let r2 = _(i), a2 = r2.truthy ?? ["true", "1", "yes", "on", "y", "enabled"], t = r2.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  r2.case !== "sensitive" && (a2 = a2.map((f2) => typeof f2 == "string" ? f2.toLowerCase() : f2), t = t.map((f2) => typeof f2 == "string" ? f2.toLowerCase() : f2));
  let n = new Set(a2), o = new Set(t), s2 = e.Codec ?? Vr, u2 = e.Boolean ?? Lr, l = new (e.String ?? zt)({ type: "string", error: r2.error }), d2 = new u2({ type: "boolean", error: r2.error }), c = new s2({ type: "pipe", in: l, out: d2, transform: (f2, v) => {
    let g2 = f2;
    return r2.case !== "sensitive" && (g2 = g2.toLowerCase()), n.has(g2) ? true : o.has(g2) ? false : (v.issues.push({ code: "invalid_value", expected: "stringbool", values: [...n, ...o], input: v.value, inst: c, continue: false }), {});
  }, reverseTransform: (f2, v) => f2 === true ? a2[0] || "true" : t[0] || "false", error: r2.error });
  return c;
}
function Nt(e, i, r2, a2 = {}) {
  let t = _(a2), n = { ..._(a2), check: "string_format", type: "string", format: i, fn: typeof r2 == "function" ? r2 : (o) => r2.test(o), ...t };
  return r2 instanceof RegExp && (n.pattern = r2), new e(n);
}
function it(e) {
  let i = (e == null ? void 0 : e.target) ?? "draft-2020-12";
  return i === "draft-4" && (i = "draft-04"), i === "draft-7" && (i = "draft-07"), { processors: e.processors ?? {}, metadataRegistry: (e == null ? void 0 : e.metadata) ?? ue, target: i, unrepresentable: (e == null ? void 0 : e.unrepresentable) ?? "throw", override: (e == null ? void 0 : e.override) ?? (() => {
  }), io: (e == null ? void 0 : e.io) ?? "output", counter: 0, seen: /* @__PURE__ */ new Map(), cycles: (e == null ? void 0 : e.cycles) ?? "ref", reused: (e == null ? void 0 : e.reused) ?? "inline", external: (e == null ? void 0 : e.external) ?? void 0 };
}
function D(e, i, r2 = { path: [], schemaPath: [] }) {
  var l, d2;
  var a2;
  let t = e._zod.def, n = i.seen.get(e);
  if (n)
    return n.count++, r2.schemaPath.includes(e) && (n.cycle = r2.path), n.schema;
  let o = { schema: {}, count: 1, cycle: void 0, path: r2.path };
  i.seen.set(e, o);
  let s2 = (d2 = (l = e._zod).toJSONSchema) == null ? void 0 : d2.call(l);
  if (s2) o.schema = s2;
  else {
    let c = { ...r2, schemaPath: [...r2.schemaPath, e], path: r2.path };
    if (e._zod.processJSONSchema) e._zod.processJSONSchema(i, o.schema, c);
    else {
      let v = o.schema, g2 = i.processors[t.type];
      if (!g2) throw Error(`[toJSONSchema]: Non-representable type encountered: ${t.type}`);
      g2(e, i, v, c);
    }
    let f2 = e._zod.parent;
    f2 && (o.ref || (o.ref = f2), D(f2, i, c), i.seen.get(f2).isParent = true);
  }
  let u2 = i.metadataRegistry.get(e);
  return u2 && Object.assign(o.schema, u2), i.io === "input" && X(e) && (delete o.schema.examples, delete o.schema.default), i.io === "input" && o.schema._prefault && ((a2 = o.schema).default ?? (a2.default = o.schema._prefault)), delete o.schema._prefault, i.seen.get(e).schema;
}
function rt(e, i) {
  var o, s2, u2, l;
  let r2 = e.seen.get(i);
  if (!r2) throw Error("Unprocessed schema. This is a bug in Zod.");
  let a2 = /* @__PURE__ */ new Map();
  for (let d2 of e.seen.entries()) {
    let c = (o = e.metadataRegistry.get(d2[0])) == null ? void 0 : o.id;
    if (c) {
      let f2 = a2.get(c);
      if (f2 && f2 !== d2[0]) throw Error(`Duplicate schema id "${c}" detected during JSON Schema conversion. Two different schemas cannot share the same id when converted together.`);
      a2.set(c, d2[0]);
    }
  }
  let t = (d2) => {
    var g2;
    let c = e.target === "draft-2020-12" ? "$defs" : "definitions";
    if (e.external) {
      let b = (g2 = e.external.registry.get(d2[0])) == null ? void 0 : g2.id, $2 = e.external.uri ?? ((N2) => N2);
      if (b) return { ref: $2(b) };
      let I2 = d2[1].defId ?? d2[1].schema.id ?? `schema${e.counter++}`;
      return d2[1].defId = I2, { defId: I2, ref: `${$2("__shared")}#/${c}/${I2}` };
    }
    if (d2[1] === r2) return { ref: "#" };
    let f2 = `#/${c}/`, v = d2[1].schema.id ?? `__schema${e.counter++}`;
    return { defId: v, ref: f2 + v };
  }, n = (d2) => {
    if (d2[1].schema.$ref) return;
    let c = d2[1], { ref: f2, defId: v } = t(d2);
    c.def = { ...c.schema }, v && (c.defId = v);
    let g2 = c.schema;
    for (let b in g2) delete g2[b];
    g2.$ref = f2;
  };
  if (e.cycles === "throw") for (let d2 of e.seen.entries()) {
    let c = d2[1];
    if (c.cycle) throw Error(`Cycle detected: #/${(s2 = c.cycle) == null ? void 0 : s2.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
  }
  for (let d2 of e.seen.entries()) {
    let c = d2[1];
    if (i === d2[0]) {
      n(d2);
      continue;
    }
    if (e.external) {
      let f2 = (u2 = e.external.registry.get(d2[0])) == null ? void 0 : u2.id;
      if (i !== d2[0] && f2) {
        n(d2);
        continue;
      }
    }
    if ((l = e.metadataRegistry.get(d2[0])) != null && l.id) {
      n(d2);
      continue;
    }
    if (c.cycle) {
      n(d2);
      continue;
    }
    if (c.count > 1 && e.reused === "ref") {
      n(d2);
      continue;
    }
  }
}
function nt(e, i) {
  var o, s2, u2;
  let r2 = e.seen.get(i);
  if (!r2) throw Error("Unprocessed schema. This is a bug in Zod.");
  let a2 = (l) => {
    let d2 = e.seen.get(l);
    if (d2.ref === null) return;
    let c = d2.def ?? d2.schema, f2 = { ...c }, v = d2.ref;
    if (d2.ref = null, v) {
      a2(v);
      let b = e.seen.get(v), $2 = b.schema;
      if ($2.$ref && (e.target === "draft-07" || e.target === "draft-04" || e.target === "openapi-3.0") ? (c.allOf = c.allOf ?? [], c.allOf.push($2)) : Object.assign(c, $2), Object.assign(c, f2), l._zod.parent === v) for (let I2 in c)
        I2 === "$ref" || I2 === "allOf" || I2 in f2 || delete c[I2];
      if ($2.$ref) for (let I2 in c)
        I2 === "$ref" || I2 === "allOf" || I2 in b.def && JSON.stringify(c[I2]) === JSON.stringify(b.def[I2]) && delete c[I2];
    }
    let g2 = l._zod.parent;
    if (g2 && g2 !== v) {
      a2(g2);
      let b = e.seen.get(g2);
      if (b != null && b.schema.$ref && (c.$ref = b.schema.$ref, b.def))
        for (let $2 in c)
          $2 === "$ref" || $2 === "allOf" || $2 in b.def && JSON.stringify(c[$2]) === JSON.stringify(b.def[$2]) && delete c[$2];
    }
    e.override({ zodSchema: l, jsonSchema: c, path: d2.path ?? [] });
  };
  for (let l of [...e.seen.entries()].reverse()) a2(l[0]);
  let t = {};
  if (e.target === "draft-2020-12" ? t.$schema = "https://json-schema.org/draft/2020-12/schema" : e.target === "draft-07" ? t.$schema = "http://json-schema.org/draft-07/schema#" : e.target === "draft-04" ? t.$schema = "http://json-schema.org/draft-04/schema#" : e.target, (o = e.external) != null && o.uri) {
    let l = (s2 = e.external.registry.get(i)) == null ? void 0 : s2.id;
    if (!l) throw Error("Schema is missing an `id` property");
    t.$id = e.external.uri(l);
  }
  Object.assign(t, r2.def ?? r2.schema);
  let n = ((u2 = e.external) == null ? void 0 : u2.defs) ?? {};
  for (let l of e.seen.entries()) {
    let d2 = l[1];
    d2.def && d2.defId && (n[d2.defId] = d2.def);
  }
  e.external || Object.keys(n).length > 0 && (e.target === "draft-2020-12" ? t.$defs = n : t.definitions = n);
  try {
    let l = JSON.parse(JSON.stringify(t));
    return Object.defineProperty(l, "~standard", { value: { ...i["~standard"], jsonSchema: { input: ft(i, "input", e.processors), output: ft(i, "output", e.processors) } }, enumerable: false, writable: false }), l;
  } catch {
    throw Error("Error converting schema to JSON.");
  }
}
function X(e, i) {
  let r2 = i ?? { seen: /* @__PURE__ */ new Set() };
  if (r2.seen.has(e)) return false;
  r2.seen.add(e);
  let a2 = e._zod.def;
  if (a2.type === "transform") return true;
  if (a2.type === "array") return X(a2.element, r2);
  if (a2.type === "set") return X(a2.valueType, r2);
  if (a2.type === "lazy") return X(a2.getter(), r2);
  if (a2.type === "promise" || a2.type === "optional" || a2.type === "nonoptional" || a2.type === "nullable" || a2.type === "readonly" || a2.type === "default" || a2.type === "prefault") return X(a2.innerType, r2);
  if (a2.type === "intersection") return X(a2.left, r2) || X(a2.right, r2);
  if (a2.type === "record" || a2.type === "map") return X(a2.keyType, r2) || X(a2.valueType, r2);
  if (a2.type === "pipe") return X(a2.in, r2) || X(a2.out, r2);
  if (a2.type === "object") {
    for (let t in a2.shape) if (X(a2.shape[t], r2)) return true;
    return false;
  }
  if (a2.type === "union") {
    for (let t of a2.options) if (X(t, r2)) return true;
    return false;
  }
  if (a2.type === "tuple") {
    for (let t of a2.items) if (X(t, r2)) return true;
    return !!(a2.rest && X(a2.rest, r2));
  }
  return false;
}
var Gl = (e, i = {}) => (r2) => {
  let a2 = it({ ...r2, processors: i });
  return D(e, a2), rt(a2, e), nt(a2, e);
}, ft = (e, i, r2 = {}) => (a2) => {
  let { libraryOptions: t, target: n } = a2 ?? {}, o = it({ ...t ?? {}, target: n, io: i, processors: r2 });
  return D(e, o), rt(o, e), nt(o, e);
}, Cg = { guid: "uuid", url: "uri", datetime: "date-time", json_string: "json-string", regex: "" }, Wl = (e, i, r2, a2) => {
  let t = r2;
  t.type = "string";
  let { minimum: n, maximum: o, format: s2, patterns: u2, contentEncoding: l } = e._zod.bag;
  if (typeof n == "number" && (t.minLength = n), typeof o == "number" && (t.maxLength = o), s2 && (t.format = Cg[s2] ?? s2, t.format === "" && delete t.format, s2 === "time" && delete t.format), l && (t.contentEncoding = l), u2 && u2.size > 0) {
    let d2 = [...u2];
    d2.length === 1 ? t.pattern = d2[0].source : d2.length > 1 && (t.allOf = [...d2.map((c) => ({ ...i.target === "draft-07" || i.target === "draft-04" || i.target === "openapi-3.0" ? { type: "string" } : {}, pattern: c.source }))]);
  }
}, ql = (e, i, r2, a2) => {
  let t = r2, { minimum: n, maximum: o, format: s2, multipleOf: u2, exclusiveMaximum: l, exclusiveMinimum: d2 } = e._zod.bag;
  typeof s2 == "string" && s2.includes("int") ? t.type = "integer" : t.type = "number", typeof d2 == "number" && (i.target === "draft-04" || i.target === "openapi-3.0" ? (t.minimum = d2, t.exclusiveMinimum = true) : t.exclusiveMinimum = d2), typeof n == "number" && (t.minimum = n, typeof d2 == "number" && i.target !== "draft-04" && (d2 >= n ? delete t.minimum : delete t.exclusiveMinimum)), typeof l == "number" && (i.target === "draft-04" || i.target === "openapi-3.0" ? (t.maximum = l, t.exclusiveMaximum = true) : t.exclusiveMaximum = l), typeof o == "number" && (t.maximum = o, typeof l == "number" && i.target !== "draft-04" && (l <= o ? delete t.maximum : delete t.exclusiveMaximum)), typeof u2 == "number" && (t.multipleOf = u2);
}, Yl = (e, i, r2, a2) => {
  r2.type = "boolean";
}, Bl = (e, i, r2, a2) => {
  if (i.unrepresentable === "throw") throw Error("BigInt cannot be represented in JSON Schema");
}, Hl = (e, i, r2, a2) => {
  if (i.unrepresentable === "throw") throw Error("Symbols cannot be represented in JSON Schema");
}, Kl = (e, i, r2, a2) => {
  i.target === "openapi-3.0" ? (r2.type = "string", r2.nullable = true, r2.enum = [null]) : r2.type = "null";
}, Xl = (e, i, r2, a2) => {
  if (i.unrepresentable === "throw") throw Error("Undefined cannot be represented in JSON Schema");
}, Ql = (e, i, r2, a2) => {
  if (i.unrepresentable === "throw") throw Error("Void cannot be represented in JSON Schema");
}, ed = (e, i, r2, a2) => {
  r2.not = {};
}, td = (e, i, r2, a2) => {
}, id = (e, i, r2, a2) => {
}, rd = (e, i, r2, a2) => {
  if (i.unrepresentable === "throw") throw Error("Date cannot be represented in JSON Schema");
}, nd = (e, i, r2, a2) => {
  let t = e._zod.def, n = $r(t.entries);
  n.every((o) => typeof o == "number") && (r2.type = "number"), n.every((o) => typeof o == "string") && (r2.type = "string"), r2.enum = n;
}, ad = (e, i, r2, a2) => {
  let t = e._zod.def, n = [];
  for (let o of t.values) if (o === void 0) {
    if (i.unrepresentable === "throw") throw Error("Literal `undefined` cannot be represented in JSON Schema");
  } else if (typeof o == "bigint") {
    if (i.unrepresentable === "throw") throw Error("BigInt literals cannot be represented in JSON Schema");
    n.push(Number(o));
  } else n.push(o);
  if (n.length !== 0) if (n.length === 1) {
    let o = n[0];
    r2.type = o === null ? "null" : typeof o, i.target === "draft-04" || i.target === "openapi-3.0" ? r2.enum = [o] : r2.const = o;
  } else
    n.every((o) => typeof o == "number") && (r2.type = "number"), n.every((o) => typeof o == "string") && (r2.type = "string"), n.every((o) => typeof o == "boolean") && (r2.type = "boolean"), n.every((o) => o === null) && (r2.type = "null"), r2.enum = n;
}, od = (e, i, r2, a2) => {
  if (i.unrepresentable === "throw") throw Error("NaN cannot be represented in JSON Schema");
}, sd = (e, i, r2, a2) => {
  let t = r2, n = e._zod.pattern;
  if (!n) throw Error("Pattern not found in template literal");
  t.type = "string", t.pattern = n.source;
}, ud = (e, i, r2, a2) => {
  let t = r2, n = { type: "string", format: "binary", contentEncoding: "binary" }, { minimum: o, maximum: s2, mime: u2 } = e._zod.bag;
  o !== void 0 && (n.minLength = o), s2 !== void 0 && (n.maxLength = s2), u2 ? u2.length === 1 ? (n.contentMediaType = u2[0], Object.assign(t, n)) : (Object.assign(t, n), t.anyOf = u2.map((l) => ({ contentMediaType: l }))) : Object.assign(t, n);
}, ld = (e, i, r2, a2) => {
  r2.type = "boolean";
}, dd = (e, i, r2, a2) => {
  if (i.unrepresentable === "throw") throw Error("Custom types cannot be represented in JSON Schema");
}, cd = (e, i, r2, a2) => {
  if (i.unrepresentable === "throw") throw Error("Function types cannot be represented in JSON Schema");
}, md = (e, i, r2, a2) => {
  if (i.unrepresentable === "throw") throw Error("Transforms cannot be represented in JSON Schema");
}, fd = (e, i, r2, a2) => {
  if (i.unrepresentable === "throw") throw Error("Map cannot be represented in JSON Schema");
}, pd = (e, i, r2, a2) => {
  if (i.unrepresentable === "throw") throw Error("Set cannot be represented in JSON Schema");
}, vd = (e, i, r2, a2) => {
  let t = r2, n = e._zod.def, { minimum: o, maximum: s2 } = e._zod.bag;
  typeof o == "number" && (t.minItems = o), typeof s2 == "number" && (t.maxItems = s2), t.type = "array", t.items = D(n.element, i, { ...a2, path: [...a2.path, "items"] });
}, gd = (e, i, r2, a2) => {
  var l;
  let t = r2, n = e._zod.def;
  t.type = "object", t.properties = {};
  let o = n.shape;
  for (let d2 in o) t.properties[d2] = D(o[d2], i, { ...a2, path: [...a2.path, "properties", d2] });
  let s2 = new Set(Object.keys(o)), u2 = new Set([...s2].filter((d2) => {
    let c = n.shape[d2]._zod;
    return i.io === "input" ? c.optin === void 0 : c.optout === void 0;
  }));
  u2.size > 0 && (t.required = Array.from(u2)), ((l = n.catchall) == null ? void 0 : l._zod.def.type) === "never" ? t.additionalProperties = false : n.catchall ? n.catchall && (t.additionalProperties = D(n.catchall, i, { ...a2, path: [...a2.path, "additionalProperties"] })) : i.io === "output" && (t.additionalProperties = false);
}, bn = (e, i, r2, a2) => {
  let t = e._zod.def, n = t.inclusive === false, o = t.options.map((s2, u2) => D(s2, i, { ...a2, path: [...a2.path, n ? "oneOf" : "anyOf", u2] }));
  n ? r2.oneOf = o : r2.anyOf = o;
}, hd = (e, i, r2, a2) => {
  let t = e._zod.def, n = D(t.left, i, { ...a2, path: [...a2.path, "allOf", 0] }), o = D(t.right, i, { ...a2, path: [...a2.path, "allOf", 1] }), s2 = (l) => "allOf" in l && Object.keys(l).length === 1, u2 = [...s2(n) ? n.allOf : [n], ...s2(o) ? o.allOf : [o]];
  r2.allOf = u2;
}, _d = (e, i, r2, a2) => {
  let t = r2, n = e._zod.def;
  t.type = "array";
  let o = i.target === "draft-2020-12" ? "prefixItems" : "items", s2 = i.target === "draft-2020-12" || i.target === "openapi-3.0" ? "items" : "additionalItems", u2 = n.items.map((f2, v) => D(f2, i, { ...a2, path: [...a2.path, o, v] })), l = n.rest ? D(n.rest, i, { ...a2, path: [...a2.path, s2, ...i.target === "openapi-3.0" ? [n.items.length] : []] }) : null;
  i.target === "draft-2020-12" ? (t.prefixItems = u2, l && (t.items = l)) : i.target === "openapi-3.0" ? (t.items = { anyOf: u2 }, l && t.items.anyOf.push(l), t.minItems = u2.length, !l && (t.maxItems = u2.length)) : (t.items = u2, l && (t.additionalItems = l));
  let { minimum: d2, maximum: c } = e._zod.bag;
  typeof d2 == "number" && (t.minItems = d2), typeof c == "number" && (t.maxItems = c);
}, bd = (e, i, r2, a2) => {
  var l;
  let t = r2, n = e._zod.def;
  t.type = "object";
  let o = n.keyType, s2 = (l = o._zod.bag) == null ? void 0 : l.patterns;
  if (n.mode === "loose" && s2 && s2.size > 0) {
    let d2 = D(n.valueType, i, { ...a2, path: [...a2.path, "patternProperties", "*"] });
    t.patternProperties = {};
    for (let c of s2) t.patternProperties[c.source] = d2;
  } else
    (i.target === "draft-07" || i.target === "draft-2020-12") && (t.propertyNames = D(n.keyType, i, { ...a2, path: [...a2.path, "propertyNames"] })), t.additionalProperties = D(n.valueType, i, { ...a2, path: [...a2.path, "additionalProperties"] });
  let u2 = o._zod.values;
  if (u2) {
    let d2 = [...u2].filter((c) => typeof c == "string" || typeof c == "number");
    d2.length > 0 && (t.required = d2);
  }
}, yd = (e, i, r2, a2) => {
  let t = e._zod.def, n = D(t.innerType, i, a2), o = i.seen.get(e);
  i.target === "openapi-3.0" ? (o.ref = t.innerType, r2.nullable = true) : r2.anyOf = [n, { type: "null" }];
}, $d = (e, i, r2, a2) => {
  let t = e._zod.def;
  D(t.innerType, i, a2);
  let n = i.seen.get(e);
  n.ref = t.innerType;
}, Id = (e, i, r2, a2) => {
  let t = e._zod.def;
  D(t.innerType, i, a2);
  let n = i.seen.get(e);
  n.ref = t.innerType, r2.default = JSON.parse(JSON.stringify(t.defaultValue));
}, kd = (e, i, r2, a2) => {
  let t = e._zod.def;
  D(t.innerType, i, a2);
  let n = i.seen.get(e);
  n.ref = t.innerType, i.io === "input" && (r2._prefault = JSON.parse(JSON.stringify(t.defaultValue)));
}, wd = (e, i, r2, a2) => {
  let t = e._zod.def;
  D(t.innerType, i, a2);
  let n = i.seen.get(e);
  n.ref = t.innerType;
  let o;
  try {
    o = t.catchValue(void 0);
  } catch {
    throw Error("Dynamic catch values are not supported in JSON Schema");
  }
  r2.default = o;
}, Sd = (e, i, r2, a2) => {
  let t = e._zod.def, n = i.io === "input" ? t.in._zod.def.type === "transform" ? t.out : t.in : t.out;
  D(n, i, a2);
  let o = i.seen.get(e);
  o.ref = n;
}, xd = (e, i, r2, a2) => {
  let t = e._zod.def;
  D(t.innerType, i, a2);
  let n = i.seen.get(e);
  n.ref = t.innerType, r2.readOnly = true;
}, Ed = (e, i, r2, a2) => {
  let t = e._zod.def;
  D(t.innerType, i, a2);
  let n = i.seen.get(e);
  n.ref = t.innerType;
}, yn = (e, i, r2, a2) => {
  let t = e._zod.def;
  D(t.innerType, i, a2);
  let n = i.seen.get(e);
  n.ref = t.innerType;
}, zd = (e, i, r2, a2) => {
  let t = e._zod.innerType;
  D(t, i, a2);
  let n = i.seen.get(e);
  n.ref = t;
}, gr = { string: Wl, number: ql, boolean: Yl, bigint: Bl, symbol: Hl, null: Kl, undefined: Xl, void: Ql, never: ed, any: td, unknown: id, date: rd, enum: nd, literal: ad, nan: od, template_literal: sd, file: ud, success: ld, custom: dd, function: cd, transform: md, map: fd, set: pd, array: vd, object: gd, union: bn, intersection: hd, tuple: _d, record: bd, nullable: yd, nonoptional: $d, default: Id, prefault: kd, catch: wd, pipe: Sd, readonly: xd, promise: Ed, optional: yn, lazy: zd };
function Td(e, i) {
  if ("_idmap" in e) {
    let a2 = e, t = it({ ...i, processors: gr }), n = {};
    for (let u2 of a2._idmap.entries()) {
      let [l, d2] = u2;
      D(d2, t);
    }
    let o = {}, s2 = { registry: a2, uri: i == null ? void 0 : i.uri, defs: n };
    t.external = s2;
    for (let u2 of a2._idmap.entries()) {
      let [l, d2] = u2;
      rt(t, d2), o[l] = nt(t, d2);
    }
    if (Object.keys(n).length > 0) {
      let u2 = t.target === "draft-2020-12" ? "$defs" : "definitions";
      o.__shared = { [u2]: n };
    }
    return { schemas: o };
  }
  let r2 = it({ ...i, processors: gr });
  return D(e, r2), rt(r2, e), nt(r2, e);
}
class Lg {
  get metadataRegistry() {
    return this.ctx.metadataRegistry;
  }
  get target() {
    return this.ctx.target;
  }
  get unrepresentable() {
    return this.ctx.unrepresentable;
  }
  get override() {
    return this.ctx.override;
  }
  get io() {
    return this.ctx.io;
  }
  get counter() {
    return this.ctx.counter;
  }
  set counter(i) {
    this.ctx.counter = i;
  }
  get seen() {
    return this.ctx.seen;
  }
  constructor(i) {
    let r2 = (i == null ? void 0 : i.target) ?? "draft-2020-12";
    r2 === "draft-4" && (r2 = "draft-04"), r2 === "draft-7" && (r2 = "draft-07"), this.ctx = it({ processors: gr, target: r2, ...(i == null ? void 0 : i.metadata) && { metadata: i.metadata }, ...(i == null ? void 0 : i.unrepresentable) && { unrepresentable: i.unrepresentable }, ...(i == null ? void 0 : i.override) && { override: i.override }, ...(i == null ? void 0 : i.io) && { io: i.io } });
  }
  process(i, r2 = { path: [], schemaPath: [] }) {
    return D(i, this.ctx, r2);
  }
  emit(i, r2) {
    r2 && (r2.cycles && (this.ctx.cycles = r2.cycles), r2.reused && (this.ctx.reused = r2.reused), r2.external && (this.ctx.external = r2.external)), rt(this.ctx, i);
    let a2 = nt(this.ctx, i), { "~standard": t, ...n } = a2;
    return n;
  }
}
var Mg = {}, Ud = {};
ye(Ud, { xor: () => Cc, xid: () => uc, void: () => Rc, uuidv7: () => ec, uuidv6: () => Qd, uuidv4: () => Xd, uuid: () => Kd, url: () => tc, unknown: () => Fe2, union: () => qi, undefined: () => Oc, ulid: () => sc, uint64: () => Tc, uint32: () => xc, tuple: () => Jn, transform: () => Bi, templateLiteral: () => Xc, symbol: () => Uc, superRefine: () => ga, success: () => Bc, stringbool: () => am, stringFormat: () => bc, string: () => ri, strictObject: () => Ac, set: () => Vc, refine: () => va, record: () => Vn, readonly: () => la, promise: () => Qc, preprocess: () => sm, prefault: () => ia, pipe: () => ht, partialRecord: () => Mc, optional: () => vt, object: () => jc, number: () => En, nullish: () => Yc, nullable: () => gt, null: () => Nn, nonoptional: () => ra, never: () => Gi, nativeEnum: () => Gc, nanoid: () => nc, nan: () => Hc, meta: () => rm, map: () => Jc, mac: () => cc, looseRecord: () => Fc, looseObject: () => Zc, literal: () => Wc, lazy: () => ma, ksuid: () => lc, keyof: () => Dc, jwt: () => _c, json: () => om, ipv6: () => mc, ipv4: () => dc, intersection: () => Mn, int64: () => zc, int32: () => Sc, int: () => ni, instanceof: () => nm, httpUrl: () => ic, hostname: () => yc, hex: () => $c, hash: () => Ic, guid: () => Hd, function: () => ai, float64: () => wc, float32: () => kc, file: () => qc, exactOptional: () => Kn, enum: () => Yi, emoji: () => rc, email: () => Bd, e164: () => hc, discriminatedUnion: () => Lc, describe: () => im, date: () => Pc, custom: () => tm, cuid2: () => oc, cuid: () => ac, codec: () => Kc, cidrv6: () => pc, cidrv4: () => fc, check: () => em, catch: () => oa, boolean: () => zn, bigint: () => Ec, base64url: () => gc, base64: () => vc, array: () => Zt, any: () => Nc, _function: () => ai, _default: () => ea, _ZodString: () => Ei, ZodXor: () => Zn, ZodXID: () => Pi, ZodVoid: () => jn, ZodUnknown: () => Pn, ZodUnion: () => Lt, ZodUndefined: () => Un, ZodUUID: () => he, ZodURL: () => Pt, ZodULID: () => Ri, ZodType: () => x, ZodTuple: () => Fn, ZodTransform: () => Bn, ZodTemplateLiteral: () => da, ZodSymbol: () => Tn, ZodSuccess: () => na, ZodStringFormat: () => Z, ZodString: () => Rt, ZodSet: () => Wn, ZodRecord: () => Mt, ZodReadonly: () => ua, ZodPromise: () => fa, ZodPrefault: () => ta, ZodPipe: () => Xi, ZodOptional: () => Hi, ZodObject: () => Ct, ZodNumberFormat: () => Ge, ZodNumber: () => Dt, ZodNullable: () => Xn, ZodNull: () => On, ZodNonOptional: () => Ki, ZodNever: () => Dn, ZodNanoID: () => Ui, ZodNaN: () => sa, ZodMap: () => Gn, ZodMAC: () => xn, ZodLiteral: () => qn, ZodLazy: () => ca, ZodKSUID: () => Di, ZodJWT: () => Ji, ZodIntersection: () => Ln, ZodIPv6: () => Ai, ZodIPv4: () => ji, ZodGUID: () => pt, ZodFunction: () => pa, ZodFile: () => Yn, ZodExactOptional: () => Hn, ZodEnum: () => at, ZodEmoji: () => Ti, ZodEmail: () => zi, ZodE164: () => Fi, ZodDiscriminatedUnion: () => Cn, ZodDefault: () => Qn, ZodDate: () => Wi, ZodCustomStringFormat: () => st, ZodCustom: () => Ft, ZodCodec: () => Qi, ZodCatch: () => aa, ZodCUID2: () => Ni, ZodCUID: () => Oi, ZodCIDRv6: () => Ci, ZodCIDRv4: () => Zi, ZodBoolean: () => jt, ZodBigIntFormat: () => Vi, ZodBigInt: () => At, ZodBase64URL: () => Mi, ZodBase64: () => Li, ZodArray: () => An, ZodAny: () => Rn });
var Od = {};
ye(Od, { uppercase: () => hi, trim: () => ki, toUpperCase: () => Si, toLowerCase: () => wi, startsWith: () => bi, slugify: () => xi, size: () => Tt, regex: () => vi, property: () => _n, positive: () => pn2, overwrite: () => Ie, normalize: () => Ii, nonpositive: () => gn, nonnegative: () => hn, negative: () => vn, multipleOf: () => tt, minSize: () => ze, minLength: () => Me, mime: () => $i, maxSize: () => ot, maxLength: () => Ut, lte: () => le, lt: () => xe, lowercase: () => gi, length: () => Ot, includes: () => _i, gte: () => ee, gt: () => Ee, endsWith: () => yi });
var $n = {};
ye($n, { time: () => Pd, duration: () => Dd, datetime: () => Nd, date: () => Rd, ZodISOTime: () => wn, ZodISODuration: () => Sn, ZodISODateTime: () => In, ZodISODate: () => kn });
var In = p("ZodISODateTime", (e, i) => {
  Ks.init(e, i), Z.init(e, i);
});
function Nd(e) {
  return ll(In, e);
}
var kn = p("ZodISODate", (e, i) => {
  Xs.init(e, i), Z.init(e, i);
});
function Rd(e) {
  return dl(kn, e);
}
var wn = p("ZodISOTime", (e, i) => {
  Qs.init(e, i), Z.init(e, i);
});
function Pd(e) {
  return cl(wn, e);
}
var Sn = p("ZodISODuration", (e, i) => {
  eu.init(e, i), Z.init(e, i);
});
function Dd(e) {
  return ml(Sn, e);
}
var jd = (e, i) => {
  kr.init(e, i), e.name = "ZodError", Object.defineProperties(e, { format: { value: (r2) => Sr(e, r2) }, flatten: { value: (r2) => wr(e, r2) }, addIssue: { value: (r2) => {
    e.issues.push(r2), e.message = JSON.stringify(e.issues, Xt, 2);
  } }, addIssues: { value: (r2) => {
    e.issues.push(...r2), e.message = JSON.stringify(e.issues, Xt, 2);
  } }, isEmpty: { get() {
    return e.issues.length === 0;
  } } });
}, Fg = p("ZodError", jd), re = p("ZodError", jd, { Parent: Error }), Ad = $t(re), Zd = It(re), Cd = kt(re), Ld = wt(re), Md = xr(re), Fd = Er(re), Jd = zr(re), Vd = Tr(re), Gd = Ur(re), Wd = Or(re), qd = Nr(re), Yd = Rr(re), x = p("ZodType", (e, i) => (S.init(e, i), Object.assign(e["~standard"], { jsonSchema: { input: ft(e, "input"), output: ft(e, "output") } }), e.toJSONSchema = Gl(e, {}), e.def = i, e.type = i.type, Object.defineProperty(e, "_def", { value: i }), e.check = (...r2) => e.clone(T.mergeDefs(i, { checks: [...i.checks ?? [], ...r2.map((a2) => typeof a2 == "function" ? { _zod: { check: a2, def: { check: "custom" }, onattach: [] } } : a2)] }), { parent: true }), e.with = e.check, e.clone = (r2, a2) => me(e, r2, a2), e.brand = () => e, e.register = (r2, a2) => (r2.add(e, a2), e), e.parse = (r2, a2) => Ad(e, r2, a2, { callee: e.parse }), e.safeParse = (r2, a2) => Cd(e, r2, a2), e.parseAsync = async (r2, a2) => Zd(e, r2, a2, { callee: e.parseAsync }), e.safeParseAsync = async (r2, a2) => Ld(e, r2, a2), e.spa = e.safeParseAsync, e.encode = (r2, a2) => Md(e, r2, a2), e.decode = (r2, a2) => Fd(e, r2, a2), e.encodeAsync = async (r2, a2) => Jd(e, r2, a2), e.decodeAsync = async (r2, a2) => Vd(e, r2, a2), e.safeEncode = (r2, a2) => Gd(e, r2, a2), e.safeDecode = (r2, a2) => Wd(e, r2, a2), e.safeEncodeAsync = async (r2, a2) => qd(e, r2, a2), e.safeDecodeAsync = async (r2, a2) => Yd(e, r2, a2), e.refine = (r2, a2) => e.check(va(r2, a2)), e.superRefine = (r2) => e.check(ga(r2)), e.overwrite = (r2) => e.check(Ie(r2)), e.optional = () => vt(e), e.exactOptional = () => Kn(e), e.nullable = () => gt(e), e.nullish = () => vt(gt(e)), e.nonoptional = (r2) => ra(e, r2), e.array = () => Zt(e), e.or = (r2) => qi([e, r2]), e.and = (r2) => Mn(e, r2), e.transform = (r2) => ht(e, Bi(r2)), e.default = (r2) => ea(e, r2), e.prefault = (r2) => ia(e, r2), e.catch = (r2) => oa(e, r2), e.pipe = (r2) => ht(e, r2), e.readonly = () => la(e), e.describe = (r2) => {
  let a2 = e.clone();
  return ue.add(a2, { description: r2 }), a2;
}, Object.defineProperty(e, "description", { get() {
  var r2;
  return (r2 = ue.get(e)) == null ? void 0 : r2.description;
}, configurable: true }), e.meta = (...r2) => {
  if (r2.length === 0) return ue.get(e);
  let a2 = e.clone();
  return ue.add(a2, r2[0]), a2;
}, e.isOptional = () => e.safeParse(void 0).success, e.isNullable = () => e.safeParse(null).success, e.apply = (r2) => r2(e), e)), Ei = p("_ZodString", (e, i) => {
  zt.init(e, i), x.init(e, i), e._zod.processJSONSchema = (a2, t, n) => Wl(e, a2, t);
  let r2 = e._zod.bag;
  e.format = r2.format ?? null, e.minLength = r2.minimum ?? null, e.maxLength = r2.maximum ?? null, e.regex = (...a2) => e.check(vi(...a2)), e.includes = (...a2) => e.check(_i(...a2)), e.startsWith = (...a2) => e.check(bi(...a2)), e.endsWith = (...a2) => e.check(yi(...a2)), e.min = (...a2) => e.check(Me(...a2)), e.max = (...a2) => e.check(Ut(...a2)), e.length = (...a2) => e.check(Ot(...a2)), e.nonempty = (...a2) => e.check(Me(1, ...a2)), e.lowercase = (a2) => e.check(gi(a2)), e.uppercase = (a2) => e.check(hi(a2)), e.trim = () => e.check(ki()), e.normalize = (...a2) => e.check(Ii(...a2)), e.toLowerCase = () => e.check(wi()), e.toUpperCase = () => e.check(Si()), e.slugify = () => e.check(xi());
}), Rt = p("ZodString", (e, i) => {
  zt.init(e, i), Ei.init(e, i), e.email = (r2) => e.check(qr(zi, r2)), e.url = (r2) => e.check(pi(Pt, r2)), e.jwt = (r2) => e.check(fn(Ji, r2)), e.emoji = (r2) => e.check(Xr(Ti, r2)), e.guid = (r2) => e.check(ii(pt, r2)), e.uuid = (r2) => e.check(Yr(he, r2)), e.uuidv4 = (r2) => e.check(Br(he, r2)), e.uuidv6 = (r2) => e.check(Hr(he, r2)), e.uuidv7 = (r2) => e.check(Kr(he, r2)), e.nanoid = (r2) => e.check(Qr(Ui, r2)), e.guid = (r2) => e.check(ii(pt, r2)), e.cuid = (r2) => e.check(en(Oi, r2)), e.cuid2 = (r2) => e.check(tn(Ni, r2)), e.ulid = (r2) => e.check(rn(Ri, r2)), e.base64 = (r2) => e.check(dn(Li, r2)), e.base64url = (r2) => e.check(cn(Mi, r2)), e.xid = (r2) => e.check(nn(Pi, r2)), e.ksuid = (r2) => e.check(an(Di, r2)), e.ipv4 = (r2) => e.check(on(ji, r2)), e.ipv6 = (r2) => e.check(sn(Ai, r2)), e.cidrv4 = (r2) => e.check(un(Zi, r2)), e.cidrv6 = (r2) => e.check(ln(Ci, r2)), e.e164 = (r2) => e.check(mn(Fi, r2)), e.datetime = (r2) => e.check(Nd(r2)), e.date = (r2) => e.check(Rd(r2)), e.time = (r2) => e.check(Pd(r2)), e.duration = (r2) => e.check(Dd(r2));
});
function ri(e) {
  return al(Rt, e);
}
var Z = p("ZodStringFormat", (e, i) => {
  A.init(e, i), Ei.init(e, i);
}), zi = p("ZodEmail", (e, i) => {
  Fs.init(e, i), Z.init(e, i);
});
function Bd(e) {
  return qr(zi, e);
}
var pt = p("ZodGUID", (e, i) => {
  Ls.init(e, i), Z.init(e, i);
});
function Hd(e) {
  return ii(pt, e);
}
var he = p("ZodUUID", (e, i) => {
  Ms.init(e, i), Z.init(e, i);
});
function Kd(e) {
  return Yr(he, e);
}
function Xd(e) {
  return Br(he, e);
}
function Qd(e) {
  return Hr(he, e);
}
function ec(e) {
  return Kr(he, e);
}
var Pt = p("ZodURL", (e, i) => {
  Js.init(e, i), Z.init(e, i);
});
function tc(e) {
  return pi(Pt, e);
}
function ic(e) {
  return pi(Pt, { protocol: /^https?$/, hostname: Ve.domain, ...T.normalizeParams(e) });
}
var Ti = p("ZodEmoji", (e, i) => {
  Vs.init(e, i), Z.init(e, i);
});
function rc(e) {
  return Xr(Ti, e);
}
var Ui = p("ZodNanoID", (e, i) => {
  Gs.init(e, i), Z.init(e, i);
});
function nc(e) {
  return Qr(Ui, e);
}
var Oi = p("ZodCUID", (e, i) => {
  Ws.init(e, i), Z.init(e, i);
});
function ac(e) {
  return en(Oi, e);
}
var Ni = p("ZodCUID2", (e, i) => {
  qs.init(e, i), Z.init(e, i);
});
function oc(e) {
  return tn(Ni, e);
}
var Ri = p("ZodULID", (e, i) => {
  Ys.init(e, i), Z.init(e, i);
});
function sc(e) {
  return rn(Ri, e);
}
var Pi = p("ZodXID", (e, i) => {
  Bs.init(e, i), Z.init(e, i);
});
function uc(e) {
  return nn(Pi, e);
}
var Di = p("ZodKSUID", (e, i) => {
  Hs.init(e, i), Z.init(e, i);
});
function lc(e) {
  return an(Di, e);
}
var ji = p("ZodIPv4", (e, i) => {
  tu.init(e, i), Z.init(e, i);
});
function dc(e) {
  return on(ji, e);
}
var xn = p("ZodMAC", (e, i) => {
  ru.init(e, i), Z.init(e, i);
});
function cc(e) {
  return sl(xn, e);
}
var Ai = p("ZodIPv6", (e, i) => {
  iu.init(e, i), Z.init(e, i);
});
function mc(e) {
  return sn(Ai, e);
}
var Zi = p("ZodCIDRv4", (e, i) => {
  nu.init(e, i), Z.init(e, i);
});
function fc(e) {
  return un(Zi, e);
}
var Ci = p("ZodCIDRv6", (e, i) => {
  au.init(e, i), Z.init(e, i);
});
function pc(e) {
  return ln(Ci, e);
}
var Li = p("ZodBase64", (e, i) => {
  ou.init(e, i), Z.init(e, i);
});
function vc(e) {
  return dn(Li, e);
}
var Mi = p("ZodBase64URL", (e, i) => {
  uu.init(e, i), Z.init(e, i);
});
function gc(e) {
  return cn(Mi, e);
}
var Fi = p("ZodE164", (e, i) => {
  lu.init(e, i), Z.init(e, i);
});
function hc(e) {
  return mn(Fi, e);
}
var Ji = p("ZodJWT", (e, i) => {
  cu.init(e, i), Z.init(e, i);
});
function _c(e) {
  return fn(Ji, e);
}
var st = p("ZodCustomStringFormat", (e, i) => {
  mu.init(e, i), Z.init(e, i);
});
function bc(e, i, r2 = {}) {
  return Nt(st, e, i, r2);
}
function yc(e) {
  return Nt(st, "hostname", Ve.hostname, e);
}
function $c(e) {
  return Nt(st, "hex", Ve.hex, e);
}
function Ic(e, i) {
  let r2 = (i == null ? void 0 : i.enc) ?? "hex", a2 = `${e}_${r2}`, t = Ve[a2];
  if (!t) throw Error(`Unrecognized hash format: ${a2}`);
  return Nt(st, a2, t, i);
}
var Dt = p("ZodNumber", (e, i) => {
  Cr.init(e, i), x.init(e, i), e._zod.processJSONSchema = (a2, t, n) => ql(e, a2, t), e.gt = (a2, t) => e.check(Ee(a2, t)), e.gte = (a2, t) => e.check(ee(a2, t)), e.min = (a2, t) => e.check(ee(a2, t)), e.lt = (a2, t) => e.check(xe(a2, t)), e.lte = (a2, t) => e.check(le(a2, t)), e.max = (a2, t) => e.check(le(a2, t)), e.int = (a2) => e.check(ni(a2)), e.safe = (a2) => e.check(ni(a2)), e.positive = (a2) => e.check(Ee(0, a2)), e.nonnegative = (a2) => e.check(ee(0, a2)), e.negative = (a2) => e.check(xe(0, a2)), e.nonpositive = (a2) => e.check(le(0, a2)), e.multipleOf = (a2, t) => e.check(tt(a2, t)), e.step = (a2, t) => e.check(tt(a2, t)), e.finite = () => e;
  let r2 = e._zod.bag;
  e.minValue = Math.max(r2.minimum ?? Number.NEGATIVE_INFINITY, r2.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null, e.maxValue = Math.min(r2.maximum ?? Number.POSITIVE_INFINITY, r2.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null, e.isInt = (r2.format ?? "").includes("int") || Number.isSafeInteger(r2.multipleOf ?? 0.5), e.isFinite = true, e.format = r2.format ?? null;
});
function En(e) {
  return fl(Dt, e);
}
var Ge = p("ZodNumberFormat", (e, i) => {
  fu.init(e, i), Dt.init(e, i);
});
function ni(e) {
  return vl(Ge, e);
}
function kc(e) {
  return gl(Ge, e);
}
function wc(e) {
  return hl(Ge, e);
}
function Sc(e) {
  return _l(Ge, e);
}
function xc(e) {
  return bl(Ge, e);
}
var jt = p("ZodBoolean", (e, i) => {
  Lr.init(e, i), x.init(e, i), e._zod.processJSONSchema = (r2, a2, t) => Yl(e, r2, a2);
});
function zn(e) {
  return yl(jt, e);
}
var At = p("ZodBigInt", (e, i) => {
  Mr.init(e, i), x.init(e, i), e._zod.processJSONSchema = (a2, t, n) => Bl(e, a2), e.gte = (a2, t) => e.check(ee(a2, t)), e.min = (a2, t) => e.check(ee(a2, t)), e.gt = (a2, t) => e.check(Ee(a2, t)), e.gte = (a2, t) => e.check(ee(a2, t)), e.min = (a2, t) => e.check(ee(a2, t)), e.lt = (a2, t) => e.check(xe(a2, t)), e.lte = (a2, t) => e.check(le(a2, t)), e.max = (a2, t) => e.check(le(a2, t)), e.positive = (a2) => e.check(Ee(BigInt(0), a2)), e.negative = (a2) => e.check(xe(BigInt(0), a2)), e.nonpositive = (a2) => e.check(le(BigInt(0), a2)), e.nonnegative = (a2) => e.check(ee(BigInt(0), a2)), e.multipleOf = (a2, t) => e.check(tt(a2, t));
  let r2 = e._zod.bag;
  e.minValue = r2.minimum ?? null, e.maxValue = r2.maximum ?? null, e.format = r2.format ?? null;
});
function Ec(e) {
  return Il(At, e);
}
var Vi = p("ZodBigIntFormat", (e, i) => {
  pu.init(e, i), At.init(e, i);
});
function zc(e) {
  return wl(Vi, e);
}
function Tc(e) {
  return Sl(Vi, e);
}
var Tn = p("ZodSymbol", (e, i) => {
  vu.init(e, i), x.init(e, i), e._zod.processJSONSchema = (r2, a2, t) => Hl(e, r2);
});
function Uc(e) {
  return xl(Tn, e);
}
var Un = p("ZodUndefined", (e, i) => {
  gu.init(e, i), x.init(e, i), e._zod.processJSONSchema = (r2, a2, t) => Xl(e, r2);
});
function Oc(e) {
  return El(Un, e);
}
var On = p("ZodNull", (e, i) => {
  hu.init(e, i), x.init(e, i), e._zod.processJSONSchema = (r2, a2, t) => Kl(e, r2, a2);
});
function Nn(e) {
  return zl(On, e);
}
var Rn = p("ZodAny", (e, i) => {
  _u.init(e, i), x.init(e, i), e._zod.processJSONSchema = (r2, a2, t) => td();
});
function Nc() {
  return Tl(Rn);
}
var Pn = p("ZodUnknown", (e, i) => {
  bu.init(e, i), x.init(e, i), e._zod.processJSONSchema = (r2, a2, t) => id();
});
function Fe2() {
  return Ul(Pn);
}
var Dn = p("ZodNever", (e, i) => {
  yu.init(e, i), x.init(e, i), e._zod.processJSONSchema = (r2, a2, t) => ed(e, r2, a2);
});
function Gi(e) {
  return Ol(Dn, e);
}
var jn = p("ZodVoid", (e, i) => {
  $u.init(e, i), x.init(e, i), e._zod.processJSONSchema = (r2, a2, t) => Ql(e, r2);
});
function Rc(e) {
  return Nl(jn, e);
}
var Wi = p("ZodDate", (e, i) => {
  Iu.init(e, i), x.init(e, i), e._zod.processJSONSchema = (a2, t, n) => rd(e, a2), e.min = (a2, t) => e.check(ee(a2, t)), e.max = (a2, t) => e.check(le(a2, t));
  let r2 = e._zod.bag;
  e.minDate = r2.minimum ? new Date(r2.minimum) : null, e.maxDate = r2.maximum ? new Date(r2.maximum) : null;
});
function Pc(e) {
  return Rl(Wi, e);
}
var An = p("ZodArray", (e, i) => {
  ku.init(e, i), x.init(e, i), e._zod.processJSONSchema = (r2, a2, t) => vd(e, r2, a2, t), e.element = i.element, e.min = (r2, a2) => e.check(Me(r2, a2)), e.nonempty = (r2) => e.check(Me(1, r2)), e.max = (r2, a2) => e.check(Ut(r2, a2)), e.length = (r2, a2) => e.check(Ot(r2, a2)), e.unwrap = () => e.element;
});
function Zt(e, i) {
  return jl(An, e, i);
}
function Dc(e) {
  let i = e._zod.def.shape;
  return Yi(Object.keys(i));
}
var Ct = p("ZodObject", (e, i) => {
  Eu.init(e, i), x.init(e, i), e._zod.processJSONSchema = (r2, a2, t) => gd(e, r2, a2, t), T.defineLazy(e, "shape", () => i.shape), e.keyof = () => Yi(Object.keys(e._zod.def.shape)), e.catchall = (r2) => e.clone({ ...e._zod.def, catchall: r2 }), e.passthrough = () => e.clone({ ...e._zod.def, catchall: Fe2() }), e.loose = () => e.clone({ ...e._zod.def, catchall: Fe2() }), e.strict = () => e.clone({ ...e._zod.def, catchall: Gi() }), e.strip = () => e.clone({ ...e._zod.def, catchall: void 0 }), e.extend = (r2) => T.extend(e, r2), e.safeExtend = (r2) => T.safeExtend(e, r2), e.merge = (r2) => T.merge(e, r2), e.pick = (r2) => T.pick(e, r2), e.omit = (r2) => T.omit(e, r2), e.partial = (...r2) => T.partial(Hi, e, r2[0]), e.required = (...r2) => T.required(Ki, e, r2[0]);
});
function jc(e, i) {
  let r2 = { type: "object", shape: e ?? {}, ...T.normalizeParams(i) };
  return new Ct(r2);
}
function Ac(e, i) {
  return new Ct({ type: "object", shape: e, catchall: Gi(), ...T.normalizeParams(i) });
}
function Zc(e, i) {
  return new Ct({ type: "object", shape: e, catchall: Fe2(), ...T.normalizeParams(i) });
}
var Lt = p("ZodUnion", (e, i) => {
  fi.init(e, i), x.init(e, i), e._zod.processJSONSchema = (r2, a2, t) => bn(e, r2, a2, t), e.options = i.options;
});
function qi(e, i) {
  return new Lt({ type: "union", options: e, ...T.normalizeParams(i) });
}
var Zn = p("ZodXor", (e, i) => {
  Lt.init(e, i), zu.init(e, i), e._zod.processJSONSchema = (r2, a2, t) => bn(e, r2, a2, t), e.options = i.options;
});
function Cc(e, i) {
  return new Zn({ type: "union", options: e, inclusive: false, ...T.normalizeParams(i) });
}
var Cn = p("ZodDiscriminatedUnion", (e, i) => {
  Lt.init(e, i), Tu.init(e, i);
});
function Lc(e, i, r2) {
  return new Cn({ type: "union", options: i, discriminator: e, ...T.normalizeParams(r2) });
}
var Ln = p("ZodIntersection", (e, i) => {
  Uu.init(e, i), x.init(e, i), e._zod.processJSONSchema = (r2, a2, t) => hd(e, r2, a2, t);
});
function Mn(e, i) {
  return new Ln({ type: "intersection", left: e, right: i });
}
var Fn = p("ZodTuple", (e, i) => {
  Fr.init(e, i), x.init(e, i), e._zod.processJSONSchema = (r2, a2, t) => _d(e, r2, a2, t), e.rest = (r2) => e.clone({ ...e._zod.def, rest: r2 });
});
function Jn(e, i, r2) {
  let a2 = i instanceof S, t = a2 ? r2 : i;
  return new Fn({ type: "tuple", items: e, rest: a2 ? i : null, ...T.normalizeParams(t) });
}
var Mt = p("ZodRecord", (e, i) => {
  Ou.init(e, i), x.init(e, i), e._zod.processJSONSchema = (r2, a2, t) => bd(e, r2, a2, t), e.keyType = i.keyType, e.valueType = i.valueType;
});
function Vn(e, i, r2) {
  return new Mt({ type: "record", keyType: e, valueType: i, ...T.normalizeParams(r2) });
}
function Mc(e, i, r2) {
  let a2 = me(e);
  return a2._zod.values = void 0, new Mt({ type: "record", keyType: a2, valueType: i, ...T.normalizeParams(r2) });
}
function Fc(e, i, r2) {
  return new Mt({ type: "record", keyType: e, valueType: i, mode: "loose", ...T.normalizeParams(r2) });
}
var Gn = p("ZodMap", (e, i) => {
  Nu.init(e, i), x.init(e, i), e._zod.processJSONSchema = (r2, a2, t) => fd(e, r2), e.keyType = i.keyType, e.valueType = i.valueType, e.min = (...r2) => e.check(ze(...r2)), e.nonempty = (r2) => e.check(ze(1, r2)), e.max = (...r2) => e.check(ot(...r2)), e.size = (...r2) => e.check(Tt(...r2));
});
function Jc(e, i, r2) {
  return new Gn({ type: "map", keyType: e, valueType: i, ...T.normalizeParams(r2) });
}
var Wn = p("ZodSet", (e, i) => {
  Ru.init(e, i), x.init(e, i), e._zod.processJSONSchema = (r2, a2, t) => pd(e, r2), e.min = (...r2) => e.check(ze(...r2)), e.nonempty = (r2) => e.check(ze(1, r2)), e.max = (...r2) => e.check(ot(...r2)), e.size = (...r2) => e.check(Tt(...r2));
});
function Vc(e, i) {
  return new Wn({ type: "set", valueType: e, ...T.normalizeParams(i) });
}
var at = p("ZodEnum", (e, i) => {
  Pu.init(e, i), x.init(e, i), e._zod.processJSONSchema = (a2, t, n) => nd(e, a2, t), e.enum = i.entries, e.options = Object.values(i.entries);
  let r2 = new Set(Object.keys(i.entries));
  e.extract = (a2, t) => {
    let n = {};
    for (let o of a2) if (r2.has(o)) n[o] = i.entries[o];
    else throw Error(`Key ${o} not found in enum`);
    return new at({ ...i, checks: [], ...T.normalizeParams(t), entries: n });
  }, e.exclude = (a2, t) => {
    let n = { ...i.entries };
    for (let o of a2) if (r2.has(o)) delete n[o];
    else throw Error(`Key ${o} not found in enum`);
    return new at({ ...i, checks: [], ...T.normalizeParams(t), entries: n });
  };
});
function Yi(e, i) {
  let r2 = Array.isArray(e) ? Object.fromEntries(e.map((a2) => [a2, a2])) : e;
  return new at({ type: "enum", entries: r2, ...T.normalizeParams(i) });
}
function Gc(e, i) {
  return new at({ type: "enum", entries: e, ...T.normalizeParams(i) });
}
var qn = p("ZodLiteral", (e, i) => {
  Du.init(e, i), x.init(e, i), e._zod.processJSONSchema = (r2, a2, t) => ad(e, r2, a2), e.values = new Set(i.values), Object.defineProperty(e, "value", { get() {
    if (i.values.length > 1) throw Error("This schema contains multiple valid literal values. Use `.values` instead.");
    return i.values[0];
  } });
});
function Wc(e, i) {
  return new qn({ type: "literal", values: Array.isArray(e) ? e : [e], ...T.normalizeParams(i) });
}
var Yn = p("ZodFile", (e, i) => {
  ju.init(e, i), x.init(e, i), e._zod.processJSONSchema = (r2, a2, t) => ud(e, r2, a2), e.min = (r2, a2) => e.check(ze(r2, a2)), e.max = (r2, a2) => e.check(ot(r2, a2)), e.mime = (r2, a2) => e.check($i(Array.isArray(r2) ? r2 : [r2], a2));
});
function qc(e) {
  return Al(Yn, e);
}
var Bn = p("ZodTransform", (e, i) => {
  Au.init(e, i), x.init(e, i), e._zod.processJSONSchema = (r2, a2, t) => md(e, r2), e._zod.parse = (r2, a2) => {
    if (a2.direction === "backward") throw new li(e.constructor.name);
    r2.addIssue = (n) => {
      if (typeof n == "string") r2.issues.push(T.issue(n, r2.value, i));
      else {
        let o = n;
        o.fatal && (o.continue = false), o.code ?? (o.code = "custom"), o.input ?? (o.input = r2.value), o.inst ?? (o.inst = e), r2.issues.push(T.issue(o));
      }
    };
    let t = i.transform(r2.value, r2);
    return t instanceof Promise ? t.then((n) => (r2.value = n, r2)) : (r2.value = t, r2);
  };
});
function Bi(e) {
  return new Bn({ type: "transform", transform: e });
}
var Hi = p("ZodOptional", (e, i) => {
  Jr.init(e, i), x.init(e, i), e._zod.processJSONSchema = (r2, a2, t) => yn(e, r2, a2, t), e.unwrap = () => e._zod.def.innerType;
});
function vt(e) {
  return new Hi({ type: "optional", innerType: e });
}
var Hn = p("ZodExactOptional", (e, i) => {
  Zu.init(e, i), x.init(e, i), e._zod.processJSONSchema = (r2, a2, t) => yn(e, r2, a2, t), e.unwrap = () => e._zod.def.innerType;
});
function Kn(e) {
  return new Hn({ type: "optional", innerType: e });
}
var Xn = p("ZodNullable", (e, i) => {
  Cu.init(e, i), x.init(e, i), e._zod.processJSONSchema = (r2, a2, t) => yd(e, r2, a2, t), e.unwrap = () => e._zod.def.innerType;
});
function gt(e) {
  return new Xn({ type: "nullable", innerType: e });
}
function Yc(e) {
  return vt(gt(e));
}
var Qn = p("ZodDefault", (e, i) => {
  Lu.init(e, i), x.init(e, i), e._zod.processJSONSchema = (r2, a2, t) => Id(e, r2, a2, t), e.unwrap = () => e._zod.def.innerType, e.removeDefault = e.unwrap;
});
function ea(e, i) {
  return new Qn({ type: "default", innerType: e, get defaultValue() {
    return typeof i == "function" ? i() : T.shallowClone(i);
  } });
}
var ta = p("ZodPrefault", (e, i) => {
  Mu.init(e, i), x.init(e, i), e._zod.processJSONSchema = (r2, a2, t) => kd(e, r2, a2, t), e.unwrap = () => e._zod.def.innerType;
});
function ia(e, i) {
  return new ta({ type: "prefault", innerType: e, get defaultValue() {
    return typeof i == "function" ? i() : T.shallowClone(i);
  } });
}
var Ki = p("ZodNonOptional", (e, i) => {
  Fu.init(e, i), x.init(e, i), e._zod.processJSONSchema = (r2, a2, t) => $d(e, r2, a2, t), e.unwrap = () => e._zod.def.innerType;
});
function ra(e, i) {
  return new Ki({ type: "nonoptional", innerType: e, ...T.normalizeParams(i) });
}
var na = p("ZodSuccess", (e, i) => {
  Ju.init(e, i), x.init(e, i), e._zod.processJSONSchema = (r2, a2, t) => ld(e, r2, a2), e.unwrap = () => e._zod.def.innerType;
});
function Bc(e) {
  return new na({ type: "success", innerType: e });
}
var aa = p("ZodCatch", (e, i) => {
  Vu.init(e, i), x.init(e, i), e._zod.processJSONSchema = (r2, a2, t) => wd(e, r2, a2, t), e.unwrap = () => e._zod.def.innerType, e.removeCatch = e.unwrap;
});
function oa(e, i) {
  return new aa({ type: "catch", innerType: e, catchValue: typeof i == "function" ? i : () => i });
}
var sa = p("ZodNaN", (e, i) => {
  Gu.init(e, i), x.init(e, i), e._zod.processJSONSchema = (r2, a2, t) => od(e, r2);
});
function Hc(e) {
  return Dl(sa, e);
}
var Xi = p("ZodPipe", (e, i) => {
  Wu.init(e, i), x.init(e, i), e._zod.processJSONSchema = (r2, a2, t) => Sd(e, r2, a2, t), e.in = i.in, e.out = i.out;
});
function ht(e, i) {
  return new Xi({ type: "pipe", in: e, out: i });
}
var Qi = p("ZodCodec", (e, i) => {
  Xi.init(e, i), Vr.init(e, i);
});
function Kc(e, i, r2) {
  return new Qi({ type: "pipe", in: e, out: i, transform: r2.decode, reverseTransform: r2.encode });
}
var ua = p("ZodReadonly", (e, i) => {
  qu.init(e, i), x.init(e, i), e._zod.processJSONSchema = (r2, a2, t) => xd(e, r2, a2, t), e.unwrap = () => e._zod.def.innerType;
});
function la(e) {
  return new ua({ type: "readonly", innerType: e });
}
var da = p("ZodTemplateLiteral", (e, i) => {
  Yu.init(e, i), x.init(e, i), e._zod.processJSONSchema = (r2, a2, t) => sd(e, r2, a2);
});
function Xc(e, i) {
  return new da({ type: "template_literal", parts: e, ...T.normalizeParams(i) });
}
var ca = p("ZodLazy", (e, i) => {
  Ku.init(e, i), x.init(e, i), e._zod.processJSONSchema = (r2, a2, t) => zd(e, r2, a2, t), e.unwrap = () => e._zod.def.getter();
});
function ma(e) {
  return new ca({ type: "lazy", getter: e });
}
var fa = p("ZodPromise", (e, i) => {
  Hu.init(e, i), x.init(e, i), e._zod.processJSONSchema = (r2, a2, t) => Ed(e, r2, a2, t), e.unwrap = () => e._zod.def.innerType;
});
function Qc(e) {
  return new fa({ type: "promise", innerType: e });
}
var pa = p("ZodFunction", (e, i) => {
  Bu.init(e, i), x.init(e, i), e._zod.processJSONSchema = (r2, a2, t) => cd(e, r2);
});
function ai(e) {
  return new pa({ type: "function", input: Array.isArray(e == null ? void 0 : e.input) ? Jn(e == null ? void 0 : e.input) : (e == null ? void 0 : e.input) ?? Zt(Fe2()), output: (e == null ? void 0 : e.output) ?? Fe2() });
}
var Ft = p("ZodCustom", (e, i) => {
  Xu.init(e, i), x.init(e, i), e._zod.processJSONSchema = (r2, a2, t) => dd(e, r2);
});
function em(e) {
  let i = new M({ check: "custom" });
  return i._zod.check = e, i;
}
function tm(e, i) {
  return Zl(Ft, e ?? (() => true), i);
}
function va(e, i = {}) {
  return Cl(Ft, e, i);
}
function ga(e) {
  return Ll(e);
}
var im = Fl, rm = Jl;
function nm(e, i = {}) {
  let r2 = new Ft({ type: "custom", check: "custom", fn: (a2) => a2 instanceof e, abort: true, ...T.normalizeParams(i) });
  return r2._zod.bag.Class = e, r2._zod.check = (a2) => {
    a2.value instanceof e || a2.issues.push({ code: "invalid_type", expected: e.name, input: a2.value, inst: r2, path: [...r2._zod.def.path ?? []] });
  }, r2;
}
var am = (...e) => Vl({ Codec: Qi, Boolean: jt, String: Rt }, ...e);
function om(e) {
  let i = ma(() => qi([ri(e), En(), zn(), Nn(), Zt(i), Vn(ri(), i)]));
  return i;
}
function sm(e, i) {
  return ht(Bi(e), i);
}
var Jg = { invalid_type: "invalid_type", too_big: "too_big", too_small: "too_small", invalid_format: "invalid_format", not_multiple_of: "not_multiple_of", unrecognized_keys: "unrecognized_keys", invalid_union: "invalid_union", invalid_key: "invalid_key", invalid_element: "invalid_element", invalid_value: "invalid_value", custom: "custom" };
function Vg(e) {
  H({ customError: e });
}
function Gg() {
  return H().customError;
}
var hr;
hr || (hr = {});
var y = { ...Ud, ...Od, iso: $n }, Wg = /* @__PURE__ */ new Set(["$schema", "$ref", "$defs", "definitions", "$id", "id", "$comment", "$anchor", "$vocabulary", "$dynamicRef", "$dynamicAnchor", "type", "enum", "const", "anyOf", "oneOf", "allOf", "not", "properties", "required", "additionalProperties", "patternProperties", "propertyNames", "minProperties", "maxProperties", "items", "prefixItems", "additionalItems", "minItems", "maxItems", "uniqueItems", "contains", "minContains", "maxContains", "minLength", "maxLength", "pattern", "format", "minimum", "maximum", "exclusiveMinimum", "exclusiveMaximum", "multipleOf", "description", "default", "contentEncoding", "contentMediaType", "contentSchema", "unevaluatedItems", "unevaluatedProperties", "if", "then", "else", "dependentSchemas", "dependentRequired", "nullable", "readOnly"]);
function qg(e, i) {
  let r2 = e.$schema;
  return r2 === "https://json-schema.org/draft/2020-12/schema" ? "draft-2020-12" : r2 === "http://json-schema.org/draft-07/schema#" ? "draft-7" : r2 === "http://json-schema.org/draft-04/schema#" ? "draft-4" : i ?? "draft-2020-12";
}
function Yg(e, i) {
  if (!e.startsWith("#")) throw Error("External $ref is not supported, only local refs (#/...) are allowed");
  let r2 = e.slice(1).split("/").filter(Boolean);
  if (r2.length === 0) return i.rootSchema;
  let a2 = i.version === "draft-2020-12" ? "$defs" : "definitions";
  if (r2[0] === a2) {
    let t = r2[1];
    if (!t || !i.defs[t]) throw Error(`Reference not found: ${e}`);
    return i.defs[t];
  }
  throw Error(`Reference not found: ${e}`);
}
function um(e, i) {
  if (e.not !== void 0) {
    if (typeof e.not == "object" && Object.keys(e.not).length === 0) return y.never();
    throw Error("not is not supported in Zod (except { not: {} } for never)");
  }
  if (e.unevaluatedItems !== void 0) throw Error("unevaluatedItems is not supported");
  if (e.unevaluatedProperties !== void 0) throw Error("unevaluatedProperties is not supported");
  if (e.if !== void 0 || e.then !== void 0 || e.else !== void 0) throw Error("Conditional schemas (if/then/else) are not supported");
  if (e.dependentSchemas !== void 0 || e.dependentRequired !== void 0) throw Error("dependentSchemas and dependentRequired are not supported");
  if (e.$ref) {
    let t = e.$ref;
    if (i.refs.has(t)) return i.refs.get(t);
    if (i.processing.has(t)) return y.lazy(() => {
      if (!i.refs.has(t)) throw Error(`Circular reference not resolved: ${t}`);
      return i.refs.get(t);
    });
    i.processing.add(t);
    let n = Yg(t, i), o = B(n, i);
    return i.refs.set(t, o), i.processing.delete(t), o;
  }
  if (e.enum !== void 0) {
    let t = e.enum;
    if (i.version === "openapi-3.0" && e.nullable === true && t.length === 1 && t[0] === null) return y.null();
    if (t.length === 0) return y.never();
    if (t.length === 1) return y.literal(t[0]);
    if (t.every((o) => typeof o == "string")) return y.enum(t);
    let n = t.map((o) => y.literal(o));
    return n.length < 2 ? n[0] : y.union([n[0], n[1], ...n.slice(2)]);
  }
  if (e.const !== void 0) return y.literal(e.const);
  let r2 = e.type;
  if (Array.isArray(r2)) {
    let t = r2.map((n) => {
      let o = { ...e, type: n };
      return um(o, i);
    });
    return t.length === 0 ? y.never() : t.length === 1 ? t[0] : y.union(t);
  }
  if (!r2) return y.any();
  let a2;
  switch (r2) {
    case "string": {
      let t = y.string();
      if (e.format) {
        let n = e.format;
        n === "email" ? t = t.check(y.email()) : n === "uri" || n === "uri-reference" ? t = t.check(y.url()) : n === "uuid" || n === "guid" ? t = t.check(y.uuid()) : n === "date-time" ? t = t.check(y.iso.datetime()) : n === "date" ? t = t.check(y.iso.date()) : n === "time" ? t = t.check(y.iso.time()) : n === "duration" ? t = t.check(y.iso.duration()) : n === "ipv4" ? t = t.check(y.ipv4()) : n === "ipv6" ? t = t.check(y.ipv6()) : n === "mac" ? t = t.check(y.mac()) : n === "cidr" ? t = t.check(y.cidrv4()) : n === "cidr-v6" ? t = t.check(y.cidrv6()) : n === "base64" ? t = t.check(y.base64()) : n === "base64url" ? t = t.check(y.base64url()) : n === "e164" ? t = t.check(y.e164()) : n === "jwt" ? t = t.check(y.jwt()) : n === "emoji" ? t = t.check(y.emoji()) : n === "nanoid" ? t = t.check(y.nanoid()) : n === "cuid" ? t = t.check(y.cuid()) : n === "cuid2" ? t = t.check(y.cuid2()) : n === "ulid" ? t = t.check(y.ulid()) : n === "xid" ? t = t.check(y.xid()) : n === "ksuid" && (t = t.check(y.ksuid()));
      }
      typeof e.minLength == "number" && (t = t.min(e.minLength)), typeof e.maxLength == "number" && (t = t.max(e.maxLength)), e.pattern && (t = t.regex(new RegExp(e.pattern))), a2 = t;
      break;
    }
    case "number":
    case "integer": {
      let t = r2 === "integer" ? y.number().int() : y.number();
      typeof e.minimum == "number" && (t = t.min(e.minimum)), typeof e.maximum == "number" && (t = t.max(e.maximum)), typeof e.exclusiveMinimum == "number" ? t = t.gt(e.exclusiveMinimum) : e.exclusiveMinimum === true && typeof e.minimum == "number" && (t = t.gt(e.minimum)), typeof e.exclusiveMaximum == "number" ? t = t.lt(e.exclusiveMaximum) : e.exclusiveMaximum === true && typeof e.maximum == "number" && (t = t.lt(e.maximum)), typeof e.multipleOf == "number" && (t = t.multipleOf(e.multipleOf)), a2 = t;
      break;
    }
    case "boolean": {
      a2 = y.boolean();
      break;
    }
    case "null": {
      a2 = y.null();
      break;
    }
    case "object": {
      let t = {}, n = e.properties || {}, o = new Set(e.required || []);
      for (let [u2, l] of Object.entries(n)) {
        let d2 = B(l, i);
        t[u2] = o.has(u2) ? d2 : d2.optional();
      }
      if (e.propertyNames) {
        let u2 = B(e.propertyNames, i), l = e.additionalProperties && typeof e.additionalProperties == "object" ? B(e.additionalProperties, i) : y.any();
        if (Object.keys(t).length === 0) {
          a2 = y.record(u2, l);
          break;
        }
        let d2 = y.object(t).passthrough(), c = y.looseRecord(u2, l);
        a2 = y.intersection(d2, c);
        break;
      }
      if (e.patternProperties) {
        let u2 = e.patternProperties, l = Object.keys(u2), d2 = [];
        for (let f2 of l) {
          let v = B(u2[f2], i), g2 = y.string().regex(new RegExp(f2));
          d2.push(y.looseRecord(g2, v));
        }
        let c = [];
        if (Object.keys(t).length > 0 && c.push(y.object(t).passthrough()), c.push(...d2), c.length === 0) a2 = y.object({}).passthrough();
        else if (c.length === 1) a2 = c[0];
        else {
          let f2 = y.intersection(c[0], c[1]);
          for (let v = 2; v < c.length; v++) f2 = y.intersection(f2, c[v]);
          a2 = f2;
        }
        break;
      }
      let s2 = y.object(t);
      e.additionalProperties === false ? a2 = s2.strict() : typeof e.additionalProperties == "object" ? a2 = s2.catchall(B(e.additionalProperties, i)) : a2 = s2.passthrough();
      break;
    }
    case "array": {
      let { prefixItems: t, items: n } = e;
      if (t && Array.isArray(t)) {
        let o = t.map((u2) => B(u2, i)), s2 = n && typeof n == "object" && !Array.isArray(n) ? B(n, i) : void 0;
        s2 ? a2 = y.tuple(o).rest(s2) : a2 = y.tuple(o), typeof e.minItems == "number" && (a2 = a2.check(y.minLength(e.minItems))), typeof e.maxItems == "number" && (a2 = a2.check(y.maxLength(e.maxItems)));
      } else if (Array.isArray(n)) {
        let o = n.map((u2) => B(u2, i)), s2 = e.additionalItems && typeof e.additionalItems == "object" ? B(e.additionalItems, i) : void 0;
        s2 ? a2 = y.tuple(o).rest(s2) : a2 = y.tuple(o), typeof e.minItems == "number" && (a2 = a2.check(y.minLength(e.minItems))), typeof e.maxItems == "number" && (a2 = a2.check(y.maxLength(e.maxItems)));
      } else if (n !== void 0) {
        let o = B(n, i), s2 = y.array(o);
        typeof e.minItems == "number" && (s2 = s2.min(e.minItems)), typeof e.maxItems == "number" && (s2 = s2.max(e.maxItems)), a2 = s2;
      } else a2 = y.array(y.any());
      break;
    }
    default:
      throw Error(`Unsupported type: ${r2}`);
  }
  return e.description && (a2 = a2.describe(e.description)), e.default !== void 0 && (a2 = a2.default(e.default)), a2;
}
function B(e, i) {
  if (typeof e == "boolean") return e ? y.any() : y.never();
  let r2 = um(e, i), a2 = e.type || e.enum !== void 0 || e.const !== void 0;
  if (e.anyOf && Array.isArray(e.anyOf)) {
    let s2 = e.anyOf.map((l) => B(l, i)), u2 = y.union(s2);
    r2 = a2 ? y.intersection(r2, u2) : u2;
  }
  if (e.oneOf && Array.isArray(e.oneOf)) {
    let s2 = e.oneOf.map((l) => B(l, i)), u2 = y.xor(s2);
    r2 = a2 ? y.intersection(r2, u2) : u2;
  }
  if (e.allOf && Array.isArray(e.allOf)) if (e.allOf.length === 0) r2 = a2 ? r2 : y.any();
  else {
    let s2 = a2 ? r2 : B(e.allOf[0], i), u2 = a2 ? 0 : 1;
    for (let l = u2; l < e.allOf.length; l++) s2 = y.intersection(s2, B(e.allOf[l], i));
    r2 = s2;
  }
  e.nullable === true && i.version === "openapi-3.0" && (r2 = y.nullable(r2)), e.readOnly === true && (r2 = y.readonly(r2));
  let t = {}, n = ["$id", "id", "$comment", "$anchor", "$vocabulary", "$dynamicRef", "$dynamicAnchor"];
  for (let s2 of n) s2 in e && (t[s2] = e[s2]);
  let o = ["contentEncoding", "contentMediaType", "contentSchema"];
  for (let s2 of o) s2 in e && (t[s2] = e[s2]);
  for (let s2 of Object.keys(e)) Wg.has(s2) || (t[s2] = e[s2]);
  return Object.keys(t).length > 0 && i.registry.add(r2, t), r2;
}
function Bg(e, i) {
  if (typeof e == "boolean") return e ? y.any() : y.never();
  let r2 = qg(e, i == null ? void 0 : i.defaultTarget), a2 = e.$defs || e.definitions || {}, t = { version: r2, defs: a2, refs: /* @__PURE__ */ new Map(), processing: /* @__PURE__ */ new Set(), rootSchema: e, registry: (i == null ? void 0 : i.registry) ?? ue };
  return B(e, t);
}
var lm = {};
ye(lm, { string: () => Hg, number: () => Kg, date: () => eh, boolean: () => Xg, bigint: () => Qg });
function Hg(e) {
  return ol(Rt, e);
}
function Kg(e) {
  return pl(Dt, e);
}
function Xg(e) {
  return $l(jt, e);
}
function Qg(e) {
  return kl(At, e);
}
function eh(e) {
  return Pl(Wi, e);
}
H(Qu());
var th = m.union([m.literal("light"), m.literal("dark")]).describe("Color theme preference for the host environment."), ha = m.union([m.literal("inline"), m.literal("fullscreen"), m.literal("pip")]).describe("Display mode for UI presentation."), ih = m.union([m.literal("--color-background-primary"), m.literal("--color-background-secondary"), m.literal("--color-background-tertiary"), m.literal("--color-background-inverse"), m.literal("--color-background-ghost"), m.literal("--color-background-info"), m.literal("--color-background-danger"), m.literal("--color-background-success"), m.literal("--color-background-warning"), m.literal("--color-background-disabled"), m.literal("--color-text-primary"), m.literal("--color-text-secondary"), m.literal("--color-text-tertiary"), m.literal("--color-text-inverse"), m.literal("--color-text-ghost"), m.literal("--color-text-info"), m.literal("--color-text-danger"), m.literal("--color-text-success"), m.literal("--color-text-warning"), m.literal("--color-text-disabled"), m.literal("--color-text-ghost"), m.literal("--color-border-primary"), m.literal("--color-border-secondary"), m.literal("--color-border-tertiary"), m.literal("--color-border-inverse"), m.literal("--color-border-ghost"), m.literal("--color-border-info"), m.literal("--color-border-danger"), m.literal("--color-border-success"), m.literal("--color-border-warning"), m.literal("--color-border-disabled"), m.literal("--color-ring-primary"), m.literal("--color-ring-secondary"), m.literal("--color-ring-inverse"), m.literal("--color-ring-info"), m.literal("--color-ring-danger"), m.literal("--color-ring-success"), m.literal("--color-ring-warning"), m.literal("--font-sans"), m.literal("--font-mono"), m.literal("--font-weight-normal"), m.literal("--font-weight-medium"), m.literal("--font-weight-semibold"), m.literal("--font-weight-bold"), m.literal("--font-text-xs-size"), m.literal("--font-text-sm-size"), m.literal("--font-text-md-size"), m.literal("--font-text-lg-size"), m.literal("--font-heading-xs-size"), m.literal("--font-heading-sm-size"), m.literal("--font-heading-md-size"), m.literal("--font-heading-lg-size"), m.literal("--font-heading-xl-size"), m.literal("--font-heading-2xl-size"), m.literal("--font-heading-3xl-size"), m.literal("--font-text-xs-line-height"), m.literal("--font-text-sm-line-height"), m.literal("--font-text-md-line-height"), m.literal("--font-text-lg-line-height"), m.literal("--font-heading-xs-line-height"), m.literal("--font-heading-sm-line-height"), m.literal("--font-heading-md-line-height"), m.literal("--font-heading-lg-line-height"), m.literal("--font-heading-xl-line-height"), m.literal("--font-heading-2xl-line-height"), m.literal("--font-heading-3xl-line-height"), m.literal("--border-radius-xs"), m.literal("--border-radius-sm"), m.literal("--border-radius-md"), m.literal("--border-radius-lg"), m.literal("--border-radius-xl"), m.literal("--border-radius-full"), m.literal("--border-width-regular"), m.literal("--shadow-hairline"), m.literal("--shadow-sm"), m.literal("--shadow-md"), m.literal("--shadow-lg")]).describe("CSS variable keys available to MCP apps for theming."), rh = m.record(ih.describe(`Style variables for theming MCP apps.

Individual style keys are optional - hosts may provide any subset of these values.
Values are strings containing CSS values (colors, sizes, font stacks, etc.).

Note: This type uses \`Record<K, string | undefined>\` rather than \`Partial<Record<K, string>>\`
for compatibility with Zod schema generation. Both are functionally equivalent for validation.`), m.union([m.string(), m.undefined()]).describe(`Style variables for theming MCP apps.

Individual style keys are optional - hosts may provide any subset of these values.
Values are strings containing CSS values (colors, sizes, font stacks, etc.).

Note: This type uses \`Record<K, string | undefined>\` rather than \`Partial<Record<K, string>>\`
for compatibility with Zod schema generation. Both are functionally equivalent for validation.`)).describe(`Style variables for theming MCP apps.

Individual style keys are optional - hosts may provide any subset of these values.
Values are strings containing CSS values (colors, sizes, font stacks, etc.).

Note: This type uses \`Record<K, string | undefined>\` rather than \`Partial<Record<K, string>>\`
for compatibility with Zod schema generation. Both are functionally equivalent for validation.`), nh = m.object({ method: m.literal("ui/open-link"), params: m.object({ url: m.string().describe("URL to open in the host's browser") }) });
m.object({ isError: m.boolean().optional().describe("True if the host failed to open the URL (e.g., due to security policy).") }).passthrough();
m.object({ isError: m.boolean().optional().describe("True if the host rejected or failed to deliver the message.") }).passthrough();
var ah = m.object({ method: m.literal("ui/notifications/sandbox-proxy-ready"), params: m.object({}) });
m.object({ method: m.literal("ui/notifications/sandbox-resource-ready"), params: m.object({ html: m.string().describe("HTML content to load into the inner iframe."), sandbox: m.string().optional().describe("Optional override for the inner iframe's sandbox attribute."), csp: m.object({ connectDomains: m.array(m.string()).optional().describe("Origins for network requests (fetch/XHR/WebSocket)."), resourceDomains: m.array(m.string()).optional().describe("Origins for static resources (scripts, images, styles, fonts).") }).optional().describe("CSP configuration from resource metadata.") }) });
var oh = m.object({ method: m.literal("ui/notifications/size-changed"), params: m.object({ width: m.number().optional().describe("New width in pixels."), height: m.number().optional().describe("New height in pixels.") }) });
m.object({ method: m.literal("ui/notifications/tool-input"), params: m.object({ arguments: m.record(m.string(), m.unknown().describe("Complete tool call arguments as key-value pairs.")).optional().describe("Complete tool call arguments as key-value pairs.") }) });
m.object({ method: m.literal("ui/notifications/tool-input-partial"), params: m.object({ arguments: m.record(m.string(), m.unknown().describe("Partial tool call arguments (incomplete, may change).")).optional().describe("Partial tool call arguments (incomplete, may change).") }) });
m.object({ method: m.literal("ui/notifications/tool-cancelled"), params: m.object({ reason: m.string().optional().describe('Optional reason for the cancellation (e.g., "user action", "timeout").') }) });
var sh = m.object({ fonts: m.string().optional().describe("CSS for font loading (@font-face rules or") }), uh = m.object({ variables: rh.optional().describe("CSS variables for theming the app."), css: sh.optional().describe("CSS blocks that apps can inject.") });
m.object({ method: m.literal("ui/resource-teardown"), params: m.object({}) });
var lh = m.record(m.string(), m.unknown()), dh = m.object({ experimental: m.object({}).optional().describe("Experimental features (structure TBD)."), openLinks: m.object({}).optional().describe("Host supports opening external URLs."), serverTools: m.object({ listChanged: m.boolean().optional().describe("Host supports tools/list_changed notifications.") }).optional().describe("Host can proxy tool calls to the MCP server."), serverResources: m.object({ listChanged: m.boolean().optional().describe("Host supports resources/list_changed notifications.") }).optional().describe("Host can proxy resource reads to the MCP server."), logging: m.object({}).optional().describe("Host accepts log messages.") }), ch = m.object({ experimental: m.object({}).optional().describe("Experimental features (structure TBD)."), tools: m.object({ listChanged: m.boolean().optional().describe("App supports tools/list_changed notifications.") }).optional().describe("App exposes MCP-style tools that the host can call.") }), mh = m.object({ method: m.literal("ui/notifications/initialized"), params: m.object({}).optional() }), fh = m.object({ connectDomains: m.array(m.string()).optional().describe("Origins for network requests (fetch/XHR/WebSocket)."), resourceDomains: m.array(m.string()).optional().describe("Origins for static resources (scripts, images, styles, fonts).") });
m.object({ csp: fh.optional().describe("Content Security Policy configuration."), domain: m.string().optional().describe("Dedicated origin for widget sandbox."), prefersBorder: m.boolean().optional().describe("Visual boundary preference - true if UI prefers a visible border.") });
var eo = m.object({ method: m.literal("ui/request-display-mode"), params: m.object({ mode: ha.describe("The display mode being requested.") }) });
m.object({ mode: ha.describe("The display mode that was actually set. May differ from requested if not supported.") }).passthrough();
var ph = m.union([m.literal("model"), m.literal("app")]).describe("Tool visibility scope - who can access the tool.");
m.object({ resourceUri: m.string().optional(), visibility: m.array(ph).optional().describe(`Who can access this tool. Default: ["model", "app"]
- "model": Tool visible to and callable by the agent
- "app": Tool callable by the app from this server only`) });
var vh = m.object({ method: m.literal("ui/message"), params: m.object({ role: m.literal("user").describe('Message role, currently only "user" is supported.'), content: m.array(ContentBlockSchema).describe("Message content blocks (text, image, etc.).") }) });
m.object({ method: m.literal("ui/notifications/tool-result"), params: CallToolResultSchema.describe("Standard MCP tool execution result.") });
var dm = m.object({ toolInfo: m.object({ id: RequestIdSchema.optional().describe("JSON-RPC id of the tools/call request."), tool: ToolSchema.describe("Tool definition including name, inputSchema, etc.") }).optional().describe("Metadata of the tool call that instantiated this App."), theme: th.optional().describe("Current color theme preference."), styles: uh.optional().describe("Style configuration for theming the app."), displayMode: ha.optional().describe("How the UI is currently displayed."), availableDisplayModes: m.array(m.string()).optional().describe("Display modes the host supports."), containerDimensions: m.union([m.object({ height: m.number().describe("Fixed container height in pixels.") }), m.object({ maxHeight: m.union([m.number(), m.undefined()]).optional().describe("Maximum container height in pixels.") })]).and(m.union([m.object({ width: m.number().describe("Fixed container width in pixels.") }), m.object({ maxWidth: m.union([m.number(), m.undefined()]).optional().describe("Maximum container width in pixels.") })])).optional().describe(`Container dimensions. Represents the dimensions of the iframe or other
container holding the app. Specify either width or maxWidth, and either height or maxHeight.`), locale: m.string().optional().describe("User's language and region preference in BCP 47 format."), timeZone: m.string().optional().describe("User's timezone in IANA format."), userAgent: m.string().optional().describe("Host application identifier."), platform: m.union([m.literal("web"), m.literal("desktop"), m.literal("mobile")]).optional().describe("Platform type for responsive design decisions."), deviceCapabilities: m.object({ touch: m.boolean().optional().describe("Whether the device supports touch input."), hover: m.boolean().optional().describe("Whether the device supports hover interactions.") }).optional().describe("Device input capabilities."), safeAreaInsets: m.object({ top: m.number().describe("Top safe area inset in pixels."), right: m.number().describe("Right safe area inset in pixels."), bottom: m.number().describe("Bottom safe area inset in pixels."), left: m.number().describe("Left safe area inset in pixels.") }).optional().describe("Mobile safe area boundaries in pixels.") }).passthrough();
m.object({ method: m.literal("ui/notifications/host-context-changed"), params: dm.describe("Partial context update containing only changed fields.") });
var gh = m.object({ method: m.literal("ui/initialize"), params: m.object({ appInfo: ImplementationSchema.describe("App identification (name and version)."), appCapabilities: ch.describe("Features and capabilities this app provides."), protocolVersion: m.string().describe("Protocol version this app supports.") }) });
m.object({ protocolVersion: m.string().describe('Negotiated protocol version string (e.g., "2025-11-21").'), hostInfo: ImplementationSchema.describe("Host application identification and version."), hostCapabilities: dh.describe("Features and capabilities provided by the host."), hostContext: dm.describe("Rich context about the host environment.") }).passthrough();
class hh {
  constructor(i = window.parent, r2) {
    F(this, "eventTarget");
    F(this, "eventSource");
    F(this, "messageListener");
    F(this, "onclose");
    F(this, "onerror");
    F(this, "onmessage");
    F(this, "sessionId");
    F(this, "setProtocolVersion");
    this.eventTarget = i, this.eventSource = r2, this.messageListener = (a2) => {
      var n, o;
      if (r2 && a2.source !== this.eventSource) {
        console.error("Ignoring message from unknown source", a2);
        return;
      }
      let t = JSONRPCMessageSchema.safeParse(a2.data);
      t.success ? (console.debug("Parsed message", t.data), (n = this.onmessage) == null || n.call(this, t.data)) : (console.error("Failed to parse message", t.error.message, a2), (o = this.onerror) == null || o.call(this, Error("Invalid JSON-RPC message received: " + t.error.message)));
    };
  }
  async start() {
    window.addEventListener("message", this.messageListener);
  }
  async send(i, r2) {
    console.debug("Sending message", i), this.eventTarget.postMessage(i, "*");
  }
  async close() {
    var i;
    window.removeEventListener("message", this.messageListener), (i = this.onclose) == null || i.call(this);
  }
}
var _h = "ui/resourceUri", _a = "text/html;profile=mcp-app";
function bh(e) {
  var r2, a2, t;
  let i = (a2 = (r2 = e._meta) == null ? void 0 : r2.ui) == null ? void 0 : a2.resourceUri;
  if (i === void 0 && (i = (t = e._meta) == null ? void 0 : t[_h]), typeof i == "string" && i.startsWith("ui://")) return i;
  if (i !== void 0) throw Error(`Invalid UI resource URI: ${JSON.stringify(i)}`);
}
var yh = [Io];
class $h extends Protocol {
  constructor(r2, a2, t, n) {
    super(n);
    F(this, "_client");
    F(this, "_hostInfo");
    F(this, "_capabilities");
    F(this, "_appCapabilities");
    F(this, "_hostContext", {});
    F(this, "_appInfo");
    F(this, "onping");
    F(this, "sendResourceTeardown", this.teardownResource);
    this._client = r2, this._hostInfo = a2, this._capabilities = t, this._hostContext = (n == null ? void 0 : n.hostContext) || {}, this.setRequestHandler(gh, (o) => this._oninitialize(o)), this.setRequestHandler(PingRequestSchema, (o, s2) => {
      var u2;
      return (u2 = this.onping) == null || u2.call(this, o.params, s2), {};
    }), this.setRequestHandler(eo, (o) => ({ mode: this._hostContext.displayMode ?? "inline" }));
  }
  getAppCapabilities() {
    return this._appCapabilities;
  }
  getAppVersion() {
    return this._appInfo;
  }
  set onsizechange(r2) {
    this.setNotificationHandler(oh, (a2) => r2(a2.params));
  }
  set onsandboxready(r2) {
    this.setNotificationHandler(ah, (a2) => r2(a2.params));
  }
  set oninitialized(r2) {
    this.setNotificationHandler(mh, (a2) => r2(a2.params));
  }
  set onmessage(r2) {
    this.setRequestHandler(vh, async (a2, t) => r2(a2.params, t));
  }
  set onopenlink(r2) {
    this.setRequestHandler(nh, async (a2, t) => r2(a2.params, t));
  }
  set onrequestdisplaymode(r2) {
    this.setRequestHandler(eo, async (a2, t) => r2(a2.params, t));
  }
  set onloggingmessage(r2) {
    this.setNotificationHandler(LoggingMessageNotificationSchema, async (a2) => {
      r2(a2.params);
    });
  }
  set oncalltool(r2) {
    this.setRequestHandler(CallToolRequestSchema, async (a2, t) => r2(a2.params, t));
  }
  sendToolListChanged(r2 = {}) {
    return this.notification({ method: "notifications/tools/list_changed", params: r2 });
  }
  set onlistresources(r2) {
    this.setRequestHandler(ListResourcesRequestSchema, async (a2, t) => r2(a2.params, t));
  }
  set onlistresourcetemplates(r2) {
    this.setRequestHandler(ListResourceTemplatesRequestSchema, async (a2, t) => r2(a2.params, t));
  }
  set onreadresource(r2) {
    this.setRequestHandler(ReadResourceRequestSchema, async (a2, t) => r2(a2.params, t));
  }
  sendResourceListChanged(r2 = {}) {
    return this.notification({ method: "notifications/resources/list_changed", params: r2 });
  }
  set onlistprompts(r2) {
    this.setRequestHandler(ListPromptsRequestSchema, async (a2, t) => r2(a2.params, t));
  }
  sendPromptListChanged(r2 = {}) {
    return this.notification({ method: "notifications/prompts/list_changed", params: r2 });
  }
  assertCapabilityForMethod(r2) {
  }
  assertRequestHandlerCapability(r2) {
  }
  assertNotificationCapability(r2) {
  }
  assertTaskCapability(r2) {
    throw Error("Tasks are not supported in MCP Apps");
  }
  assertTaskHandlerCapability(r2) {
    throw Error("Task handlers are not supported in MCP Apps");
  }
  getCapabilities() {
    return this._capabilities;
  }
  async _oninitialize(r2) {
    let a2 = r2.params.protocolVersion;
    return this._appCapabilities = r2.params.appCapabilities, this._appInfo = r2.params.appInfo, { protocolVersion: yh.includes(a2) ? a2 : Io, hostCapabilities: this.getCapabilities(), hostInfo: this._hostInfo, hostContext: this._hostContext };
  }
  setHostContext(r2) {
    let a2 = {}, t = false;
    for (let n of Object.keys(r2)) {
      let o = this._hostContext[n], s2 = r2[n];
      Ih(o, s2) || (a2[n] = s2, t = true);
    }
    t && (this._hostContext = r2, this.sendHostContextChange(a2));
  }
  sendHostContextChange(r2) {
    return this.notification({ method: "ui/notifications/host-context-changed", params: r2 });
  }
  sendToolInput(r2) {
    return this.notification({ method: "ui/notifications/tool-input", params: r2 });
  }
  sendToolInputPartial(r2) {
    return this.notification({ method: "ui/notifications/tool-input-partial", params: r2 });
  }
  sendToolResult(r2) {
    return this.notification({ method: "ui/notifications/tool-result", params: r2 });
  }
  sendToolCancelled(r2) {
    return this.notification({ method: "ui/notifications/tool-cancelled", params: r2 });
  }
  sendSandboxResourceReady(r2) {
    return this.notification({ method: "ui/notifications/sandbox-resource-ready", params: r2 });
  }
  teardownResource(r2, a2) {
    return this.request({ method: "ui/resource-teardown", params: r2 }, lh, a2);
  }
  async connect(r2) {
    if (this._client) {
      let a2 = this._client.getServerCapabilities();
      if (!a2) throw Error("Client server capabilities not available");
      a2.tools && (this.oncalltool = async (t, n) => this._client.request({ method: "tools/call", params: t }, CallToolResultSchema, { signal: n.signal }), a2.tools.listChanged && this._client.setNotificationHandler(ToolListChangedNotificationSchema, (t) => this.sendToolListChanged(t.params))), a2.resources && (this.onlistresources = async (t, n) => this._client.request({ method: "resources/list", params: t }, ListResourcesResultSchema, { signal: n.signal }), this.onlistresourcetemplates = async (t, n) => this._client.request({ method: "resources/templates/list", params: t }, ListResourceTemplatesResultSchema, { signal: n.signal }), this.onreadresource = async (t, n) => this._client.request({ method: "resources/read", params: t }, ReadResourceResultSchema, { signal: n.signal }), a2.resources.listChanged && this._client.setNotificationHandler(ResourceListChangedNotificationSchema, (t) => this.sendResourceListChanged(t.params))), a2.prompts && (this.onlistprompts = async (t, n) => this._client.request({ method: "prompts/list", params: t }, ListPromptsResultSchema, { signal: n.signal }), a2.prompts.listChanged && this._client.setNotificationHandler(PromptListChangedNotificationSchema, (t) => this.sendPromptListChanged(t.params)));
    }
    return super.connect(r2);
  }
}
function Ih(e, i) {
  return JSON.stringify(e) === JSON.stringify(i);
}
const Sh = 1e4;
async function xh(e) {
  const i = document.createElement("iframe");
  i.style.width = "100%", i.style.height = "600px", i.style.border = "none", i.style.backgroundColor = "transparent", i.setAttribute("sandbox", "allow-scripts allow-same-origin allow-forms");
  const r2 = new Promise((a2, t) => {
    let n = false;
    const o = () => {
      window.removeEventListener("message", u2), i.removeEventListener("error", l);
    }, s2 = setTimeout(() => {
      n || (n = true, o(), t(new Error("Timed out waiting for sandbox proxy iframe to be ready")));
    }, Sh), u2 = (d2) => {
      d2.source === i.contentWindow && d2.data && d2.data.method === kf && (n || (n = true, clearTimeout(s2), o(), a2()));
    }, l = () => {
      n || (n = true, clearTimeout(s2), o(), t(new Error("Failed to load sandbox proxy iframe")));
    };
    window.addEventListener("message", u2), i.addEventListener("error", l);
  });
  return i.src = e.href, { iframe: i, onReady: r2 };
}
async function Eh(e, i) {
  let r2, a2;
  do {
    const n = await e.listTools({ cursor: a2 });
    r2 = n.tools.find((o) => o.name === i), a2 = n.nextCursor;
  } while (!r2 && a2);
  if (!r2)
    throw new Error(`tool ${i} not found`);
  if (!r2._meta)
    return null;
  const t = bh(r2);
  if (!t)
    return null;
  if (!t.startsWith("ui://"))
    throw new Error(`tool ${i} has unsupported output template URI: ${t}`);
  return { uri: t };
}
async function zh(e, i) {
  const r2 = await e.readResource({ uri: i.uri });
  if (!r2)
    throw new Error("UI resource not found: " + i.uri);
  if (r2.contents.length !== 1)
    throw new Error("Unsupported UI resource content length: " + r2.contents.length);
  const a2 = r2.contents[0];
  let t;
  const n = (o) => o === _a;
  if ("text" in a2 && typeof a2.text == "string" && n(a2.mimeType))
    t = a2.text;
  else if ("blob" in a2 && typeof a2.blob == "string" && n(a2.mimeType))
    t = atob(a2.blob);
  else
    throw new Error("Unsupported UI resource content format: " + JSON.stringify(a2));
  return t;
}
function Th(e, i) {
  const r2 = new URL(e.href);
  return i && Object.keys(i).length > 0 && r2.searchParams.set("csp", JSON.stringify(i)), r2;
}
const Uh = (e) => {
  const { html: i, sandbox: r2, appBridge: a2, onSizeChanged: t, onInitialized: n, toolInput: o, toolResult: s2, onError: u2 } = e, [l, d2] = reactExports.useState(false), [c, f2] = reactExports.useState(false), [v, g2] = reactExports.useState(null), b = reactExports.useRef(null), $2 = reactExports.useRef(null), I2 = reactExports.useRef(null), N2 = reactExports.useRef(null), G2 = reactExports.useRef(t), U2 = reactExports.useRef(n), O = reactExports.useRef(u2);
  return reactExports.useEffect(() => {
    G2.current = t, U2.current = n, O.current = u2;
  }), reactExports.useEffect(() => {
    const R2 = Th(r2.url, r2.csp), E2 = R2.href;
    if (I2.current === E2 && N2.current === a2 && $2.current)
      return;
    d2(false), f2(false), g2(null);
    let P2 = true;
    return (async () => {
      var ne2, te2;
      try {
        $2.current && ((ne2 = b.current) != null && ne2.contains($2.current)) && (b.current.removeChild($2.current), $2.current = null, I2.current = null, N2.current = null);
        const { iframe: K2, onReady: ge2 } = await xh(R2);
        if (!P2 || ($2.current = K2, I2.current = E2, N2.current = a2, b.current && b.current.appendChild(K2), await ge2, !P2) || (a2.onsizechange = async (ae2) => {
          var We;
          (We = G2.current) == null || We.call(G2, ae2), $2.current && (ae2.width !== void 0 && ($2.current.style.width = `${ae2.width}px`), ae2.height !== void 0 && ($2.current.style.height = `${ae2.height}px`));
        }, a2.oninitialized = () => {
          var ae2;
          P2 && (console.log("[AppFrame] App initialized"), d2(true), (ae2 = U2.current) == null || ae2.call(U2, {
            appVersion: a2.getAppVersion(),
            appCapabilities: a2.getAppCapabilities()
          }));
        }, await a2.connect(
          new hh(K2.contentWindow, K2.contentWindow)
        ), !P2)) return;
        f2(true);
      } catch (K2) {
        if (console.error("[AppFrame] Error:", K2), !P2) return;
        const ge2 = K2 instanceof Error ? K2 : new Error(String(K2));
        g2(ge2), (te2 = O.current) == null || te2.call(O, ge2);
      }
    })(), () => {
      P2 = false;
    };
  }, [r2.url, r2.csp, a2]), reactExports.useEffect(() => {
    if (!c || !i || N2.current !== a2) return;
    (async () => {
      var E2;
      try {
        console.log("[AppFrame] Sending HTML to sandbox"), await a2.sendSandboxResourceReady({
          html: i,
          csp: r2.csp
        });
      } catch (P2) {
        const ve2 = P2 instanceof Error ? P2 : new Error(String(P2));
        g2(ve2), (E2 = O.current) == null || E2.call(O, ve2);
      }
    })();
  }, [c, i, a2, r2.csp]), reactExports.useEffect(() => {
    c && l && o && N2.current === a2 && (console.log("[AppFrame] Sending tool input:", o), a2.sendToolInput({ arguments: o }));
  }, [a2, c, l, o]), reactExports.useEffect(() => {
    c && l && s2 && N2.current === a2 && (console.log("[AppFrame] Sending tool result:", s2), a2.sendToolResult(s2));
  }, [a2, c, l, s2]), /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      ref: b,
      style: {
        width: "100%",
        height: "100%",
        display: "flex",
        flexDirection: "column"
      },
      children: v && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { color: "red", padding: "1rem" }, children: [
        "Error: ",
        v.message
      ] })
    }
  );
}, Oh = reactExports.forwardRef((e, i) => {
  const {
    client: r2,
    toolName: a2,
    sandbox: t,
    toolResourceUri: n,
    html: o,
    toolInput: s2,
    toolResult: u2,
    toolInputPartial: l,
    toolCancelled: d2,
    hostContext: c,
    onMessage: f2,
    onOpenLink: v,
    onLoggingMessage: g2,
    onSizeChanged: b,
    onError: $2,
    onCallTool: I2,
    onListResources: N2,
    onListResourceTemplates: G2,
    onReadResource: U2,
    onListPrompts: O,
    onFallbackRequest: R2
  } = e, [E2, P2] = reactExports.useState(null), [ve2, ne2] = reactExports.useState(o ?? null), [te2, K2] = reactExports.useState(null), ge2 = reactExports.useRef(f2), ae2 = reactExports.useRef(v), We = reactExports.useRef(g2), ba = reactExports.useRef(b), Ue = reactExports.useRef($2), er2 = reactExports.useRef(I2), tr2 = reactExports.useRef(N2), ir2 = reactExports.useRef(G2), qe2 = reactExports.useRef(U2), rr2 = reactExports.useRef(O), nr2 = reactExports.useRef(R2);
  reactExports.useEffect(() => {
    ge2.current = f2, ae2.current = v, We.current = g2, ba.current = b, Ue.current = $2, er2.current = I2, tr2.current = N2, ir2.current = G2, qe2.current = U2, rr2.current = O, nr2.current = R2;
  }), reactExports.useImperativeHandle(
    i,
    () => ({
      sendToolListChanged: () => E2 == null ? void 0 : E2.sendToolListChanged(),
      sendResourceListChanged: () => E2 == null ? void 0 : E2.sendResourceListChanged(),
      sendPromptListChanged: () => E2 == null ? void 0 : E2.sendPromptListChanged(),
      teardownResource: () => E2 == null ? void 0 : E2.teardownResource({})
    }),
    [E2]
  ), reactExports.useEffect(() => {
    let ut2 = true;
    return (() => {
      var Oe;
      try {
        const oe2 = r2 == null ? void 0 : r2.getServerCapabilities(), Y2 = new $h(
          r2 ?? null,
          {
            name: "MCP-UI Host",
            version: "1.0.0"
          },
          {
            openLinks: {},
            serverTools: oe2 == null ? void 0 : oe2.tools,
            serverResources: oe2 == null ? void 0 : oe2.resources
          }
        );
        if (Y2.onmessage = async (V2, j2) => {
          if (ge2.current)
            return ge2.current(V2, j2);
          throw new McpError(ErrorCode.MethodNotFound, "Method not found");
        }, Y2.onopenlink = async (V2, j2) => {
          if (ae2.current)
            return ae2.current(V2, j2);
          throw new McpError(ErrorCode.MethodNotFound, "Method not found");
        }, Y2.onloggingmessage = (V2) => {
          We.current && We.current(V2);
        }, er2.current && (Y2.oncalltool = (V2, j2) => er2.current(V2, j2)), tr2.current && (Y2.onlistresources = (V2, j2) => tr2.current(V2, j2)), ir2.current && (Y2.onlistresourcetemplates = (V2, j2) => ir2.current(V2, j2)), qe2.current && (Y2.onreadresource = (V2, j2) => qe2.current(V2, j2)), rr2.current && (Y2.onlistprompts = (V2, j2) => rr2.current(V2, j2)), Y2.fallbackRequestHandler = async (V2, j2) => {
          if (nr2.current)
            return nr2.current(V2, j2);
          throw new McpError(
            ErrorCode.MethodNotFound,
            `No handler for method: ${V2.method}`
          );
        }, !ut2) return;
        P2(Y2);
      } catch (oe2) {
        if (console.error("[AppRenderer] Error creating bridge:", oe2), !ut2) return;
        const Y2 = oe2 instanceof Error ? oe2 : new Error(String(oe2));
        K2(Y2), (Oe = Ue.current) == null || Oe.call(Ue, Y2);
      }
    })(), () => {
      ut2 = false;
    };
  }, [r2]), reactExports.useEffect(() => {
    if (o) {
      ne2(o);
      return;
    }
    const ut2 = !!r2, ya = !!n && !!qe2.current;
    if (!ut2 && !ya) {
      K2(
        new Error(
          "Either 'html' prop, 'client', or ('toolResourceUri' + 'onReadResource') must be provided to fetch UI resource"
        )
      );
      return;
    }
    let Oe = true;
    return (async () => {
      var Y2, V2;
      try {
        let j2;
        if (n)
          j2 = n, console.log(`[AppRenderer] Using provided resource URI: ${j2}`);
        else if (r2) {
          console.log(`[AppRenderer] Fetching resource URI for tool: ${a2}`);
          const Re2 = await Eh(r2, a2);
          if (!Re2)
            throw new Error(
              `Tool ${a2} has no UI resource (no ui/resourceUri in tool._meta)`
            );
          j2 = Re2.uri, console.log(`[AppRenderer] Got resource URI: ${j2}`);
        } else
          throw new Error("Cannot determine resource URI without client or toolResourceUri");
        if (!Oe) return;
        console.log(`[AppRenderer] Reading resource HTML from: ${j2}`);
        let Ne;
        if (r2)
          Ne = await zh(r2, { uri: j2 });
        else if (qe2.current) {
          const Re2 = await qe2.current({ uri: j2 }, {});
          if (!Re2.contents || Re2.contents.length !== 1)
            throw new Error("Unsupported UI resource content length: " + ((Y2 = Re2.contents) == null ? void 0 : Y2.length));
          const _e2 = Re2.contents[0], $a = (mm) => mm === _a;
          if ("text" in _e2 && typeof _e2.text == "string" && $a(_e2.mimeType))
            Ne = _e2.text;
          else if ("blob" in _e2 && typeof _e2.blob == "string" && $a(_e2.mimeType))
            Ne = atob(_e2.blob);
          else
            throw new Error("Unsupported UI resource content format: " + JSON.stringify(_e2));
        } else
          throw new Error("No way to read resource HTML");
        if (!Oe) return;
        ne2(Ne);
      } catch (j2) {
        if (!Oe) return;
        const Ne = j2 instanceof Error ? j2 : new Error(String(j2));
        K2(Ne), (V2 = Ue.current) == null || V2.call(Ue, Ne);
      }
    })(), () => {
      Oe = false;
    };
  }, [r2, a2, n, o]), reactExports.useEffect(() => {
    E2 && c && E2.setHostContext(c);
  }, [E2, c]), reactExports.useEffect(() => {
    E2 && l && E2.sendToolInputPartial(l);
  }, [E2, l]), reactExports.useEffect(() => {
    E2 && d2 && E2.sendToolCancelled({});
  }, [E2, d2]);
  const cm = ba.current;
  return te2 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { color: "red", padding: "1rem" }, children: [
    "Error: ",
    te2.message
  ] }) : !E2 || !ve2 ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(
    Uh,
    {
      html: ve2,
      sandbox: t,
      appBridge: E2,
      toolInput: s2,
      toolResult: u2,
      onSizeChanged: cm,
      onError: $2
    }
  );
});
Oh.displayName = "AppRenderer";
const AppRenderer = ({
  sandboxPath,
  tool,
  mcpClient,
  toolInput,
  toolResult,
  onNotification
}) => {
  const [error, setError] = reactExports.useState(null);
  const { toast: toast2 } = useToast();
  const normalizedToolResult = reactExports.useMemo(() => {
    if (!toolResult) {
      return void 0;
    }
    if ("content" in toolResult) {
      const parsedResult = CallToolResultSchema.safeParse(toolResult);
      return parsedResult.success ? parsedResult.data : void 0;
    }
    if ("toolResult" in toolResult) {
      const parsedResult = CallToolResultSchema.safeParse(
        toolResult.toolResult
      );
      return parsedResult.success ? parsedResult.data : void 0;
    }
    return void 0;
  }, [toolResult]);
  const hostContext = reactExports.useMemo(
    () => ({
      theme: document.documentElement.classList.contains("dark") ? "dark" : "light"
    }),
    []
  );
  const handleOpenLink = async ({ url: url2 }) => {
    let isError = true;
    if (url2.startsWith("https://") || url2.startsWith("http://")) {
      window.open(url2, "_blank");
      isError = false;
    }
    return { isError };
  };
  const handleMessage = async (params, _extra) => {
    const message = params.content.filter(
      (block) => Boolean(block.type === "text")
    ).map((block) => block.text).join("\n");
    if (message) {
      toast2({
        description: message
      });
    }
    return {};
  };
  const handleLoggingMessage = (params) => {
    if (onNotification) {
      onNotification({
        method: "notifications/message",
        params
      });
    }
  };
  if (!mcpClient) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(Alert, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(CircleAlert, { className: "h-4 w-4" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(AlertDescription, { children: "Waiting for MCP client..." })
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col h-full", children: [
    error && /* @__PURE__ */ jsxRuntimeExports.jsxs(Alert, { variant: "destructive", className: "mb-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(CircleAlert, { className: "h-4 w-4" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(AlertDescription, { children: error })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: "flex-1 border rounded overflow-hidden",
        style: { minHeight: "400px" },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Oh,
          {
            client: mcpClient,
            onOpenLink: handleOpenLink,
            onMessage: handleMessage,
            onLoggingMessage: handleLoggingMessage,
            toolName: tool.name,
            hostContext,
            toolInput,
            toolResult: normalizedToolResult,
            sandbox: {
              url: new URL(sandboxPath, window.location.origin)
            },
            onError: (err) => setError(err.message)
          }
        )
      }
    )
  ] });
};
const hasUIMetadata = (tool) => {
  return !!pk(tool);
};
const cloneToolParams$1 = (source) => {
  try {
    return structuredClone(source);
  } catch {
    return { ...source };
  }
};
const AppsTab = ({
  sandboxPath,
  tools,
  listTools,
  callTool,
  prefilledToolCall,
  onPrefilledToolCallConsumed,
  error,
  mcpClient,
  onNotification
}) => {
  const [appTools, setAppTools] = reactExports.useState([]);
  const [selectedTool, setSelectedTool] = reactExports.useState(null);
  const [params, setParams] = reactExports.useState({});
  const [isAppOpen, setIsAppOpen] = reactExports.useState(false);
  const [isOpeningApp, setIsOpeningApp] = reactExports.useState(false);
  const [isMaximized, setIsMaximized] = reactExports.useState(false);
  const [hasValidationErrors, setHasValidationErrors] = reactExports.useState(false);
  const [submittedParams, setSubmittedParams] = reactExports.useState(void 0);
  const [submittedToolResult, setSubmittedToolResult] = reactExports.useState(null);
  const formRefs = reactExports.useRef({});
  const openAppRunIdRef = reactExports.useRef(0);
  const prefillingParamsRef = reactExports.useRef(null);
  const consumedPrefilledCallIdRef = reactExports.useRef(null);
  const buildInitialParams = reactExports.useCallback((tool) => {
    const initialParams = Object.entries(tool.inputSchema.properties ?? []).map(
      ([key, value]) => {
        const resolvedValue = resolveRef(
          value,
          tool.inputSchema
        );
        return [
          key,
          generateDefaultValue(
            resolvedValue,
            key,
            tool.inputSchema
          )
        ];
      }
    );
    return Object.fromEntries(initialParams);
  }, []);
  const checkValidationErrors = reactExports.useCallback(() => {
    const errors2 = Object.values(formRefs.current).some(
      (ref2) => ref2 && !ref2.validateJson().isValid
    );
    setHasValidationErrors(errors2);
    return errors2;
  }, []);
  reactExports.useEffect(() => {
    const filtered = tools.filter(hasUIMetadata);
    console.log("[AppsTab] Filtered app tools:", {
      totalTools: tools.length,
      appTools: filtered.length,
      appToolNames: filtered.map((t) => t.name)
    });
    setAppTools(filtered);
    if (selectedTool && !filtered.find((t) => t.name === selectedTool.name)) {
      setSelectedTool(null);
      setIsAppOpen(false);
      setSubmittedParams(void 0);
      setSubmittedToolResult(null);
    }
  }, [tools, selectedTool]);
  reactExports.useEffect(() => {
    if (selectedTool) {
      const prefillingParams = prefillingParamsRef.current;
      if (prefillingParams) {
        setParams(prefillingParams);
        prefillingParamsRef.current = null;
      } else {
        setParams(buildInitialParams(selectedTool));
      }
      setHasValidationErrors(false);
      formRefs.current = {};
    } else {
      setParams({});
      setIsAppOpen(false);
      setSubmittedParams(void 0);
      setSubmittedToolResult(null);
    }
  }, [buildInitialParams, selectedTool]);
  reactExports.useEffect(() => {
    if (!prefilledToolCall) {
      return;
    }
    if (consumedPrefilledCallIdRef.current === prefilledToolCall.id) {
      return;
    }
    const matchingTool = appTools.find(
      (tool) => tool.name === prefilledToolCall.toolName
    );
    if (!matchingTool) {
      return;
    }
    const hydratedParams = cloneToolParams$1(prefilledToolCall.params);
    openAppRunIdRef.current += 1;
    setIsOpeningApp(false);
    prefillingParamsRef.current = hydratedParams;
    setSelectedTool(matchingTool);
    setSubmittedParams(hydratedParams);
    setSubmittedToolResult(prefilledToolCall.result);
    setIsAppOpen(true);
    setIsMaximized(false);
    consumedPrefilledCallIdRef.current = prefilledToolCall.id;
    onPrefilledToolCallConsumed?.(prefilledToolCall.id);
  }, [appTools, onPrefilledToolCallConsumed, prefilledToolCall]);
  const handleRefresh = reactExports.useCallback(() => {
    listTools();
  }, [listTools]);
  const executeToolAndOpenApp = reactExports.useCallback(
    async (tool, toolParams) => {
      const runId = ++openAppRunIdRef.current;
      const runParams = cloneToolParams$1(toolParams);
      prefillingParamsRef.current = null;
      setIsOpeningApp(true);
      setSubmittedParams(runParams);
      setSubmittedToolResult(null);
      try {
        const result = await callTool(tool.name, runParams);
        if (runId !== openAppRunIdRef.current) {
          return;
        }
        setSubmittedParams(runParams);
        setSubmittedToolResult(result);
        setIsAppOpen(true);
      } catch {
        if (runId !== openAppRunIdRef.current) {
          return;
        }
        setSubmittedToolResult(null);
        setIsAppOpen(false);
      } finally {
        if (runId === openAppRunIdRef.current) {
          setIsOpeningApp(false);
        }
      }
    },
    [callTool]
  );
  const handleCloseApp = reactExports.useCallback(() => {
    openAppRunIdRef.current += 1;
    setIsOpeningApp(false);
    setIsAppOpen(false);
    setSubmittedToolResult(null);
  }, []);
  const handleOpenApp = reactExports.useCallback(async () => {
    if (!selectedTool || checkValidationErrors()) {
      return;
    }
    await executeToolAndOpenApp(selectedTool, params);
  }, [checkValidationErrors, executeToolAndOpenApp, params, selectedTool]);
  const handleSelectTool = reactExports.useCallback(
    (tool) => {
      openAppRunIdRef.current += 1;
      setIsOpeningApp(false);
      prefillingParamsRef.current = null;
      setSelectedTool(tool);
      setSubmittedParams(void 0);
      setSubmittedToolResult(null);
      const hasFields = tool.inputSchema.properties && Object.keys(tool.inputSchema.properties).length > 0;
      if (hasFields) {
        setIsAppOpen(false);
        return;
      }
      const initialParams = buildInitialParams(tool);
      void executeToolAndOpenApp(tool, initialParams);
    },
    [buildInitialParams, executeToolAndOpenApp]
  );
  const handleDeselectTool = reactExports.useCallback(() => {
    openAppRunIdRef.current += 1;
    setIsOpeningApp(false);
    prefillingParamsRef.current = null;
    setSelectedTool(null);
    setIsAppOpen(false);
    setIsMaximized(false);
    setSubmittedParams(void 0);
    setSubmittedToolResult(null);
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "apps", className: "space-y-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: isMaximized ? "grid grid-cols-1 gap-4" : "grid grid-cols-1 md:grid-cols-2 gap-4",
      children: [
        !isMaximized && /* @__PURE__ */ jsxRuntimeExports.jsx(
          ListPane,
          {
            items: appTools,
            listItems: handleRefresh,
            setSelectedItem: handleSelectTool,
            renderItem: (tool) => {
              return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start w-full gap-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-shrink-0 mt-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconDisplay, { icons: tool.icons, size: "sm" }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col flex-1 min-w-0", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "truncate font-semibold", children: tool.name }),
                  tool.description && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm text-gray-500 text-left line-clamp-2", children: tool.description })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRight, { className: "w-4 h-4 flex-shrink-0 text-gray-400 mt-1" })
              ] });
            },
            title: "MCP Apps",
            buttonText: "Refresh Apps"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-card border border-border rounded-lg shadow", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-4 border-b border-gray-200 dark:border-border", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
              selectedTool && /* @__PURE__ */ jsxRuntimeExports.jsx(
                IconDisplay,
                {
                  icons: selectedTool.icons,
                  size: "md"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold", children: selectedTool ? selectedTool.name : "Select an app" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
              selectedTool && isAppOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: () => setIsMaximized(!isMaximized),
                  variant: "ghost",
                  size: "sm",
                  "aria-label": isMaximized ? "Minimize" : "Maximize",
                  children: isMaximized ? /* @__PURE__ */ jsxRuntimeExports.jsx(Minimize2, { className: "w-4 h-4" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Maximize2, { className: "w-4 h-4" })
                }
              ),
              selectedTool && /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: handleDeselectTool,
                  variant: "ghost",
                  size: "sm",
                  "aria-label": "Close app",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(X$2, { className: "w-4 h-4" })
                }
              )
            ] })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4", children: [
            error && /* @__PURE__ */ jsxRuntimeExports.jsxs(Alert, { variant: "destructive", className: "mb-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(CircleAlert, { className: "h-4 w-4" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(AlertDescription, { children: error })
            ] }),
            selectedTool ? (() => {
              const hasFields = selectedTool.inputSchema.properties && Object.keys(selectedTool.inputSchema.properties).length > 0;
              return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-4", children: !isAppOpen ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
                selectedTool.description && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-600 dark:text-gray-400 whitespace-pre-wrap", children: selectedTool.description }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4 border rounded-lg p-4 bg-muted/30", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium text-sm", children: "App Input" }),
                  Object.entries(
                    selectedTool.inputSchema.properties ?? []
                  ).map(([key, value]) => {
                    const resolvedValue = resolveRef(
                      value,
                      selectedTool.inputSchema
                    );
                    const prop = normalizeUnionType(resolvedValue);
                    const inputSchema = selectedTool.inputSchema;
                    const required2 = isPropertyRequired(
                      key,
                      inputSchema
                    );
                    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between", children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsxs(
                          Label$1,
                          {
                            htmlFor: key,
                            className: "block text-sm font-medium text-gray-700 dark:text-gray-300",
                            children: [
                              key,
                              required2 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-red-500 ml-1", children: "*" })
                            ]
                          }
                        ),
                        prop.nullable ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx(
                            Checkbox,
                            {
                              id: `${key}-null`,
                              checked: params[key] === null,
                              onCheckedChange: (checked) => setParams({
                                ...params,
                                [key]: checked ? null : prop.type === "array" ? void 0 : prop.default !== null ? prop.default : prop.type === "boolean" ? false : prop.type === "string" ? "" : void 0
                              })
                            }
                          ),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(
                            "label",
                            {
                              htmlFor: `${key}-null`,
                              className: "text-sm font-medium text-gray-700 dark:text-gray-300",
                              children: "null"
                            }
                          )
                        ] }) : null
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "div",
                        {
                          className: `${prop.nullable && params[key] === null ? "pointer-events-none opacity-50" : ""}`,
                          children: prop.type === "boolean" ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx(
                              Checkbox,
                              {
                                id: key,
                                checked: !!params[key],
                                onCheckedChange: (checked) => setParams({
                                  ...params,
                                  [key]: checked
                                })
                              }
                            ),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(
                              "label",
                              {
                                htmlFor: key,
                                className: "text-sm font-medium text-gray-700 dark:text-gray-300",
                                children: prop.description || "Toggle this option"
                              }
                            )
                          ] }) : prop.type === "string" && prop.enum ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
                            Select,
                            {
                              value: params[key] === void 0 ? "" : String(params[key]),
                              onValueChange: (value2) => {
                                setParams({
                                  ...params,
                                  [key]: value2 === "" ? void 0 : value2
                                });
                              },
                              children: [
                                /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { id: key, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                                  SelectValue,
                                  {
                                    placeholder: prop.description || "Select an option"
                                  }
                                ) }),
                                /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContent, { children: prop.enum.map((option) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                                  SelectItem,
                                  {
                                    value: option,
                                    children: option
                                  },
                                  option
                                )) })
                              ]
                            }
                          ) : prop.type === "string" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                            Textarea,
                            {
                              id: key,
                              placeholder: prop.description,
                              value: params[key] === void 0 ? "" : String(params[key]),
                              onChange: (e) => {
                                setParams({
                                  ...params,
                                  [key]: e.target.value === "" ? void 0 : e.target.value
                                });
                              }
                            }
                          ) : prop.type === "object" || prop.type === "array" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                            DynamicJsonForm,
                            {
                              ref: (ref2) => formRefs.current[key] = ref2,
                              schema: {
                                type: prop.type,
                                properties: prop.properties,
                                description: prop.description,
                                items: prop.items
                              },
                              value: params[key] ?? generateDefaultValue(prop),
                              onChange: (newValue) => {
                                setParams({
                                  ...params,
                                  [key]: newValue
                                });
                                setTimeout(checkValidationErrors, 100);
                              }
                            }
                          ) : prop.type === "number" || prop.type === "integer" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                            Input,
                            {
                              type: "number",
                              id: key,
                              placeholder: prop.description,
                              value: params[key] === void 0 ? "" : String(params[key]),
                              onChange: (e) => {
                                const value2 = e.target.value;
                                if (value2 === "") {
                                  setParams({
                                    ...params,
                                    [key]: void 0
                                  });
                                } else {
                                  const num = Number(value2);
                                  setParams({
                                    ...params,
                                    [key]: isNaN(num) ? value2 : num
                                  });
                                }
                              }
                            }
                          ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                            DynamicJsonForm,
                            {
                              ref: (ref2) => formRefs.current[key] = ref2,
                              schema: {
                                type: prop.type,
                                properties: prop.properties,
                                description: prop.description,
                                items: prop.items
                              },
                              value: params[key],
                              onChange: (newValue) => {
                                setParams({
                                  ...params,
                                  [key]: newValue
                                });
                                setTimeout(checkValidationErrors, 100);
                              }
                            }
                          )
                        }
                      )
                    ] }, key);
                  }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    Button,
                    {
                      onClick: () => void handleOpenApp(),
                      className: "w-full",
                      disabled: hasValidationErrors || isOpeningApp,
                      children: [
                        isOpeningApp ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoaderCircle, { className: "w-4 h-4 mr-2 animate-spin" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Play, { className: "w-4 h-4 mr-2" }),
                        isOpeningApp ? "Opening App..." : "Open App"
                      ]
                    }
                  )
                ] })
              ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
                hasFields && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    onClick: handleCloseApp,
                    variant: "outline",
                    size: "sm",
                    children: "Back to Input"
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-[600px]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  AppRenderer,
                  {
                    sandboxPath,
                    tool: selectedTool,
                    mcpClient,
                    toolInput: submittedParams,
                    toolResult: submittedToolResult,
                    onNotification
                  }
                ) })
              ] }) });
            })() : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center justify-center py-12 text-muted-foreground space-y-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(CircleAlert, { className: "w-12 h-12 opacity-20" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Select an app from the list to get started" }),
              appTools.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-xs text-center max-w-[200px]", children: [
                "No MCP Apps available. Apps are tools that include a",
                " ",
                /* @__PURE__ */ jsxRuntimeExports.jsx("code", { className: "bg-muted px-1 rounded", children: "_meta.ui.resourceUri" })
              ] })
            ] })
          ] })
        ] })
      ]
    }
  ) });
};
const ElicitationRequest = ({
  request,
  onResolve
}) => {
  const [formData, setFormData] = reactExports.useState({});
  const [validationError, setValidationError] = reactExports.useState(null);
  reactExports.useEffect(() => {
    const defaultValue = generateDefaultValue(request.request.requestedSchema);
    setFormData(defaultValue);
    setValidationError(null);
  }, [request.request.requestedSchema]);
  const validateEmailFormat = (email2) => {
    const emailRegex2 = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex2.test(email2);
  };
  const validateFormData = (data2, schema) => {
    if (schema.type === "object" && schema.properties && typeof data2 === "object" && data2 !== null) {
      const dataObj = data2;
      if (Array.isArray(schema.required)) {
        for (const field of schema.required) {
          const value = dataObj[field];
          if (value === void 0 || value === null || value === "") {
            setValidationError(`Required field missing: ${field}`);
            return false;
          }
        }
      }
      for (const [fieldName, fieldValue] of Object.entries(dataObj)) {
        const fieldSchema = schema.properties[fieldName];
        if (fieldSchema && fieldSchema.format === "email" && typeof fieldValue === "string") {
          if (!validateEmailFormat(fieldValue)) {
            setValidationError(`Invalid email format: ${fieldName}`);
            return false;
          }
        }
      }
    }
    return true;
  };
  const handleAccept = () => {
    try {
      if (!validateFormData(formData, request.request.requestedSchema)) {
        return;
      }
      const ajv2 = new Ajv$1();
      const validate2 = ajv2.compile(request.request.requestedSchema);
      const isValid2 = validate2(formData);
      if (!isValid2) {
        const errorMessage = ajv2.errorsText(validate2.errors);
        setValidationError(errorMessage);
        return;
      }
      onResolve(request.id, {
        action: "accept",
        content: formData
      });
    } catch (error) {
      setValidationError(
        error instanceof Error ? error.message : "Validation failed"
      );
    }
  };
  const handleDecline = () => {
    onResolve(request.id, { action: "decline" });
  };
  const handleCancel = () => {
    onResolve(request.id, { action: "cancel" });
  };
  const schemaTitle = request.request.requestedSchema.title || "Information Request";
  const schemaDescription = request.request.requestedSchema.description;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      "data-testid": "elicitation-request",
      className: "flex gap-4 p-4 border rounded-lg space-y-4",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1 bg-gray-50 dark:bg-gray-800 dark:text-gray-100 p-2 rounded", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-semibold", children: schemaTitle }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm", children: request.request.message }),
          schemaDescription && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-muted-foreground", children: schemaDescription }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { className: "text-xs font-medium mb-1", children: "Request Schema:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              JsonView,
              {
                data: JSON.stringify(request.request.requestedSchema, null, 2)
              }
            )
          ] })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1 space-y-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium", children: "Response Form" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              DynamicJsonForm,
              {
                schema: request.request.requestedSchema,
                value: formData,
                onChange: (newValue) => {
                  setFormData(newValue);
                  setValidationError(null);
                }
              }
            ),
            validationError && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-4 p-3 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-md", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-sm text-red-600 dark:text-red-400", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Validation Error:" }),
              " ",
              validationError
            ] }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex space-x-2 mt-1", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { type: "button", onClick: handleAccept, children: "Submit" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { type: "button", variant: "outline", onClick: handleDecline, children: "Decline" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { type: "button", variant: "outline", onClick: handleCancel, children: "Cancel" })
          ] })
        ] })
      ]
    }
  );
};
const ElicitationTab = ({ pendingRequests, onResolve }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "elicitations", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "h-96", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(AlertDescription, { children: "When the server requests information from the user, requests will appear here for response." }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-4 space-y-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold", children: "Recent Requests" }),
      pendingRequests.map((request) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        ElicitationRequest,
        {
          request,
          onResolve
        },
        request.id
      )),
      pendingRequests.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-500", children: "No pending requests" })
    ] })
  ] }) });
};
const MetadataTab = ({
  metadata: metadata2,
  onMetadataChange
}) => {
  const [entries, setEntries] = reactExports.useState(() => {
    return Object.entries(metadata2).map(([key, value]) => ({ key, value }));
  });
  const addEntry = () => {
    setEntries([...entries, { key: "", value: "" }]);
  };
  const removeEntry = (index2) => {
    const newEntries = entries.filter((_2, i) => i !== index2);
    setEntries(newEntries);
    updateMetadata(newEntries);
  };
  const updateEntry = (index2, field, value) => {
    const newEntries = [...entries];
    newEntries[index2][field] = value;
    setEntries(newEntries);
    updateMetadata(newEntries);
  };
  const updateMetadata = (newEntries) => {
    const metadataObject = {};
    newEntries.forEach(({ key, value }) => {
      const trimmedKey = key.trim();
      if (trimmedKey && value.trim() && hasValidMetaPrefix(trimmedKey) && !isReservedMetaKey(trimmedKey) && hasValidMetaName(trimmedKey)) {
        metadataObject[trimmedKey] = value.trim();
      }
    });
    onMetadataChange(metadataObject);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "metadata", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold", children: "Metadata" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-600 dark:text-gray-400", children: "Key-value pairs that will be included in all MCP requests" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { onClick: addEntry, size: "sm", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Plus, { className: "w-4 h-4 mr-2" }),
        "Add Entry"
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-3", children: entries.map((entry, index2) => {
      const trimmedKey = entry.key.trim();
      const hasInvalidPrefix = trimmedKey !== "" && !hasValidMetaPrefix(trimmedKey);
      const isReservedKey = trimmedKey !== "" && isReservedMetaKey(trimmedKey);
      const hasInvalidName = trimmedKey !== "" && !hasValidMetaName(trimmedKey);
      const validationMessage = hasInvalidPrefix ? META_PREFIX_RULES_MESSAGE : isReservedKey ? RESERVED_NAMESPACE_MESSAGE : hasInvalidName ? META_NAME_RULES_MESSAGE : null;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-1", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { htmlFor: `key-${index2}`, className: "sr-only", children: "Key" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input,
              {
                id: `key-${index2}`,
                placeholder: "Key",
                value: entry.key,
                onChange: (e) => updateEntry(index2, "key", e.target.value),
                "aria-invalid": Boolean(validationMessage),
                className: cn$2(
                  validationMessage && "border-red-500 focus-visible:ring-red-500 focus-visible:ring-1"
                )
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { htmlFor: `value-${index2}`, className: "sr-only", children: "Value" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input,
              {
                id: `value-${index2}`,
                placeholder: "Value",
                value: entry.value,
                onChange: (e) => updateEntry(index2, "value", e.target.value),
                disabled: Boolean(validationMessage)
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              variant: "outline",
              size: "sm",
              onClick: () => removeEntry(index2),
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Trash2, { className: "w-4 h-4" })
            }
          )
        ] }),
        validationMessage && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-red-600 dark:text-red-400", children: validationMessage })
      ] }, index2);
    }) }),
    entries.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center py-8", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-500 dark:text-gray-400 mb-4", children: 'No metadata entries. Click "Add Entry" to add key-value pairs.' }) })
  ] }) });
};
const CONFIG_LOCAL_STORAGE_KEY = "inspectorConfig_v1";
const hasAppResourceUri = (tool) => {
  return Boolean(pk(tool));
};
const cloneToolParams = (source) => {
  try {
    return structuredClone(source);
  } catch {
    return { ...source };
  }
};
const filterReservedMetadata = (metadata2) => {
  return Object.entries(metadata2).reduce(
    (acc, [key, value]) => {
      if (!isReservedMetaKey(key) && hasValidMetaPrefix(key) && hasValidMetaName(key)) {
        acc[key] = value;
      }
      return acc;
    },
    {}
  );
};
const App = () => {
  const [resources, setResources] = reactExports.useState([]);
  const [resourceTemplates, setResourceTemplates] = reactExports.useState([]);
  const [resourceContent, setResourceContent] = reactExports.useState("");
  const [resourceContentMap, setResourceContentMap] = reactExports.useState({});
  const [fetchingResources, setFetchingResources] = reactExports.useState(
    /* @__PURE__ */ new Set()
  );
  const [prompts, setPrompts] = reactExports.useState([]);
  const [promptContent, setPromptContent] = reactExports.useState("");
  const [tools, setTools] = reactExports.useState([]);
  const [tasks, setTasks] = reactExports.useState([]);
  const [toolResult, setToolResult] = reactExports.useState(null);
  const [prefilledAppsToolCall, setPrefilledAppsToolCall] = reactExports.useState(null);
  const [errors2, setErrors] = reactExports.useState({
    resources: null,
    prompts: null,
    tools: null,
    tasks: null
  });
  const [command, setCommand] = reactExports.useState(getInitialCommand);
  const [args, setArgs] = reactExports.useState(getInitialArgs);
  const [sseUrl, setSseUrl] = reactExports.useState(getInitialSseUrl);
  const [transportType, setTransportType] = reactExports.useState(getInitialTransportType);
  const [connectionType, setConnectionType] = reactExports.useState(
    () => {
      return localStorage.getItem("lastConnectionType") || "proxy";
    }
  );
  const [logLevel, setLogLevel] = reactExports.useState("debug");
  const [notifications, setNotifications] = reactExports.useState([]);
  const [roots, setRoots] = reactExports.useState([]);
  const [env, setEnv] = reactExports.useState({});
  const [config2, setConfig] = reactExports.useState(
    () => initializeInspectorConfig(CONFIG_LOCAL_STORAGE_KEY)
  );
  const [bearerToken, setBearerToken] = reactExports.useState(() => {
    return localStorage.getItem("lastBearerToken") || "";
  });
  const [headerName, setHeaderName] = reactExports.useState(() => {
    return localStorage.getItem("lastHeaderName") || "";
  });
  const [oauthClientId, setOauthClientId] = reactExports.useState(() => {
    return localStorage.getItem("lastOauthClientId") || "";
  });
  const [oauthScope, setOauthScope] = reactExports.useState(() => {
    return localStorage.getItem("lastOauthScope") || "";
  });
  const [oauthClientSecret, setOauthClientSecret] = reactExports.useState(() => {
    return localStorage.getItem("lastOauthClientSecret") || "";
  });
  const [customHeaders, setCustomHeaders] = reactExports.useState(() => {
    const savedHeaders = localStorage.getItem("lastCustomHeaders");
    if (savedHeaders) {
      try {
        return JSON.parse(savedHeaders);
      } catch (error) {
        console.warn(
          `Failed to parse custom headers: "${savedHeaders}", will try legacy migration`,
          error
        );
      }
    }
    const legacyToken = localStorage.getItem("lastBearerToken") || "";
    const legacyHeaderName = localStorage.getItem("lastHeaderName") || "";
    if (legacyToken) {
      return migrateFromLegacyAuth(legacyToken, legacyHeaderName);
    }
    return [
      {
        name: "Authorization",
        value: "Bearer ",
        enabled: false
      }
    ];
  });
  const [pendingSampleRequests, setPendingSampleRequests] = reactExports.useState([]);
  const [pendingElicitationRequests, setPendingElicitationRequests] = reactExports.useState([]);
  const [isAuthDebuggerVisible, setIsAuthDebuggerVisible] = reactExports.useState(false);
  const [authState, setAuthState] = reactExports.useState(EMPTY_DEBUGGER_STATE);
  const [metadata2, setMetadata] = reactExports.useState(() => {
    const savedMetadata = localStorage.getItem("lastMetadata");
    if (savedMetadata) {
      try {
        const parsed = JSON.parse(savedMetadata);
        if (parsed && typeof parsed === "object") {
          return filterReservedMetadata(parsed);
        }
      } catch (error) {
        console.warn("Failed to parse saved metadata:", error);
      }
    }
    return {};
  });
  const updateAuthState = (updates) => {
    setAuthState((prev) => ({ ...prev, ...updates }));
  };
  const handleMetadataChange = (newMetadata) => {
    const sanitizedMetadata = filterReservedMetadata(newMetadata);
    setMetadata(sanitizedMetadata);
    localStorage.setItem("lastMetadata", JSON.stringify(sanitizedMetadata));
  };
  const nextRequestId = reactExports.useRef(0);
  const rootsRef = reactExports.useRef([]);
  const [selectedResource, setSelectedResource] = reactExports.useState(
    null
  );
  const [resourceSubscriptions, setResourceSubscriptions] = reactExports.useState(/* @__PURE__ */ new Set());
  const [selectedPrompt, setSelectedPrompt] = reactExports.useState(null);
  const [selectedTool, setSelectedTool] = reactExports.useState(null);
  const [selectedTask, setSelectedTask] = reactExports.useState(null);
  const [isPollingTask, setIsPollingTask] = reactExports.useState(false);
  const [nextResourceCursor, setNextResourceCursor] = reactExports.useState();
  const [nextResourceTemplateCursor, setNextResourceTemplateCursor] = reactExports.useState();
  const [nextPromptCursor, setNextPromptCursor] = reactExports.useState();
  const [nextToolCursor, setNextToolCursor] = reactExports.useState();
  const [nextTaskCursor, setNextTaskCursor] = reactExports.useState();
  const progressTokenRef = reactExports.useRef(0);
  const prefilledAppsToolCallIdRef = reactExports.useRef(0);
  const [activeTab, setActiveTab] = reactExports.useState(() => {
    const hash = window.location.hash.slice(1);
    const initialTab = hash || "resources";
    return initialTab;
  });
  const currentTabRef = reactExports.useRef(activeTab);
  const lastToolCallOriginTabRef = reactExports.useRef(activeTab);
  reactExports.useEffect(() => {
    currentTabRef.current = activeTab;
  }, [activeTab]);
  const navigateToOriginatingTab = (originatingTab) => {
    if (!originatingTab) return;
    const validTabs = [
      ...serverCapabilities?.resources ? ["resources"] : [],
      ...serverCapabilities?.prompts ? ["prompts"] : [],
      ...serverCapabilities?.tools ? ["tools"] : [],
      ...serverCapabilities?.tasks ? ["tasks"] : [],
      "apps",
      "ping",
      "sampling",
      "elicitations",
      "roots",
      "auth",
      "metadata"
    ];
    if (!validTabs.includes(originatingTab)) return;
    setActiveTab(originatingTab);
    window.location.hash = originatingTab;
    setTimeout(() => {
      setActiveTab(originatingTab);
      window.location.hash = originatingTab;
    }, 100);
  };
  const { height: historyPaneHeight, handleDragStart } = useDraggablePane(300);
  const {
    width: sidebarWidth,
    isDragging: isSidebarDragging,
    handleDragStart: handleSidebarDragStart
  } = useDraggableSidebar(320);
  const selectedTaskRef = reactExports.useRef(null);
  reactExports.useEffect(() => {
    selectedTaskRef.current = selectedTask;
  }, [selectedTask]);
  const {
    connectionStatus,
    serverCapabilities,
    serverImplementation,
    mcpClient,
    requestHistory,
    clearRequestHistory,
    makeRequest,
    cancelTask: cancelMcpTask,
    listTasks: listMcpTasks,
    sendNotification,
    handleCompletion,
    completionsSupported,
    connect: connectMcpServer,
    disconnect: disconnectMcpServer
  } = useConnection({
    transportType,
    command,
    args,
    sseUrl,
    env,
    customHeaders,
    oauthClientId,
    oauthClientSecret,
    oauthScope,
    config: config2,
    connectionType,
    onNotification: (notification) => {
      setNotifications((prev) => [...prev, notification]);
      if (notification.method === "notifications/tasks/list_changed") {
        void listTasks();
      }
      if (notification.method === "notifications/tasks/status") {
        const task = notification.params;
        setTasks((prev) => {
          const exists = prev.some((t) => t.taskId === task.taskId);
          if (exists) {
            return prev.map((t) => t.taskId === task.taskId ? task : t);
          } else {
            return [task, ...prev];
          }
        });
        if (selectedTaskRef.current?.taskId === task.taskId) {
          setSelectedTask(task);
        }
      }
    },
    onPendingRequest: (request, resolve2, reject) => {
      const currentTab = lastToolCallOriginTabRef.current;
      setPendingSampleRequests((prev) => [
        ...prev,
        {
          id: nextRequestId.current++,
          request,
          originatingTab: currentTab,
          resolve: resolve2,
          reject
        }
      ]);
      setActiveTab("sampling");
      window.location.hash = "sampling";
    },
    onElicitationRequest: (request, resolve2) => {
      const currentTab = lastToolCallOriginTabRef.current;
      setPendingElicitationRequests((prev) => [
        ...prev,
        {
          id: nextRequestId.current++,
          request: {
            id: nextRequestId.current,
            message: request.params.message,
            requestedSchema: request.params.requestedSchema
          },
          originatingTab: currentTab,
          resolve: resolve2,
          decline: (error) => {
            console.error("Elicitation request rejected:", error);
          }
        }
      ]);
      setActiveTab("elicitations");
      window.location.hash = "elicitations";
    },
    getRoots: () => rootsRef.current,
    defaultLoggingLevel: logLevel,
    metadata: metadata2
  });
  reactExports.useEffect(() => {
    if (serverCapabilities) {
      const hash = window.location.hash.slice(1);
      const validTabs = [
        ...serverCapabilities?.resources ? ["resources"] : [],
        ...serverCapabilities?.prompts ? ["prompts"] : [],
        ...serverCapabilities?.tools ? ["tools"] : [],
        ...serverCapabilities?.tasks ? ["tasks"] : [],
        "apps",
        "ping",
        "sampling",
        "elicitations",
        "roots",
        "auth",
        "metadata"
      ];
      const isValidTab = validTabs.includes(hash);
      if (!isValidTab) {
        const defaultTab = serverCapabilities?.resources ? "resources" : serverCapabilities?.prompts ? "prompts" : serverCapabilities?.tools ? "tools" : serverCapabilities?.tasks ? "tasks" : "ping";
        setActiveTab(defaultTab);
        window.location.hash = defaultTab;
      }
    }
  }, [serverCapabilities]);
  reactExports.useEffect(() => {
    if (mcpClient && activeTab === "tasks") {
      void listTasks();
    }
  }, [mcpClient, activeTab]);
  reactExports.useEffect(() => {
    if (mcpClient && activeTab === "apps" && serverCapabilities?.tools) {
      void listTools();
    }
  }, [mcpClient, activeTab, serverCapabilities?.tools]);
  reactExports.useEffect(() => {
    localStorage.setItem("lastCommand", command);
  }, [command]);
  reactExports.useEffect(() => {
    localStorage.setItem("lastArgs", args);
  }, [args]);
  reactExports.useEffect(() => {
    localStorage.setItem("lastSseUrl", sseUrl);
  }, [sseUrl]);
  reactExports.useEffect(() => {
    localStorage.setItem("lastTransportType", transportType);
  }, [transportType]);
  reactExports.useEffect(() => {
    localStorage.setItem("lastConnectionType", connectionType);
  }, [connectionType]);
  reactExports.useEffect(() => {
    if (bearerToken) {
      localStorage.setItem("lastBearerToken", bearerToken);
    } else {
      localStorage.removeItem("lastBearerToken");
    }
  }, [bearerToken]);
  reactExports.useEffect(() => {
    if (headerName) {
      localStorage.setItem("lastHeaderName", headerName);
    } else {
      localStorage.removeItem("lastHeaderName");
    }
  }, [headerName]);
  reactExports.useEffect(() => {
    localStorage.setItem("lastCustomHeaders", JSON.stringify(customHeaders));
  }, [customHeaders]);
  reactExports.useEffect(() => {
    if (customHeaders.length === 0 && (bearerToken || headerName)) {
      const migratedHeaders = migrateFromLegacyAuth(bearerToken, headerName);
      if (migratedHeaders.length > 0) {
        setCustomHeaders(migratedHeaders);
        setBearerToken("");
        setHeaderName("");
      }
    }
  }, [bearerToken, headerName, customHeaders, setCustomHeaders]);
  reactExports.useEffect(() => {
    localStorage.setItem("lastOauthClientId", oauthClientId);
  }, [oauthClientId]);
  reactExports.useEffect(() => {
    localStorage.setItem("lastOauthScope", oauthScope);
  }, [oauthScope]);
  reactExports.useEffect(() => {
    localStorage.setItem("lastOauthClientSecret", oauthClientSecret);
  }, [oauthClientSecret]);
  reactExports.useEffect(() => {
    saveInspectorConfig(CONFIG_LOCAL_STORAGE_KEY, config2);
  }, [config2]);
  const onOAuthConnect = reactExports.useCallback(
    (serverUrl) => {
      setSseUrl(serverUrl);
      setIsAuthDebuggerVisible(false);
      void connectMcpServer();
    },
    [connectMcpServer]
  );
  const onOAuthDebugConnect = reactExports.useCallback(
    async ({
      authorizationCode,
      errorMsg,
      restoredState
    }) => {
      setIsAuthDebuggerVisible(true);
      if (errorMsg) {
        updateAuthState({
          latestError: new Error(errorMsg)
        });
        return;
      }
      if (restoredState && authorizationCode) {
        let currentState = {
          ...restoredState,
          authorizationCode,
          oauthStep: "token_request",
          isInitiatingAuth: true,
          statusMessage: null,
          latestError: null
        };
        try {
          const stateMachine = new OAuthStateMachine(sseUrl, (updates) => {
            currentState = { ...currentState, ...updates };
          });
          while (currentState.oauthStep !== "complete" && currentState.oauthStep !== "authorization_code") {
            await stateMachine.executeStep(currentState);
          }
          if (currentState.oauthStep === "complete") {
            updateAuthState({
              ...currentState,
              statusMessage: {
                type: "success",
                message: "Authentication completed successfully"
              },
              isInitiatingAuth: false
            });
          }
        } catch (error) {
          console.error("OAuth continuation error:", error);
          updateAuthState({
            latestError: error instanceof Error ? error : new Error(String(error)),
            statusMessage: {
              type: "error",
              message: `Failed to complete OAuth flow: ${error instanceof Error ? error.message : String(error)}`
            },
            isInitiatingAuth: false
          });
        }
      } else if (authorizationCode) {
        updateAuthState({
          authorizationCode,
          oauthStep: "token_request"
        });
      }
    },
    [sseUrl]
  );
  reactExports.useEffect(() => {
    const loadOAuthTokens = async () => {
      try {
        if (sseUrl) {
          const key = getServerSpecificKey(SESSION_KEYS.TOKENS, sseUrl);
          const tokens = sessionStorage.getItem(key);
          if (tokens) {
            const parsedTokens = await OAuthTokensSchema.parseAsync(
              JSON.parse(tokens)
            );
            updateAuthState({
              oauthTokens: parsedTokens,
              oauthStep: "complete"
            });
          }
        }
      } catch (error) {
        console.error("Error loading OAuth tokens:", error);
      }
    };
    loadOAuthTokens();
  }, [sseUrl]);
  reactExports.useEffect(() => {
    const headers = {};
    const { token: proxyAuthToken, header: proxyAuthTokenHeader } = getMCPProxyAuthToken(config2);
    if (proxyAuthToken) {
      headers[proxyAuthTokenHeader] = `Bearer ${proxyAuthToken}`;
    }
    fetch(`${getMCPProxyAddress(config2)}/config`, { headers }).then((response) => response.json()).then((data2) => {
      setEnv(data2.defaultEnvironment);
      if (data2.defaultCommand) {
        setCommand(data2.defaultCommand);
      }
      if (data2.defaultArgs) {
        setArgs(data2.defaultArgs);
      }
      if (data2.defaultTransport) {
        setTransportType(
          data2.defaultTransport
        );
      }
      if (data2.defaultServerUrl) {
        setSseUrl(data2.defaultServerUrl);
      }
    }).catch(
      (error) => console.error("Error fetching default environment:", error)
    );
  }, [config2]);
  reactExports.useEffect(() => {
    rootsRef.current = roots;
  }, [roots]);
  reactExports.useEffect(() => {
    if (mcpClient && !window.location.hash) {
      const defaultTab = serverCapabilities?.resources ? "resources" : serverCapabilities?.prompts ? "prompts" : serverCapabilities?.tools ? "tools" : serverCapabilities?.tasks ? "tasks" : "ping";
      window.location.hash = defaultTab;
    } else if (!mcpClient && window.location.hash) {
      window.history.replaceState(
        null,
        "",
        window.location.pathname + window.location.search
      );
    }
  }, [mcpClient, serverCapabilities]);
  reactExports.useEffect(() => {
    const handleHashChange = () => {
      const hash = window.location.hash.slice(1);
      if (hash && hash !== activeTab) {
        setActiveTab(hash);
      }
    };
    window.addEventListener("hashchange", handleHashChange);
    return () => window.removeEventListener("hashchange", handleHashChange);
  }, [activeTab]);
  const handleApproveSampling = (id2, result) => {
    setPendingSampleRequests((prev) => {
      const request = prev.find((r2) => r2.id === id2);
      request?.resolve(result);
      navigateToOriginatingTab(request?.originatingTab);
      return prev.filter((r2) => r2.id !== id2);
    });
  };
  const handleRejectSampling = (id2) => {
    setPendingSampleRequests((prev) => {
      const request = prev.find((r2) => r2.id === id2);
      request?.reject(new Error("Sampling request rejected"));
      navigateToOriginatingTab(request?.originatingTab);
      return prev.filter((r2) => r2.id !== id2);
    });
  };
  const handleResolveElicitation = (id2, response) => {
    setPendingElicitationRequests((prev) => {
      const request = prev.find((r2) => r2.id === id2);
      if (request) {
        request.resolve(response);
        if (request.originatingTab) {
          const originatingTab = request.originatingTab;
          const validTabs = [
            ...serverCapabilities?.resources ? ["resources"] : [],
            ...serverCapabilities?.prompts ? ["prompts"] : [],
            ...serverCapabilities?.tools ? ["tools"] : [],
            ...serverCapabilities?.tasks ? ["tasks"] : [],
            "apps",
            "ping",
            "sampling",
            "elicitations",
            "roots",
            "auth",
            "metadata"
          ];
          if (validTabs.includes(originatingTab)) {
            setActiveTab(originatingTab);
            window.location.hash = originatingTab;
            setTimeout(() => {
              setActiveTab(originatingTab);
              window.location.hash = originatingTab;
            }, 100);
          }
        }
      }
      return prev.filter((r2) => r2.id !== id2);
    });
  };
  const clearError = (tabKey) => {
    setErrors((prev) => ({ ...prev, [tabKey]: null }));
  };
  const sendMCPRequest = async (request, schema, tabKey) => {
    try {
      const response = await makeRequest(request, schema);
      if (tabKey !== void 0) {
        clearError(tabKey);
      }
      return response;
    } catch (e) {
      const errorString = e.message ?? String(e);
      if (tabKey !== void 0) {
        setErrors((prev) => ({
          ...prev,
          [tabKey]: errorString
        }));
      }
      throw e;
    }
  };
  const listResources = async () => {
    const response = await sendMCPRequest(
      {
        method: "resources/list",
        params: nextResourceCursor ? { cursor: nextResourceCursor } : {}
      },
      ListResourcesResultSchema,
      "resources"
    );
    setResources(resources.concat(response.resources ?? []));
    setNextResourceCursor(response.nextCursor);
  };
  const listResourceTemplates = async () => {
    const response = await sendMCPRequest(
      {
        method: "resources/templates/list",
        params: nextResourceTemplateCursor ? { cursor: nextResourceTemplateCursor } : {}
      },
      ListResourceTemplatesResultSchema,
      "resources"
    );
    setResourceTemplates(
      resourceTemplates.concat(response.resourceTemplates ?? [])
    );
    setNextResourceTemplateCursor(response.nextCursor);
  };
  const getPrompt = async (name2, args2 = {}) => {
    lastToolCallOriginTabRef.current = currentTabRef.current;
    const response = await sendMCPRequest(
      {
        method: "prompts/get",
        params: { name: name2, arguments: args2 }
      },
      GetPromptResultSchema,
      "prompts"
    );
    setPromptContent(JSON.stringify(response, null, 2));
  };
  const readResource = async (uri2) => {
    if (fetchingResources.has(uri2) || resourceContentMap[uri2]) {
      return;
    }
    console.log("[App] Reading resource:", uri2);
    setFetchingResources((prev) => new Set(prev).add(uri2));
    lastToolCallOriginTabRef.current = currentTabRef.current;
    try {
      const response = await sendMCPRequest(
        {
          method: "resources/read",
          params: { uri: uri2 }
        },
        ReadResourceResultSchema,
        "resources"
      );
      console.log("[App] Resource read response:", {
        uri: uri2,
        responseLength: JSON.stringify(response).length,
        hasContents: !!response.contents
      });
      const content = JSON.stringify(response, null, 2);
      setResourceContent(content);
      setResourceContentMap((prev) => ({
        ...prev,
        [uri2]: content
      }));
    } catch (error) {
      console.error(`[App] Failed to read resource ${uri2}:`, error);
      const errorString = error.message ?? String(error);
      setResourceContentMap((prev) => ({
        ...prev,
        [uri2]: JSON.stringify({ error: errorString })
      }));
    } finally {
      setFetchingResources((prev) => {
        const next = new Set(prev);
        next.delete(uri2);
        return next;
      });
    }
  };
  const subscribeToResource = async (uri2) => {
    if (!resourceSubscriptions.has(uri2)) {
      await sendMCPRequest(
        {
          method: "resources/subscribe",
          params: { uri: uri2 }
        },
        objectType({}),
        "resources"
      );
      const clone2 = new Set(resourceSubscriptions);
      clone2.add(uri2);
      setResourceSubscriptions(clone2);
    }
  };
  const unsubscribeFromResource = async (uri2) => {
    if (resourceSubscriptions.has(uri2)) {
      await sendMCPRequest(
        {
          method: "resources/unsubscribe",
          params: { uri: uri2 }
        },
        objectType({}),
        "resources"
      );
      const clone2 = new Set(resourceSubscriptions);
      clone2.delete(uri2);
      setResourceSubscriptions(clone2);
    }
  };
  const listPrompts = async () => {
    const response = await sendMCPRequest(
      {
        method: "prompts/list",
        params: nextPromptCursor ? { cursor: nextPromptCursor } : {}
      },
      ListPromptsResultSchema,
      "prompts"
    );
    setPrompts(response.prompts);
    setNextPromptCursor(response.nextCursor);
  };
  const listTools = async () => {
    const response = await sendMCPRequest(
      {
        method: "tools/list",
        params: nextToolCursor ? { cursor: nextToolCursor } : {}
      },
      ListToolsResultSchema,
      "tools"
    );
    setTools(response.tools);
    setNextToolCursor(response.nextCursor);
    cacheToolOutputSchemas(response.tools);
  };
  const callTool = async (name2, params, toolMetadata, runAsTask) => {
    lastToolCallOriginTabRef.current = currentTabRef.current;
    try {
      const tool = tools.find((t) => t.name === name2);
      const cleanedParams = tool?.inputSchema ? cleanParams(params, tool.inputSchema) : params;
      const mergedMetadata = {
        ...metadata2,
        // General metadata
        progressToken: progressTokenRef.current++,
        ...toolMetadata
        // Tool-specific metadata
      };
      const request = {
        method: "tools/call",
        params: {
          name: name2,
          arguments: cleanedParams,
          _meta: mergedMetadata
        }
      };
      if (runAsTask) {
        request.params = {
          ...request.params,
          task: {
            ttl: getMCPTaskTtl(config2)
          }
        };
      }
      const response = await sendMCPRequest(
        request,
        CompatibilityCallToolResultSchema,
        "tools"
      );
      const isTaskResult = (res) => !!res && typeof res === "object" && "task" in res && !!res.task && typeof res.task === "object" && "taskId" in res.task;
      if (runAsTask && isTaskResult(response)) {
        const taskId = response.task.taskId;
        const pollInterval = response.task.pollInterval;
        setIsPollingTask(true);
        const initialResponseMeta = response && typeof response === "object" && "_meta" in response ? response._meta ?? {} : void 0;
        let latestToolResult = {
          content: [
            {
              type: "text",
              text: `Task created: ${taskId}. Polling for status...`
            }
          ],
          _meta: {
            ...initialResponseMeta || {},
            "io.modelcontextprotocol/related-task": { taskId }
          }
        };
        setToolResult(latestToolResult);
        let taskCompleted = false;
        while (!taskCompleted) {
          try {
            await new Promise((resolve2) => setTimeout(resolve2, pollInterval));
            const taskStatus = await sendMCPRequest(
              {
                method: "tasks/get",
                params: { taskId }
              },
              GetTaskResultSchema
            );
            if (taskStatus.status === "completed" || taskStatus.status === "failed" || taskStatus.status === "cancelled") {
              taskCompleted = true;
              console.log(
                `Polling complete for task ${taskId}: ${taskStatus.status}`
              );
              if (taskStatus.status === "completed") {
                console.log(`Fetching result for task ${taskId}`);
                const result = await sendMCPRequest(
                  {
                    method: "tasks/result",
                    params: { taskId }
                  },
                  CompatibilityCallToolResultSchema
                );
                console.log(`Result received for task ${taskId}:`, result);
                latestToolResult = result;
                setToolResult(latestToolResult);
                void listTasks();
              } else {
                latestToolResult = {
                  content: [
                    {
                      type: "text",
                      text: `Task ${taskStatus.status}: ${taskStatus.statusMessage || "No additional information"}`
                    }
                  ],
                  isError: true
                };
                setToolResult(latestToolResult);
                void listTasks();
              }
            } else {
              const pollingResponseMeta = response && typeof response === "object" && "_meta" in response ? response._meta ?? {} : void 0;
              latestToolResult = {
                content: [
                  {
                    type: "text",
                    text: `Task status: ${taskStatus.status}${taskStatus.statusMessage ? ` - ${taskStatus.statusMessage}` : ""}. Polling...`
                  }
                ],
                _meta: {
                  ...pollingResponseMeta || {},
                  "io.modelcontextprotocol/related-task": { taskId }
                }
              };
              setToolResult(latestToolResult);
              void listTasks();
            }
          } catch (pollingError) {
            console.error("Error polling task status:", pollingError);
            latestToolResult = {
              content: [
                {
                  type: "text",
                  text: `Error polling task status: ${pollingError instanceof Error ? pollingError.message : String(pollingError)}`
                }
              ],
              isError: true
            };
            setToolResult(latestToolResult);
            taskCompleted = true;
          }
        }
        setIsPollingTask(false);
        setErrors((prev) => ({ ...prev, tools: null }));
        return latestToolResult;
      } else {
        const directResult = response;
        setToolResult(directResult);
        setErrors((prev) => ({ ...prev, tools: null }));
        return directResult;
      }
    } catch (e) {
      const toolResult2 = {
        content: [
          {
            type: "text",
            text: e.message ?? String(e)
          }
        ],
        isError: true
      };
      setToolResult(toolResult2);
      setErrors((prev) => ({ ...prev, tools: null }));
      return toolResult2;
    }
  };
  const listTasks = reactExports.useCallback(async () => {
    try {
      const response = await listMcpTasks(nextTaskCursor);
      setTasks(response.tasks);
      setNextTaskCursor(response.nextCursor);
      setErrors((prev) => ({ ...prev, tasks: null }));
    } catch (e) {
      setErrors((prev) => ({
        ...prev,
        tasks: e.message ?? String(e)
      }));
    }
  }, [listMcpTasks, nextTaskCursor]);
  const cancelTask = async (taskId) => {
    try {
      const response = await cancelMcpTask(taskId);
      setTasks((prev) => prev.map((t) => t.taskId === taskId ? response : t));
      if (selectedTask?.taskId === taskId) {
        setSelectedTask(response);
      }
      clearError("tasks");
    } catch (e) {
      setErrors((prev) => ({
        ...prev,
        tasks: e.message ?? String(e)
      }));
    }
  };
  const handleRootsChange = async () => {
    await sendNotification({ method: "notifications/roots/list_changed" });
  };
  const handleClearNotifications = () => {
    setNotifications([]);
  };
  const sendLogLevelRequest = async (level) => {
    await sendMCPRequest(
      {
        method: "logging/setLevel",
        params: { level }
      },
      objectType({})
    );
    setLogLevel(level);
  };
  const AuthDebuggerWrapper = () => /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "auth", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    AuthDebugger,
    {
      serverUrl: sseUrl,
      onBack: () => setIsAuthDebuggerVisible(false),
      authState,
      updateAuthState
    }
  ) });
  if (window.location.pathname === "/oauth/callback") {
    const OAuthCallback = React.lazy(
      () => __vitePreload(() => import("./OAuthCallback-vugip8g8.js"), true ? [] : void 0)
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Loading..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(OAuthCallback, { onConnect: onOAuthConnect }) });
  }
  if (window.location.pathname === "/oauth/callback/debug") {
    const OAuthDebugCallback = React.lazy(
      () => __vitePreload(() => import("./OAuthDebugCallback-DjBTxwEA.js"), true ? [] : void 0)
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Loading..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(OAuthDebugCallback, { onConnect: onOAuthDebugConnect }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex h-screen bg-background", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          width: sidebarWidth,
          minWidth: 200,
          maxWidth: 600,
          transition: isSidebarDragging ? "none" : "width 0.15s"
        },
        className: "bg-card border-r border-border flex flex-col h-full relative",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Sidebar,
            {
              connectionStatus,
              transportType,
              setTransportType,
              command,
              setCommand,
              args,
              setArgs,
              sseUrl,
              setSseUrl,
              env,
              setEnv,
              config: config2,
              setConfig,
              customHeaders,
              setCustomHeaders,
              oauthClientId,
              setOauthClientId,
              oauthClientSecret,
              setOauthClientSecret,
              oauthScope,
              setOauthScope,
              onConnect: connectMcpServer,
              onDisconnect: disconnectMcpServer,
              logLevel,
              sendLogLevelRequest,
              loggingSupported: !!serverCapabilities?.logging || false,
              connectionType,
              setConnectionType,
              serverImplementation
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              onMouseDown: handleSidebarDragStart,
              style: {
                cursor: "col-resize",
                position: "absolute",
                top: 0,
                right: 0,
                width: 6,
                height: "100%",
                zIndex: 10,
                background: isSidebarDragging ? "rgba(0,0,0,0.08)" : "transparent"
              },
              "aria-label": "Resize sidebar",
              "data-testid": "sidebar-drag-handle"
            }
          )
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1 flex flex-col overflow-hidden", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1 overflow-auto", children: mcpClient ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Tabs,
        {
          value: activeTab,
          className: "w-full p-4",
          onValueChange: (value) => {
            setActiveTab(value);
            window.location.hash = value;
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsList, { className: "mb-4 py-0", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                TabsTrigger,
                {
                  value: "resources",
                  disabled: !serverCapabilities?.resources,
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Files, { className: "w-4 h-4 mr-2" }),
                    "Resources"
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                TabsTrigger,
                {
                  value: "prompts",
                  disabled: !serverCapabilities?.prompts,
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(MessageSquare, { className: "w-4 h-4 mr-2" }),
                    "Prompts"
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                TabsTrigger,
                {
                  value: "tools",
                  disabled: !serverCapabilities?.tools,
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Hammer, { className: "w-4 h-4 mr-2" }),
                    "Tools"
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                TabsTrigger,
                {
                  value: "tasks",
                  disabled: !serverCapabilities?.tasks,
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(ListTodo, { className: "w-4 h-4 mr-2" }),
                    "Tasks"
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsTrigger, { value: "apps", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(AppWindow, { className: "w-4 h-4 mr-2" }),
                "Apps"
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsTrigger, { value: "ping", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Bell, { className: "w-4 h-4 mr-2" }),
                "Ping"
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsTrigger, { value: "sampling", className: "relative", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Hash, { className: "w-4 h-4 mr-2" }),
                "Sampling",
                pendingSampleRequests.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "absolute -top-1 -right-1 bg-red-500 text-white text-xs rounded-full h-4 w-4 flex items-center justify-center", children: pendingSampleRequests.length })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsTrigger, { value: "elicitations", className: "relative", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(MessageSquare, { className: "w-4 h-4 mr-2" }),
                "Elicitations",
                pendingElicitationRequests.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "absolute -top-1 -right-1 bg-red-500 text-white text-xs rounded-full h-4 w-4 flex items-center justify-center", children: pendingElicitationRequests.length })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsTrigger, { value: "roots", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(FolderTree, { className: "w-4 h-4 mr-2" }),
                "Roots"
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsTrigger, { value: "auth", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Key, { className: "w-4 h-4 mr-2" }),
                "Auth"
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsTrigger, { value: "metadata", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Settings, { className: "w-4 h-4 mr-2" }),
                "Metadata"
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full", children: !serverCapabilities?.resources && !serverCapabilities?.prompts && !serverCapabilities?.tools ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center p-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-lg text-gray-500 dark:text-gray-400", children: "The connected server does not support any MCP capabilities" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                PingTab,
                {
                  onPingClick: () => {
                    void sendMCPRequest(
                      {
                        method: "ping"
                      },
                      EmptyResultSchema
                    );
                  }
                }
              )
            ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                ResourcesTab,
                {
                  resources,
                  resourceTemplates,
                  listResources: () => {
                    clearError("resources");
                    listResources();
                  },
                  clearResources: () => {
                    setResources([]);
                    setNextResourceCursor(void 0);
                  },
                  listResourceTemplates: () => {
                    clearError("resources");
                    listResourceTemplates();
                  },
                  clearResourceTemplates: () => {
                    setResourceTemplates([]);
                    setNextResourceTemplateCursor(void 0);
                  },
                  readResource: (uri2) => {
                    clearError("resources");
                    readResource(uri2);
                  },
                  selectedResource,
                  setSelectedResource: (resource) => {
                    clearError("resources");
                    setSelectedResource(resource);
                  },
                  resourceSubscriptionsSupported: serverCapabilities?.resources?.subscribe || false,
                  resourceSubscriptions,
                  subscribeToResource: (uri2) => {
                    clearError("resources");
                    subscribeToResource(uri2);
                  },
                  unsubscribeFromResource: (uri2) => {
                    clearError("resources");
                    unsubscribeFromResource(uri2);
                  },
                  handleCompletion,
                  completionsSupported,
                  resourceContent,
                  nextCursor: nextResourceCursor,
                  nextTemplateCursor: nextResourceTemplateCursor,
                  error: errors2.resources
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                PromptsTab,
                {
                  prompts,
                  listPrompts: () => {
                    clearError("prompts");
                    listPrompts();
                  },
                  clearPrompts: () => {
                    setPrompts([]);
                    setNextPromptCursor(void 0);
                  },
                  getPrompt: (name2, args2) => {
                    clearError("prompts");
                    getPrompt(name2, args2);
                  },
                  selectedPrompt,
                  setSelectedPrompt: (prompt) => {
                    clearError("prompts");
                    setSelectedPrompt(prompt);
                    setPromptContent("");
                  },
                  handleCompletion,
                  completionsSupported,
                  promptContent,
                  nextCursor: nextPromptCursor,
                  error: errors2.prompts
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                ToolsTab,
                {
                  serverSupportsTaskRequests: !!serverCapabilities?.tasks?.requests?.tools?.call,
                  tools,
                  listTools: () => {
                    clearError("tools");
                    listTools();
                  },
                  clearTools: () => {
                    setTools([]);
                    setNextToolCursor(void 0);
                    cacheToolOutputSchemas([]);
                  },
                  callTool: async (name2, params, metadata22, runAsTask) => {
                    clearError("tools");
                    setToolResult(null);
                    const result = await callTool(
                      name2,
                      params,
                      metadata22,
                      runAsTask
                    );
                    const calledTool = tools.find(
                      (tool) => tool.name === name2
                    );
                    if (calledTool && hasAppResourceUri(calledTool)) {
                      setPrefilledAppsToolCall({
                        id: ++prefilledAppsToolCallIdRef.current,
                        toolName: name2,
                        params: cloneToolParams(params),
                        result
                      });
                    } else {
                      setPrefilledAppsToolCall(null);
                    }
                    return result;
                  },
                  selectedTool,
                  setSelectedTool: (tool) => {
                    clearError("tools");
                    setSelectedTool(tool);
                    setToolResult(null);
                  },
                  toolResult,
                  isPollingTask,
                  nextCursor: nextToolCursor,
                  error: errors2.tools,
                  resourceContent: resourceContentMap,
                  onReadResource: (uri2) => {
                    clearError("resources");
                    readResource(uri2);
                  }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                TasksTab,
                {
                  tasks,
                  listTasks: () => {
                    clearError("tasks");
                    listTasks();
                  },
                  clearTasks: () => {
                    setTasks([]);
                    setNextTaskCursor(void 0);
                  },
                  cancelTask,
                  selectedTask,
                  setSelectedTask: (task) => {
                    clearError("tasks");
                    setSelectedTask(task);
                  },
                  error: errors2.tasks,
                  nextCursor: nextTaskCursor
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                AppsTab,
                {
                  sandboxPath: `${getMCPProxyAddress(config2)}/sandbox`,
                  tools,
                  listTools: () => {
                    clearError("tools");
                    listTools();
                  },
                  callTool: async (name2, params, metadata22, runAsTask) => {
                    clearError("tools");
                    setToolResult(null);
                    return callTool(name2, params, metadata22, runAsTask);
                  },
                  prefilledToolCall: prefilledAppsToolCall,
                  onPrefilledToolCallConsumed: (callId) => {
                    setPrefilledAppsToolCall(
                      (prev) => prev?.id === callId ? null : prev
                    );
                  },
                  error: errors2.tools,
                  mcpClient,
                  onNotification: (notification) => {
                    setNotifications((prev) => [...prev, notification]);
                  }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(ConsoleTab, {}),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                PingTab,
                {
                  onPingClick: () => {
                    void sendMCPRequest(
                      {
                        method: "ping"
                      },
                      EmptyResultSchema
                    );
                  }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                SamplingTab,
                {
                  pendingRequests: pendingSampleRequests,
                  onApprove: handleApproveSampling,
                  onReject: handleRejectSampling
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                ElicitationTab,
                {
                  pendingRequests: pendingElicitationRequests,
                  onResolve: handleResolveElicitation
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                RootsTab,
                {
                  roots,
                  setRoots,
                  onRootsChange: handleRootsChange
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(AuthDebuggerWrapper, {}),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                MetadataTab,
                {
                  metadata: metadata2,
                  onMetadataChange: handleMetadataChange
                }
              )
            ] }) })
          ]
        }
      ) : isAuthDebuggerVisible ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        Tabs,
        {
          defaultValue: "auth",
          className: "w-full p-4",
          onValueChange: (value) => window.location.hash = value,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(AuthDebuggerWrapper, {})
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center justify-center h-full gap-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-lg text-gray-500 dark:text-gray-400", children: "Connect to an MCP server to start inspecting" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground", children: "Need to configure authentication?" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              variant: "outline",
              size: "sm",
              onClick: () => setIsAuthDebuggerVisible(true),
              children: "Open Auth Settings"
            }
          )
        ] })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: "relative border-t border-border",
          style: {
            height: `${historyPaneHeight}px`
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "absolute w-full h-4 -top-2 cursor-row-resize flex items-center justify-center hover:bg-accent/50 dark:hover:bg-input/40",
                onMouseDown: handleDragStart,
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-8 h-1 rounded-full bg-border" })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-full overflow-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              HistoryAndNotifications,
              {
                requestHistory,
                serverNotifications: notifications,
                onClearHistory: clearRequestHistory,
                onClearNotifications: handleClearNotifications
              }
            ) })
          ]
        }
      )
    ] })
  ] });
};
clientExports.createRoot(document.getElementById("root")).render(
  /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.StrictMode, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Toaster, {})
  ] })
);
export {
  InspectorOAuthClientProvider as I,
  SESSION_KEYS as S,
  auth as a,
  generateOAuthErrorDescription as g,
  jsxRuntimeExports as j,
  parseOAuthCallbackParams as p,
  reactExports as r,
  useToast as u
};
